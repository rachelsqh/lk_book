<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>objtool &mdash; Rachel&#39;s E-book 1.0 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="二进制工具" href="comp_bin_tool.html" />
    <link rel="prev" title="UWIND" href="comp_uwind.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> Rachel's E-book
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../os_base/index.html">linux 操作系统概述</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">linux 内核开发基础</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../k_doc.html">内核文档综述</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lk_build/index.html">linux 内核构建</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">linux 内核编程</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="comp_api.html">linux 二进制接口</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_as.html">AS:内核汇编</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_ld.html">ld 在linux中的应用</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_gcc.html">GCC 在linux 内核中的应用</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_elf.html">ELF基础</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_uwind.html">UWIND</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">objtool</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id2">规则</a></li>
<li class="toctree-l4"><a class="reference internal" href="#s">.S 文件中的错误</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c">.c文件中的错误</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">添加例外</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="comp_bin_tool.html">二进制工具</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kernel_st.html">内核测试</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kernel_debug_ig.html">kernel debug 实验记录</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gnuplot.html">曲线图-gnuplot</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../x86_kernel_base.html">linux X86内核基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lk_code/index.html">linux 内核基础代码分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pm.html">电源管理框架</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ps.html">进程管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mem.html">内存管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fs.html">文件系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver.html">设备驱动管理框架</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sec.html">linux 内核安全</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dot.html">dot画图</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Rachel's E-book</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">linux 内核开发基础</a> &raquo;</li>
          <li><a href="index.html">linux 内核编程</a> &raquo;</li>
      <li>objtool</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/lk_devel/lk_comp/comp_objtool.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="objtool">
<h1>objtool<a class="headerlink" href="#objtool" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>概述<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>内核CONFIG_STACK_VALIDATION选项使能了在编译时运行的名为objtool的宿主机工具。它有一个“check”子命令,用于分析每个.o文件并确保其堆栈元数据的有效性。
它对asm代码和C内联汇编代码强制执行一组规则来确保堆栈跟踪的可靠的。
目前它只检查帧指针的使用情况，但有计划为 C 文件添加 CFI 验证和为 asm 文件添加 CFI 生成。
对于每个函数，它递归地遵循所有可能的代码路径，并在每条指令处验证正确的帧指针状态。
它还遵循涉及特殊部分的代码路径，例如 .altinstructions、__jump_table 和 __ex_table，它们可以为给定指令（或指令集）添加替代执行路径。 类似地，它知道如何遵循 switch 语句，gcc 有时会为此使用跳转表。</p>
<p>以下是验证堆栈元数据的一些好处：
a )为启用帧指针的内核提供更可靠的堆栈跟踪，帧指针用于调试目的。它们允许运行时代码和调试工具能够遍历堆栈以确定到当前执行的函数调用链。</p>
<blockquote>
<div><p>对于某些体系结构，帧指针由CONFIG_FRAME_POINTER使能。对于其他一些架构，ABI要求其实现（有时称为“backchain pointers” ）。
对于C 代码，当gcc后加-fno-omit-frame-pointer选项来自动生成帧指针的设置指令。
但是对于asm代码，帧设置指令必须采用手动方式进行编码，但很多人不会去写。最终的结果就是CONFIG_FRAME_POINTER一般应用在C代码中，但不适用于大多数 asm 代码。
为了使基于帧指针的堆栈跟踪可靠，所有调用其他函数的函数必须首先创建一个堆栈帧并更新帧指针。如果第一个函数在调用第二个函数前没有正确地构建栈帧，堆栈跟踪中将跳过第一个函数。
例如，考虑以下启用栈帧的回溯示例</p>
<blockquote>
<div><p>[&lt; ffffffff81812584 &gt;] dump_stack + 0x4b / 0x63
[&lt; ffffffff812d6dc2 &gt;] cmdline_proc_show + 0x12 / 0x30
[&lt; ffffffff8127f568 &gt;] seq_read + 0x108 / 0x3e0
[&lt; ffffffff812cce62 &gt;] proc_reg_read + 0x42 / 0x70
[&lt; ffffffff81256197 &gt;] __vfs_read + 0x37 / 0x100
[&lt; ffffffff81256b16 &gt;] vfs_read + 0x86 / 0x130
[&lt; ffffffff81257898 &gt;] SyS_read + 0x58 / 0xd0
[&lt; ffffffff8181c1f2 &gt;] entry_SYSCALL_64_fastpath + 0x12 / 0x76</p>
</div></blockquote>
<p>它正确显示cmdline_proc_show ()的调用者是 seq_read ()。
如果我们从cmdline_proc_show ()中删除帧指针逻辑，用nops替换帧指针相关指令，则会显示如下：</p>
<blockquote>
<div><p>[&lt;ffffffff81812584&gt;] dump_stack+0x4b/0x63
[&lt;ffffffff812d6dc2&gt;] cmdline_proc_show+0x12/0x30
[&lt;ffffffff812cce62&gt;] proc_reg_read+0x42/0x70
[&lt;ffffffff81256197&gt;] __vfs_read+0x37/0x100
[&lt;ffffffff81256b16&gt;] vfs_read+0x86/0x130
[&lt;ffffffff81257898&gt;] SyS_read+0x58/0xd0
[&lt;ffffffff8181c1f2&gt;] entry_SYSCALL_64_fastpath+0x12/0x76</p>
</div></blockquote>
<p>注意 cmdline_proc_show()的调用者seq_read ( )被跳过。相反，堆栈跟踪似乎表明cmdline_proc_show ()被proc_reg_read ()调用。</p>
<p>这里 objtool的好处是因为它确保所有函数启用 CONFIG_FRAME_POINTER ，任何函数在堆栈跟踪中都不会被跳过。以下清楚除外：
除非函数开始创建栈帧以前或者在函数析构栈指针之后发生中断或异常，这是帧指针的固有限制。（如何理解？）</p>
</div></blockquote>
<dl class="simple">
<dt>b ) 100 %可靠的DWARF 内核堆栈跟踪 （注意：这还没有实现）</dt><dd><p>作为帧指针的替代，DWARF调用帧信息(CFI)元数据可用于遍历堆栈。与帧指针不同，CFI元数据带外（与代码不在一块）。所以它不会影响运行时性能，即使产生中断或异常时也很可靠。
对于 C 代码，gcc 会自动生成 DWARF CFI 元数据。但对于asm 代码，生成 CFI需要繁琐的手动操作，需要手动在整个代码中放置.cfi 汇编器宏。它很笨拙而且很容易出错，它使真正的代码更难阅读。
Stacktool将通过多种方式改善这种情况。对于代码已经有 CFI 注释，它将验证它们。对于代码 它没有CFI 注释，它将生成它们。所以一个架构可以选择去除所有手动 .cfi 注释，从他们的 asm 代码并让 objtool 生成它们。
我们还可以在其中添加一个运行时堆栈验证调试选项定期从 schedule() 和/或 NMI 遍历堆栈以确保堆栈元数据是健全的，我们到达了底部堆。
所以objtool 的好处是外部工具应该总是显示完美的堆栈跟踪。同样的情况也适用于内核警告/oops 跟踪架构是否有运行时 DWARF unwinder。</p>
</dd>
</dl>
<ol class="loweralpha" start="3">
<li><p>更高的实时补丁兼容率（注意：这还没有实现）
目前使用 CONFIG_LIVEPATCH 有一个基本的实时补丁框架对于大约85-90 %的“安全”修复是安全的。但补丁不能有复杂的特性，比如函数依赖或原型更改或数据结构更改。</p>
<p>强烈需要支持更复杂的补丁功能，以便安全修复的补丁兼容性率可以最终接近类似于100 % 的东西。为了达到这个目的，一个需要“一致性模型” ，它可以让任务安全从未打补丁的状态转变为打补丁的状态。
当前提议的 livepatch 的关键要求之一 一致性模型[*]是它需要遍历每个睡眠任务，以确定它是否可以转换到已修补的任务状态。如果objtool 可以确保堆栈跟踪是可靠的，这可以使用一致性模型和实时补丁兼容性率可以显着提高。具体参考[*] https : <a class="reference external" href="mailto://lkml&#46;kernel&#46;org/r/cover&#46;1423499826&#46;git&#46;jpoimboe&#37;&#52;&#48;redhat&#46;com">//lkml<span>&#46;</span>kernel<span>&#46;</span>org/r/cover<span>&#46;</span>1423499826<span>&#46;</span>git<span>&#46;</span>jpoimboe<span>&#64;</span>redhat<span>&#46;</span>com</a></p>
</li>
</ol>
</div>
<div class="section" id="id2">
<h2>规则<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>为了实现验证，objtool 强制执行以下规则：
1.每个可调用函数都必须使用ELF函数类型进行注解，在asm代码中，这通常使用ENTRY/ENDPROC 宏。如果objtool在函数外找到返回指令，它会标记一个错误，因为这通常表明相应注释的可调用代码。</p>
<blockquote>
<div><p>此规则以便 objtool 可以正确识别每个可调用函数以分析其堆栈元数据。</p>
</div></blockquote>
<dl class="simple">
<dt>2.相反，每段*not*可调用的代码应该*not*被注释为ELF函数。这种情况下不应使用ENDPROC宏。</dt><dd><p>需要此规则以便 objtool 可以忽略不可调用的代码。
这样的代码不必遵循任何其他规则。</p>
</dd>
<dt>3.每个调用另一个函数的可调用函数必须具有正确的帧指针逻辑，如果CONFIG_FRAME_POINTER或架构的后链规则需要。这可以在 asm 代码中完成使用 FRAME_BEGIN/FRAME_END 宏。</dt><dd><p>此规则确保基于帧指针的堆栈跟踪以设计的方式工作。如果函数 A在调用B之前没有创建堆栈帧，函数A的 _caller_将在堆栈上被跳过。</p>
</dd>
<dt>4.只有在以下情况下才允许动态跳转和跳转到未定义的符号：</dt><dd><p>a )跳转是switch语句的一部分；要么
b )跳转匹配兄弟调用语义并且帧指针有它在函数entry上的值相同。（递归？）
需要此规则，以便 objtool 可以可靠地分析所有函数的代码路径。如果一个函数跳转到另一个文件中的代码，而且它不是同级调用，objtool没有办法跟随跳转因为它一次只分析一个文件。</p>
</dd>
<dt>5.可调用函数可能不执行内核进入/退出指令。唯一需要此类指令的代码是内核入口代码，无论如何   ，它不应该在可调用函数中。</dt><dd><p>此规则只是一个健全性检查，以确保可调用函数正常返回。</p>
</dd>
</dl>
</div>
<div class="section" id="s">
<h2>.S 文件中的错误<a class="headerlink" href="#s" title="Permalink to this headline">¶</a></h2>
<p>如果您在编译的.S文件时产生了一个不理解的错误，首先确保手影响的代码遵循以上规则。
以下是 objtool 报告的一些常见警告示例，警告的含义，以及如何解决它们的建议。
1. asm_file.o:</p>
<blockquote>
<div><p>警告: objtool: func()+0x128: call without frame pointer save/setup
解析：func()函数在调用函数时没有先保存和/或更新帧指针。
解决方法：如果 func() 确实是一个可调用函数，请使用 FRAME_BEGIN 和 FRAME_END 宏添加适当的帧指针逻辑。否则，删除通过将 ENDPROC 更改为 END 将其 ELF 函数注释去掉。
如果您在a.c 文件产生这个警告，请参阅“.c 中的错误”节。</p>
</div></blockquote>
<ol class="arabic" start="2">
<li><dl>
<dt>asm_file 。o ：</dt><dd><p>警告：objtool ：.text + 0x53 ：在可调用函数之外返回指令;
解析：检测到返回指令，但 objtool检测不到可调用函数调用返回指令的路径；
解决方法：</p>
<blockquote>
<div><p>如果返回指令在可调用函数内（或可从调用函数访问）该函数需要用 ENTRY/ENDPROC宏 注释
如果您需要函数之外的返回指令，并且100% 确定它不会影响堆栈跟踪，你可以让objtool 忽略它。请参阅下面的“添加例外”部分。</p>
</div></blockquote>
</dd>
</dl>
</li>
<li><p>asm_file 。o ：警告：objtool ：func （）+ 0x9 ：函数有无法访问的指令
该指令存在于可调用函数中，但没有从函数开始到函数的可能控制流路径
如果确实需要该指令，并且它实际上在一个可调用函数中，确保其函数使用ENTRY / ENDPROC正确注释。
如果它实际上不在可调用函数中（例如内核入口代码），将 ENDPROC 更改为 END。</p></li>
<li><dl>
<dt>asm_file.o:</dt><dd><dl class="simple">
<dt>警告: objtool: func():找不到启动指令</dt><dd><p>或者：objtool ：func （）+ 0x11dd ：无法解码指令</p>
</dd>
</dl>
<p>解析：您是否将数据放入text部分？如果是这样，那可能会混淆objtool的指令解码器。将数据移动到像.data或.rodata等更合适的位置；</p>
</dd>
</dl>
</li>
<li><dl>
<dt>asm_file 。o ：</dt><dd><p>警告：objtool ：func （）+ 0x6 ：内核进入/退出可调用指令
解析：这是一个如sysenter或sysret内核进入/退出指令。这样的指令在可调用函数中是不允许的，并且是大多数可能是内核入口代码的一部分。</p>
<blockquote>
<div><p>如果指令实际上不在可调用函数中，请ENDPROC更改为END 。</p>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl>
<dt>asm_file 。o ：</dt><dd><p>警告：objtool ：func （）+ 0x26 ：来自可调用指令的同级调用，帧指针已更改
解析：这是动态跳转或跳转到未定义符号。堆栈工具假设它是同级调用并检测到帧指针不是首先恢复到原来的状态。</p>
<blockquote>
<div><p>如果它不是真正的兄弟调用，则可能需要移动目标代码到本地文件。
如果指令实际上不在可调用函数中（例如内核入口代码），将 ENDPROC 更改为 END。</p>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>asm_file:</dt><dd><p>警告: objtool: func()+0x5c: 帧指针状态不匹配
解析：指令的帧指针状态不一致，取决于采用哪条执行路径到达指令。</p>
</dd>
</dl>
<p>确保函数在函数的开头推送并设置帧指针（对于x86_64 ，这意味着 rbp )并在函数的末尾弹出它。还要确保没有函数中其他代码触及帧指针。</p>
</li>
</ol>
</div>
<div class="section" id="c">
<h2>.c文件中的错误<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>如果您在编译的.c文件中遇到objtool错误，则可能是该文件使用具有“call”指令的 asm() 语句。一个带有 call 指令的 asm() 语句必须声明使用其输出操作数中的堆栈指针。例如，在 x86_64 上：</dt><dd><p>register void <a href="#id3"><span class="problematic" id="id4">*</span></a>__sp asm(“rsp”);
asm volatile(“call func” : “+r” (__sp));</p>
</dd>
</dl>
<p>否则堆栈帧可能不会在调用之前创建。
C 代码出错的另一个可能原因是如果 Makefile 删除了gcc 的-fno-omit-frame-pointer 选项或将 -fomit-frame-pointer 添加到 gcc 选项。
有关 .S 文件错误的更多信息，另请参阅上述部分各个错误消息的含义。
如果错误似乎没有意义，则可能是objtool中的错误。</p>
</div>
<div class="section" id="id5">
<h2>添加例外<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>如果您真的需要 objtool 来忽略某些东西，并且100 %确定 它不会影响内核堆栈跟踪，您可以告诉 objtool忽略它：
- 要跳过函数验证，请使用 STACK_FRAME_NON_STANDARD宏。
- 要跳过文件验证，请添加 OBJECT_FILES_NON_STANDARD_filename.o := n到 Makefile。
- 要跳过目录验证，请添加OBJECT_FILES_NON_STANDARD := y到 Makefile。</p>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="comp_uwind.html" class="btn btn-neutral float-left" title="UWIND" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="comp_bin_tool.html" class="btn btn-neutral float-right" title="二进制工具" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Rachel.Sun.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>