<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GCC 在linux 内核中的应用 &mdash; Rachel&#39;s E-book 1.0 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="ELF基础" href="comp_elf.html" />
    <link rel="prev" title="ld 在linux中的应用" href="comp_ld.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> Rachel's E-book
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../os_base/index.html">linux 操作系统概述</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">linux 内核开发基础</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../k_doc.html">内核文档综述</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lk_build/index.html">linux 内核构建</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">linux 内核编程</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="comp_api.html">linux 二进制接口</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id4">寄存器和栈帧</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id10">异常接口</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id11">虚拟地址空间</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id12">页长度</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id13">虚拟地址对齐</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id19">初始化栈和寄存器状态</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id20">辅助向量</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id24">架构约束</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id25">约定</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id26">位置无关的函数序言</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id27">数据对象</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id28">函数调用</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id29">分支</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id30">变量参数列表</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id31">DWARF 发行值</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id32">DWARF 寄存器号映射</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id34">机器信息</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id36">节标识</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id37">节类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id38">特定节</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id39">EH_FRAME节</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id42">重定位类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id43">大模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id45">程序头</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id47">程序加载器</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id48">初始化和结束函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id49">全局数据符号</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id50">浮点环境函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id51">异常句柄架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id52">数据结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id53">丢出异常</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id54">异常对象管理</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id55">上下文管理</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id56">私有例程</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id59">调用约定</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id60">栈布局</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id61">请求处理器特性</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_api.html#id63">其他问题</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_as.html">AS:内核汇编</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_ld.html">ld 在linux中的应用</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">GCC 在linux 内核中的应用</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#gccc">Gcc对C语言的支持</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">控制输出种类的选项</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">控制诊断消息格式的选项</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">控制静态分析的选项</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">调试程序选项</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">控制优化的选项</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">程序工具选项(3.12)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id21">控制预处理器的选项</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id22">将选项传递给汇编器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id23">链接选项</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id24">目录搜索选项</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id25">代码生成约定的选项:</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id32">机器相关的选项</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id33">指定子流程和传递给它们的开关</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id48">影响GCC的环境变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id49">使用预编译头</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id50">表达式中的陈述和声明</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id51">本地声明的标签 （通过实验来理解）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id52">标签作为值</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id63">嵌套函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gotos">非本地Gotos</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id68">构造函数调用</a></li>
<li class="toctree-l4"><a class="reference internal" href="#typeoftype">用typeof引用Type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id69">省略操作数的条件</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id70">命名地址空间</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id71">长度为零的数组</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id72">没有成员的结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id73">可变长度的数组</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id74">参数可变的宏</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id75">转义换行符的较宽松规则</a></li>
<li class="toctree-l4"><a class="reference internal" href="#non-lvalue">Non-Lvalue 数组可能带有下标</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id76">无效指针和函数指针的算法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id77">可变参数函数中的指针参数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id80">带有限定符的数组的指针按预期工作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id81">非常数初始化器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id82">复合字面量</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id85">指定的初始化程序</a></li>
<li class="toctree-l4"><a class="reference internal" href="#case">case范围</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id86">转换为联合类型</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id87">混合声明，标签和代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id88">声明函数的属性</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id207">指定变量的属性</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id254">指定类型的属性</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id267">标签属性</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id270">枚举器属性</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id271">语句属性</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id272">属性语法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id283">原型和旧式函数定义</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id290">标识符名称中的美元符号</a></li>
<li class="toctree-l4"><a class="reference internal" href="#esc">常量中的字符ESC</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id291">确定函数，类型或变量的对齐方式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id292">内联函数的速度与宏一样快</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id305">什么时候访问易失对象？</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c">如何在C代码中使用内联汇编语言</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id324">备用关键字</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id325">不完整的枚举类型</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id326">函数名称为字符串</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id327">获取函数的返回地址或帧地址</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id330">通过内置函数使用矢量指令</a></li>
<li class="toctree-l4"><a class="reference internal" href="#offsetof">支持offsetof</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sync">用于原子内存访问的旧版__sync内置函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id331">内存模型感知原子操作的内置函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id342">内置函数，可通过溢出检查执行算术运算</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id343">x86特定于事务性内存的内存模型扩展</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id344">对象大小检查内置函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id345">GCC提供的其他内置函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id360">特定于目标机器的内置函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id365">特定于特定目标计算机的格式检查</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id366">接受的用语说明</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id367">未命名的结构和联合字段</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id368">线程本地存储</a></li>
<li class="toctree-l4"><a class="reference internal" href="#b">使用“ 0b”前缀的二进制常量</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c-linux">C 扩展部分在linux 内核中的应用</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gcov-tool">gcov-tool</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gcov-dump">gcov-dump</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lto-dump">lto-dump</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="comp_elf.html">ELF基础</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_uwind.html">UWIND</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_objtool.html">objtool</a></li>
<li class="toctree-l3"><a class="reference internal" href="comp_bin_tool.html">二进制工具</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kernel_st.html">内核测试</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kernel_debug_ig.html">kernel debug 实验记录</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gnuplot.html">曲线图-gnuplot</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../lk_code/index.html">linux 内核基础代码分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../yocto_kernel.html">yocto uboot与内核模块、内核开发总结</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../uboot.html">uboot理解</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver.html">设备驱动(待修正）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gitlab.html">基于gitlab的项目管理(待修正)</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Rachel's E-book</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">linux 内核开发基础</a> &raquo;</li>
          <li><a href="index.html">linux 内核编程</a> &raquo;</li>
      <li>GCC 在linux 内核中的应用</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/lk_devel/lk_comp/comp_gcc.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="gcc-linux">
<h1>GCC 在linux 内核中的应用<a class="headerlink" href="#gcc-linux" title="Permalink to this headline">¶</a></h1>
<p>只针对C语言进行总结，属性的指定，可以借助已经有的进行搜索替换</p>
<div class="section" id="gccc">
<h2>Gcc对C语言的支持<a class="headerlink" href="#gccc" title="Permalink to this headline">¶</a></h2>
<p>ANSI C标准（X3.159-1989）1989年批准，1990年发行。这个版本作为ISO标准于随后的1990年通过批准（ISO/IEC 9899：1990）。这两个版本内没有技术方面差异。这个标准以C89或C90名字广为人知。GCC通过选项’-ansi’,’-std=c90’或’-std=iso9899:1990’来进行指定;如果需要获取所有标准的诊断信息，需要通过’-pedantic’进行指定（如果想以错误而非警告方式打印，可以用’-pedantic-errors’进行指定）</p>
<p>1990 ISO C标准经历了1995和1996两次技术勘误。 GCC不支持未经过纠正的版本。</p>
<p>1995年发布了1990年标准的修订版本。这个版本增加了digraphs和__STDC_VERSION__。其他涉及到库相关修改。这个版本以AMD1的名字被熟知;称为C94或C95。’-std=iso9899:199409’(‘-pedantic’功能相同)进行指定。</p>
<p>新的ISO C标准版本于1999年作为ISO/IEC 9099：1999进行发行，称为C99。（开发中，这个版本的草稿版本称为C9X）GCC对此标准版本完全支持 <a class="reference external" href="http://gcc.gnu.org/c99status.html">http://gcc.gnu.org/c99status.html</a> 有细节描述。通过‘-std=c99’或‘-std=iso9899:1999’进行指定。</p>
<p>1999 ISO C标准经历了2001,2004和2007三次技术勘误。GCC不支持未经修正的版本。</p>
<p>C标准的第四个版本为C11，也就是2011年发行的ISO/IEC 9899:2011版本（开发中，以C1X代指相关的草稿版本），GCC对本标准进行了大幅完全支持 ，通过 ‘-std=c11’ 或’-std=iso9899:2011’进行指定。2017年准备的综合校正版本，于2018年发行，为标准ISO/IEC 9899：2018;称为C17，通过命令‘-std=c17’和 ‘-std=iso9899:2017’进行指定。这个版本也可以通过’-std-c11’指定（2017是2011的修正版本），C11和C17唯一的差别在__STDC_VERSION__的值不同。</p>
<p>C标准的未来版本称为C2X，处于开发阶段;通过指令‘-std=c2x’来使能其不完整支持或实验。</p>
<p>通常情况下，GCC会提供C语言的一些扩展，极少数情况下会与C标准冲突，这些扩展具体参考第6章，这也是我们linux内核中需要注意的部分。</p>
<p>很对C90标准的一些扩展作为C99标准的一部分进行发行，针对C90和C99标准中的扩展也会合并到C11标准中。可以通过’-std’选项指定C标准来关闭这些扩展，可可以通过‘-std=gnu90’ (for C90 with GNU extensions)，‘-std=gnu99’ (for C99 with GNU extensions) or ‘-std=gnu11’ (for C11 with GNU extensions).来使能这些扩展，</p>
<p>‘-std=gnu17’没有给出dialect选项。</p>
<blockquote>
<div><p>ISO C标准定义了两类兼容性实现。一类宿主实现支持所有标准包括所有库特性;一类独立实现仅仅需要宿主提供特定的库特征：those in &lt;float.h&gt;, &lt;limits.h&gt;, &lt;stdarg.h&gt;, and &lt;stddef.h&gt;;since AMD1, also those in &lt;iso646.h&gt;; since C99, also those in &lt;stdbool.h&gt; and &lt;stdint.h&gt;;and since C11, also those in &lt;stdalign.h&gt; and &lt;stdnoreturn.h&gt;. In addition, complex types, added in C99, are not required for freestanding implementations.</p>
</div></blockquote>
<p>该标准还为程序定义了两个环境，（a freestanding environment,required of all implementations and which may not have library facilities beyond those required of freestanding implementations, where the handling of program startup and termination are implementation-defined; and a hosted environment, which is not required,in which all the library facilities are provided and startup is through a function int main (void) or int main (int, char <a href="#id1"><span class="problematic" id="id2">*</span></a>[]).）操作系统内核是一个运行在独立环境中的程序的例子;一个程序使用操作系统特征是程序运行在宿主环境中的例子。</p>
<p>GCC目标是作为符合标准的独立实现，或者作为兼容宿主实现的编译器。默认，作为宿主实现的编译器，定义__STDC_HOSTED__为1,并假设当使用ISO C函数名字时，使用标准定义的语义。如果为一个独立环境作为兼容独立环境，使用‘-ffreestanding’选项指定;定义__STDC_HOSTED_为0,此时不假设使用函数名字来自标准库，如有例外，在后面内容中描述。构建一个操作系统内核，可能仍然需要为链接和启动做出自己的安排。（这部分说明留意 SEC 3.4 [Options Controlling C Dialect]).</p>
<p>GCC使用的大多数编译器支持例程都在’ libgcc ‘中，但这也存在一些例外。GCC需要独立环境提供memcpy,memmove,memset和</p>
<p>memcmp函数。最后，如果使用了__builtin_trap，目标不会实现trap 语法，GCC调用对abort终止。</p>
<p>技术勘误及相关技术聊聊索引，关于C历史的基本原理文件和信息可以在网上找到，具体参考http://gcc.gnu.org/readings.html</p>
<p>调用GCC时，通常会进行预处理，编译，汇编和链接。</p>
<p>“总体选项”使您可以在中间阶段停止此过程。 例如，“-c”选项表示不运行链接器 ，然后，输出由汇编器汇编后的目标文件。</p>
<p>其他选项将传递到一个或多个处理阶段。 一些选项控制预处理器，而其他选项控制编译器本身。 还有其他选项控制着汇编器和链接器。 我们只使用其中很少的一部分，大部分没有在文档中提及。</p>
<p>GCC的大多数命令行选项对于C程序都是有用的。 当一个选项仅对另一种语言（通常是C ++）有用时，会明确地说明。 如果特定选项的描述未提及特定源语言，则可以将该选项与所有受支持的语言一起使用。</p>
<p>gcc/machine-gcc/machine-gcc-version。</p>
<p>gcc程序接受选项和文件名作为操作数。 许多选项具有多字母名称； 因此，多个单字母选项可能不会分组： ‘-dv’与‘-d -v’是不一样的。</p>
<p>您可以混合使用选项和其他参数。 在大多数情况下，您使用的顺序无关紧要。 当您使用相同种类的多个选项时，顺序确实很重要。 例如，如果您多次指定“ -L”，则会以指定的顺序搜索目录。 同样，“-l”选项的位置也很重要。</p>
<p>许多选项的长名称都以“ -f”或“ -W”开头，例如“ -fmove-loop-invariants”，“-Wformat”等。 其中大多数都有积极和消极的形式。 “ -ffoo”的否定形式是“ -fno-foo”。 本手册仅记录这两种形式中的一种，不是默认形式。</p>
<p>某些选项采用一个或多个参数，通常在选项名称之间用空格或等号（’=’）分隔。 除非特别说明，否则参数可以是数字或字符串。数值参数通常必须是小的无符号十进制或十六进制整数。 十六进制参数必须以“ 0x”前缀开头。用于指定某种大小阈值的选项的参数可以是任意大的十进制或十六进制整数，后跟一个字节大小后缀，用于指定千字节和kibibyte的多个字节，例如kB和KiB， MB和MiB分别表示兆字节和兆字节，GB和GiB表示千兆字节和千兆字节，依此类推。 在下面的文本中，此类参数由字节大小指定。 有关二进制和十进制字节大小前缀的完整列表和说明，请参阅NIST，IEC和其他相关的国家和国际标准。</p>
<p>重要选项</p>
</div>
<div class="section" id="id3">
<h2>控制输出种类的选项<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>编译可能涉及四个阶段 ：预处理，编译，汇编和链接，始终按该顺序进行。 GCC能够将多个文件预处理并编译为多个汇编程序输入文件或一个汇编程序输入文件； 然后，每个汇编程序输入文件都会生成一个目标文件，并将所有目标文件（新编译的和指定为输入的那些目标文件）的链接合并到一个可执行文件中。</p>
<p>对于任何给定的输入文件，文件名后缀确定完成哪种编译：</p>
<p>file.c ：需要预处理的C源代码。
file.i ：不需要预处理的C源代码。
file.h ：C头文件（or C, C++ header file to be turned into an Ada spec (via the ‘-fdump-ada-spec’ switch）</p>
<p>而已利用’-x’选项来准确制定输入语言：</p>
<p>-x language：为后面的输入文件指定使用的语言（代替处理器利用文件名后缀来确定输入语言）。这个选项接受所有下一个’-x’选项出来前的输入文件采用指定的语言。语言的名字可以指定为：</p>
<div class="literal-block-wrapper docutils container" id="id377">
<div class="code-block-caption"><span class="caption-text">可以指定的语言</span><a class="headerlink" href="#id377" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="n">c</span><span class="o">-</span><span class="n">header</span> <span class="n">cpp</span><span class="o">-</span><span class="n">output</span>
<span class="hll"><span class="n">c</span><span class="o">++</span> <span class="n">c</span><span class="o">++-</span><span class="n">header</span> <span class="n">c</span><span class="o">++-</span><span class="n">cpp</span><span class="o">-</span><span class="n">output</span>
</span><span class="n">objective</span><span class="o">-</span><span class="n">c</span> <span class="n">objective</span><span class="o">-</span><span class="n">c</span><span class="o">-</span><span class="n">header</span> <span class="n">objective</span><span class="o">-</span><span class="n">c</span><span class="o">-</span><span class="n">cpp</span><span class="o">-</span><span class="n">output</span>
<span class="n">objective</span><span class="o">-</span><span class="n">c</span><span class="o">++</span> <span class="n">objective</span><span class="o">-</span><span class="n">c</span><span class="o">++-</span><span class="n">header</span> <span class="n">objective</span><span class="o">-</span><span class="n">c</span><span class="o">++-</span><span class="n">cpp</span><span class="o">-</span><span class="n">output</span>
<span class="n">assembler</span> <span class="n">assembler</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">cpp</span>
<span class="n">ada</span>
<span class="n">d</span>
<span class="n">f77</span> <span class="n">f77</span><span class="o">-</span><span class="n">cpp</span><span class="o">-</span><span class="n">input</span> <span class="n">f95</span> <span class="n">f95</span><span class="o">-</span><span class="n">cpp</span><span class="o">-</span><span class="n">input</span>
<span class="n">go</span>
<span class="n">brig</span>
</pre></div>
</td></tr></table></div>
</div>
<p>-x none: 关闭指定语言，接下来的文件通过文件后缀名来确定其语言类型。（回到没有使用’-x’的时候）。</p>
<p>如果只想要某些编译阶段，您可以使用“ -x”（或使用特定文件名后缀）告诉gcc从哪里开始，以及选项“ -c”，“-S”或“ -E”之一来说明gcc的停止位置。 请注意，某些组合（例如，“-x cpp-output -E”）指示gcc完全不执行任何操作。</p>
<ul class="simple">
<li><p>-c ：编译或汇编源文件，但不链接。最终的输出是每个源文件对应的目标文件的形式。默认目标文件名字用’.o’代替源文件的后缀，如’.c’,’.i’,’.s’等。忽略掉不能识别的输入文件。</p></li>
<li><p>-S ：编译阶段后停止;不进行汇编。输出非汇编输出文件对应的汇编代码文件。默认，输出的汇编文件用’.s’代替输入文件的后缀’.c’,’.i’等。忽略掉不需要编译的文件。</p></li>
<li><p>-E ：预处理阶段后停止;不运行编译过程。以预处理源代码形式做为输出，忽略掉不需要预处理的文件。</p></li>
<li><p>-o file:</p></li>
<li><p>-dumpbase dumpbase</p></li>
<li><p>-dumpbase-ext auxdropsuf</p></li>
<li><p>-dumpdir dumppfx</p></li>
<li><p>-v</p></li>
<li><p>-### Like ‘-v’ except the commands are not executed and arguments are quoted
unless they contain only alphanumeric characters or ./-_. This is useful for
shell scripts to capture the driver-generated command lines.</p></li>
<li><p>–help</p></li>
<li><p>–target-help</p></li>
<li><p>–help={class|[^]qualifier}[,…]</p></li>
<li><p>–version</p></li>
<li><p>-pass-exit-codes</p></li>
<li><p>-pipe</p></li>
<li><p>-specs=file</p></li>
<li><p>-wrapper</p></li>
<li><p>-ffile-prefix-map=old=new</p></li>
<li><p>-fplugin=name.so</p></li>
<li><p>-fplugin-arg-name-key=value</p></li>
<li><p>-fdump-ada-spec[-slim]</p></li>
<li><p>-fada-spec-parent=unit</p></li>
<li><p>&#64;file</p></li>
</ul>
<blockquote>
<div></div></blockquote>
<ul class="simple">
<li><p>ansi：在C模式下,这相当于-std=c90。这会关闭GCC的某些功能，这些功能与ISO C90（在编译C代码时）不兼容，例如 asm 和 typeof 关键字，以及预定义的宏（例如 unix 和 vax )，这些功能可识别使用的系统类型。它还启用了不受欢迎且很少使用的ISO三部曲功能。对于C编译器，它将禁用对C ++样式的识别，//’注释以及 inline 关键字。备用关键字 __asm__ ， __extension__ ， __inline__ 和 __typeof__ 继续工作，尽管-ansi。当然，您不想在ISO C程序中使用它们，但是将它们放在可能包含在使用C语言完成的编译中的头文件中很有用。-ansi。可选的预定义宏（例如 __unix__ 和 __vax__ )也可以使用，无论有没有-ansi.The-ansi选项不会导致非ISO程序被无偿拒绝。对于这一点。-Wpedantic除此以外,还需要-ansi。请参阅警告选项。宏 __STRICT_ANSI__ 是在-ansi使用选项。一些头文件可能会注意到此宏，而避免声明某些功能或定义ISO标准不要求的某些宏。这是为了避免干扰可能将这些名称用于其他用途的任何程序。通常内置的但不具有ISO C定义的语义的函数（例如 alloca 和 ffs ）在以下情况下不是内置函数-ansi用来。</p></li>
<li><p>-std=：确定语言标准。有关这些标准版本的详细信息，请参见GCC支持的语言标准。当前仅在编译C或C ++时才支持此选项。编译器可以接受几种基本标准，例如“c90’ 要么 ‘c++98”以及这些标准的GNU方言，例如“gnu90’ 要么 ‘gnu++98’。指定基本标准后，编译器将接受该标准之后的所有程序，以及使用与该标准不矛盾的GNU扩展的程序。例如，-std=c90关闭与ISO C90不兼容的GCC某些功能（例如 asm 和 typeof 关键字），但关闭其他在ISO C90中没有含义的GNU扩展，例如省略 ?: 表达式的中间术语。另一方面，当指定了标准的GNU方言时，即使编译器支持的所有功能更改了基本标准的含义，也将启用它们。结果，可能会拒绝某些严格符合要求的程序。该特定标准由-Wpedantic来确定哪些功能是该版本标准的GNU扩展。例如-std = gnu90 -Wpedantic警告有关C ++样式’//”评论，而-std = gnu99 -Wpedantic没有。必须为该选项提供一个值;可能的值是:</p></li>
<li><p>-fgnu89-inline：该选项-fgnu89-inline告诉GCC 在C99模式下将传统GNU语义用于 inline 函数。请参见内联函数与宏一样快。使用此选项大致等效于将 gnu_inline 函数属性添加到所有内联函数（请参见函数属性）。该选项-fno-gnu89-inline明确告诉GCC 在C99或gnu99模式下将C99语义用于 inline （即，它指定默认行为）。该选项在以下版本中不受支持-std=c90or-std=gnu90mode.预处理器宏 __GNUC_GNU_INLINE__ 和 __GNUC_STDC_INLINE__ 可用于检查哪些语义 inline 函数有效。请参阅C 预处理器中的通用预定义宏。</p></li>
<li><p>-fpermitted-flt-eval-methods指定编译器是只允许C99 / C11中指定的 FLT_EVAL_METHOD 值，还是ISO / IEC TS 18661-3中指定的扩展值集。style 为 c11 或 ts-18661-3 (视情况而定）。在标准兼容模式下的默认值 (-std=c11或类似)是-fpermitted-flt-eval-methods=c11。使用GNU方言时的默认设置（-std=gnu11或类似)是-fpermitted-flt-eval-methods=ts-18661-3.</p></li>
<li><p>-aux-info filename 将翻译单元中声明和/或定义的所有函数(包括头文件中的函数)的原型声明输出到给定文件名。在C语言以外的任何语言中,这个选项都会被默默地忽略。除声明外，该文件还在注释中指出每个声明的来源（源文件和行），无论该声明是隐式，原型还是非原型（’I’，’N“是新的还是”O’分别代表行号和冒号后的第一个字符中的旧字符，以及它是来自声明还是定义（’C’ 要么 ‘F’，分别用以下字符）。对于函数定义，在声明之后的注释内还会提供K＆R样式的参数列表及其后跟的声明。</p></li>
<li><p>-fallow-parameterless-variadic-functions:接受没有命名参数的变量函数。虽然可以定义这样一个函数,但由于无法读取参数,所以用处不大。这只在C语言中得到支持,因为C++允许这种结构。</p></li>
<li><p>-fno-asm:不要将 asm ， inline 或 typeof 识别为关键字，以便代码可以将这些单词用作标识符。您可以使用关键字 __asm__ ， __inline__ 和 __typeof__ 代替。-ansiimplies-fno-asm.在C ++中，此开关仅影响 typeof 关键字，因为 asm 和 inline 是标准关键字。您可能要使用-fno-gnu-keywords标志代替,效果相同。在C99模式下(-std=c99or-std=gnu99），此开关仅影响 asm 和 typeof 关键字，因为 inline 是ISO C99中的标准关键字。</p></li>
<li><p>-fno-builtin:
-fno-builtin-function
无法识别不以’开头的内置函数__builtin_’作为前缀。有关受影响的功能的详细信息，请参阅GCC提供的其他内置功能，包括那些非内置功能。-ansior-std严格符合ISO C标准的选项被使用,因为它们没有ISO标准的含义。GCC通常会生成特殊的代码来更有效地处理某些内置函数；例如，对 alloca 的调用可能成为直接调整堆栈的单个指令，对 memcpy 的调用可能成为内联复制循环。生成的代码通常更小且更快，但是由于函数调用不再像这样出现，因此您无法在这些调用上设置断点，也无法通过链接到其他库来更改函数的行为。此外，当某个功能被识别为内置功能时，GCC可能会使用有关该功能的信息来警告对该功能的调用存在问题，或者生成更有效的代码，即使结果代码仍包含对该功能的调用。例如，警告带有-Wformat内置 printf 且 strlen 被称为不修改全局内存时，对 printf 的错误调用。</p></li>
</ul>
<p>随着-fno-builtin-function选项仅禁用内置功能 function 。 function 不能以’__builtin_’。如果此版本的GCC中没有内置函数的名称，则忽略此选项。没有对应的-fbuiltin-function选项;如果您希望在使用时有选择地启用内置功能,则可使用-fno-builtinor-ffreestanding，您可以定义宏，例如：</p>
<ul>
<li><dl class="option-list">
<dt><kbd><span class="option">-f<var>gimple</var></span></kbd></dt>
<dd><p>启用对标记为 __GIMPLE 的函数定义的解析。这是一项实验功能，可以对GIMPLE通过进行单元测试。</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-f<var>hosted</var></span></kbd></dt>
<dd><p>断言编译的目标是托管环境。这意味着-fbuiltin。托管环境是可以使用整个标准库的环境，其中 main 具有返回类型 int 的环境。除内核外，几乎所有示例都是如此。这相当于-fno-freestanding.</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-f<var>freestanding</var></span></kbd></dt>
<dd><p>断言编译的目标是一个独立的环境。这意味着-fno-builtin。独立环境是其中可能不存在标准库的环境，并且程序启动不一定必须处于 main 。最明显的例子是OS内核。这相当于-fno-hosted.</p>
<p>有关独立和托管环境的详细信息，请参见GCC支持的语言标准。</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-f<var>openacc</var></span></kbd></dt>
<dd><p>在C / C ++中启用OpenACC指令 #pragma acc 的处理，在Fortran中启用 !$acc 的处理。什么时候-fopenacc指定后，编译器将根据OpenACC应用程序编程接口v2.6 <a class="reference external" href="https://www.openacc">https://www.openacc</a>.org生成加速的代码。此选项暗示-pthread，因此仅在具有以下功能的目标上受支持-pthread.</p>
</dd>
</dl>
</li>
<li><p>-fopenacc-dim=geom</p>
<blockquote>
<div><p>为未明确指定的并行卸载区域指定默认计算维度。所述 geom 值是三重的“：” -分离尺寸，为了“团伙”，“工”和“矢量”。可以省略大小，以使用特定于目标的默认值。</p>
</div></blockquote>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-f<var>openmp</var></span></kbd></dt>
<dd><p>在C / C ++中启用OpenMP指令 #pragma omp 的处理，在Fortran中启用 !$omp 的处理。什么时候-fopenmp指定后，编译器将根据OpenMP应用程序接口v4.5 <a class="reference external" href="https://www.openmp">https://www.openmp</a>.org生成并行代码。此选项暗示-pthread，因此仅在具有以下功能的目标上受支持-pthread.-fopenmpimplies-fopenmp-simd.</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-f<var>openmp-simd</var></span></kbd></dt>
<dd><p>使用C / C ++中的 #pragma omp 和Fortran中的 !$omp 启用对OpenMP SIMD指令的处理。其他OpenMP指令将被忽略。</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-f<var>gnu-tm</var></span></kbd></dt>
<dd><p>当该选项-fgnu-tm如果指定，编译器将为Intel当前事务存储ABI规范文档（修订版1.1，2009年5月6日）的Linux变体生成代码。这是一项实验性功能，随着官方规范的更改，其界面在GCC的未来版本中可能会更改。请注意，此功能并非支持所有架构。</p>
<p>有关 GCC 对事务内存的支持的更多信息，请参阅GNU 事务内存库中的 GNU 事务内存库。</p>
<p>请注意,非调用异常不支持事务性内存功能(-fnon-call-exceptions).</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-f<var>ms-extensions</var></span></kbd></dt>
<dd><p>接受微软头文件中使用的一些非标准结构。</p>
<p>在C++代码中,这使得结构中的成员名与之前的类型声明相似。</p>
<p>请注意,除了使用 ms-abi 的 x86 目标外,所有目标都关闭了这个选项。</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-f<var>plan9-extensions</var></span></kbd></dt>
<dd><p>接受计划9代码中使用的一些非标准结构。</p>
<p>这使得-fms-extensions，允许将指向带有匿名字段的结构的指针传递给需要指向该字段类型元素的指针的函数，并允许引用使用typedef声明的匿名字段。有关详细信息，请参见结构/联合中的未命名结构/联合字段。仅C语言支持此功能，C ++不支持。</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-f<var>cond-mismatch</var></span></kbd></dt>
<dd><p>允许在第二个和第三个参数中使用类型不匹配的条件表达式。这种表达式的值是void。C++不支持这个选项。</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-f<var>lax-vector-conversions</var></span></kbd></dt>
<dd><p>允许在元素数量不同和/或元素类型不兼容的向量之间进行隐式转换。这个选项不应该用于新代码。</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-f<var>unsigned-char</var></span></kbd></dt>
<dd><p>让类型 char 为unsigned，就像 unsigned char 一样。</p>
<p>每种机器都有默认的 char 字符。默认情况下，它就像 unsigned char ，或者默认情况下像 signed char 。</p>
<p>理想情况下，当可移植程序依赖于对象的 unsigned char 时，应始终使用有 signed char 或无符号字符。但是，已经编写了许多使用纯 char 并希望它们可以被签名，或者期望它是未签名的，这取决于编写它们的机器。此选项及其相反的选项使您可以使用相反的默认值使此类程序正常工作。</p>
<p>char 类型始终是与每个有 signed char 或 unsigned char 截然不同的类型，即使它的行为总是与这两个字符之一相同。</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-f<var>signed-char</var></span></kbd></dt>
<dd><p>让 char 类型像 signed char 一样被签名。</p>
<p>请注意,这相当于-fno-unsigned-char，这是的否定形式-funsigned-char。同样，该选项-fno-signed-char相当于-funsigned-char.</p>
</dd>
</dl>
</li>
<li><p>-fsigned-bitfields
-funsigned-bitfields
-fno-signed-bitfields
-fno-unsigned-bitfields</p>
<blockquote>
<div><p>当声明不使用 signed 或 unsigned 时，这些选项控制位字段是带符号的还是无符号的。默认情况下，这样的位字段是带符号的，因为这是一致的：诸如 int 之类的基本整数类型是带符号的类型。</p>
</div></blockquote>
</li>
<li><p>-fsso-struct=endianness</p>
<blockquote>
<div><p>将结构和联合的默认标量存储顺序设置为指定的字节序。可接受的值为“big-endian’，’little-endian’和’native’表示目标的本地字节序（默认）。C ++不支持此选项。</p>
<p>警告：在-fsso-struct如果指定的endianness不是目标的本机endianness,开关会导致GCC生成的代码与没有它的代码不二进制兼容。</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="id4">
<h2>控制诊断消息格式的选项<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>传统上，诊断消息的格式与输出设备的外观无关（例如，其宽度等）。您可以使用下面描述的选项来控制诊断消息的格式算法，例如，每行多少个字符，应该多久报告一次源位置信息。请注意，某些语言的前端可能不支持这些选项。</p>
<p>-fmessage-length=n</p>
<blockquote>
<div><p>尝试格式化错误消息，以使它们适合大约 n 个字符的行。如果 n 为零，则不进行换行。每个错误消息都显示在一行上。这是所有前端的默认设置。</p>
<p>注意-此选项还会影响“#error’和’#warning’预处理程序指令，以及’deprecated’函数/类型/变量属性。但是，它不会影响“参数GCC警告’和’pragma GCC错误语篇</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>diagnostics-plain-output</var></span></kbd></dt>
<dd><p>此选项要求诊断输出看起来尽可能简单，这在运行 dejagnu 或其他需要解析诊断输出并希望它随时间保持更稳定的实用程序时可能很有用。-fdiagnostics-plain-output目前等同于以下选项。</p>
</dd>
</dl>
<div class="literal-block-wrapper docutils container" id="id378">
<div class="code-block-caption"><span class="caption-text">可以指定的语言</span><a class="headerlink" href="#id378" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span>-fno-diagnostics-show-caret
<span class="hll">-fno-diagnostics-show-line-numbers
</span>-fdiagnostics-color=never
-fdiagnostics-urls=never
-fdiagnostics-path-format=separate-events


 未来,如果GCC改变了其诊断程序的默认外观,相应的禁用新行为的选项将被添加到这个列表中。
</pre></div>
</td></tr></table></div>
</div>
<p>-fdiagnostics-show-location=once</p>
<blockquote>
<div><p>仅在换行模式下有意义。指示诊断消息报告程序一次发出源位置信息；也就是说，如果消息太长而无法容纳在单个物理行上并且必须进行包装，则源位置将不会在后续的连续行中一遍又一遍地发出（作为前缀）。这是默认行为。</p>
</div></blockquote>
<p>-fdiagnostics-show-location=every-line</p>
<blockquote>
<div><p>只有在包线模式下才有意义。指示诊断电文报告器对因电文太长而无法在单行上显示而产生的物理行发出相同的源位置信息(作为前缀)。</p>
</div></blockquote>
<p>-fdiagnostics-color[=WHEN]
-fno-diagnostics-color</p>
<blockquote>
<div><p>在诊断中使用颜色。 WHEN 是’never’，’always’， 要么 ‘auto’。默认值取决于编译器的配置方式，它可以是上述任何 WHEN 选项，也可以是’never’如果环境中不存在 GCC_COLORS 环境变量，则’auto’ 除此以外。’auto’仅当标准错误为终端且未在emacs shell中执行时，才使GCC使用颜色。表格-fdiagnostics-colorand-fno-diagnostics-color的别名。-fdiagnostics-color=alwaysand-fdiagnostics-color=never， 分别。</p>
<p>颜色由环境变量 GCC_COLORS 定义。它的值是用冒号分隔的功能和选择图形渲染（SGR）子字符串列表。SGR命令由终端或终端仿真器解释。（有关允许的值及其作为字符属性的含义，请参见文本终端文档中的部分。）这些子字符串值是十进制表示形式的整数，可以与分号连接。连接的常见值包括“1“大胆”4“下划线”5“眨眼，”7“反之，”39’为默认前景色，’30’ 至 ‘37“代表前景色”90’ 至 ‘97’用于16色模式前景色，’38;5;0’ 至 ‘38;5;255’用于88色和256色模式的前景色，’49’为默认背景色，’40’ 至 ‘47’为背景色’100’ 至 ‘107’用于16色模式背景色，和’48;5;0’ 至 ‘48;5;255’代表88色和256色模式的背景色。</p>
<p>默认的 GCC_COLORS 是</p>
</div></blockquote>
<div class="literal-block-wrapper docutils container" id="id379">
<div class="code-block-caption"><span class="caption-text">可以指定的语言</span><a class="headerlink" href="#id379" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53</pre></div></td><td class="code"><div class="highlight"><pre><span></span>error=01;31:warning=01;35:note=01;36:range1=32:range2=34:locus=01:\
<span class="hll">quote=01:path=01;36:fixit-insert=32:fixit-delete=31:\
</span>diff-filename=01:diff-hunk=32:diff-delete=31:diff-insert=32:\
type-diff=01;32


 在哪里01;31&#39;是大胆的红色，&#39;01;35&#39;是大胆的洋红色，&#39;01;36&#39;是粗体青色，&#39;32&#39;是绿色的&#39;34&#39;是蓝色的&#39;01&#39;粗体，&#39;31&#39;是红色的。将 GCC_COLORS 设置为空字符串将禁用颜色。支持的功能如下。

 error=

     错误的SGR子串:标记。
 warning=

     警告的SGR子串:标记。
 note=

     注释的SGR子串:标记。
 path=

     SGR子串,用于对控制流事件的路径进行着色,因为它通过-fdiagnostics-path-format=，例如各个事件的标识符和指示过程间调用和返回的行。
 range1=

     第一个附加范围的SGR子串。
 range2=

     第二个附加范围的SGR子串。
 locus=

     用于位置信息的SGR子字符串，“file:line&#39; 要么 &#39;file:line:column&#39;等
 quote=

     SGR子串,用于打印引号内的信息。
 fixit-insert=

     SGR子串用于修复提示,建议插入或替换文本。
 fixit-delete=

     SGR子串,用于提示要删除的文本的修复提示。
 diff-filename=

     SGR子串用于生成补丁中的文件名头。
 diff-hunk=

     SGR子串,用于在生成的补丁中启动hunks。
 diff-delete=

     在生成的补丁中删除行的SGR子串。
 diff-insert=

     在生成的补丁中插入的行的SGR子串。
 type-diff=

     SGR子串,用于在C++前端高亮显示模板参数内的不匹配类型。
</pre></div>
</td></tr></table></div>
</div>
<p>-fdiagnostics-urls[=WHEN]</p>
<blockquote>
<div><p>使用转义序列在诊断程序中嵌入URL。例如,当-fdiagnostics-show-option发出文本显示控制诊断的命令行选项,嵌入该选项的文档URL。</p>
<p>WHEN 是’never’，’always’， 要么 ‘auto’。’auto’仅当标准错误是终端，并且不在emacs shell或任何已知与此功能不兼容的图形终端中执行时，才使GCC使用URL转义序列。请参见下文。</p>
<p>默认值取决于编译器的配置方式。它可以是以上任何 WHEN 选项。</p>
<p>也可以配置GCC(通过–with-diagnostics-urls=auto-if-envconfigure-time选项），以便默认值受环境变量影响。在这种配置下，GCC默认使用’auto’如果 GCC_URLS 或 TERM_URLS 环境变量在编译器环境中存在且为非空，则为’never’如果两者都不是。</p>
<p>然而,即使有-fdiagnostics-urls=always行为取决于以下环境变量：如果 GCC_URLS 设置为空或’no’，请勿在诊断程序中嵌入URL。如果设置为“st’，URL使用ST转义序列。如果设置为“bel’（默认情况下，URL使用BEL转义序列）。任何其他非空值都会启用该功能。如果 GCC_URLS 没有设置，使用 TERM_URLS 作为后备。注意：ST是ANSI转义序列，字符串终止符’ESC’，BEL是ASCII字符CTRL-G，通常听起来像是哔声。</p>
<p>此时GCC还试图检测一些已知没有实现URL功能的终端,并且在某些仍在使用的版本中存在bug或至少有过bug,在这些版本中,URL转义很可能出现错误行为,即在屏幕上打印垃圾。这个列表目前是xfce4-terminal、某些已知有bug的gnome-terminal版本、linux控制台和mingw。这个检查可以用-fdiagnostics-urls=always.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>no-diagnostics-show-option</var></span></kbd></dt>
<dd><p>默认情况下,每个诊断器发出的文本包括指示直接控制诊断器的命令行选项的文本(如果诊断器知道有这样的选项)。指定-fno-diagnostics-show-option标志可以抑制这种行为。</p>
</dd>
<dt><kbd><span class="option">-f<var>no-diagnostics-show-caret</var></span></kbd></dt>
<dd><p>默认情况下，发出的每个诊断都包括原始源代码行和插入符号’^’表示该列。此选项禁止显示此信息。如果源行被截断为 n 个字符，-fmessage-length=n选项给出。当输出到终端时，宽度限制为由 COLUMNS 环境变量指定的宽度，或者，如果未设置，则限制为终端宽度。</p>
</dd>
<dt><kbd><span class="option">-f<var>no-diagnostics-show-labels</var></span></kbd></dt>
<dd><p>默认情况下,当打印源代码时(通过-fdiagnostics-show-caret），诊断程序可以使用相关信息（例如表达式的类型）标记源代码范围：</p>
</dd>
</dl>
<div class="literal-block-wrapper docutils container" id="id380">
<div class="code-block-caption"><span class="caption-text">可以指定的语言</span><a class="headerlink" href="#id380" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span>printf (&quot;foo %s bar&quot;, long_i + long_j);
<span class="hll">          ~^       ~~~~~~~~~~~~~~~
</span>           |              |
           char *         long int


 此选项禁止打印这些标签（在上面的示例中，竖线以及“ char *”和“ long int”文本）。
</pre></div>
</td></tr></table></div>
</div>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>no-diagnostics-show-cwe</var></span></kbd></dt>
<dd><p>诊断消息可以选择具有关联的CWE标识符。GCC本身仅为某些-fanalyzer诊断程序。GCC插件也可以提供带有这种元数据的诊断程序。默认情况下,如果存在这些信息,它将与诊断程序一起打印。这个选项会抑制打印这些元数据。</p>
</dd>
<dt><kbd><span class="option">-f<var>no-diagnostics-show-line-numbers</var></span></kbd></dt>
<dd><p>默认情况下,当打印源代码时(通过-fdiagnostics-show-caret），则打印出左边距，显示行号。此选项禁止显示此左边距。</p>
</dd>
</dl>
<p>-fdiagnostics-minimum-margin-width=width</p>
<blockquote>
<div><p>这个选项可以控制由以下方式打印的左页边距的最小宽度-fdiagnostics-show-line-numbers。默认为6。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>diagnostics-parseable-fixits</var></span></kbd></dt>
<dd><p>以机器可解析的格式发出修复提示，适合IDE使用。对于每个修复程序，将在相关诊断后打印一行，以字符串“ fix-it：”开头。例如：</p>
</dd>
</dl>
<div class="literal-block-wrapper docutils container" id="id381">
<div class="code-block-caption"><span class="caption-text">可以指定的语言</span><a class="headerlink" href="#id381" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">fix</span><span class="o">-</span><span class="nl">it</span><span class="p">:</span><span class="s">&quot;test.c&quot;</span><span class="o">:</span><span class="p">{</span><span class="mi">45</span><span class="o">:</span><span class="mi">3-45</span><span class="o">:</span><span class="mi">21</span><span class="p">}</span><span class="o">:</span><span class="s">&quot;gtk_widget_show_all&quot;</span>
</pre></div>
</td></tr></table></div>
</div>
<p>该位置表示为半开范围，表示为字节数，从初始列的字节1开始。在上面的示例中，“ test.c”的第45行的字节3到20将用给定的字符串替换：</p>
<div class="literal-block-wrapper docutils container" id="id382">
<div class="code-block-caption"><span class="caption-text">可以指定的语言</span><a class="headerlink" href="#id382" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span> 00000000011111111112222222222
<span class="hll"> 12345678901234567890123456789
</span> gtk_widget_showall (dlg);
   ^^^^^^^
 gtk_widget_show_all

 文件名和替换字符串以反斜杠转义为“ \\”，制表符为“ \ t”，换行符为“ \ n”，双引号为“ \”，不可打印字符为八进制（例如，垂直制表符为“ \ 013” ）。

 空的替换字符串表示要删除给定范围。空范围（例如“ 45：3-45：3”）指示字符串将被插入到给定位置。
</pre></div>
</td></tr></table></div>
</div>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>diagnostics-generate-patch</var></span></kbd></dt>
<dd><p>在任何诊断程序被打印出来后,以统一的 diff 格式将修复提示打印到 stderr。例如</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>diagnostics-show-template-tree</var></span></kbd></dt>
<dd><p>在C++前端,当打印诊断结果显示模板类型不匹配时,如。</p>
</dd>
</dl>
<div class="literal-block-wrapper docutils container" id="id383">
<div class="code-block-caption"><span class="caption-text">可以指定的语言</span><a class="headerlink" href="#id383" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span> could not convert &#39;std::map&lt;int, std::vector&lt;double&gt; &gt;()&#39;
<span class="hll">   from &#39;map&lt;[...],vector&lt;double&gt;&gt;&#39; to &#39;map&lt;[...],vector&lt;float&gt;&gt;
</span>
 the-fdiagnostics-show-template-tree标志可以打印树状结构,显示类型的共同部分和不同部分,例如。

 map&lt;
   [...],
   vector&lt;
     [double != float]&gt;&gt;

 不同的部分以颜色突出显示（在这种情况下为“ double”和“ float”）。
</pre></div>
</td></tr></table></div>
</div>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>no-elide-type</var></span></kbd></dt>
<dd><p>默认情况下，当C ++前端打印出显示模板类型不匹配的诊断信息时，这些类型的公共部分将打印为“ […]”以简化错误消息。例如：</p>
</dd>
</dl>
<div class="literal-block-wrapper docutils container" id="id384">
<div class="code-block-caption"><span class="caption-text">可以指定的语言</span><a class="headerlink" href="#id384" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span> could not convert &#39;std::map&lt;int, std::vector&lt;double&gt; &gt;()&#39;
<span class="hll">   from &#39;map&lt;[...],vector&lt;double&gt;&gt;&#39; to &#39;map&lt;[...],vector&lt;float&gt;&gt;
</span>
 指定-fno-elide-type标志会抑制这种行为。这个标志也会影响-fdiagnostics-show-template-treeflag.
</pre></div>
</td></tr></table></div>
</div>
<p>-fdiagnostics-path-format=KIND</p>
<blockquote>
<div><p>指定如何打印具有相关路径的诊断程序的控制流事件的路径。</p>
<p>KIND 是“none’，’separate-events’， 要么 ‘inline-events’，即默认值。</p>
<p>‘none’表示不打印诊断路径。</p>
<p>‘separate-events表示要为诊断中的每个事件打印单独的“注释”诊断。例如：</p>
</div></blockquote>
<div class="literal-block-wrapper docutils container" id="id385">
<div class="code-block-caption"><span class="caption-text">可以指定的语言</span><a class="headerlink" href="#id385" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span> test.c:29:5: error: passing NULL as argument 1 to &#39;PyList_Append&#39; which requires a non-NULL parameter
<span class="hll"> test.c:25:10: note: (1) when &#39;PyList_New&#39; fails, returning NULL
</span> test.c:27:3: note: (2) when &#39;i &lt; count&#39;
 test.c:29:5: note: (3) when calling &#39;PyList_Append&#39;, passing NULL from (1) as argument 1

 ‘inline-events&#39;表示在源代码中“内联”打印事件。该视图试图将事件合并为足够接近的事件，并将其打印为源内的标记范围。

 例如,与上述相同的事件可能被打印成:
</pre></div>
</td></tr></table></div>
</div>
<div class="literal-block-wrapper docutils container" id="id386">
<div class="code-block-caption"><span class="caption-text">可以指定的语言</span><a class="headerlink" href="#id386" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span></span> &#39;test&#39;: events 1-3
<span class="hll">   |
</span>   |   25 |   list = PyList_New(0);
   |      |          ^~~~~~~~~~~~~
   |      |          |
   |      |          (1) when &#39;PyList_New&#39; fails, returning NULL
   |   26 |
   |   27 |   for (i = 0; i &lt; count; i++) {
   |      |   ~~~
   |      |   |
   |      |   (2) when &#39;i &lt; count&#39;
   |   28 |     item = PyLong_FromLong(random());
   |   29 |     PyList_Append(list, item);
   |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~
   |      |     |
   |      |     (3) when calling &#39;PyList_Append&#39;, passing NULL from (1) as argument 1
   |

 程序间的控制流程是通过按堆栈框架对事件进行分组,并使用缩进来显示堆栈框架的嵌套、推送和弹出方式。

 例如:
</pre></div>
</td></tr></table></div>
</div>
<div class="literal-block-wrapper docutils container" id="id387">
<div class="code-block-caption"><span class="caption-text">可以指定的语言</span><a class="headerlink" href="#id387" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></div></td><td class="code"><div class="highlight"><pre><span></span> &#39;test&#39;: events 1-2
<span class="hll">     |
</span>     |  133 | {
     |      | ^
     |      | |
     |      | (1) entering &#39;test&#39;
     |  134 |   boxed_int *obj = make_boxed_int (i);
     |      |                    ~~~~~~~~~~~~~~~~~~
     |      |                    |
     |      |                    (2) calling &#39;make_boxed_int&#39;
     |
     +--&gt; &#39;make_boxed_int&#39;: events 3-4
            |
            |  120 | {
            |      | ^
            |      | |
            |      | (3) entering &#39;make_boxed_int&#39;
            |  121 |   boxed_int *result = (boxed_int *)wrapped_malloc (sizeof (boxed_int));
            |      |                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            |      |                                    |
            |      |                                    (4) calling &#39;wrapped_malloc&#39;
            |
            +--&gt; &#39;wrapped_malloc&#39;: events 5-6
                   |
                   |    7 | {
                   |      | ^
                   |      | |
                   |      | (5) entering &#39;wrapped_malloc&#39;
                   |    8 |   return malloc (size);
                   |      |          ~~~~~~~~~~~~~
                   |      |          |
                   |      |          (6) calling &#39;malloc&#39;
                   |
     &lt;-------------+
     |
  &#39;test&#39;: event 7
     |
     |  138 |   free_boxed_int (obj);
     |      |   ^~~~~~~~~~~~~~~~~~~~
     |      |   |
     |      |   (7) calling &#39;free_boxed_int&#39;
     |
 (etc)
</pre></div>
</td></tr></table></div>
</div>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>diagnostics-show-path-depths</var></span></kbd></dt>
<dd><p>当打印与诊断相关的控制流路径时,该选项提供了额外的信息。</p>
<p>如果提供了这个选项,那么堆栈深度将被打印出来,用于在-fdiagnostics-path-format=separate-events.</p>
<p>这是为了让GCC开发人员和插件开发人员在调试诊断报告程序间控制流时使用。</p>
</dd>
<dt><kbd><span class="option">-f<var>no-show-column</var></span></kbd></dt>
<dd><p>不要在诊断中打印列号。如果诊断程序是由不了解列号的程序（例如 dejagnu )扫描的，则可能有必要。</p>
</dd>
</dl>
<p>-fdiagnostics-column-unit=UNIT</p>
<blockquote>
<div><p>选择列号的单位。这影响到传统的诊断方法(在没有-fno-show-column)，以及 JSON 格式诊断（如果需要）。</p>
<p>默认 UNIT , ‘display’, 考虑每个字符占用的显示列数。在制表符的情况下，这可能大于对字符进行编码所需的字节数，或者在多字节字符的情况下可能更小。例如，字符“GREEK SMALL LETTER PI (U+03C0)”占用一个显示列，其UTF-8编码需要两个字节；字符“SLIGHTLY SMILING FACE (U+1F642)”占据两个显示列，其UTF-8编码需要四个字节。</p>
<p>将 UNIT 设置为 ‘byte’ 在所有情况下都将列号更改为原始字节数，这是 GCC 在 11.1.0 版之前的传统输出。</p>
</div></blockquote>
<p>-fdiagnostics-column-origin=ORIGIN</p>
<blockquote>
<div><p>选择列号的来源,即分配给第一列的列号。默认值为1,与传统的GCC行为和GNU风格指南相一致。有些工具在原点为0时可能表现得更好;可以指定任何非负值。</p>
</div></blockquote>
<p>-fdiagnostics-format=FORMAT</p>
<blockquote>
<div><p>选择其他格式进行打印诊断。 FORMAT 为“text’ 要么 ‘json’。默认值为“text’.</p>
<p>这 ‘json格式由包含表示诊断的JSON对象的顶级JSON数组组成。</p>
<p>JSON是以一行的形式发出的,没有格式化;为了清楚起见,下面的例子已经进行了格式化。</p>
<p>诊断程序可以有子诊断程序。例如,这个错误和说明。</p>
</div></blockquote>
<div class="literal-block-wrapper docutils container" id="id388">
<div class="code-block-caption"><span class="caption-text">可以指定的语言</span><a class="headerlink" href="#id388" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59</pre></div></td><td class="code"><div class="highlight"><pre><span></span> [
<span class="hll">     {
</span>         &quot;kind&quot;: &quot;warning&quot;,
         &quot;locations&quot;: [
             {
                 &quot;caret&quot;: {
                 &quot;display-column&quot;: 3,
                 &quot;byte-column&quot;: 3,
                     &quot;column&quot;: 3,
                     &quot;file&quot;: &quot;misleading-indentation.c&quot;,
                     &quot;line&quot;: 15
                 },
                 &quot;finish&quot;: {
                 &quot;display-column&quot;: 4,
                 &quot;byte-column&quot;: 4,
                     &quot;column&quot;: 4,
                     &quot;file&quot;: &quot;misleading-indentation.c&quot;,
                     &quot;line&quot;: 15
                 }
             }
         ],
         &quot;message&quot;: &quot;this \u2018if\u2019 clause does not guard...&quot;,
         &quot;option&quot;: &quot;-Wmisleading-indentation&quot;,
         &quot;option_url&quot;: &quot;https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#index-Wmisleading-indentation&quot;,
         &quot;children&quot;: [
             {
                 &quot;kind&quot;: &quot;note&quot;,
                 &quot;locations&quot;: [
                     {
                         &quot;caret&quot;: {
                         &quot;display-column&quot;: 5,
                         &quot;byte-column&quot;: 5,
                             &quot;column&quot;: 5,
                             &quot;file&quot;: &quot;misleading-indentation.c&quot;,
                             &quot;line&quot;: 17
                         }
                     }
                 ],
                 &quot;message&quot;: &quot;...this statement, but the latter is …&quot;
             }
         ]
     &quot;column-origin&quot;: 1,
     },
     …
 ]

 当 note 是一个孩子 warning 。

 诊断有 kind 。如果这是 warning ，则有一个 option 键描述控制警告的命令行选项。

 诊断可以包含零个或多个位置。每个位置都有一个可选的 label 字符串和其中最多三个位置： caret 位置和可选的 start 和 finish 位置。位置由 file 名、 line 号和表示列位置的三个数字描述：

     display-column 计数显示列，占制表符和多字节字符。
     byte-column 计算原始字节数。
     column 等于前两个之一，如-fdiagnostics-column-unitoption.

 所有这三列都是相对于由下列文件指定的原点而言的-fdiagnostics-column-origin，通常等于 1，但可以设置为例如 0 以与其他从 0 开始编号列的实用程序兼容。列来源记录在 JSON 输出中的 column-origin 标记中。在下面的其余示例中，为简洁起见，省略了额外的列号输出。

 例如,这个错误。
</pre></div>
</td></tr></table></div>
</div>
<p>警告是诊断信息,它报告的结构本身没有错误,但有风险,或暗示可能有错误。</p>
<p>以下与语言无关的选项不启用特定的警告,但可以控制GCC产生的诊断类型。</p>
<ul>
<li><dl class="option-list">
<dt><kbd><span class="option">-f<var>syntax-only</var></span></kbd></dt>
<dd><p>检查代码中是否存在语法错误，但不要做其他任何事情。</p>
</dd>
</dl>
</li>
<li><p>-fmax-errors=n</p>
<blockquote>
<div><p>将错误消息的最大数量限制为 n ，这时GCC摆脱困境，而不是尝试继续处理源代码。如果 n 为0（默认值），则错误消息的数量没有限制。如果-Wfatal-errors也指定了,那么-Wfatal-errors优先于此选项。</p>
</div></blockquote>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-w</span></kbd></dt>
<dd><p>抑制所有警告信息。</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-W<var>error</var></span></kbd></dt>
<dd><p>把所有的警告都变成错误。</p>
</dd>
</dl>
</li>
<li><p>-Werror=</p>
<blockquote>
<div><p>将指定的警告变成一个错误。警告的指定符被附加,例如-Werror=switch将警告控制在-Wswitch成错误。这个开关采用负值形式,要用来否定-Werror具体的警告;例如-Wno-error=switchmakes-Wswitch警告不出错,即使在-Werror是有效的。</p>
<p>每个可控警告的警告信息包括控制该警告的选项。该选项可以与-Werror=and-Wno-error=如上所述。(警告信息中的选项的打印可以通过使用-fno-diagnostics-show-optionflag.)</p>
<p>请注意,指定-Werror=foo 自动暗示-Wfoo 。然而，-Wno-error=foo 并不表示任何内容。</p>
</div></blockquote>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-W<var>fatal-errors</var></span></kbd></dt>
<dd><p>这个选项会使编译器在第一次发生错误时中止编译,而不是试图继续编译并打印更多的错误信息。</p>
</dd>
</dl>
</li>
</ul>
<p>您可以使用“’-W’， 例如-Wimplicit请求对隐式声明的警告。这些特定的警告选项中的每一个也都有一个以’-Wno-‘关闭警告；例如，-Wno-implicit。本手册仅列出两种形式中的一种，而不是默认形式。有关其他特定于语言的选项，请参阅C ++语言选项和Objective-C和Objective-C ++语言选项。通过启用静态分析器可以产生其他警告。请参阅静态分析器选项。</p>
<p>一些选项,如-Walland-Wextra，打开其他选项，例如-Wunused，这可能会打开其他选项，例如-Wunused-value。正负形式的综合效果是，较具体的选项优先于较不具体的选项，而与它们在命令行中的位置无关。对于相同特异性的选项，最后一个选项生效。通过编译指示启用或禁用的选项（请参阅诊断编译指示）将生效，就像它们出现在命令行末尾一样。</p>
<p>当要求使用未识别的警告选项时(例如:)-Wunknown-warning），GCC发出诊断信息，指出该选项未被识别。但是，如果-Wno-的形式,行为略有不同:没有对-Wno-unknown-warning除非正在制作其他诊断程序。这允许使用新的-Wno-选项,但如果出了问题,编译器会警告说有一个未识别的选项存在。</p>
<p>一些警告的有效性取决于是否也启用了优化。例如-Wsuggest-final-types是更有效的链接时间优化和-Wmaybe-uninitialized除非启用优化,否则根本不会发出警告。</p>
<ul>
<li><p>-Wpedantic
-pedantic</p>
<blockquote>
<div><p>发出严格的ISO C和ISO C++所要求的所有警告;拒绝所有使用禁止扩展的程序,以及其他一些不遵循ISO C和ISO C++的程序。对于ISO C,遵循ISO C标准指定的版本,由任何一个-std使用的选项。</p>
<p>不管有没有这个选项,有效的ISO C和ISO C++程序都应该能正常编译(尽管有极少数的程序需要使用-ansi或-std选项指定了所需的ISO C版本)。)但是,如果没有这个选项,某些GNU扩展和传统的C和C++特性也会被支持。有了这个选项,它们会被拒绝。</p>
<p>-Wpedantic不会引起警告消息，提示使用名称以’结尾’<a href="#id402"><span class="problematic" id="id403">的替代关键字__</span></a>’。这种替代格式也可以用于禁用非ISO’__intN’类型，即’__intN__’。在 __extension__ 后面的表达式中也禁用了Pedantic警告。但是，只有系统头文件才应使用这些转义路由。应用程序应避免使用它们。请参阅备用关键字。</p>
<p>一些用户尝试使用-Wpedantic检查程序是否严格符合ISOC。他们很快发现它并没有达到他们想要的功能：它发现了一些非ISO的实践，但不是全部-仅发现那些需要 ISO C 进行诊断的实践，以及发现了一些已添加诊断的实践。</p>
<p>在某些情况下,报告任何不符合ISO C的情况的功能可能是有用的,但需要做大量的额外工作,并将在很大程度上不同于ISO C。-Wpedantic。我们没有计划在不久的将来支持这种功能。</p>
<p>在以下标准的情况下:-std代表C的GNU扩展方言，例如’gnu90’ 要么 ‘gnu99’，有一个相应的基本标准，即GNU扩展方言所基于的ISO C版本。来自的警告-Wpedantic在基本标准要求的地方给出警告。(如果只对不在指定的GNU C方言中的特性发出警告,那是没有意义的,因为根据定义,GNU C方言包括了编译器支持的所有特性,所以没有什么需要警告的。)</p>
</div></blockquote>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-p<var>edantic-errors</var></span></kbd></dt>
<dd><p>只要基本标准（请参阅-Wpedantic）需要进行诊断，在某些情况下会在编译时出现未定义的行为，而在某些其他情况下会阻止进行根据标准有效的程序的编译。这不等于-Werror=pedantic，因为此选项启用了错误，而该选项未启用，反之亦然。</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-W<var>all</var></span></kbd></dt>
<dd><p>这样就可以启用所有有关某些用户认为可疑的构造的警告，即使与宏结合使用，也很容易避免（或进行修改以防止出现警告）。这还启用了某些特定于语言的警告，这些警告在C ++语言选项和Objective-C和Objective-C ++语言选项中进行了描述。</p>
<p>-Wall开启以下警告标志。</p>
<p>-Waddress
-Warray-bounds=1 (only with -O2)
-Warray-parameter=2 (C and Objective-C only)
-Wbool-compare
-Wbool-operation
-Wc++11-compat  -Wc++14-compat
-Wcatch-value (C++ and Objective-C++ only)
-Wchar-subscripts
-Wcomment
-Wduplicate-decl-specifier (C and Objective-C only)
-Wenum-compare (in C/ObjC; this is on by default in C++)
-Wformat
-Wformat-overflow
-Wformat-truncation
-Wint-in-bool-context
-Wimplicit (C and Objective-C only)
-Wimplicit-int (C and Objective-C only)
-Wimplicit-function-declaration (C and Objective-C only)
-Winit-self (only for C++)
-Wlogical-not-parentheses
-Wmain (only for C/ObjC and unless -ffreestanding)
-Wmaybe-uninitialized
-Wmemset-elt-size
-Wmemset-transposed-args
-Wmisleading-indentation (only for C/C++)
-Wmissing-attributes
-Wmissing-braces (only for C/ObjC)
-Wmultistatement-macros
-Wnarrowing (only for C++)
-Wnonnull
-Wnonnull-compare
-Wopenmp-simd
-Wparentheses
-Wpessimizing-move (only for C++)
-Wpointer-sign
-Wrange-loop-construct (only for C++)
-Wreorder
-Wrestrict
-Wreturn-type
-Wsequence-point
-Wsign-compare (only in C++)
-Wsizeof-array-div
-Wsizeof-pointer-div
-Wsizeof-pointer-memaccess
-Wstrict-aliasing
-Wstrict-overflow=1
-Wswitch
-Wtautological-compare
-Wtrigraphs
-Wuninitialized
-Wunknown-pragmas
-Wunused-function
-Wunused-label
-Wunused-value
-Wunused-variable
-Wvla-parameter (C and Objective-C only)
-Wvolatile-register-var
-Wzero-length-bounds</p>
<p>请注意,有些警告标志不是由-Wall。他们中的一些人警告用户通常认为不会有问题的结构，但有时您可能希望检查一下。其他人则警告在某些情况下必须避免的或难以避免的构造，并且没有简单的方法来修改代码以抑制警告。其中一些启用了-Wextra但其中很多必须单独启用。</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-W<var>extra</var></span></kbd></dt>
<dd><p>这将启用一些额外的警告标志,而这些标志不是由-Wall。（此选项以前称为-W。仍然支持较旧的名称，但较新的名称更具描述性。）</p>
<p>-Wclobbered
-Wcast-function-type
-Wdeprecated-copy (C++ only)
-Wempty-body
-Wenum-conversion (C only)
-Wignored-qualifiers
-Wimplicit-fallthrough=3
-Wmissing-field-initializers
-Wmissing-parameter-type (C only)
-Wold-style-declaration (C only)
-Woverride-init
-Wsign-compare (C only)
-Wstring-compare
-Wredundant-move (only for C++)
-Wtype-limits
-Wuninitialized
-Wshift-negative-value (in C++03 and in C99 and newer)
-Wunused-parameter (only with -Wunused or -Wall)
-Wunused-but-set-parameter (only with -Wunused or -Wall)</p>
<p>该选项-Wextra还会打印以下情况的警告信息:</p>
<blockquote>
<div><p>使用 &lt; ， &lt;= ， &gt; 或 &gt;= 将指针与整数零进行比较。
（仅C ++）枚举器和非枚举器都出现在条件表达式中。
（仅C ++）模糊的虚拟基础。
（仅C ++）对已声明为 register 的数组进行下标。
（仅C ++）获取已声明为 register 的变量的地址。
（仅C ++）未在派生类的副本构造函数中初始化基类。</p>
</div></blockquote>
</dd>
</dl>
</li>
<li><p>-Wabi (C, Objective-C, C++ and Objective-C++ only)</p>
<blockquote>
<div><p>警告受ABI变化影响的代码。这包括可能与厂商中立的 C++ABI 以及特定目标的 psABI 不兼容的代码。</p>
<p>由于G++现在默认在每个主要版本中都会更新ABI,因此通常情况下-Wabi如果在发布系列的后面添加了一个检查,以检查自初始发布以来发现的ABI问题,则只对C++ABI兼容性问题发出警告。-Wabi如果选择了一个较旧的ABI版本,则警告更多的事情(用-fabi-version=n).</p>
<p>-Wabi也可以用一个明确的版本号来警告C++ABI是否与特定的-fabi-version级,例如-Wabi=2以警告相对于-fabi-version=2.</p>
<p>如果提供了一个明确的版本号,并且-fabi-compat-version未指定,此选项中的版本号将用于兼容性别名。如果这个选项没有提供明确的版本号,但提供了-fabi-compat-version指定了版本号,该版本号用于C++ABI警告。</p>
<p>虽然我们已经努力对所有这些情况发出警告,但可能有一些情况没有被警告,即使G++生成的是不兼容的代码。还有一些情况,即使生成的代码是兼容的,也会发出警告。</p>
<p>如果你担心G++生成的代码可能与其他编译器生成的代码在二进制上不兼容,你应该重写你的代码以避免这些警告。</p>
<p>已知的不兼容性-fabi-version=2（这是GCC 3.4至4.9的默认设置）包括：</p>
<blockquote>
<div><p>引用类型的非类型模板参数的模板被错误地混入。</p>
<p>extern int N;
template &lt;int &amp;&gt; struct S {};
void n (S&lt;N&gt;) {2}</p>
<p>这一点已在-fabi-version=3.
使用 __attribute ((vector_size)) 声明的SIMD向量类型以一种非标准的方式处理，不允许使用不同大小的向量重载函数。</p>
<p>mangling被改变在-fabi-version=4.
__attribute ((const)) 和 noreturn 被修饰为类型限定符，并且普通声明的 decltype 被折叠掉了。</p>
<p>这些乱码问题已在-fabi-version=5.
像无作用域枚举器一样，将作为参数传递给可变参数函数的作用域枚举器得到提升，从而导致 va_arg 抱怨。在大多数目标上，这实际上不会影响传递ABI的参数，因为没有办法传递小于 int 的参数。</p>
<p>此外，ABI更改了模板参数包 const_cast ， static_cast ，前缀增量/减量和用作模板参数的类范围函数的处理。</p>
<p>这些问题已在-fabi-version=6.
默认参数范围中的Lambda错误处理，ABI更改了 nullptr_t 的处理。</p>
<p>这些问题已在-fabi-version=7.
当使用function-cv-限定符对函数类型进行混淆时,未限定的函数类型被错误地处理为替换候选人。</p>
<p>这一点已在-fabi-version=8，是GCC 5.1的默认设置。
decltype(nullptr) 的对齐方式错误地为1，导致未对齐的访问。请注意，这不会影响具有 nullptr_t 参数的函数的ABI ，因为参数具有最小对齐方式。</p>
<p>这一点已在-fabi-version=9，是GCC 5.2的默认设置。
影响类型身份的特定目标属性,如函数类型上的ia32调用约定(stdcall、regparm等),并不影响乱名,导致函数指针被用作模板参数时出现名称碰撞。</p>
<p>这一点已在-fabi-version=10，是GCC 6.1的默认设置。</p>
</div></blockquote>
<p>该选项还可以对psABI相关的变化发出警告。此时已知的 psABI 变更包括。</p>
<blockquote>
<div><p>对于SysV / x86-64，具有 long double 精度成员的并集将按照psABI中的指定在内存中传递。在GCC 4.4之前，情况并非如此。例如：</p>
<dl class="simple">
<dt>union U {</dt><dd><p>long double ld;
int i;</p>
</dd>
</dl>
<p>};</p>
<p>union U 现在，工会U总是在内存中传递。</p>
</div></blockquote>
</div></blockquote>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-W<var>char-subscripts</var></span></kbd></dt>
<dd><p>如果数组下标的类型为 char ,则发出警告。这是导致错误的常见原因，因为程序员经常忘记这种类型是在某些机器上签名的。此警告通过以下方式启用-Wall.</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-W<var>no-coverage-mismatch</var></span></kbd></dt>
<dd><p>如果在使用的时候反馈信息不匹配,则发出警告。-fprofile-use选项。如果源文件在使用-fprofile-generate并与-fprofile-use，具有配置文件反馈的文件可能无法与源文件匹配，并且GCC无法使用配置文件反馈信息。默认情况下，此警告处于启用状态，并被视为错误。-Wno-coverage-mismatch可用于禁用警告或-Wno-error=coverage-mismatch可以用来禁用该错误。禁用该警告的错误可能会导致代码优化不良,并且只在非常小的变化的情况下有用,例如对现有代码库的错误修复。不建议完全禁用该警告。</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-W<var>no-cpp</var></span></kbd></dt>
<dd><p>（仅C，Objective-C，C ++，Objective-C ++和Fortran）禁止显示 #warning 指令发出的警告消息。</p>
</dd>
</dl>
</li>
<li><p>-Wdouble-promotion (C, C++, Objective-C and Objective-C++ only)</p>
<blockquote>
<div><p>当 float 类型的值隐式提升为 double 时发出警告。具有32位“单精度”浮点单元的CPU 在硬件中实现 float ，但在软件中实现 double 仿真。在这样的机器上，由于软件仿真所需的开销，使用 double 值进行计算要昂贵得多。</p>
<p>意外地使用 double 进行计算很容易，因为浮点文字是隐式的 double 类型。例如，在：</p>
<p>float area(float radius)
{</p>
<blockquote>
<div><p>return 3.14159 * radius * radius;</p>
</div></blockquote>
<p>}</p>
<p>编译器使用 double 执行整个计算，因为浮点文字是 double 。</p>
</div></blockquote>
</li>
<li><p>-Wduplicate-decl-specifier (C and Objective-C only)</p>
<blockquote>
<div><p>发出警告的声明中有重复的 const ， volatile ， restrict 或 _Atomic 符。此警告通过以下方式启用-Wall.</p>
</div></blockquote>
</li>
<li><p>-Wformat
-Wformat=n</p>
<blockquote>
<div><p>检查对 printf 和 scanf 等的调用，以确保提供的参数具有与指定的格式字符串相对应的类型，并且确保在格式字符串中指定的转换有意义。这包括标准函数以及在 printf ， scanf ， strftime 和 strfmon （X / Open扩展，不是C标准），系列（或其他特定于目标的系列）中由格式属性指定的其他功能（请参见功能属性）。在未指定格式属性的情况下检查哪些功能取决于所选的标准版本，而未在未指定属性的情况下进行的功能检查将被禁用-ffreestandingor-fno-builtin.</p>
<p>对照GNU libc 2.2版支持的格式功能检查格式。这些功能包括所有ISO C90和C99功能，以及Single Unix Specification中的功能以及某些BSD和GNU扩展。其他库实现可能不支持所有这些功能。 GCC不支持有关超出特定库限制的功能的警告。但是，如果-Wpedantic是与-Wformat时，会发出有关所选标准版本中没有的格式功能的警告（但不会针对 strfmon 格式发出警告，因为这些功能不在C标准的任何版本中）。请参阅控制C语言的选项。</p>
<p>-Wformat=1
-Wformat</p>
<blockquote>
<div><p>Option-Wformat相当于-Wformat=1， 和-Wno-format相当于-Wformat=0。以来-Wformat还会检查几个函数的空格式参数。-Wformat也意味着-Wnonnull。可以通过以下选项禁用此级别的格式检查的某些方面：-Wno-format-contains-nul,-Wno-format-extra-args， 和-Wno-format-zero-length.-Wformat是通过以下方式启用的-Wall.</p>
</div></blockquote>
<p>-Wformat=2</p>
<blockquote>
<div><p>Enable-Wformat加上额外的格式检查。目前相当于-Wformat -Wformat-非文字-Wformat-安全性-Wformat-y2k.</p>
</div></blockquote>
</div></blockquote>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-W<var>no-format-contains-nul</var></span></kbd></dt>
<dd><p>If-Wformat指定了,不对包含NUL字节的格式字符串发出警告。</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-W<var>no-format-extra-args</var></span></kbd></dt>
<dd><p>If-Wformat是指定的，不要警告 printf 或 scanf 格式函数的多余参数。C标准指定忽略此类参数。</p>
<p>未使用的参数位于用’指定的已使用参数之间$’操作数编号规范，通常仍会给出警告，因为该实现无法知道将哪种类型传递给 va_arg 来跳过未使用的参数。但是，在 scanf 格式的情况下，如果未使用的参数都是指针，则此选项禁止显示警告，因为Single Unix Specification指出允许使用这些未使用的参数。</p>
</dd>
</dl>
</li>
<li><p>-Wformat-overflow
-Wformat-overflow=level</p>
<blockquote>
<div><p>警告对可能会导致目标缓冲区溢出的格式化输入/输出功能（如 sprintf 和 vsprintf )的调用。当无法在编译时确定由format指令写入的确切字节数时，将根据依赖于 level 参数和优化的试探法进行估算。虽然启用优化将在大多数情况下提高警告的准确性，但也可能导致误报。</p>
<p>-Wformat-overflow
-Wformat-overflow=1</p>
<blockquote>
<div><p>等级 1 的-Wformat-overflow启用-Wformat采用保守的方法，仅警告最有可能溢出缓冲区的调用。在此级别上，假定格式指令的数字参数具有未知值，其数值为1，长度未知的字符串为空。假定已知以其类型的子范围为界的数字参数，或以其指令的精度或一组有限的字符串常量为输出范围的字符串参数，假定其值在导致输出中的大多数字节。例如，下面的 sprintf 调用被诊断，因为即使 a 和 b 都等于零，终止NUL字符（ ‘0’ 函数附加到目标缓冲区的）将在其末尾写入。将缓冲区的大小增加单个字节足以避免出现警告，尽管可能不足以避免溢出。</p>
<p>void f (int a, int b)
{</p>
<blockquote>
<div><p>char buf [13];
sprintf (buf, “a = %i, b = %in”, a, b);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>-Wformat-overflow=2</p>
<blockquote>
<div><p>级别 2 还警告有关给定足够长或足够大的自变量的调用可能会使目标缓冲区溢出的情况。在级别 2 上，假定精度为大于1的有符号类型的未知数字参数的最小可表示值，否则为最大可表示值。未知字符串参数的长度不能假定为伪指令的精度或它们可能求值的有限字符串文字集或它们可能指向的字符数组的长度为1个字符长。</p>
<p>在级别 2 ，在上述的例子中，呼叫被再次诊断，但此时，因为与 a 等于32位 INT_MIN 第一 %i 指令将写它的一些数字超出目标缓冲区的末尾。为了使调用安全，而与两个变量的值无关，必须将目标缓冲区的大小增加到至少34个字节。 GCC在警告之后的信息性注释中包括缓冲区的最小大小。</p>
<p>增加目标缓冲区大小的另一种方法是限制格式化值的范围。可以通过在format指令中指定精度来限制字符串参数的最大长度。当可以假定格式指令的数字参数的边界小于其类型的精度时，为格式说明符选择适当的长度修饰符将减小所需的缓冲区大小。例如，如果可以将上面示例中的 a 和 b 假定为 short int 类型的精度之内，则使用 %hi format指令或将参数强制转换为 short 会将缓冲区的最大所需大小减少到24个字节。</p>
<p>void f (int a, int b)
{</p>
<blockquote>
<div><p>char buf [23];
sprintf (buf, “a = %hi, b = %in”, a, (short)b);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</div></blockquote>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-W<var>no-format-zero-length</var></span></kbd></dt>
<dd><p>If-Wformat被指定,不要对零长度格式发出警告。C标准规定允许使用零长度格式。</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-W<var>format-nonliteral</var></span></kbd></dt>
<dd><p>If-Wformat被指定，如果格式字符串不是字符串文字，因此也发出警告，因此无法检查，除非格式函数将其格式参数作为 va_list 。</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-W<var>format-security</var></span></kbd></dt>
<dd><p>If-Wformat被指定，还警告表示可能存在安全问题的格式函数的使用。目前，这会警告对 printf 和 scanf 函数的调用，在这些函数中，格式字符串不是字符串文字，并且没有格式参数，如 printf (foo); 。如果格式字符串来自不受信任的输入并且包含“%n’。（目前，这是-Wformat-nonliteral警告,但在未来可能会将警告添加到-Wformat-security不包括在-Wformat-nonliteral.)</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-W<var>format-signedness</var></span></kbd></dt>
<dd><p>If-Wformat如果格式化字符串需要一个无符号参数,而该参数是有符号的,反之亦然。</p>
</dd>
</dl>
</li>
<li><p>-Wformat-truncation</p></li>
<li><p>-Wformat-truncation=level</p>
<blockquote>
<div><p>警告有关对格式化输入/输出函数（例如 snprintf 和 vsnprintf )的调用，这可能会导致输出截断。当无法在编译时确定由format指令写入的确切字节数时，将根据依赖于 level 参数和优化的试探法进行估算。虽然启用优化将在大多数情况下提高警告的准确性，但也可能导致误报。除非另有说明，否则该选项使用相同的逻辑-Wformat-overflow.</p>
<p>-Wformat-truncation
-Wformat-truncation=1</p>
<blockquote>
<div><p>等级 1 的-Wformat-truncation启用-Wformat采用了一种保守的方法,只对那些返回值未被使用且很可能导致输出截断的有界函数的调用发出警告。</p>
</div></blockquote>
<p>-Wformat-truncation=2</p>
<blockquote>
<div><p>级别 2 还会警告对调用其返回值已使用的有界函数的警告，如果给定足够长或足够大的自变量，则可能会导致截断。</p>
</div></blockquote>
</div></blockquote>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-W<var>format-y2k</var></span></kbd></dt>
<dd><p>If-Wformat指定，还警告可能仅产生两位数年份的 strftime 格式。</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-W<var>nonnull</var></span></kbd></dt>
<dd><p>警告有关为 nonnull 函数属性标记为需要非null值的参数传递null指针。</p>
<p>-Wnonnull包括在-Walland-Wformat。可以用-Wno-nonnulloption.</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-W<var>nonnull-compare</var></span></kbd></dt>
<dd><p>将标有 nonnull 函数属性的参数与函数内部的null 比较时发出警告。</p>
<p>-Wnonnull-compare包括在-Wall。可以用-Wno-nonnull-compareoption.</p>
</dd>
</dl>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-W<var>null-dereference</var></span></kbd></dt>
<dd><p>如果编译器检测到一些路径由于解除引用null指针而引发错误或未定义行为,则发出警告。这个选项只有在-fdelete-null-pointer-checks是激活的,大多数目标的优化都会启用这个功能。警告的精度取决于所使用的优化选项。</p>
</dd>
</dl>
</li>
<li><p>-Winit-self (C, C++, Objective-C and Objective-C++ only)</p>
<blockquote>
<div><p>对未初始化的变量发出警告,因为这些变量是用自己初始化的。注意这个选项只能与-Wuninitializedoption.</p>
<p>例如，GCC 仅在以下情况下警告 i 未在以下代码段中初始化-Winit-self已具体说明。</p>
<p>int f()
{</p>
<blockquote>
<div><p>int i = i;
return i;</p>
</div></blockquote>
<p>}</p>
<p>启用该警告的方法是-Wall在C++中。</p>
</div></blockquote>
</li>
<li><p>-Wno-implicit-int (C and Objective-C only)</p>
<blockquote>
<div><p>这个选项控制当声明没有指定类型时的警告。在C99及以后的C语言中,这个警告是默认启用的,也可以通过以下方式启用-Wall.</p>
</div></blockquote>
</li>
<li><p>-Wno-implicit-function-declaration (C and Objective-C only)</p>
<blockquote>
<div><p>这个选项控制当一个函数在被声明之前被使用时的警告。在C99及以后的C语言中,这个警告是默认启用的,也可以通过以下方式启用-Wall。通过以下方式将警告变为错误-pedantic-errors.</p>
</div></blockquote>
</li>
<li><p>-Wimplicit (C and Objective-C only)</p>
<blockquote>
<div><p>同理-Wimplicit-intand-Wimplicit-function-declaration。此警告通过以下方式启用-Wall.</p>
</div></blockquote>
</li>
<li><dl class="option-list">
<dt><kbd><span class="option">-W<var>implicit-fallthrough</var></span></kbd></dt>
<dd><p>-Wimplicit-fallthrough是一样的-Wimplicit-fallthrough=3and-Wno-implicit-fallthrough是一样的-Wimplicit-fallthrough=0.</p>
</dd>
</dl>
</li>
<li><p>-Wimplicit-fallthrough=n</p>
<blockquote>
<div><p>当开关盒跌破时,发出警告。例如:</p>
</div></blockquote>
</li>
</ul>
<p>-Wno-if-not-aligned (C, C++, Objective-C and Objective-C++ only)</p>
<blockquote>
<div><p>控制是否发出由 warn_if_not_aligned 属性触发的警告。这些警告默认情况下处于启用状态。</p>
</div></blockquote>
<p>-Wignored-qualifiers (C and C++ only)</p>
<blockquote>
<div><p>如果函数的返回类型具有类型限定符（例如 const )，则发出警告。对于ISO C，这种类型限定符无效，因为函数返回的值不是左值。对于C ++，仅针对标量类型或 void 发出警告。 ISO C禁止在函数定义中使用合格的 void 返回类型，因此即使没有此选项，此类返回类型也始终会收到警告。</p>
<p>该警告也可通过以下方式启用-Wextra.</p>
</div></blockquote>
<p>-Wno-ignored-attributes (C and C++ only)</p>
<blockquote>
<div><p>这个选项控制属性被忽略时的警告。这与-Wattributes选项,因为每当编译器决定放弃一个属性时,它就会发出警告,而不是说这个属性是未知的,或者用错了地方等等。这个警告是默认启用的。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>main</var></span></kbd></dt>
<dd><p>如果 main 类型可疑，请发出警告。 main 应该是具有外部链接的函数，返回int，采用零参数，两个或三个适当类型的参数。默认情况下，此警告在C ++中处于启用状态，-Wallor-Wpedantic.</p>
</dd>
</dl>
<p>-Wmisleading-indentation (C and C++ only)</p>
<blockquote>
<div><p>当代码缩进不反映块结构时发出警告。特别是， if ， else ， while 和 for 子句的保护语句不使用大括号，则发出警告，然后是带有相同缩进的无保护语句。</p>
<p>在以下示例中，对“ bar”的调用被误导了缩进，好像它受到“ if”条件的保护。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>missing-attributes</var></span></kbd></dt>
<dd><p>当一个函数的声明缺少一个或多个相关函数声明的属性,并且这些属性的缺失可能会对生成代码的正确性或效率产生不利影响时,发出警告。例如,当别名的声明使用属性来指定比目标更少限制性的要求时,就会发出警告。这通常代表了一个潜在的优化机会。相比之下-Wattribute-alias=2当别名比目标限制更多时，此选项控制发出的警告，这可能导致错误的代码生成。考虑属性包括 alloc_align ， alloc_size ， cold ， const ， hot ， leaf ， malloc 的， nonnull ， noreturn ， nothrow ， pure ， returns_nonnull 和 returns_twice 。</p>
<p>在C ++中，当主模板的明确分工与属性声明发出警告 alloc_align ， alloc_size ， assume_aligned ， format ， format_arg ， malloc 的，或者 nonnull 不声明它。 deprecated 属性， error 和 warning 禁止显示警告。（请参阅功能属性）。</p>
<p>您可以使用 copy 属性将与其他声明相同的属性集应用于声明，而无需显式枚举属性。此属性可以应用于函数的声明（请参见“ 通用函数属性”），变量（请参见“ Common Variable Attributes”）或类型（请参见“ Common Type Attributes”）。</p>
<p>-Wmissing-attributes是通过以下方式启用的-Wall.</p>
<p>例如，由于下面的主要功能模板的声明同时使用了属性 malloc 和 alloc_size ，因此可以诊断模板的显式特化的声明，因为它缺少属性之一。</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>missing-braces</var></span></kbd></dt>
<dd><p>如果聚合或联合初始化程序未完全括入括号，则发出警告。在以下示例中，用于初始化 a 没有完全括号，但对于 b 被完全括号。</p>
</dd>
</dl>
<p>-Wmissing-include-dirs (C, C++, Objective-C and Objective-C++ only)</p>
<blockquote>
<div><p>如果用户提供的include目录不存在,则发出警告。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>no-missing-profile</var></span></kbd></dt>
<dd><p>此选项可控制在使用-fprofile-use选项。这个选项可以诊断出在编译过程中,在使用-fprofile-generate并与-fprofile-use，而无需重新生成配置文件。在这些情况下，配置文件反馈数据文件不分别包含有关新添加的功能或文件的任何配置文件反馈信息。同样，在删除配置文件计数数据（.gcda）文件的情况下，GCC无法使用任何配置文件反馈信息。在所有这些情况下，都会发出警告以通知您配置文件生成步骤已到期。忽略该警告可能会导致代码优化效果不佳。-Wno-missing-profile可用于禁用警告,但不建议这样做,只有在不存在的配置文件数据是合理的时,才应这样做。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-mismatched-dealloc</var></span></kbd></dt>
<dd><p>警告调用解除分配函数，其指针参数从分配函数返回，而前者不是合适的解除分配器。通过使用属性 malloc 可以将一对函数关联为匹配的分配器和解除分配器。除非被禁用-fno-builtin选项标准函数 calloc 、 malloc 、 realloc 和 free ，以及相应形式的 C++ operator new 和 operator delete 隐式关联为匹配分配器和解除分配器。在以下示例中， mydealloc 是从 myalloc 返回的指针的解除分配器。</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>multistatement-macros</var></span></kbd></dt>
<dd><p>警告似乎由子句保护的不安全的多语句宏，例如 if ， else ， for ， switch 或 while ，在该子句中，实际上只有第一个语句在扩展宏后才受到保护。</p>
<p>例如:</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>parentheses</var></span></kbd></dt>
<dd><p>如果在某些上下文中省略了括号,例如当在上下文中存在一个预期为真值的赋值时,或者当运算符被嵌套时,人们经常会对其优先级感到困惑时,就会发出警告。</p>
<p>如果出现类似 x&lt;=y&lt;=z 的比较，也要发出警告；这等效于 (x&lt;=y ? 1 : 0) &lt;= z ，它与普通数学符号的解释不同。</p>
<p>还警告GNU扩展到 ?: 的危险用途，并省略中间操作数。当条件在 ? ：运算符是一个布尔表达式，忽略的值始终为1。程序员通常希望它是在条件表达式中计算的值。</p>
<p>对于C++来说,这也警告了一些声明中不必要的小括号的情况,这可能表明试图调用一个函数而不是声明。</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>sequence-point</var></span></kbd></dt>
<dd><p>警告由于违反C和C++标准中的序列点规则,代码可能有未定义的语义。</p>
<p>C和C ++标准定义了按顺序点对C / C ++程序中的表达式进行求值的顺序，顺序点代表程序各部分执行之间的部分顺序：在顺序点之前执行的部分以及在顺序点之后执行的部分它。这些发生在对完整表达式（不是较大表达式的一部分）进行求值之后，对 &amp;&amp; ， || 的第一个操作数求值之后。， ? : 或者 , （逗号）运算符，在调用函数之前（但在评估其参数和表示被调用函数的表达式之后），以及在某些其他位置。除了序列点规则所表示的以外，未指定表达式的子表达式的求值顺序。所有这些规则仅描述部分顺序，而不描述全部顺序，因为例如，如果在一个表达式中调用两个函数而它们之间没有序列点，则不会指定调用函数的顺序。但是，标准委员会已裁定功能调用不得重叠。</p>
<p>在序列点之间对对象的值的修改生效时，未指定。行为依赖于此的程序具有未定义的行为；C和C ++标准规定：“在上一个序列点与下一个序列点之间，对象的存储值最多只能通过对表达式的求值来修改。此外，先前的值应仅被读取以确定要存储的值。”。如果程序违反了这些规则，则任何特定实现的结果都是完全不可预测的。</p>
<p>具有未定义行为的代码示例为 a = a++; ， a[n] = b[n++] 和 a[i++] = i; 。使用此选项无法诊断出一些更复杂的情况，并且可能偶尔会出现误报的结果，但总的来说，已发现在检测程序中此类问题方面相当有效。</p>
<p>C++17标准将在更多的情况下定义操作数的评估顺序:特别是它要求赋值的右手边必须在左手边之前进行评估,所以上面的例子不再是未定义的。但这个选项仍然会对它们发出警告,以帮助人们避免写出在C和C++早期版本中未定义的代码。</p>
<p>该标准的措辞令人困惑，因此对于微妙情况下序列点规则的确切含义存在一些争论。可以在 GCC 阅读页面http://gcc.gnu.org/readings.html上找到该问题讨论的链接，包括提议的正式定义。</p>
<p>启用该警告的方法是-WallC和C++的。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-return-local-addr</var></span></kbd></dt>
<dd><p>在函数返回后,不要警告返回一个指针(或在C++中,一个引用)到一个超出范围的变量。</p>
</dd>
<dt><kbd><span class="option">-W<var>return-type</var></span></kbd></dt>
<dd><p>当函数定义的返回类型默认为 int 时发出警告。还警告在返回类型不是 void 的函数中任何没有返回值的 return 语句（从函数体的末尾掉落被视为没有值的返回）。</p>
<p>仅对于C，警告 return 语句中包含返回类型为 void 的函数的表达式，除非表达式类型也为 void 。作为GNU扩展，除非有警告，否则接受后一种情况，除非-Wpedantic用来。试图使用非的返回值 void 比其他功能 main 由到达右大括号终止功能是未定义流出的端部。</p>
<p>与C中的C语言不同，在C ++中，即使没有使用函数的值，从 main 函数以外的非 void 函数的末尾流出也会导致未定义的行为。</p>
<p>在C++中,这个警告是默认启用的,并且通过-Wallotherwise.</p>
</dd>
<dt><kbd><span class="option">-W<var>no-shift-count-negative</var></span></kbd></dt>
<dd><p>控制移位计数为负值时的警告。默认情况下,该警告是启用的。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-shift-count-overflow</var></span></kbd></dt>
<dd><p>如果移位数大于或等于类型的位宽,控制警告。默认情况下,该警告已启用。</p>
</dd>
<dt><kbd><span class="option">-W<var>shift-negative-value</var></span></kbd></dt>
<dd><p>左移为负值时发出警告。这个警告是由-Wextra在C99和C++11模式下(以及更新)。</p>
</dd>
</dl>
<p>-Wno-shift-overflow
-Wshift-overflow=n</p>
<blockquote>
<div><p>这些选项控制了左移溢出的警告。</p>
<p>-Wshift-overflow=1</p>
<blockquote>
<div><p>这是警告级别的-Wshift-overflow并在C99和C++11模式(以及更新的模式)中默认启用。这个警告级别不对左移1到符号位发出警告。然而,在C语言中,在需要整数常数表达式的情况下,这种溢出仍然被拒绝)。在C++20模式(和更新的模式)中没有警告,因为有符号的左移总是被包起来。</p>
</div></blockquote>
<p>-Wshift-overflow=2</p>
<blockquote>
<div><p>这个警告级别也警告左移1到符号位,除非C++14模式(或更新的)是活动的。</p>
</div></blockquote>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>switch</var></span></kbd></dt>
<dd><p>当 switch 语句具有枚举类型的索引并且缺少该枚举的一个或多个命名代码的 case ，就发出警告。（使用 default 标签可以防止出现此警告。）使用此选项时，枚举范围以外的 case 标签也会引发警告（即使有 default 标签）。此警告通过以下方式启用-Wall.</p>
</dd>
<dt><kbd><span class="option">-W<var>switch-default</var></span></kbd></dt>
<dd><p>当 switch 语句没有 default 大小写时发出警告。</p>
</dd>
<dt><kbd><span class="option">-W<var>switch-enum</var></span></kbd></dt>
<dd><p>当 switch 语句具有枚举类型的索引并且缺少该枚举的一个或多个命名代码的 case ，就发出警告。使用此选项时，枚举范围之外的 case 标签也会引发警告。之间的唯一区别-Wswitch并且此选项是即使存在 default 标签，此选项也会给出有关省略的枚举代码的警告。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-switch-bool</var></span></kbd></dt>
<dd><p>当 switch 语句具有布尔类型的索引并且大小写值超出布尔类型的范围时，请勿发出警告。通过将控制表达式强制转换为 bool 以外的其他类型，可以抑制此警告。例如：</p>
<dl class="simple">
<dt>switch ((int) (a == 4))</dt><dd><p>{
…
}</p>
</dd>
</dl>
<p>该警告在C和C++程序中默认为启用。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-switch-outside-range</var></span></kbd></dt>
<dd><p>当 switch 盒的值超出其各自的类型范围时，此选项控制警告。默认情况下，C和C ++程序启用此警告。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-switch-unreachable</var></span></kbd></dt>
<dd><p>当 switch 语句包含在控制表达式和第一个case标签之间的语句（永远不会执行）时，请勿发出警告。例如：</p>
</dd>
</dl>
<p>-Wsync-nand (C and C++ only)</p>
<blockquote>
<div><p>当使用 __sync_fetch_and_nand 和 __sync_nand_and_fetch 内置函数时发出警告。这些功能更改了GCC 4.4中的语义。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>unused-but-set-parameter</var></span></kbd></dt>
<dd><p>每当一个函数参数被赋值,但未被使用(除了它的声明)时,就发出警告。</p>
<p>要取消显示此警告，请使用 unused 属性（请参见可变属性）。</p>
<p>该警告也可通过以下方式启用-Wunused连同-Wextra.</p>
</dd>
<dt><kbd><span class="option">-W<var>unused-but-set-variable</var></span></kbd></dt>
<dd><p>每当一个局部变量被分配到,但未被使用(除了它的声明)时发出警告。这个警告是由-Wall.</p>
<p>要取消显示此警告，请使用 unused 属性（请参见可变属性）。</p>
<p>该警告也可通过以下方式启用-Wunused，由启用-Wall.</p>
</dd>
<dt><kbd><span class="option">-W<var>unused-function</var></span></kbd></dt>
<dd><p>当一个静态函数被声明但未被定义或一个非内联静态函数未被使用时发出警告。这个警告是由-Wall.</p>
</dd>
<dt><kbd><span class="option">-W<var>unused-label</var></span></kbd></dt>
<dd><p>每当一个标签被声明但未被使用时发出警告。这个警告是由-Wall.</p>
<p>要取消显示此警告，请使用 unused 属性（请参见可变属性）。</p>
</dd>
</dl>
<p>-Wunused-local-typedefs (C, Objective-C, C++ and Objective-C++ only)</p>
<blockquote>
<div><p>当函数中本地定义的typedef未被使用时发出警告。这个警告是由-Wall.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>unused-parameter</var></span></kbd></dt>
<dd><p>每当一个函数参数除了声明之外没有被使用时,就会发出警告。</p>
<p>要取消显示此警告，请使用 unused 属性（请参见可变属性）。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-unused-result</var></span></kbd></dt>
<dd><p>如果标记有属性 warn_unused_result 的函数的调用者（请参见Function Attributes）未使用其返回值，则不要发出警告。默认是-Wunused-result.</p>
</dd>
<dt><kbd><span class="option">-W<var>unused-variable</var></span></kbd></dt>
<dd><p>当一个局部变量或静态变量在声明之外未被使用时,就会发出警告。这个选项意味着-Wunused-const-variable=1但不适用C++。这个警告是由-Wall.</p>
<p>要取消显示此警告，请使用 unused 属性（请参见可变属性）。</p>
</dd>
</dl>
<p>-Wunused-const-variable
-Wunused-const-variable=n</p>
<blockquote>
<div><p>每当一个常量静态变量除了声明之外未被使用时,就会发出警告。-Wunused-const-variable=1是通过以下方式启用的-Wunused-variable适用于C，但不适用于C ++。在C中，这声明了变量存储，但是在C ++中，这不是错误，因为const变量代替了 #define 。</p>
<p>要取消显示此警告，请使用 unused 属性（请参见可变属性）。</p>
<p>-Wunused-const-variable=1</p>
<blockquote>
<div><p>这是由-Wunused-variable它只对主编译单元中定义的未使用的静态常量变量发出警告,而不是对包含在任何头文件中声明的静态常量变量发出警告。</p>
</div></blockquote>
<p>-Wunused-const-variable=2</p>
<blockquote>
<div><p>这个警告级别也会对头文件(不包括系统头文件)中未使用的常量静态变量发出警告。这是警告级别的-Wunused-const-variable并且必须明确请求，因为在C ++中这不是错误，在C语言中清理包含的所有标头可能更困难。</p>
</div></blockquote>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>unused-value</var></span></kbd></dt>
<dd><p>每当语句计算显式未使用的结果时发出警告。为了消除此警告，请将未使用的表达式强制转换为 void 。这包括表达式语句或不包含副作用的逗号表达式的左侧。例如，诸如 x[i,j] 的表达式会引起警告，而 x[(void)i,j] 则不会。</p>
<p>启用该警告的方法是-Wall.</p>
</dd>
<dt><kbd><span class="option">-W<var>unused</var></span></kbd></dt>
<dd><p>以上所有-Wunused选项组合。</p>
<p>为了得到一个未使用的函数参数的警告,你必须指定-Wextra-不满意（注意-Wallimplies-Wunused），或分别指定-Wunused-parameter.</p>
</dd>
<dt><kbd><span class="option">-W<var>uninitialized</var></span></kbd></dt>
<dd><p>如果在未初始化的情况下使用具有自动或分配的存储持续时间的对象，则发出警告。在 C++ 中，如果非静态引用或非静态 const 成员出现在没有构造函数的类中，也会发出警告。</p>
<p>此外，将指向未初始化对象的指针（或在 C++ 中，引用）传递给已知读取对象的内置函数的 const 限定参数也可通过此警告进行诊断。(-Wmaybe-uninitialized是为普通功能发布的)。)</p>
<p>如果你想警告那些在自己的初始化器中使用未初始化的变量值的代码,可以使用-Winit-selfoption.</p>
<p>对于结构，联合或数组变量的各个未初始化元素以及整体上未初始化的变量，会发生这些警告。对于声明为 volatile 的变量或元素，它们不会发生。因为这些警告取决于优化，所以存在警告的确切变量或元素取决于精确的优化选项和所使用的GCC版本。</p>
<p>需要注意的是,如果一个变量只是用来计算一个本身从未使用过的值,那么可能不会有任何警告,因为这种计算可能会在打印警告之前被数据流分析删除。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-invalid-memory-model</var></span></kbd></dt>
<dd><p>此选项控制带有内存一致性参数的__atomic Builtins，__sync Builtins和C11原子泛型函数的调用警告，该参数对于该操作无效或在 memory_order 枚举的值范围之外。例如，由于仅针对轻松，释放和顺序一致的内存顺序定义了 __atomic_store 和 __atomic_store_n 内置插件，因此将诊断以下代码：</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>maybe-uninitialized</var></span></kbd></dt>
<dd><p>对于一个具有自动或分配存储期限的对象,如果存在一个从函数入口到使用对象的路径是初始化的,但存在一些其他的路径,而这些路径的对象没有被初始化,如果编译器不能证明未初始化的路径在运行时没有被执行,则会发出一个警告。</p>
<p>此外，将指向未初始化对象的指针（或在 C++ 中，引用）传递给 const 限定的函数参数也可通过此警告进行诊断。(-Wuninitialized为已知读取对象的内置函数发出。）使用属性 access (none) ）注释函数表示该参数不用于访问对象并避免警告（请参阅通用函数属性）。</p>
<p>这些警告只有在优化编译时才有可能,因为否则GCC不会跟踪变量的状态。</p>
<p>这些警告是可选的,因为GCC可能无法确定代码是否正确,尽管看起来有错误。这里有一个例子可以说明这种情况是如何发生的。</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>unknown-pragmas</var></span></kbd></dt>
<dd><p>在遇到GCC无法理解的 #pragma 指令时发出警告。如果使用此命令行选项，则甚至会针对系统头文件中的未知杂项发出警告。如果仅由警告启用警告，则不是这种情况。-Wall命令行选项。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-pragmas</var></span></kbd></dt>
<dd><p>不要对滥用语法提出警告,例如错误的参数、无效的语法或语法之间的冲突。参见-Wunknown-pragmas.</p>
</dd>
<dt><kbd><span class="option">-W<var>no-prio-ctor-dtor</var></span></kbd></dt>
<dd><p>如果构造函数或析构函数的优先级为0到100，则不发出警告。使用构造函数和析构函数属性可让您为构造函数/析构函数分配优先级，以控制其在调用 main 或返回main之后的执行顺序。优先级值必须大于100，因为编译器为实现保留了0-100之间的优先级值。</p>
</dd>
<dt><kbd><span class="option">-W<var>strict-aliasing</var></span></kbd></dt>
<dd><p>该选项仅在以下情况下有效-fstrict-aliasing是活跃的。它对可能违反编译器用于优化的严格别名规则的代码发出警告。该警告并不能捕获所有的情况,但确实试图捕获更常见的陷阱。它包含在-Wall。相当于-Wstrict-aliasing=3</p>
</dd>
</dl>
<p>-Wstrict-aliasing=n</p>
<blockquote>
<div><p>该选项仅在以下情况下有效-fstrict-aliasing是活跃的。它对可能违反编译器用于优化的严格别名规则的代码发出警告。更高的级别对应着更高的准确性(更少的误报)。更高的级别也对应着更多的努力,类似于-Oworks.-Wstrict-aliasing相当于-Wstrict-aliasing=3.</p>
<p>1级:最激进,速度快,最不准确。当较高等级不发出警告时,可能有用,但是-fstrict-aliasing仍然会破坏代码,因为它的假阴性很少。然而,它有很多误报。对所有可能不兼容类型之间的指针转换发出警告,即使从未被取消引用。仅在前端运行。</p>
<p>2级:积极、快速、不太精确。可能仍有许多假阳性(虽然没有1级那么多),假阴性也很少(但可能比1级更多)。与1级不同的是,它只在地址被采集时发出警告。对不完整类型发出警告。只在前端运行。</p>
<p>级别3(默认为-Wstrict-aliasing）：应该只有很少的误报和很少的误报。启用优化后，速度比级别1或2稍慢。照顾前端的普通双关+引用模式： <em>(int</em>)&amp;some_float 。如果启用了优化，它还将在后端运行，在该处使用流敏感的指向信息处理多个语句案例。仅在取消引用转换后的指针时警告。不警告类型不完整。</p>
</div></blockquote>
<p>-Wstrict-overflow
-Wstrict-overflow=n</p>
<blockquote>
<div><p>这个选项只有在未定义signed overflow时才有效。它对编译器基于不发生签名溢出的假设进行优化的情况发出警告。请注意,它并不是对所有代码可能溢出的情况发出警告:它只对编译器实现某些优化的情况发出警告。因此这个警告取决于优化级别。</p>
<p>假设不会发生签名溢出的优化是完全安全的,如果所涉及的变量的值是这样的,溢出实际上从未发生。因此,这个警告很容易给出一个假阳性:一个关于实际上没有问题的代码的警告。为了帮助关注重要的问题,我们定义了几个警告级别。在估计一个循环需要多少次迭代时,特别是在确定一个循环是否会被执行时,使用未定义的符号溢出不会发出警告。</p>
<p>-Wstrict-overflow=1</p>
<blockquote>
<div><p>警告可疑且易于避免的案件。例如，编译器将 x + 1 &gt; x 简化为 1 。这个级别的-Wstrict-overflow是通过以下方式启用的-Wall; 没有更高的级别，必须明确要求。</p>
</div></blockquote>
<p>-Wstrict-overflow=2</p>
<blockquote>
<div><p>还警告将比较简化为常数的其他情况。例如： abs (x) &gt;= 0 。仅当未定义有符号整数溢出时才可以简化此操作，因为 abs (INT_MIN) 溢出到小于零的 INT_MIN 。-Wstrict-overflow（无级别）与-Wstrict-overflow=2.</p>
</div></blockquote>
<p>-Wstrict-overflow=3</p>
<blockquote>
<div><p>还警告简化比较的其他情况。例如： x + 1 &gt; 1 简化为 x &gt; 0 。</p>
</div></blockquote>
<p>-Wstrict-overflow=4</p>
<blockquote>
<div><p>还警告上述情况未涵盖的其他简化方法。例如： (x * 10) / 5 简化为 x * 2 。</p>
</div></blockquote>
<p>-Wstrict-overflow=5</p>
<blockquote>
<div><p>还警告编译器减小比较所涉及的常数的大小的情况。例如： x + 2 &gt; y 简化为 x + 1 &gt;= y 。仅在最高警告级别上报告此事件，因为此简化适用于许多比较，因此此警告级别给出了大量误报。</p>
</div></blockquote>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>string-compare</var></span></kbd></dt>
<dd><p>警告对 strcmp 和 strncmp 的调用，在这种相等性测试中，由于一个参数的长度大于另一个参数存储在其中的数组的大小（或边界存储在对于 strncmp ）。这样的电话可能是错误的。例如，诊断以下对 strcmp 的调用是因为其结果必然为非零值，而与数组 a 的内容无关。</p>
</dd>
</dl>
<p>-Wno-stringop-overflow
-Wstringop-overflow
-Wstringop-overflow=type</p>
<blockquote>
<div><p>警告对确定为溢出目标缓冲区的字符串操作函数（例如 memcpy 和 strcpy )的调用。可选参数比确定目标大小要执行的“对象大小检查”类型大一。请参阅对象大小检查。该参数仅对在字符数组上运行的函数有意义，而对于像 memcpy 这样总是使用Object Size type-0的原始内存函数没有意义。该选项还警告指定大小超出最大可能对象或最多 SIZE_MAX / 2 调用个字节。该选项在启用优化的情况下产生最佳结果，但是即使不优化对与标准函数相对应的GCC内置函数（如 __builtin_memcpy )的调用，也可以检测出一小部分简单的缓冲区溢出。在任何情况下，该选项仅会警告由相应的溢出检查内置程序检测到的缓冲区溢出子集。例如，该选项对下面的 strcpy 调用发出警告，因为该选项将至少5个字符（包括终止NUL的字符串 “blue” ）复制到大小为4的缓冲区中。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>no-stringop-overread</var></span></kbd></dt>
<dd><p>警告调用字符串操作函数，例如 memchr 或 strcpy ，这些函数被确定为读取超过源序列的末尾。</p>
<p>Option-Wstringop-overread默认情况下是启用的。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-stringop-truncation</var></span></kbd></dt>
<dd><p>不要警告对可能会截断复制的字符串或使目标保持不变的限制字符串操作函数（例如 strncat ， strncpy 和 stpncpy )的调用。</p>
<p>在下面的示例中，对 strncat 的调用指定的界限小于源字符串的长度。结果，源的副本将被截断，因此将诊断呼叫。为避免警告，请使用 bufsize - strlen (buf) - 1) 作为界限。</p>
</dd>
</dl>
<p>-Wsuggest-attribute=[pure|const|noreturn|format|cold|malloc]</p>
<blockquote>
<div><p>对于添加属性可能会有好处的情况,请注意。目前支持的属性如下。</p>
<p>-Wsuggest-attribute=pure
-Wsuggest-attribute=const
-Wsuggest-attribute=noreturn
-Wmissing-noreturn
-Wsuggest-attribute=malloc</p>
<blockquote>
<div><p>警告可能可能用作 pure ， const 或 noreturn 或 malloc 属性的候选函数。编译器仅警告在其他编译单元中可见的函数，或者在无法证明该函数正常返回的情况下（对于 pure 和 const ）发出警告。如果一个函数不包含无限循环，或者通过抛出，调用 abort 或trapping 异常返回，则该函数将正常返回。此分析需要选择-fipa-pure-const，默认情况下启用-O和更高。较高的优化水平可以提高分析的准确性。</p>
</div></blockquote>
<p>-Wsuggest-attribute=format
-Wmissing-format-attribute</p>
<blockquote>
<div><p>警告可能是 format 属性候选的函数指针。请注意，这些只是可能的候选人，而不是绝对的候选人。 GCC猜测在赋值，初始化，参数传递或return语句中使用的具有 format 属性的函数指针应在结果类型中具有相应的 format 属性。即，赋值或初始化的左侧，参数变量的类型或包含函数的返回类型也应分别具有 format 属性，以避免发出警告。</p>
<p>GCC还警告可能是 format 属性候选的函数定义。同样，这些只是可能的候选者。 GCC猜测 format 属性可能适用于任何调用 vprintf 或 vscanf 之类的函数的函数，但这并非总是如此，并且某些 format 属性适用的函数可能无法检测到。</p>
</div></blockquote>
<p>-Wsuggest-attribute=cold</p>
<blockquote>
<div><p>警告可能用作 cold 属性的候选函数。这是基于静态检测的，通常只警告那些总是导致调用另一个 cold 函数的函数，例如C ++ throw 的包装器或导致 abort 致命错误报告函数。</p>
</div></blockquote>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>alloc-zero</var></span></kbd></dt>
<dd><p>警告调用饰属性分配功能 alloc_size 指定零个字节，包括那些功能的内置形式 aligned_alloc ， alloca ， calloc ， malloc 的，和 realloc 的。因为以零大小调用这些函数的行为在实现中会有所不同（并且在不赞成使用 realloc 的情况下），因此依赖它们可能会导致细微的可移植性错误，应避免使用。</p>
</dd>
</dl>
<p>-Walloc-size-larger-than=byte-size</p>
<blockquote>
<div><p>警告有关调用用 alloc_size 属性修饰的函数的尝试，这些函数试图分配大于指定字节数的对象，或者以无限精度整数类型进行大小计算的结果将超过’PTRDIFF_MAX在目标上。-Walloc-size-larger-than=‘PTRDIFF_MAX默认情况下启用。可以通过指定’的 byte-size 来禁用由该选项控制的警告SIZE_MAX’或更多或-Wno-alloc-size-larger-than。请参见函数属性。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>no-alloc-size-larger-than</var></span></kbd></dt>
<dd><p>Disable-Walloc-size-larger-than=警告。该选项相当于-Walloc-size-larger-than=‘SIZE_MAX’或更大。</p>
</dd>
<dt><kbd><span class="option">-W<var>alloca</var></span></kbd></dt>
<dd><p>此选项警告源中对 alloca 的所有使用。</p>
</dd>
</dl>
<p>-Walloca-larger-than=byte-size</p>
<blockquote>
<div><p>此选项会警告使用整数参数（其值为零或不受控制谓词限制的整数参数）调用 alloca ，该控制谓词将其值限制为最大 byte-size 。它还会警告调用绑定值未知的 alloca 。非整数类型的参数即使被限制在预期范围内也被认为是无界的。</p>
<p>例如， alloca 的有限情况可能是：</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>no-alloca-larger-than</var></span></kbd></dt>
<dd><p>Disable-Walloca-larger-than=警告。该选项相当于-Walloca-larger-than=‘SIZE_MAX’或更大。</p>
</dd>
<dt><kbd><span class="option">-W<var>arith-conversion</var></span></kbd></dt>
<dd><p>警告算术运算中的隐式转换,即使操作数转换为相同类型也不能改变其值。这将影响来自-Wconversion,-Wfloat-conversion， 和-Wsign-conversion.</p>
</dd>
</dl>
<p>-Warray-bounds
-Warray-bounds=n</p>
<blockquote>
<div><p>该选项仅在以下情况下有效-ftree-vrp激活(默认为-O2及以上)。)它对总是超出边界的数组的下标发出警告。这个警告是由-Wall.</p>
<p>-Warray-bounds=1</p>
<blockquote>
<div><p>这是警告级别的-Warray-bounds并通过以下方式启用-Wall; 没有更高的级别，必须明确要求。</p>
</div></blockquote>
<p>-Warray-bounds=2</p>
<blockquote>
<div><p>这个警告级别还对结构末尾的数组和通过指针访问的数组的越界访问发出警告。这个警告级别可能会给出较多的误报,默认情况下是停用的。</p>
</div></blockquote>
</div></blockquote>
<p>-Warray-parameter
-Warray-parameter=n</p>
<blockquote>
<div><p>警告涉及不一致种类或形式的数组或指针类型的参数的函数的重新声明,并通过以下警告检测对这些参数的越界访问,如-Warray-bounds.</p>
<p>如果第一个函数声明使用数组形式,那么数组中指定的边界被假定为在调用该函数时预期提供的最小元素数和它所访问的最大元素数。未能提供足够大小的参数或访问超过最大数量的元素可能会被诊断为警告,如-Warray-bounds. 在第 1 级，警告诊断涉及使用 T[static N] 形式声明的数组参数的不一致。</p>
<p>例如，以下重新声明会触发警告，因为第一个允许将任意大小的数组传递给 f ,而第二个带有关键字 static 的指定数组参数必须至少有四个元素。</p>
</div></blockquote>
<div class="literal-block-wrapper docutils container" id="id389">
<div class="code-block-caption"><span class="caption-text">可以指定的语言</span><a class="headerlink" href="#id389" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span> void f (int[static 4]);
<span class="hll"> void f (int[]);           // 警告（数组形式不一致）
</span>
 void g (void)
 {
   int *p = (int *)malloc (4);
   f (p);                  // 警告（数组太小）
   …
 }

 在第2级,对于涉及任何其他不一致的表示数组或指针参数形式的重新声明,也会触发警告。未指定边界的指针和数组被认为是等同的,不会触发警告。
</pre></div>
</td></tr></table></div>
</div>
<p>-Wattribute-alias=n
-Wno-attribute-alias</p>
<blockquote>
<div><p>警告使用 alias 和目标与别名类型不兼容的相似属性的声明。请参见声明函数的属性。</p>
<p>-Wattribute-alias=1</p>
<blockquote>
<div><p>的默认警告级别。-Wattribute-alias选项诊断别名声明的类型与目标类型之间的不兼容。这种不一致通常表明存在错误。</p>
</div></blockquote>
<p>-Wattribute-alias=2</p>
<blockquote>
<div><p>在这一级-Wattribute-alias还可以诊断别名声明的属性比应用于目标的属性更具限制性的情况。这些不匹配可能会导致不正确的代码生成。在其他情况下,它们可能是良性的,只需将缺失的属性添加到目标中即可解决。为了比较,请看-Wmissing-attributes选项,当别名声明的限制性小于目标,而不是限制性更强时,该选项控制诊断。</p>
<p>考虑属性包括 alloc_align ， alloc_size ， cold ， const ， hot ， leaf ， malloc 的， nonnull ， noreturn ， nothrow ， pure ， returns_nonnull 和 returns_twice 。</p>
</div></blockquote>
<p>-Wattribute-alias相当于-Wattribute-alias=1。这是默认值。您可以通过以下任一方式禁用这些警告-Wno-attribute-aliasor-Wattribute-alias=0.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>bool-compare</var></span></kbd></dt>
<dd><p>警告布尔表达式与不同于 true / false 的整数值。例如，以下比较始终为假：</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>bool-operation</var></span></kbd></dt>
<dd><p>警告对布尔类型表达式的可疑操作。例如,布尔型的位否定很可能是程序中的一个错误。对于C语言来说,这个警告也会警告递增或递减一个布尔值,这很少有意义。(在C++中,递减一个布尔值总是无效的。在C++17中,递增一个布尔值是无效的,否则就会被废弃)。)</p>
<p>启用该警告的方法是-Wall.</p>
</dd>
<dt><kbd><span class="option">-W<var>duplicated-branches</var></span></kbd></dt>
<dd><p>当if-else有相同分支时发出警告。该警告会检测到以下情况</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>duplicated-cond</var></span></kbd></dt>
<dd><p>对if-else-if链中的重复条件提出警告。例如,对以下代码发出警告。</p>
<p>if (p-&gt;q != NULL) { … }
else if (p-&gt;q != NULL) { … }</p>
</dd>
<dt><kbd><span class="option">-W<var>frame-address</var></span></kbd></dt>
<dd><p>当“__builtin_frame_address’ 要么 ‘__builtin_return_address使用大于0的参数调用’。此类调用可能返回不确定的值或使程序崩溃。该警告包含在-Wall.</p>
</dd>
</dl>
<p>-Wno-discarded-qualifiers (C and Objective-C only)</p>
<blockquote>
<div><p>不要警告是否丢弃了指针上的类型限定符。通常，如果将 const char * 变量传递给采用 char * 参数的函数，则编译器会发出警告。此选项可用于禁止显示此类警告。</p>
</div></blockquote>
<p>-Wno-discarded-array-qualifiers (C and Objective-C only)</p>
<blockquote>
<div><p>不要警告是否舍弃了作为指针目标的数组上的类型限定符。通常，如果将 const int (*)[] 变量传递给采用 int (*)[] 参数的函数，则编译器会发出警告。此选项可用于禁止显示此类警告。</p>
</div></blockquote>
<p>-Wno-incompatible-pointer-types (C and Objective-C only)</p>
<blockquote>
<div><p>当有不兼容类型的指针之间发生转换时,不要发出警告。这个警告是针对-Wno-pointer-sign，它警告传递或签名不同的指针参数。</p>
</div></blockquote>
<p>-Wno-int-conversion (C and Objective-C only)</p>
<blockquote>
<div><p>不要对不兼容的整数到指针和指针到整数的转换发出警告。这个警告是关于隐式转换的;对于显式转换,警告为-Wno-int-to-pointer-castand-Wno-pointer-to-int-cast可使用。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>zero-length-bounds</var></span></kbd></dt>
<dd><p>警告访问长度可能为零的数组成员的元素，这些元素可能与同一对象的其他成员重叠。不建议声明内部零长度数组，因为对它们的访问未定义。请参阅“零长度”。</p>
<p>例如，由于数组元素与后续成员 b 和 c 重叠，因此诊断出函数 bad 中的前两个存储。第三家商店被诊断为-Warray-bounds因为它超出了包围对象的范围。</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>no-div-by-zero</var></span></kbd></dt>
<dd><p>不要警告编译时的整数除以零。不警告浮点除以零,因为这可能是获得无穷大和NaN的合法方式。</p>
</dd>
<dt><kbd><span class="option">-W<var>system-headers</var></span></kbd></dt>
<dd><p>打印系统头文件中发现的构造的警告信息。来自系统头文件的警告通常会被抑制,因为它们通常不会显示真正的问题,只会让编译器的输出更难读。使用这个命令行选项可以让GCC发出来自系统头文件的警告,就像它们发生在用户代码中一样。但是,请注意,使用这个命令行选项可以让GCC从系统头文件中发出警告,就像它们发生在用户代码中一样。-Wall与此选项结合使用时，不会警告系统标题中存在未知的编译指示，为此，-Wunknown-pragmas也必须使用。</p>
</dd>
<dt><kbd><span class="option">-W<var>tautological-compare</var></span></kbd></dt>
<dd><p>如果一个自我比较总是评估为真或假,则发出警告。该警告可检测各种错误,如:</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>trampolines</var></span></kbd></dt>
<dd><p>警惕为嵌套函数的指针生成的蹦床。蹦床是运行时在堆栈上取嵌套函数的地址时产生的一小段数据或代码,用于间接调用嵌套函数。对于某些目标来说,它只由数据组成,因此不需要特殊处理。但是,对于大多数目标来说,它是由代码组成的,因此需要使堆栈可以执行,程序才能正常运行。</p>
</dd>
<dt><kbd><span class="option">-W<var>float-equal</var></span></kbd></dt>
<dd><p>如果在等价比较中使用浮点值,则发出警告。</p>
<p>其背后的想法是，有时（对于程序员而言）将浮点值视为无限精确的实数的近似值很方便。如果执行此操作，则需要计算（通过分析代码或通过其他方式）计算所引入的最大或可能的最大误差，并在进行比较（以及生成输出时）允许它，但这是不同的问题）。特别是，您应该检查两个值是否具有重叠的范围，而不是测试是否相等。并且这是通过关系运算符完成的，因此相等比较可能是错误的。</p>
</dd>
</dl>
<p>-Wtraditional (C and Objective-C only)</p>
<blockquote>
<div><p>警告某些在传统C语言和ISO C语言中表现不同的构造,同时警告那些没有传统C语言等价物的ISO C语言构造和/或应该避免的问题构造。</p>
<blockquote>
<div><p>宏体中出现在字符串字元内的宏参数。在传统的C语言中,宏的替换是在字符串字元中进行的,但在ISO C语言中则不然。
在传统的C语言中，不存在某些预处理程序指令。传统预处理器仅在以下情况下将行视为指令：#’出现在该行的第1列中。因此-Wtraditional警告传统C可以理解但会忽略的指令，因为’#’不会显示为该行的第一个字符。它还建议您通过缩进来隐藏诸如传统C不能理解的 #pragma 之类的指令。一些传统的实现无法识别 #elif ，因此此选项建议完全避免使用它。
一个无参数出现的类似函数的宏。
单音加运算符。
这 ‘U’整数常量后缀，或’F’ 要么 ‘L浮点常量后缀。（传统C确实支持“L’后缀为整数常量。）请注意，这些后缀出现在大多数现代系统的系统标头中定义的宏中，例如’_MIN’/‘_MAX’ &lt;limits.h&gt; 中的宏。在用户代码中使用这些宏通常可能会导致虚假警告，但是GCC的集成预处理器具有足够的上下文可以避免在这些情况下发出警告。
在一个区块中声明的外部函数,然后在区块结束后使用。
一个 switch 语句类型的操作数 long 。
非 static 函数声明跟在 static 声明之后。一些传统的C编译器不接受此构造。
一个整数常量的ISO类型与传统类型的宽度或签名不同。只有当常量的基数是十时,才会发出这个警告。即十六进制或八进制值,通常代表位模式,不会被警告。
检测到ISO字符串连接的使用。
自动汇总的初始化。
标识符与标签冲突。传统C语言缺乏单独的标签命名空间。
工会的初始化。如果初始值设定项为零，则忽略警告。这是在以下假设下完成的：用户代码中的零初始值设定项似乎以 __STDC__ 为条件，以避免丢失初始值设定项警告，并且在传统C情况下依赖于默认初始化为零。
通过原型在定点/浮点值之间进行转换,反之亦然。在用传统C语言编译时,如果没有这些原型,会导致严重的问题。这是可能出现的转换警告的一个子集,完整的警告集请使用-Wtraditional-conversion.
使用ISO C样式函数定义。不会为原型声明或可变参数发出此警告，因为在使用libiberty的传统C兼容性宏 PARAMS 和 VPARAMS 时，这些ISO C功能会出现在您的代码中。嵌套函数也绕过此警告，因为该功能已经是GCC扩展，因此与传统C兼容性无关。</p>
</div></blockquote>
</div></blockquote>
<p>-Wtraditional-conversion (C and Objective-C only)</p>
<blockquote>
<div><p>如果原型引起的类型转换与没有原型时相同参数的类型转换不同,则发出警告。这包括从定点到浮点的转换,反之亦然,以及改变定点参数的宽度或符号的转换,除非与默认值相同。</p>
</div></blockquote>
<p>-Wdeclaration-after-statement (C and Objective-C only)</p>
<blockquote>
<div><p>在块中的语句之后发现声明时发出警告。这个结构，从 C++ 中知道，是在 ISO C99 中引入的，默认情况下在 GCC 中是允许的。ISO C90 不支持它。请参阅混合标签和声明。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>shadow</var></span></kbd></dt>
<dd><p>当一个局部变量或类型声明对另一个变量、参数、类型、类成员(在C++中)或实例变量(在Objective-C中)产生阴影时,或者当一个内置函数产生阴影时,都会发出警告。请注意,在C++中,如果一个局部变量对一个显式typedef产生阴影,编译器会发出警告,但如果它对一个结构/类/枚举产生阴影,则不会发出警告。如果启用了这个警告,它也包括所有本地影子的实例。这意味着-Wno-shadow=localand-Wno-shadow=compatible-local的时候会被忽略。-Wshadow是用。同-Wshadow=global.</p>
</dd>
</dl>
<p>-Wno-shadow-ivar (Objective-C only)</p>
<blockquote>
<div><p>当一个局部变量在Objective-C方法中影射一个实例变量时,不要发出警告。</p>
</div></blockquote>
<p>-Wshadow=global</p>
<blockquote>
<div><p>警告任何阴影。同-Wshadow.</p>
</div></blockquote>
<p>-Wshadow=local</p>
<blockquote>
<div><p>当一个局部变量对另一个局部变量或参数产生阴影时发出警告。</p>
</div></blockquote>
<p>-Wshadow=compatible-local</p>
<blockquote>
<div><p>当一个局部变量屏蔽了另一个局部变量或参数,而该变量的类型与被屏蔽变量的类型兼容时,发出警告。在C++中,这里的类型兼容性意味着影子变量的类型可以转换为被影子变量的类型。这个标志的创建(除了-Wshadow=local）的想法是，当局部变量遮盖另一个不兼容类型的变量时，它很可能是有意的，而不是错误或错字，如以下示例所示：</p>
</div></blockquote>
<p>-Wlarger-than=byte-size</p>
<blockquote>
<div><p>在定义大小超过 byte-size 的对象时发出警告。-Wlarger-than=‘PTRDIFF_MAX默认情况下启用。可以通过指定’的 byte-size 来禁用由该选项控制的警告SIZE_MAX’或更多或-Wno-larger-than.</p>
<p>还警告调用有界函数，例如 memchr 或 strnlen ，这些函数指定的界限大于可能的最大对象，即 ‘PTRDIFF_MAX’ 默认为字节。这些警告只能通过以下方式禁用-Wno-larger-than.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>no-larger-than</var></span></kbd></dt>
<dd><p>Disable-Wlarger-than=警告。该选项相当于-Wlarger-than=‘SIZE_MAX’或更大。</p>
</dd>
</dl>
<p>-Wframe-larger-than=byte-size</p>
<blockquote>
<div><p>如果功能框 byte-size 超过byte-size，则发出警告。确定堆栈帧大小所做的计算是近似的，而不是保守的。即使您没有收到警告，实际的要求也可能比 byte-size 要大一些。此外，在确定是否发出警告时，编译器不包括通过 alloca ，可变长度数组或相关结构分配的任何空间。-Wframe-larger-than=‘PTRDIFF_MAX默认情况下启用。可以通过指定’的 byte-size 来禁用由该选项控制的警告SIZE_MAX’或更多或-Wno-frame-larger-than.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>no-frame-larger-than</var></span></kbd></dt>
<dd><p>Disable-Wframe-larger-than=警告。该选项相当于-Wframe-larger-than=‘SIZE_MAX’或更大。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-free-nonheap-object</var></span></kbd></dt>
<dd><p>尝试释放未在堆上分配的对象或使用未从先前调用相应分配函数返回的指针时发出警告。例如，因为对 stpcpy 的调用返回一个指向终止 nul 字符而不是指向对象的开始的指针，所以下面对 free 的调用被诊断出来。</p>
</dd>
</dl>
<p>-Wstack-usage=byte-size</p>
<blockquote>
<div><p>如果函数的堆栈使用量可能超过 byte-size ，则发出警告。确定堆栈使用情况所做的计算是保守的。在确定是否发出警告时，编译器将包括通过 alloca ，可变长度数组或相关结构分配的任何空间。</p>
<p>该信息与-fstack-usage.</p>
<blockquote>
<div><p>如果堆栈使用情况是完全静态的，但超过了指定的数量，则为：</p>
<p>warning: stack usage is 1120 bytes</p>
<p>如果堆栈使用率是（部分）动态但有界的，则为：</p>
<p>warning: stack usage might be 1648 bytes</p>
<p>如果堆栈使用情况（部分）是动态的且不受限制，则为：</p>
<p>warning: stack usage might be unbounded</p>
</div></blockquote>
<p>-Wstack-usage=‘PTRDIFF_MAX默认情况下启用。可以通过指定’的 byte-size 来禁用由该选项控制的警告SIZE_MAX’或更多或-Wno-stack-usage.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>no-stack-usage</var></span></kbd></dt>
<dd><p>Disable-Wstack-usage=警告。该选项相当于-Wstack-usage=‘SIZE_MAX’或更大。</p>
</dd>
<dt><kbd><span class="option">-W<var>unsafe-loop-optimizations</var></span></kbd></dt>
<dd><p>如果循环不能被优化,因为编译器不能假设循环指数的任何界限,则发出警告。有了-funsafe-loop-optimizations如果编译器做出这样的假设,则发出警告。</p>
</dd>
</dl>
<p>-Wno-pedantic-ms-format (MinGW targets only)</p>
<blockquote>
<div><p>当结合使用-Wformatand-pedantic如果不使用GNU扩展名，则此选项将禁用有关非ISO printf / scanf 格式宽度说明符 I32 ， I64 以及 I 在Windows目标上使用的警告（取决于Windows运行时）。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>pointer-arith</var></span></kbd></dt>
<dd><p>警告任何取决于函数类型或 void 的“大小”的内容。为了方便使用 void * 指针和函数指针，GNU C将这些类型的大小分配为1 。在C ++中，当算术运算涉及 NULL 时也要发出警告。此警告也通过以下方式启用-Wpedantic.</p>
</dd>
<dt><kbd><span class="option">-W<var>no-pointer-compare</var></span></kbd></dt>
<dd><p>如果指针与一个零字符常量进行比较,不要发出警告。这通常意味着该指针是要被取消引用的。例如</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>tsan</var></span></kbd></dt>
<dd><p>对ThreadSanitizer中不支持的功能发出警告。</p>
<p>ThreadSanitizer 不支持 std::atomic_thread_fence 并且可以报告误报。</p>
<p>该警告默认为启用。</p>
</dd>
<dt><kbd><span class="option">-W<var>type-limits</var></span></kbd></dt>
<dd><p>由于数据类型的范围有限，警告比较是对还是错，但不要对常量表达式发出警告。例如，警告是否使用 &lt; 或 &gt;= 将无符号变量与零进行比较。此警告也通过以下方式启用-Wextra.</p>
</dd>
</dl>
<p>-Wabsolute-value (C and Objective-C only)</p>
<blockquote>
<div><p>当更合适的标准函数可用时，警告调用计算标准绝对值的标准函数。例如，调用 abs(3.14) 会触发警告，因为要调用的用于计算double参数的绝对值的适当函数是 fabs 。当对该函数的调用中的参数为无符号类型时，该选项还会触发警告。可以使用显式类型强制转换禁止此警告，也可以通过以下方式启用该警告：-Wextra.</p>
</div></blockquote>
<p>-Wcomment
-Wcomments</p>
<blockquote>
<div><p>每当评论开始序列时发出警告’/<em>’出现在’/</em>’注释，或每当反斜杠换行符出现在’//发表评论。此警告通过以下方式启用-Wall.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>trigraphs</var></span></kbd></dt>
<dd><p>如果遇到任何可能改变程序含义的三段式,则发出警告。除了那些会形成转义的新行外,注释中的三段式不会被警告。</p>
<p>这个选项是由-Wall。如果-Wall不给定,除非启用三角图,否则该选项仍会被启用。要想在没有警告的情况下获得三角图转换,但却能获得其他的选项。-Wall警告，使用’-trigraphs -Wall -Wnotrigraphs’.</p>
</dd>
<dt><kbd><span class="option">-W<var>undef</var></span></kbd></dt>
<dd><p>如果在 #if 指令中评估了未定义的标识符，则发出警告。此类标识符将替换为零。</p>
</dd>
<dt><kbd><span class="option">-W<var>expansion-to-defined</var></span></kbd></dt>
<dd><p>当“defined在宏的扩展中会遇到“（包括用’#if’指令）。这种用法是不可移植的。此警告也通过以下方式启用-Wpedanticand-Wextra.</p>
</dd>
<dt><kbd><span class="option">-W<var>unused-macros</var></span></kbd></dt>
<dd><p>警告主文件中定义的未使用的宏。如果宏至少被扩展或测试一次存在，则使用该宏。预处理器还会警告在重新定义或未定义宏时是否尚未使用该宏。</p>
<p>内置宏、在命令行定义的宏和在include文件中定义的宏都不会被警告。</p>
<p>注意：如果实际使用了宏，但仅在跳过的条件块中使用了宏，则预处理器会将其报告为未使用。为了避免这种情况下的警告，您可以通过例如将宏移到第一个跳过的块中来改善宏定义的范围。或者，您可以提供类似以下内容的虚拟使用：</p>
<p>#if defined the_macro_causing_the_warning
#endif</p>
</dd>
<dt><kbd><span class="option">-W<var>no-endif-labels</var></span></kbd></dt>
<dd><p>当 #else 或 #endif 后跟文本时，请勿发出警告。有时在使用以下形式的代码的旧程序中会发生这种情况</p>
</dd>
</dl>
<p>-Wbad-function-cast (C and Objective-C only)</p>
<blockquote>
<div><p>当一个函数调用被转换为非匹配类型时发出警告。例如,当一个返回整数类型的函数调用被转为指针类型时,发出警告。</p>
</div></blockquote>
<p>-Wc90-c99-compat (C and Objective-C only)</p>
<blockquote>
<div><p>警告ISO C90中没有但ISO C99中存在的功能。例如，警告使用可变长度数组， long long 类型， bool 类型，复合文字，指定的初始值设定项等。此选项独立于标准模式。 __extension__ 后面的表达式中禁用警告。</p>
</div></blockquote>
<p>-Wc99-c11-compat (C and Objective-C only)</p>
<blockquote>
<div><p>警告ISO C99中不存在但ISO C11中存在的功能。例如，警告使用匿名结构和联合， _Atomic 类型限定符， _Thread_local 存储类指定符， _Alignas 指定符， Alignof 运算符， _Generic 关键字等。此选项独立于标准模式。 __extension__ 后面的表达式中禁用警告。</p>
</div></blockquote>
<p>-Wc11-c2x-compat (C and Objective-C only)</p>
<blockquote>
<div><p>警告ISO C11中不存在但ISO C2X中存在的功能。例如，警告有关省略 _Static_assert 中的字符串，请使用’[[]]’属性的语法，十进制浮点类型的使用，等等。此选项独立于标准模式。 __extension__ 后面的表达式中禁用警告。</p>
</div></blockquote>
<p>-Wc++-compat (C and Objective-C only)</p>
<blockquote>
<div><p>警告在ISO C和ISO C ++的公共子集之外的ISO C构造，例如，请求从 void * 隐式转换为指向非 void 类型的指针。</p>
</div></blockquote>
<p>-Wc++11-compat (C++ and Objective-C++ only)</p>
<blockquote>
<div><p>对ISO C++1998和ISO C++2011意义不同的C++结构提出警告,例如,ISO C++1998中的标识符在ISO C++2011中是关键字。这个警告会开启-Wnarrowing并通过以下方式启用-Wall.</p>
</div></blockquote>
<p>-Wc++14-compat (C++ and Objective-C++ only)</p>
<blockquote>
<div><p>对ISO C++2011和ISO C++2014之间含义不同的C++结构提出警告。启用该警告的方法是-Wall.</p>
</div></blockquote>
<p>-Wc++17-compat (C++ and Objective-C++ only)</p>
<blockquote>
<div><p>警告C++结构,其含义在ISO C++2014和ISO C++2017之间有所不同。该警告通过以下方式启用-Wall.</p>
</div></blockquote>
<p>-Wc++20-compat (C++ and Objective-C++ only)</p>
<blockquote>
<div><p>警告C++结构,其含义在ISO C++2017和ISO C++2020之间有所不同。该警告通过以下方式启用-Wall.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>cast-qual</var></span></kbd></dt>
<dd><p>在强制转换指针时发出警告，以便从目标类型中删除类型限定符。例如，警告是否将 const char * 强制转换为普通 char * 。</p>
<p>在进行以不安全方式引入类型限定符的强制转换时也要发出警告。例如，将 char ** 强制转换为 const char ** 是不安全的，如以下示例所示：</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>cast-align</var></span></kbd></dt>
<dd><p>在投射指针时发出警告，以增加目标的所需对齐方式。例如，警告在将整数只能在两字节或四字节边界访问的计算机上，如果将 char * 强制转换为 int * 。</p>
</dd>
</dl>
<p>-Wcast-align=strict</p>
<blockquote>
<div><p>在投射指针时发出警告，以增加目标的所需对齐方式。例如，警告是否将 char * 强制转换为 int * ,而与目标计算机无关。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>cast-function-type</var></span></kbd></dt>
<dd><p>在将函数指针强制转换为不兼容的函数指针时发出警告。在涉及具有可变参数列表的函数类型的转换中，仅考虑提供的初始参数的类型。指针类型的任何参数都与任何其他指针类型匹配。整数类型的任何良性差异都将被忽略，例如ILP32目标上的 int vs. long 。同样，类型限定符也将被忽略。函数类型 void (*) (void) 是特殊的，并且与所有内容匹配，可用于抑制此警告。在涉及成员类型指针的转换中，只要类型转换将指针更改为成员类型，此警告都会发出警告。此警告通过以下方式启用-Wextra.</p>
</dd>
<dt><kbd><span class="option">-W<var>write-strings</var></span></kbd></dt>
<dd><p>在编译C时，给字符串常量一个 const char[length] 类型的值，以便将一个地址复制到一个非 const char * 指针中会产生警告。这些警告可以帮助您在编译时找到可以尝试写入字符串常量的代码，但前提是您非常谨慎地在声明和原型中使用 const 。否则，这只是个麻烦。这就是为什么我们没有做-Wall请求这些警告。</p>
<p>在编译C ++时，警告从字符串文字到 char * 的弃用转换。默认情况下，C ++程序启用此警告。</p>
</dd>
<dt><kbd><span class="option">-W<var>clobbered</var></span></kbd></dt>
<dd><p>警告可能由 longjmp 或 vfork 更改的变量。此警告也通过以下方式启用-Wextra.</p>
</dd>
<dt><kbd><span class="option">-W<var>conversion</var></span></kbd></dt>
<dd><p>警告可能会更改值的隐式转换。这包括实数和整数之间的转换，例如 x 为 double 时的 abs (x) ；有符号和无符号之间的转换，例如 unsigned ui = -1 ;并转换为较小的类型，例如 sqrtf (M_PI) 。不要警告像 abs ((int) x) 和 ui = (unsigned) -1 这样的显式强制类型转换，或者如果该值没有像 abs (2.0) 那样由转换更改，则不要发出警告。可以通过使用禁用有关有符号和无符号整数之间转换的警告-Wno-sign-conversion.</p>
<p>对于C ++，还警告用户定义转换时的重载解析混乱；以及从未使用类型转换运算符的转换：转换为 void ，相同类型，基类或对其的引用。除非在C ++中，否则默认禁用有关有符号和无符号整数之间转换的警告-Wsign-conversion明确启用。</p>
<p>关于从小类型上的算术转换回该类型的警告,只有在使用了-Warith-conversion.</p>
</dd>
<dt><kbd><span class="option">-W<var>dangling-else</var></span></kbd></dt>
<dd><p>警告有关 if 语句 else 分支所属的结构可能会造成混乱的地方。这是这种情况的示例：</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>date-time</var></span></kbd></dt>
<dd><p>警告宏时 __TIME__ ， __DATE__ 或 __TIMESTAMP__ 遇到，因为他们可能会阻止逐位完全相同的重复性汇编。</p>
</dd>
<dt><kbd><span class="option">-W<var>empty-body</var></span></kbd></dt>
<dd><p>如果 if ， else 或 do while 语句中出现空主体，则发出警告。此警告也通过以下方式启用-Wextra.</p>
</dd>
<dt><kbd><span class="option">-W<var>no-endif-labels</var></span></kbd></dt>
<dd><p>不要在 #else 和 #endif 之后警告流浪令牌。</p>
</dd>
<dt><kbd><span class="option">-W<var>enum-compare</var></span></kbd></dt>
<dd><p>对不同枚举类型的值之间的比较发出警告。在C++中,条件表达式中的枚举类型不匹配也会被诊断出来,默认情况下该警告是启用的。在C语言中,这个警告是由-Wall.</p>
</dd>
<dt><kbd><span class="option">-W<var>enum-conversion</var></span></kbd></dt>
<dd><p>当一个枚举类型的值被隐式转换为不同的枚举类型时发出警告。这个警告是由-Wextra在C。</p>
</dd>
</dl>
<p>-Wjump-misses-init (C, Objective-C only)</p>
<blockquote>
<div><p>如果 goto 语句或 switch 语句在变量的初始化过程中向前跳转，或者在变量已初始化后向后跳转至标签，则发出警告。这仅警告声明变量时已初始化的变量。仅C和Objective-C支持此警告。在C ++中，这种分支在任何情况下都是错误。</p>
<p>-Wjump-misses-init包括在-Wc++-compat。可以用-Wno-jump-misses-initoption.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>sign-compare</var></span></kbd></dt>
<dd><p>当有符号值和无符号值之间的比较在将有符号值转换为无符号值时可能产生不正确的结果时发出警告。在C++中,这个警告也可以通过-Wall。在C中，也可以通过启用-Wextra.</p>
</dd>
<dt><kbd><span class="option">-W<var>sign-conversion</var></span></kbd></dt>
<dd><p>警告隐式转换可能会改变一个整数值的符号,比如将一个有符号的整数表达式赋值给一个无符号的整数变量。显式转换会使警告消失。在C语言中,这个选项也可以通过-Wconversion.</p>
</dd>
<dt><kbd><span class="option">-W<var>float-conversion</var></span></kbd></dt>
<dd><p>对降低实值精度的隐式转换提出警告。这包括从实数到整数的转换,以及从高精度实数到低精度实数的转换。这个选项也可以通过-Wconversion.</p>
</dd>
<dt><kbd><span class="option">-W<var>no-scalar-storage-order</var></span></kbd></dt>
<dd><p>不要对涉及反向标量存储顺序的可疑构造发出警告。</p>
</dd>
<dt><kbd><span class="option">-W<var>sizeof-array-div</var></span></kbd></dt>
<dd><p>警告两个sizeof运算符的除法,当第一个运算符应用于一个数组时,除数不等于数组元素的大小。在这种情况下,计算不会产生数组中的元素数,这可能是用户的意图。这个警告警告了,例如,关于</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>sizeof-pointer-div</var></span></kbd></dt>
<dd><p>警告对两个sizeof表达式进行可疑的划分，这些表达式会将指针大小除以元素大小，这是计算数组大小的常用方法，但无法正确使用指针。如果 ptr 不是数组而是指针，则此警告将警告有关例如 sizeof (ptr) / sizeof (ptr[0]) 。此警告通过以下方式启用-Wall.</p>
</dd>
<dt><kbd><span class="option">-W<var>sizeof-pointer-memaccess</var></span></kbd></dt>
<dd><p>如果参数使用 sizeof ,则警告某些字符串和内存内置函数的可疑长度参数。例如，此警告会触发 memset (ptr, 0, sizeof (ptr)); 如果 ptr 不是数组，而是一个指针，并提出了可能的解决方法，或者关于 memcpy (&amp;foo, ptr, sizeof (&amp;foo)); 。-Wsizeof-pointer-memaccess还警告有关对绑定字符串复制函数（如 strncat 或 strncpy )的调用，这些函数将源数组的 sizeof 表达式指定为绑定对象。例如，在以下函数中，对 strncat 的调用将源字符串的大小指定为绑定的大小。几乎可以肯定这是一个错误，因此可以诊断出该呼叫。</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>no-sizeof-array-argument</var></span></kbd></dt>
<dd><p>当 sizeof 运算符应用于在函数定义中声明为数组的参数时，请勿发出警告。默认情况下，C和C ++程序启用此警告。</p>
</dd>
<dt><kbd><span class="option">-W<var>memset-elt-size</var></span></kbd></dt>
<dd><p>如果第一个参数引用一个数组，而第三个参数是一个等于元素数量但不等于内存中数组大小的数字，则警告可疑调用 memset 内置函数。这表明用户已经省略了元素大小的乘法。此警告通过以下方式启用-Wall.</p>
</dd>
<dt><kbd><span class="option">-W<var>memset-transposed-args</var></span></kbd></dt>
<dd><p>警告第二个参数不为零，第三个参数为零的可疑调用 memset 内置函数。例如，诊断呼叫 memset (buf, sizeof buf, 0) 是因为意味着要使用 memset (buf, 0, sizeof buf) 。仅当第三个参数是文字零时才发出诊断。否则，如果它是折叠为零的表达式，或者是将零强制转换为某种类型的表达式，则参数被错误地转置并且不发出警告的可能性要小得多。此警告通过以下方式启用-Wall.</p>
</dd>
<dt><kbd><span class="option">-W<var>address</var></span></kbd></dt>
<dd><p>警告有关内存地址的可疑使用。这些包括在条件表达式中使用函数的地址，例如 void func(void); if (func) ，并与字符串文字的内存地址进行比较，例如 if (x == “abc”) 。这样的用法通常表示程序员错误：函数的地址总是评估为true，因此在有条件的条件下使用它们通常表明程序员忘记了函数调用中的括号。以及与字符串文字的比较会导致未指定的行为，并且不能在C语言中移植，因此，它们通常表明程序员打算使用 strcmp 。此警告通过以下方式启用-Wall.</p>
</dd>
<dt><kbd><span class="option">-W<var>no-address-of-packed-member</var></span></kbd></dt>
<dd><p>当结构或联合体的打包成员的地址被取走时,不要发出警告,因为这通常会导致一个未对齐的指针值。这在默认情况下是启用的。</p>
</dd>
<dt><kbd><span class="option">-W<var>logical-op</var></span></kbd></dt>
<dd><p>警惕在表达式中可疑地使用逻辑运算符。这包括在可能会出现位智运算符的情况下使用逻辑运算符。当逻辑运算符的操作数相同时,也会发出警告。</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>logical-not-parentheses</var></span></kbd></dt>
<dd><p>在比较的左手操作数上没有使用逻辑时发出警告。如果右侧操作数被认为是布尔表达式,这个选项不会发出警告。它的目的是检测可疑的代码,比如下面的代码。</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>aggregate-return</var></span></kbd></dt>
<dd><p>如果定义或调用了任何返回结构或联合的函数,则发出警告。(在可以返回数组的语言中,这也会引起警告。)</p>
</dd>
<dt><kbd><span class="option">-W<var>no-aggressive-loop-optimizations</var></span></kbd></dt>
<dd><p>如果在一个恒定迭代次数的循环中,编译器在一次或多次迭代中检测到某些语句的未定义行为,则发出警告。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-attributes</var></span></kbd></dt>
<dd><p>如果使用了意外的 __attribute__ （例如，无法识别的属性，应用于变量的函数属性等），则不会发出警告。这不会因错误使用支持的属性而停止错误。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-builtin-declaration-mismatch</var></span></kbd></dt>
<dd><p>如果一个内置函数被声明为不兼容的签名或非函数,或者当一个内置函数被声明为不包含原型的类型时,如果调用的参数的类型与函数所期望的类型不匹配,则发出警告。当-Wextra指定,当一个内置函数在没有原型的情况下被声明为接受参数时,也会发出警告。语句中的-Wbuiltin-declaration-mismatch警告是默认启用的。要避免该警告,请包含适当的头,以使内置函数的原型进入范围。</p>
<p>例如，对以下 memset 的调用通过警告进行诊断，因为该函数希望将 size_t 类型的值作为其自变量，而类型 32 是 int 。用-Wextra，功能的声明也会被诊断。</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>no-builtin-macro-redefined</var></span></kbd></dt>
<dd><p>如果某些内置宏被重新定义，则不发出警告。这抑制了警告，重新定义 __TIMESTAMP__ ， __TIME__ ， __DATE__ ， __FILE__ 和 __BASE_FILE__ 。</p>
</dd>
</dl>
<p>-Wstrict-prototypes (C and Objective-C only)</p>
<blockquote>
<div><p>如果一个函数在没有指定参数类型的情况下被声明或定义,则发出警告。(如果在声明之前指定了参数类型,那么旧式函数定义可以不发出警告。)</p>
</div></blockquote>
<p>-Wold-style-declaration (C and Objective-C only)</p>
<blockquote>
<div><p>根据声明，警告使用过时（根据C标准）。例如，警告诸如 static 之类的存储类说明符不是声明中的首要内容。此警告也通过以下方式启用-Wextra.</p>
</div></blockquote>
<p>-Wold-style-definition (C and Objective-C only)</p>
<blockquote>
<div><p>如果使用旧式函数定义，则发出警告。即使有以前的原型，也会发出警告。使用’的定义()’在C2X模式下不被视为旧式定义，因为它等效于’(void)在这种情况下，则被视为旧标准的旧式定义。</p>
</div></blockquote>
<p>-Wmissing-parameter-type (C and Objective-C only)</p>
<blockquote>
<div><p>在K＆R样式的函数中声明的函数参数没有类型说明符：</p>
<p>void foo(bar) { }</p>
<p>该警告也可通过以下方式启用-Wextra.</p>
</div></blockquote>
<p>-Wmissing-prototypes (C and Objective-C only)</p>
<blockquote>
<div><p>如果全局函数的定义没有事先声明原型,则发出警告。即使定义本身提供了原型,也会发出警告。使用这个选项来检测头文件中没有匹配原型声明的全局函数。这个选项对C++无效,因为所有的函数声明都提供原型,不匹配的声明会声明一个重载,而不是与之前的声明冲突。使用-Wmissing-declarations以检测C++中缺失的声明。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>missing-declarations</var></span></kbd></dt>
<dd><p>如果一个全局函数在没有事先声明的情况下被定义,则发出警告。即使定义本身提供了原型,也会发出警告。使用这个选项可以检测没有在头文件中声明的全局函数。在C语言中,对于之前有非原型声明的函数不会发出警告;使用-Wmissing-prototypes来检测丢失的原型。在C++中,不会对函数模板、内联函数或匿名命名空间中的函数发出警告。</p>
</dd>
<dt><kbd><span class="option">-W<var>missing-field-initializers</var></span></kbd></dt>
<dd><p>如果结构的初始化程序缺少某些字段，则发出警告。例如，以下代码会导致这样的警告，因为 x.h 隐式为零：</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>no-multichar</var></span></kbd></dt>
<dd><p>如果多字符常量（’’FOOF’’） 用来。通常，它们在用户代码中指示输入错误，因为它们具有实现定义的值，因此不应在可移植代码中使用。</p>
</dd>
</dl>
<p>-Wnormalized=[none|id|nfc|nfkc]</p>
<blockquote>
<div><p>在ISO C和ISO C ++中，如果两个标识符是不同的字符序列，则它们是不同的。但是，有时当使用基本ASCII字符集以外的字符时，您可以具有两个看起来相同的不同字符序列。为避免混淆，ISO 10646标准制定了一些规范化规则，这些规范在应用时可确保将看起来相同的两个序列转换为相同的序列。如果您使用的是未规范化的标识符，GCC会警告您。此选项控制该警告。</p>
<p>GCC支持的警告有四个级别。默认值是-Wnormalized=nfc，它会警告任何未采用ISO 10646“ C”标准化形式的标识符NFC。建议将NFC用于大多数用途。相当于-Wnormalized.</p>
<p>不幸的是，ISO C和ISO C ++的标识符中允许使用某些字符，当转换为NFC时，标识符中不允许使用这些字符。也就是说，无法在便携式ISO C或C ++中使用这些符号，而将所有标识符都包含在NFC中。-Wnormalized=id抑制这些字符的警告。希望未来相关标准的版本能够纠正这一点,这也是为什么这个选项不是默认的原因。</p>
<p>你可以通过写下以下内容来关闭所有字符的警告。-Wnormalized=noneor-Wno-normalized。仅在使用其他规范化方案（如“ D”）时才应执行此操作，因为否则，您可以轻松创建实际上看不到的错误。</p>
<p>ISO 10646中的某些字符具有不同的含义，但是在某些字体或显示方法上看起来相同，尤其是在应用格式后。例如 u207F ，“ SUPERSCRIPT 拉丁文小写字母 N”，显示的方式就像放置在上标中的常规 n 一样。ISO 10646定义了NFKC规范化方案，也将所有这些都转换为标准格式，如果您使用的代码不在NFKC中，则GCC会发出警告-Wnormalized=nfkc。该警告类似于关于每个包含字母O的标识符的警告，因为它可能与数字0混淆，因此不是默认值，但是如果不能固定编程环境来显示这些字母，则该警告可用作局部编码约定字符鲜明。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>no-attribute-warning</var></span></kbd></dt>
<dd><p>不要警告使用 warning 属性声明的函数（请参见Function Attributes）。默认情况下，此警告处于启用状态。-Wno-attribute-warning可用于禁用警告或-Wno-error=attribute-warning编译时,可以用它来禁用错误。-Werrorflag.</p>
</dd>
<dt><kbd><span class="option">-W<var>no-deprecated</var></span></kbd></dt>
<dd><p>不要警告使用已弃用的功能。请参阅不推荐使用的功能。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-deprecated-declarations</var></span></kbd></dt>
<dd><p>时不发出警告的功能用途（见函数属性），变量（见变量属性）和类型（见类型属性）标记的使用为废弃 deprecated 属性。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-overflow</var></span></kbd></dt>
<dd><p>不要对常量表达式中的编译时溢出发出警告。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-odr</var></span></kbd></dt>
<dd><p>在链接时间优化过程中对违反一定义规则的行为发出警告。默认为启用。</p>
</dd>
<dt><kbd><span class="option">-W<var>openmp-simd</var></span></kbd></dt>
<dd><p>如果向量器成本模型覆盖了用户设置的OpenMP simd指令,则发出警告。该-fsimd-cost-model=unlimited选项可用于放宽成本模型。</p>
</dd>
</dl>
<p>-Woverride-init (C and Objective-C only)</p>
<blockquote>
<div><p>当使用指定的初始化程序时，警告是否覆盖了没有副作用的初始化字段（请参见Designated Initializers）。</p>
<p>该警告包含在-Wextra。得到其他-Wextra警告没有这个,用-Wextra -Wno-override-init.</p>
</div></blockquote>
<p>-Wno-override-init-side-effects (C and Objective-C only)</p>
<blockquote>
<div><p>使用指定的初始化程序时，请不要警告是否会覆盖带有副作用的初始化字段（请参阅“指定的初始化程序”）。默认情况下启用此警告。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>packed</var></span></kbd></dt>
<dd><p>警告是否为结构赋予了packed属性，但packed属性对结构的布局或大小没有影响。这样的结构可能会错位，几乎没有好处。例如，在此代码中，即使 struct bar 本身不具有packed属性， struct bar 的变量 f.x 也未对齐：</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>nopacked-bitfield-compat</var></span></kbd></dt>
<dd><p>GCC的4.1、4.2和4.3系列忽略了 char 类型的位字段上的 packed 属性。这在GCC 4.4中已修复，但更改可能导致结构布局上的差异。当GCC 4.4中的此类字段的偏移量发生更改时，GCC会通知您。例如，在此结构中，字段 a 和 b 之间不再存在4位填充：</p>
</dd>
</dl>
<p>-Wpacked-not-aligned (C, C++, Objective-C and Objective-C++ only)</p>
<blockquote>
<div><p>如果在打包的结构或联合中具有明确指定的对齐方式的结构字段未对齐，则发出警告。例如，将在 struct S 上 warning: alignment 1 of ‘struct S’ is less than 8 ，例如警告：“ struct S”的对齐方式1小于8，在此代码中：</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>padded</var></span></kbd></dt>
<dd><p>如果结构中包含了padding,无论是为了对齐结构中的某个元素还是为了对齐整个结构,都要发出警告。在这种情况下,有时可以重新排列结构的字段,以减少填充物,从而使结构变小。</p>
</dd>
<dt><kbd><span class="option">-W<var>redundant-decls</var></span></kbd></dt>
<dd><p>如果任何东西在同一个作用域中被声明了不止一次,即使在多次声明有效且没有任何改变的情况下,也要发出警告。</p>
</dd>
<dt><kbd><span class="option">-W<var>restrict</var></span></kbd></dt>
<dd><p>当由 restrict 限定参数（或在C ++中为 __restrict 限定参数）引用的对象被另一个参数别名时，或当此类对象之间的副本重叠时发出警告。例如，下面对 strcpy 函数的调用试图通过将字符串的起始字符替换为后四个字符来截断该字符串。但是，由于调用将终止NUL写入 a[4] ，因此副本重叠并且诊断了调用。</p>
</dd>
</dl>
<p>-Wnested-externs (C and Objective-C only)</p>
<blockquote>
<div><p>如果在函数内遇到 extern 声明，则发出警告。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>inline</var></span></kbd></dt>
<dd><p>如果一个被声明为内联的函数不能内联,则发出警告。即使有这个选项,编译器也不会对系统头文件中声明为内联的函数失败发出警告。</p>
<p>编译器使用各种启发式方法来决定是否对一个函数进行内联。例如,编译器会考虑被内联的函数的大小和当前函数中已经完成的内联量。因此,源程序中看似微不足道的变化,都可能导致由-Winline出现或消失。</p>
</dd>
<dt><kbd><span class="option">-W<var>int-in-bool-context</var></span></kbd></dt>
<dd><p>警告在可能需要布尔值的地方使用可疑的整数值，例如在布尔上下文中使用非布尔整数常量的条件表达式（？:)，例如 if (a &lt;= b ? 2 : 3) 。或在布尔上下文中左移有符号整数，例如 for (a = 0; 1 &lt;&lt; a; a++); 。同样，对于所有类型的乘法，无论数据类型如何。此警告通过以下方式启用-Wall.</p>
</dd>
<dt><kbd><span class="option">-W<var>no-int-to-pointer-cast</var></span></kbd></dt>
<dd><p>抑制对不同大小的整数指针类型的投掷的警告。在C++中,投射到一个较小的指针类型是一个错误。Wint-to-pointer-cast默认情况下是启用的。</p>
</dd>
</dl>
<p>-Wno-pointer-to-int-cast (C and Objective-C only)</p>
<blockquote>
<div><p>抑制从指针投掷到不同大小的整数类型的警告。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>invalid-pch</var></span></kbd></dt>
<dd><p>警告是否在搜索路径中找到了预编译头（请参阅Precompiled Headers），但无法使用。</p>
</dd>
<dt><kbd><span class="option">-W<var>long-long</var></span></kbd></dt>
<dd><p>如果使用 long long 类型，则发出警告。可以通过以下任一方式启用-Wpedanticor-Wtraditional在ISO C90和C++98模式下。要抑制警告信息,使用-Wno-long-long.</p>
</dd>
<dt><kbd><span class="option">-W<var>variadic-macros</var></span></kbd></dt>
<dd><p>如果在ISO C90模式下使用了变量宏,或者在ISO C99模式下使用了GNU替代语法,则发出警告。这可以通过以下两种方式启用-Wpedanticor-Wtraditional。要禁止显示警告消息，请使用-Wno-variadic-macros.</p>
</dd>
<dt><kbd><span class="option">-W<var>no-varargs</var></span></kbd></dt>
<dd><p>不要警告用于处理可变参数（例如 va_start )的宏的可疑用法。这些警告默认情况下处于启用状态。</p>
</dd>
<dt><kbd><span class="option">-W<var>vector-operation-performance</var></span></kbd></dt>
<dd><p>如果没有通过体系结构的SIMD功能实现矢量操作，则发出警告。主要用于性能调整。向量运算可以 piecewise 实现，这意味着对每个向量元素都执行标量运算。 in parallel ，这意味着向量运算是使用较宽类型的标量实现的，通常，这种标量具有更高的性能效率；并且 as a single scalar ，这意味着矢量适合标量类型。</p>
</dd>
<dt><kbd><span class="option">-W<var>vla</var></span></kbd></dt>
<dd><p>如果在代码中使用了一个可变长度的数组,则发出警告。-Wno-vla防止-Wpedantic变长数组的警告。</p>
</dd>
</dl>
<p>-Wvla-larger-than=byte-size</p>
<blockquote>
<div><p>如果使用此选项，则编译器会警告您声明变长数组，其大小可以是无界的，也可以由允许数组大小超过 byte-size 字节的参数限制。这类似于-Walloca-larger-than=byte-size 有效，但具有可变长度数组。</p>
<p>请注意,GCC可能会将一个已知值的小变长数组优化成普通数组,所以对于这样的数组,这个警告可能不会被触发。</p>
<p>-Wvla-larger-than=‘PTRDIFF_MAX’默认启用，但通常仅在以下情况下有效-ftree-vrp激活(默认为-O2及以上)。)</p>
<p>另见-Walloca-larger-than=byte-size.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>no-vla-larger-than</var></span></kbd></dt>
<dd><p>Disable-Wvla-larger-than=警告。该选项相当于-Wvla-larger-than=‘SIZE_MAX’或更大。</p>
</dd>
<dt><kbd><span class="option">-W<var>vla-parameter</var></span></kbd></dt>
<dd><p>警告涉及种类或形式不一致的变长阵列类型的参数的函数的重新声明,并通过以下警告检测对这类参数的越界访问,如-Warray-bounds.</p>
<p>如果第一个函数声明使用VLA形式,则假定数组中指定的边界是在调用该函数时预期提供的最小元素数和它所访问的最大元素数。未能提供足够大小的参数或访问超过最大数量的元素可能会被诊断出来。</p>
<p>例如，以下重新声明会触发警告，因为第一个允许将任意大小的数组传递给 f ,而第二个指定数组参数必须至少有 n 个元素。此外，使用超过实际 VLA 界限的关联 VLA 界限参数调用 f 也会触发警告。</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>volatile-register-var</var></span></kbd></dt>
<dd><p>如果一个寄存器变量被声明为易失性,则发出警告。易失性修饰符并不能抑制所有可能消除对寄存器变量的读和/或写的优化。这个警告是由-Wall.</p>
</dd>
<dt><kbd><span class="option">-W<var>disabled-optimization</var></span></kbd></dt>
<dd><p>如果请求的优化通过被禁用，则发出警告。此警告通常并不表示您的代码有任何问题；它仅表示GCC的优化器无法有效处理代码。通常，问题在于您的代码太大或太复杂。当优化本身可能花费过多时间时，GCC拒绝优化程序。</p>
</dd>
</dl>
<p>-Wpointer-sign (C and Objective-C only)</p>
<blockquote>
<div><p>对指针参数传递或赋值有不同签名的情况发出警告。这个选项只支持C和Objective-C。它是由-Wall并以-Wpedantic，可以通过以下方式禁用-Wno-pointer-sign.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>stack-protector</var></span></kbd></dt>
<dd><p>该选项仅在以下情况下有效-fstack-protector是活动的。它警告那些没有防止堆栈粉碎的函数。</p>
</dd>
<dt><kbd><span class="option">-W<var>overlength-strings</var></span></kbd></dt>
<dd><p>警告长于C标准中指定的“最小最大”长度的字符串常量。现代的编译器通常允许比标准的最小限制长得多的字符串常量，但是非常可移植的程序应避免使用更长的字符串。</p>
<p>该限制在字符串常量连接之后适用，并且不计算尾随的NUL。在C90中，限制为509个字符；在C99中，它被提高到4095。C++ 98没有指定规范的最小最大值，因此我们无法在C ++中诊断超长字符串。</p>
<p>这个选项是由-Wpedantic，并且可以通过-Wno-overlength-strings.</p>
</dd>
</dl>
<p>-Wunsuffixed-float-constants (C and Objective-C only)</p>
<blockquote>
<div><p>对任何没有后缀的浮动常量发出警告。当与-Wsystem-headers它警告系统头文件中的此类常量。当准备使用 FLOAT_CONST_DECIMAL64 编译代码从十进制浮点扩展到C99 时，这很有用。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>no-lto-type-mismatch</var></span></kbd></dt>
<dd><p>在链接时的优化过程中,不要对来自不同编译单元的全局声明的类型不匹配发出警告。要求-flto启用。默认为启用。</p>
</dd>
</dl>
<p>-Wno-designated-init (C and Objective-C only)</p>
<blockquote>
<div><p>当使用位置初始值设定项来初始化已用 designated_init 属性标记的结构时，禁止显示警告。</p>
</div></blockquote>
</div>
<div class="section" id="id5">
<h2>控制静态分析的选项<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>analyzer</var></span></kbd></dt>
<dd><p>此选项可对程序流进行静态分析，以通过代码寻找“有趣的”过程间路径，并对在其上发现的问题发出警告。</p>
<p>这种分析比其他GCC警告贵得多。</p>
<p>启用该选项可有效地启用以下警告:</p>
</dd>
</dl>
<div class="literal-block-wrapper docutils container" id="id390">
<div class="code-block-caption"><span class="caption-text">可以指定的语言</span><a class="headerlink" href="#id390" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span>-Wanalyzer-double-fclose
<span class="hll">-Wanalyzer-double-free
</span>-Wanalyzer-exposure-through-output-file
-Wanalyzer-file-leak
-Wanalyzer-free-of-non-heap
-Wanalyzer-malloc-leak
-Wanalyzer-mismatching-deallocation
-Wanalyzer-possible-null-argument
-Wanalyzer-possible-null-dereference
-Wanalyzer-null-argument
-Wanalyzer-null-dereference
-Wanalyzer-shift-count-negative
-Wanalyzer-shift-count-overflow
-Wanalyzer-stale-setjmp-buffer
-Wanalyzer-tainted-array-index
-Wanalyzer-unsafe-call-within-signal-handler
-Wanalyzer-use-after-free
-Wanalyzer-use-of-pointer-in-stale-stack-frame
-Wanalyzer-write-to-const
-Wanalyzer-write-to-string-literal

 只有在配置GCC时启用了分析器支持时,这个选项才可用。
</pre></div>
</td></tr></table></div>
</div>
<dl class="option-list">
<dt><kbd><span class="option">-W<var>analyzer-too-complex</var></span></kbd></dt>
<dd><p>If-fanalyzer启用后,分析器使用各种启发式方法试图探索程序中的控制流和数据流,但这些方法可以被足够复杂的代码所击败。</p>
<p>默认情况下,如果代码太复杂,分析器无法完全探索,达到内部极限,分析就会默默停止。在-Wanalyzer-too-complex如果发生这种情况,选项会发出警告。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-analyzer-double-fclose</var></span></kbd></dt>
<dd><p>此警告要求-fanalyzer，这使它成为可能；使用-Wno-analyzer-double-fclose以禁用它。</p>
<p>此诊断警告通过 FILE * 可以多次调用 fclose 的代码的路径。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-analyzer-double-free</var></span></kbd></dt>
<dd><p>此警告要求-fanalyzer，这使它成为可能；使用-Wno-analyzer-double-free以禁用它。</p>
<p>此诊断会警告通过代码的路径，在这些路径中，指针可以多次调用解除分配器，或者是 free ，或者是属性 malloc 引用的解除分配器。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-analyzer-exposure-through-output-file</var></span></kbd></dt>
<dd><p>此警告要求-fanalyzer，这使它成为可能；使用-Wno-analyzer-exposure-through-output-file以禁用它。</p>
<p>该诊断对代码中写入安全敏感值到输出文件的路径发出警告(例如向日志文件写入密码)。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-analyzer-file-leak</var></span></kbd></dt>
<dd><p>此警告要求-fanalyzer，这使它成为可能；使用-Wno-analyzer-file-leak以禁用它。</p>
<p>此诊断警告通过 &lt;stdio.h&gt; FILE * 流对象泄漏的代码的路径。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-analyzer-free-of-non-heap</var></span></kbd></dt>
<dd><p>此警告要求-fanalyzer，这使它成为可能；使用-Wno-analyzer-free-of-non-heap以禁用它。</p>
<p>该诊断警告通过非堆指针（例如，堆栈缓冲区或全局缓冲区）上调用 free 的代码的路径。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-analyzer-malloc-leak</var></span></kbd></dt>
<dd><p>此警告要求-fanalyzer，这使它成为可能；使用-Wno-analyzer-malloc-leak以禁用它。</p>
<p>此诊断会警告通过分配器分配的指针泄漏的代码路径： malloc 或标记为属性 malloc 的函数。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-analyzer-mismatching-deallocation</var></span></kbd></dt>
<dd><p>此警告要求-fanalyzer，这使它成为可能；使用-Wno-analyzer-mismatching-deallocation以禁用它。</p>
<p>此诊断根据用于分配指针值的函数来警告通过代码的路径，在该路径中对指针值调用了错误的解除分配函数。诊断将警告 free 、 scalar delete 和 vector delete[] 之间的不匹配，以及使用属性 malloc 标记为分配器/释放器对的那些。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-analyzer-possible-null-argument</var></span></kbd></dt>
<dd><p>此警告要求-fanalyzer，这使它成为可能；使用-Wno-analyzer-possible-null-argument以禁用它。</p>
<p>该诊断警告通过代码的路径，其中将可能为NULL的值传递给标有 __attribute__((nonnull)) 的函数自变量，要求使用非NULL值。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-analyzer-possible-null-dereference</var></span></kbd></dt>
<dd><p>此警告要求-fanalyzer，这使它成为可能；使用-Wno-analyzer-possible-null-dereference以禁用它。</p>
<p>该诊断对代码中可能存在NULL值的路径发出警告。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-analyzer-null-argument</var></span></kbd></dt>
<dd><p>此警告要求-fanalyzer，这使它成为可能；使用-Wno-analyzer-null-argument以禁用它。</p>
<p>此诊断警告通过代码的路径，其中将已知为NULL的值传递给标有 __attribute__((nonnull)) 的函数自变量，要求使用非NULL值。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-analyzer-null-dereference</var></span></kbd></dt>
<dd><p>此警告要求-fanalyzer，这使它成为可能；使用-Wno-analyzer-null-dereference以禁用它。</p>
<p>该诊断对代码中一个已知为NULL的值被取消引用的路径发出警告。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-analyzer-shift-count-negative</var></span></kbd></dt>
<dd><p>此警告要求-fanalyzer，这使它成为可能；使用-Wno-analyzer-shift-count-negative以禁用它。</p>
<p>这种诊断方法对代码中试图用负数进行移位的路径提出警告。它类似于-Wshift-count-negative在C/C++前端实现了诊断,但是是基于分析程序间的路径来实现的,而不仅仅是解析句法树。然而,分析器并不优先检测这种路径,所以相对于其他警告,假阴性的可能性更大。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-analyzer-shift-count-overflow</var></span></kbd></dt>
<dd><p>此警告要求-fanalyzer，这使它成为可能；使用-Wno-analyzer-shift-count-overflow以禁用它。</p>
<p>此诊断会警告通过代码的路径，其中尝试以大于或等于操作数类型精度的计数进行移位。它类似于-Wshift-count-overflow在C/C++前端实现了诊断,但是是基于分析程序间的路径来实现的,而不仅仅是解析句法树。然而,分析器并不优先检测这种路径,所以相对于其他警告,假阴性的可能性更大。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-analyzer-stale-setjmp-buffer</var></span></kbd></dt>
<dd><p>此警告要求-fanalyzer，这使它成为可能；使用-Wno-analyzer-stale-setjmp-buffer以禁用它。</p>
<p>此诊断警告通过调用 longjmp 的代码中的路径回 jmp_buf 与返回的函数中的 setjmp 调用有关的jmp_buf。</p>
<p>在 jmp_buf 上调用 setjmp 记录倒带位置时，它会记录堆栈帧。当包含 setjmp 调用的函数返回时，堆栈帧无效。尝试通过 longjmp 倒带到它会引用不再存在的堆栈帧，并可能导致崩溃（或更糟糕的是）。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-analyzer-tainted-array-index</var></span></kbd></dt>
<dd><p>该警告要求同时-fanalyzerand-fanalyzer-checker=taint来启用它;使用-Wno-analyzer-tainted-array-index以禁用它。</p>
<p>该诊断警告通过代码的路径，其中可能受到攻击者控制的值被用作数组访问的索引，而没有被清除。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-analyzer-unsafe-call-within-signal-handler</var></span></kbd></dt>
<dd><p>此警告要求-fanalyzer，这使它成为可能；使用-Wno-analyzer-unsafe-call-within-signal-handler以禁用它。</p>
<p>该诊断警告通过代码的路径，其中从信号处理程序中调用了已知为异步信号不安全的函数（例如 fprintf ）。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-analyzer-use-after-free</var></span></kbd></dt>
<dd><p>此警告要求-fanalyzer，这使它成为可能；使用-Wno-analyzer-use-after-free以禁用它。</p>
<p>此诊断会警告在调用解除分配器后使用指针的代码中的路径： free 或属性 malloc 引用的解除分配器。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-analyzer-use-of-pointer-in-stale-stack-frame</var></span></kbd></dt>
<dd><p>此警告要求-fanalyzer，这使它成为可能；使用-Wno-analyzer-use-of-pointer-in-stale-stack-frame以禁用它。</p>
<p>该诊断警告代码中的指针被取消引用的路径,该路径指向堆栈框架中的一个变量。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-analyzer-write-to-const</var></span></kbd></dt>
<dd><p>此警告要求-fanalyzer，这使它成为可能；使用-Wno-analyzer-write-to-const以禁用它。</p>
<p>此诊断警告通过代码的路径，其中分析器检测到尝试通过指向 const 对象的指针进行写入。但是，分析器不会优先检测此类路径，因此相对于其他警告，更可能出现误报。</p>
</dd>
<dt><kbd><span class="option">-W<var>no-analyzer-write-to-string-literal</var></span></kbd></dt>
<dd><p>此警告要求-fanalyzer，这使它成为可能；使用-Wno-analyzer-write-to-string-literal以禁用它。</p>
<p>这种诊断方法对代码中的路径提出警告,在这些路径中,分析器检测到试图通过指针写到字符串字面的行为。然而,分析器并不优先检测这种路径,所以相对于其他警告,假阴性的可能性更大。</p>
</dd>
</dl>
<p>控制勘探的相关参数有:–param analyser-bb-explosion-factor = value,–param analyser-max-enodes-per-program-point = value,–param analyser-max-recursion-depth = value， 和–param analyser-min-snodes-for-call-summary = value.</p>
<p>以下是控制分析仪的选项。</p>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>analyzer-call-summaries</var></span></kbd></dt>
<dd><p>通过计算某些调用的效果来简化程序间的分析,而不是探索从callite到每个可能返回的函数的所有路径。</p>
<p>如果启用,调用摘要只用于有多个调用点,并且足够复杂的函数(按照–param analyser-min-snodes-for-call-summary = value).</p>
</dd>
</dl>
<p>-fanalyzer-checker=name</p>
<blockquote>
<div><p>限制分析器只运行命名的检查器,并启用它。</p>
<p>有些检查器是默认禁用的(即使是在使用了-fanalyzer），例如实施的 taint 检查器-Wanalyzer-tainted-array-index，并且需要启用此选项。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>no-analyzer-feasibility</var></span></kbd></dt>
<dd><p>这个选项是为分析器开发人员准备的。</p>
<p>默认情况下,分析器会验证它发出的每个诊断有一个可行的控制流路径:持有的条件不是相互排斥的。找不到可行路径的诊断被拒绝。这种过滤可以用-fno-analyzer-feasibility，用于调试此代码中的问题。</p>
</dd>
<dt><kbd><span class="option">-f<var>analyzer-fine-grained</var></span></kbd></dt>
<dd><p>这个选项是为分析器开发人员准备的。</p>
<p>在内部，分析仪会构建一个“分解图”，将控制流图与数据流信息结合在一起。</p>
<p>默认情况下,该图中的一条边可以包含一个基本块中多条语句的运行效果。有了这条边,就可以在一个基本块中包含多个语句的运行效果。-fanalyzer-fine-grained，每个语句都有自己的优势。</p>
</dd>
<dt><kbd><span class="option">-f<var>analyzer-show-duplicate-count</var></span></kbd></dt>
<dd><p>这个选项是为分析器开发人员准备的:如果检测到多个诊断程序相互重复,它在报告最佳诊断程序时就会发出一个说明,给出被重复数据删除逻辑抑制的额外诊断程序的数量。</p>
</dd>
<dt><kbd><span class="option">-f<var>no-analyzer-state-merge</var></span></kbd></dt>
<dd><p>这个选项是为分析器开发人员准备的。</p>
<p>默认情况下，分析仪会在构建“爆炸图”时尝试通过在每个程序点处合并足够相似的状态来简化分析。和-fno-analyzer-state-merge这种合并可以被抑制,用于调试状态处理问题。</p>
</dd>
<dt><kbd><span class="option">-f<var>no-analyzer-state-purge</var></span></kbd></dt>
<dd><p>这个选项是为分析器开发人员准备的。</p>
<p>默认情况下，分析器尝试通过清除似乎不再相关的程序点处的状态来简化分析，例如，在函数中稍后无法访问且与泄漏分析不相关的局部值。</p>
<p>With-fno-analyzer-state-purge这种状态的清除可以被抑制,用于调试状态处理问题。</p>
</dd>
<dt><kbd><span class="option">-f<var>analyzer-transitivity</var></span></kbd></dt>
<dd><p>这个选项可以使分析器内的约束条件具有转折性。</p>
</dd>
<dt><kbd><span class="option">-f<var>analyzer-verbose-edges</var></span></kbd></dt>
<dd><p>这个选项是为分析器开发人员准备的。它使诊断路径中的控制流的描述更加详细、低级。</p>
</dd>
<dt><kbd><span class="option">-f<var>analyzer-verbose-state-changes</var></span></kbd></dt>
<dd><p>这个选项是为分析器开发人员准备的。它使诊断路径中与状态机有关的事件描述更加详细、低层次。</p>
</dd>
</dl>
<p>-fanalyzer-verbosity=level</p>
<blockquote>
<div><p>该选项控制分析仪诊断时发出的控制流路径的复杂性。</p>
<p>该 level 可以是一个：</p>
<p>‘0’</p>
<blockquote>
<div><p>在此级别上，将显示过程间调用和返回事件，以及与诊断有关的最相关的状态更改事件。例如，对于双重 free 诊断，将显示两个 free 呼叫。</p>
</div></blockquote>
<p>‘1’</p>
<blockquote>
<div><p>与上一级一样,但也要显示每个功能的入口事件。</p>
</div></blockquote>
<p>‘2’</p>
<blockquote>
<div><p>按照之前的级别，还会显示与控制流相关的事件，这些事件对于触发问题很重要（例如，在有条件的情况下采用“真实路径”）。</p>
<p>这个级别是默认的。</p>
</div></blockquote>
<p>‘3’</p>
<blockquote>
<div><p>与上一级一样,但显示所有控制流事件,而不仅仅是重要事件。</p>
</div></blockquote>
<p>‘4’</p>
<blockquote>
<div><p>这个级别是为分析器开发人员准备的;它增加了各种其他事件,用于调试分析器。</p>
</div></blockquote>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>dump-analyzer</var></span></kbd></dt>
<dd><p>转储分析器正在做什么的内部细节,以达到以下目的file.analyzer.txt。此选项被覆盖-fdump-analyzer-stderr.</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-analyzer-stderr</var></span></kbd></dt>
<dd><p>将分析器正在做的内部细节转储到stderr。这个选项会覆盖-fdump-analyzer.</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-analyzer-callgraph</var></span></kbd></dt>
<dd><p>将适合于用GraphViz查看的调用图的表示形式转储到file.callgraph.dot.</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-analyzer-exploded-graph</var></span></kbd></dt>
<dd><p>将适合用GraphViz查看的“爆炸图”的表示转储到file.eg.dot。节点根据状态机状态进行颜色编码，以强调状态变化。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-analyzer-exploded-nodes</var></span></kbd></dt>
<dd><p>发出诊断信息，以显示“爆炸图”中的节点相对于程序源的位置。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-analyzer-exploded-nodes-2</var></span></kbd></dt>
<dd><p>将“分解图”的文本表示转储到file.eg.txt.</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-analyzer-exploded-nodes-3</var></span></kbd></dt>
<dd><p>将“分解图”的文本表示转储到每个节点的一个转储文件中，以file.eg-id.txt。这通常是大量的转储文件。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-analyzer-feasibility</var></span></kbd></dt>
<dd><p>转储有关分析器搜索可行路径的内部详细信息。详细信息以适合使用 GraphViz 查看的形式写入表单的文件名file.*.fg.dotandfile.*.tg.dot.</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-analyzer-json</var></span></kbd></dt>
<dd><p>将分析器内部结构的压缩JSON表示转储到file.analyzer.json.gz. 准确的格式可能会发生变化。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-analyzer-state-purge</var></span></kbd></dt>
<dd><p>根据-fdump-analyzer-supergraph，转储适合使用GraphViz查看的“上层图”的表示形式，但用在每个节点上将清除什么状态的信息来注释图。该图被写入file.state-purge.dot.</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-analyzer-supergraph</var></span></kbd></dt>
<dd><p>将适用于GraphViz的“上标”的转储表示形式转储到file.supergraph.dot和file.supergraph-eg.dot。这些显示了程序中的所有控制流程图，以及用于调用和返回的过程间边缘。第二个转储包含注释，这些注释显示“爆炸图”中的节点以及与之关联的诊断。</p>
</dd>
</dl>
</div>
<div class="section" id="id6">
<h2>调试程序选项<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>要告诉GCC发出额外的信息供调试器使用,在几乎所有的情况下,您只需要添加-g到你的其他选项。</p>
<p>GCC允许您使用-gwith-O。优化的代码所采用的快捷方式有时可能会令人惊讶：您声明的某些变量可能根本不存在。控制流可能会短暂移动到您未曾想到的地方；某些语句可能无法执行，因为它们计算的是恒定结果或它们的值已在手边；由于某些语句已移出循环，因此它们可能在不同的位置执行。不过，可以调试优化的输出。这使得将优化程序用于可能存在错误的程序变得合理。</p>
<p>如果您没有使用其他优化选项,可以考虑使用-Og（请参阅优化选项）-g。没有-O选项,一些收集对调试有用的信息的编译器通证根本不会运行,所以-Og可能会带来更好的调试体验。</p>
<dl class="option-list">
<dt><kbd><span class="option">-g</span></kbd></dt>
<dd><p>以操作系统的本机格式（stab，COFF，XCOFF或DWARF）产生调试信息。GDB可以使用此调试信息。</p>
<p>在大多数使用stabs格式的系统上。-g使得可以使用只有GDB才能使用的额外调试信息;这种额外的信息使调试在GDB中更好地工作,但可能使其他调试器崩溃或拒绝读取程序。如果你想确定是否生成额外的信息,使用-gstabs+,-gstabs,-gxcoff+,-gxcoff， 或者-gvms（见下文）。</p>
</dd>
<dt><kbd><span class="option">-g<var>gdb</var></span></kbd></dt>
<dd><p>产生调试信息供GDB使用。这意味着要使用可用的最有表现力的格式(DWARF,stabs,或者本地格式,如果这两种格式都不支持的话),包括GDB扩展(如果可能的话)。</p>
</dd>
</dl>
<p>-gdwarf
-gdwarf-version</p>
<blockquote>
<div><p>以 DWARF 格式生成调试信息（如果支持）。 version 的值可以是 2、3、4 或 5；大多数目标的默认版本是 5（VxWorks、TPF 和 Darwin/Mac OS X 除外，它们默认为版本 2，以及 AIX，默认为版本 4）。</p>
<p>需要注意的是,在DWARF第2版中,有些端口需要并总是在unwind表中使用一些不冲突的DWARF 3扩展。</p>
<p>第4版可能需要GDB 7.0 和-fvar-tracking-assignments以获得最大利益。第五版需要GDB 8.0或更高版本。</p>
<p>GCC不再支持DWARF第1版,这与第2版及以后的版本有很大的不同。由于历史原因,其他一些与DWARF相关的选项,如-fno-dwarf2-cfi-asm）在名称中保留对DWARF版本2的引用，但适用于DWARF当前支持的所有版本。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-g<var>stabs</var></span></kbd></dt>
<dd><p>生成stabs格式的调试信息(如果支持的话),不需要GDB扩展。这是大多数BSD系统上DBX使用的格式。在MIPS、Alpha和System V Release 4系统上,这个选项产生的stabs调试输出不被DBX理解。在System V Release 4系统上,这个选项需要使用GNU汇编器。</p>
</dd>
</dl>
<p>-gstabs+</p>
<blockquote>
<div><p>使用只有GNU调试器(GDB)才能理解的GNU扩展,以stabs格式(如果支持的话)生成调试信息。使用这些扩展可能会使其他调试器崩溃或拒绝读取程序。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-g<var>xcoff</var></span></kbd></dt>
<dd><p>生成XCOFF格式的调试信息(如果支持的话)。这是IBM RS/6000系统上DBX调试器使用的格式。</p>
</dd>
</dl>
<p>-gxcoff+</p>
<blockquote>
<div><p>使用只有GNU调试器(GDB)才能理解的GNU扩展,以XCOFF格式(如果支持的话)生成调试信息。使用这些扩展可能会使其他调试器崩溃或拒绝读取程序,并可能导致GNU汇编器(GAS)以外的汇编器出错。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-g<var>vms</var></span></kbd></dt>
<dd><p>以Alpha/VMS调试格式生成调试信息(如果支持的话)。这是Alpha/VMS系统中DEBUG使用的格式。</p>
</dd>
</dl>
<p>-glevel
-ggdblevel
-gstabslevel
-gxcofflevel
-gvmslevel</p>
<blockquote>
<div><p>请求调试信息，并使用 level 指定多少信息。默认级别为2。</p>
<p>0级根本不会产生任何调试信息。因此:-g0negates-g.</p>
<p>级别1产生的信息最少，足以在您不打算调试的程序部分中进行追溯。其中包括函数和外部变量的描述，以及行号表，但没有有关局部变量的信息。</p>
<p>第3级包括额外的信息,如程序中存在的所有宏定义。一些调试器支持宏扩展,当您使用-g3.</p>
<p>如果您使用多个-g选项,无论是否有等级号,最后一个这样的选项都是有效的。</p>
<p>-gdwarf不接受串联的调试级别,以避免与-gdwarf-level。而是使用额外的-glevel选项来改变DWARF的调试级别。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>no-eliminate-unused-debug-symbols</var></span></kbd></dt>
<dd><p>默认情况下,对于没有实际使用的符号,不会产生调试信息。如果想要所有符号的调试信息,请使用此选项。</p>
</dd>
<dt><kbd><span class="option">-f<var>emit-class-debug-always</var></span></kbd></dt>
<dd><p>不要只在一个对象文件中发布一个C++类的调试信息,而是在使用该类的所有对象文件中发布。这个选项应该只用于无法处理GCC通常为类发出调试信息的方式的调试器,因为使用这个选项会使调试信息的大小增加2倍之多。</p>
</dd>
<dt><kbd><span class="option">-f<var>no-merge-debug-strings</var></span></kbd></dt>
<dd><p>指示链接器不要将调试信息中不同对象文件中相同的字符串合并在一起。并非所有汇编器或链接器都支持合并。合并会以增加链接处理时间为代价,减少输出文件中调试信息的大小。合并在默认情况下是启用的。</p>
</dd>
</dl>
<p>-fdebug-prefix-map=old=new</p>
<blockquote>
<div><p>编译目录下的文件时old，记录描述它们的调试信息，就像文件位于目录中一样new来代替。这可以用来在 debug info 中用安装时间路径替换 build-time 路径。它也可以通过使用.为 new 。这样可以提供可重现的构建，它们与位置无关，但是可能需要一个额外的命令来告诉GDB在哪里找到源文件。也可以看看-ffile-prefix-map.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>var-tracking</var></span></kbd></dt>
<dd><p>运行变量跟踪通。它计算代码中每个位置的变量存储位置。然后生成更好的调试信息(如果调试信息格式支持这些信息)。</p>
<p>当使用优化编译时,它是默认启用的(-Os,-O,-O2，…），调试信息（-g），并且调试信息格式支持它。</p>
</dd>
<dt><kbd><span class="option">-f<var>var-tracking-assignments</var></span></kbd></dt>
<dd><p>在编译初期对用户变量的赋值进行注释,并试图在整个编译过程中一直将注释延续到最后,试图在优化的同时改善调试信息。使用-gdwarf-4伴随着它被推荐。</p>
<p>即使在var-tracking被禁用的情况下,它也可以被启用,在这种情况下,注解会被创建和维护,但会在最后被丢弃。默认情况下,这个标志与-fvar-tracking，除非启用了选择性计划。</p>
</dd>
<dt><kbd><span class="option">-g<var>split-dwarf</var></span></kbd></dt>
<dd><p>如果启用了DWARF调试信息,请将尽可能多的调试信息分离到一个单独的输出文件中,扩展名为.dwo。此选项使构建系统避免链接带有调试信息的文件。为了有用，此选项需要能够读取的调试器.dwofiles.</p>
</dd>
</dl>
<p>-gdwarf32
-gdwarf64</p>
<blockquote>
<div><p>如果DWARF调试信息被启用,则-gdwarf32选择32位DWARF格式和-gdwarf64选择64位DWARF格式。缺省是针对具体目标的,在大多数目标上,它是-gdwarf32尽管。32 位 DWARF 格式较小，但不能支持任何 DWARF 调试信息部分中超过 2GiB 的调试信息。64 位 DWARF 格式允许更大的调试信息，并且可能尚未得到所有消费者的良好支持。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-g<var>describe-dies</var></span></kbd></dt>
<dd><p>为一些没有名称属性的DWARF DIE增加描述属性,如人工变量、外部引用和调用站点参数DIE。</p>
</dd>
<dt><kbd><span class="option">-g<var>pubnames</var></span></kbd></dt>
<dd><p>生成DWARF .debug_pubnames 和 .debug_pubtypes 部分。</p>
</dd>
<dt><kbd><span class="option">-g<var>gnu-pubnames</var></span></kbd></dt>
<dd><p>以适合于转换为GDB索引的格式生成 .debug_pubnames 和 .debug_pubtypes 部分。该选项仅对可生成GDB索引版本7的链接器有用。</p>
</dd>
<dt><kbd><span class="option">-f<var>debug-types-section</var></span></kbd></dt>
<dd><p>使用DWARF版本4或更高版本时，可以将类型的 .debug_types 放在其自己的.debug_types部分中，而不必将其作为 .debug_info 部分的一部分。将它们放在单独的comdat部分中会更有效，因为链接器随后可以删除重复项。但是，并非所有DWARF使用者都支持 .debug_types 节，并且在某些对象上 .debug_types 会产生较大的调试信息，而不是较小的调试信息。</p>
</dd>
</dl>
<p>-grecord-gcc-switches
-gno-record-gcc-switches</p>
<blockquote>
<div><p>这个开关使得用于调用编译器的可能影响代码生成的命令行选项被附加到DWARF调试信息中的DW_AT_producer属性中。这些选项是连在一起的,它们之间和编译器版本之间用空格隔开。默认情况下是启用的。另请参阅-frecord-gcc-switches以获得另一种将编译器选项存储到对象文件中的方法。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-g<var>strict-dwarf</var></span></kbd></dt>
<dd><p>不允许使用DWARF标准版本以后的扩展,而不允许用-gdwarf-version。在大多数目标上，允许使用较新的标准版本的无冲突DWARF扩展。</p>
</dd>
<dt><kbd><span class="option">-g<var>no-strict-dwarf</var></span></kbd></dt>
<dd><p>允许使用DWARF标准版本以后的扩展,而不是选择的标准版本。-gdwarf-version.</p>
</dd>
<dt><kbd><span class="option">-g<var>as-loc-support</var></span></kbd></dt>
<dd><p>通知编译器汇编器支持 .loc 指令。然后，可以将它们用于汇编程序以生成DWARF2 +行号表。</p>
<p>这通常是可取的,因为汇编器生成的行号表比编译器自己生成的行号表要紧凑得多。</p>
<p>如果在GCC配置时发现汇编器支持这种指令,那么这个选项将被默认启用。</p>
</dd>
<dt><kbd><span class="option">-g<var>no-as-loc-support</var></span></kbd></dt>
<dd><p>如果要生成DWARF2+行号表,强制GCC在内部生成DWARF2+行号表。</p>
</dd>
<dt><kbd><span class="option">-g<var>as-locview-support</var></span></kbd></dt>
<dd><p>通知编译器汇编器支持 view 分配并重置 .loc 指令中的断言检查。</p>
<p>如果在GCC配置时发现汇编器支持它们,这个选项将被默认启用。</p>
</dd>
<dt><kbd><span class="option">-g<var>no-as-locview-support</var></span></kbd></dt>
<dd><p>强制GCC在内部分配视图编号,如果…。-gvariable-location-views是明确要求的。</p>
</dd>
</dl>
<p>-gcolumn-info
-gno-column-info</p>
<blockquote>
<div><p>在DWARF调试信息中输入位置列信息,而不仅仅是文件和行。该选项默认为启用。</p>
</div></blockquote>
<p>-gstatement-frontiers
-gno-statement-frontiers</p>
<blockquote>
<div><p>此选项使GCC在语句的开头在内部表示中创建标记，并在整个编译过程中将它们大致保持在适当的位置，并使用它们来指导 is_stmt 标记在行号表中的输出。使用优化进行编译时，默认情况下启用此功能（-Os,-O,-O2，…），然后以正常级别输出DWARF 2调试信息。</p>
</div></blockquote>
<p>-gvariable-location-views
-gvariable-location-views=incompat5
-gno-variable-location-views</p>
<blockquote>
<div><p>扩充变量位置列表，其中包含行号表中隐含的渐进视图号。这使调试信息使用者能够检查程序某些点的状态，即使在该点不存在与相应源位置关联的指令也是如此。如果汇编程序不支持行号表中的视图号，则将导致编译器发出行号表，这通常会使它们的紧凑性降低。扩展的行号表和位置列表是完全向后兼容的，因此调试信息使用方可以使用它们，这些用户不知道这些扩展，但是它们也不会从中获得任何好处。</p>
<p>在正常输出DWARF 2调试信息时,只要有汇编器支持,该功能默认为启用。-fvar-tracking-assignments启用,并且-gstrict-dwarf不支持。当汇编器支持不可用时,这可能仍然会被启用,但它会强制GCC输出内部行号表,如果-ginternal-reset-location-views不启用,那肯定会导致位置视图的默默错配。</p>
<p>对于视图编号,有一个建议的表示方法,它与DWARF 5中引入的位置列表格式不向后兼容,可以通过以下方式启用-gvariable-location-views=incompat5。该选项将来可能会删除，仅作为建议的表示形式的参考实现提供。调试信息使用者不希望支持此扩展格式，因此将使其无法使用该格式解码位置列表。</p>
</div></blockquote>
<p>-ginternal-reset-location-views
-gno-internal-reset-location-views</p>
<blockquote>
<div><p>尝试确定可以从位置视图列表中省略的位置视图。这要求编译器具有非常准确的insn长度估计，而这并非总是如此，并且在使用不支持位置视图列表的汇编器时，它可能会导致不正确地生成不正确的视图列表。GNU汇编器会将任何此类错误标记为 view number mismatch 。仅在定义可靠估计功能的端口上启用此功能。</p>
</div></blockquote>
<p>-ginline-points
-gno-inline-points</p>
<blockquote>
<div><p>生成内联函数的扩展调试信息。将位置视图跟踪标记插入到内联的入口点，以便可以计算地址和视图编号并将其输出到调试信息中。可以独立于位置视图启用此功能，在这种情况下，将不会输出视图编号，但只能与语句边界一起启用，并且仅在启用位置视图的情况下默认启用。</p>
</div></blockquote>
<p>-gz[=type]</p>
<blockquote>
<div><p>如果支持，则以DWARF格式生成压缩的调试节。如果未提供 type ，则默认类型取决于所使用的汇编器和链接器的功能。 type 可能是“none’（不压缩调试部分），’zlib’（使用ELF gABI格式的zlib压缩），或’zlib-gnu’（使用传统GNU格式的zlib压缩）。如果链接器不支持编写压缩的调试节，则该选项被拒绝。否则，如果汇编器不支持它们，-gz在制作对象文件时被默默忽略。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>emit-struct-debug-baseonly</var></span></kbd></dt>
<dd><p>只有当编译源文件的基名与定义结构体的文件基名一致时,才会发出类结构体类型的调试信息。</p>
<p>这个选项大大减少了调试信息的大小,但对调试器来说,可能会损失大量的类型信息。参见-femit-struct-debug-reduced以获得一个较低的激进选项。见-femit-struct-debug-detailed以便进行更详细的控制。</p>
<p>该选项仅对DWARF调试输出有效。</p>
</dd>
<dt><kbd><span class="option">-f<var>emit-struct-debug-reduced</var></span></kbd></dt>
<dd><p>只有当编译源文件的基名与定义该类型的文件基名一致时,才会发出类结构类型的调试信息,除非该结构是模板或定义在系统头中。</p>
<p>这个选项大大减小了调试信息的大小,在类型信息上可能会给调试器带来一些损失。参见-femit-struct-debug-baseonly以获得更积极的选择。请看-femit-struct-debug-detailed以便进行更详细的控制。</p>
<p>该选项仅对DWARF调试输出有效。</p>
</dd>
</dl>
<p>-femit-struct-debug-detailed[=spec-list]</p>
<blockquote>
<div><p>指定编译器生成调试信息的类结构类型。目的是为了减少同一程序中不同对象文件之间重复的结构体调试信息。</p>
<p>这个选项是详细版的-femit-struct-debug-reducedand-femit-struct-debug-baseonly，可满足大多数需求。</p>
<p>规范的语法为[‘dir:’|‘ind:’][‘ord:’|‘gen:’](‘any’|‘sys’|‘base’|‘none’)</p>
<p>可选的第一个字将规范限制为直接使用的结构（“dir:’）或间接使用（’ind:’）。当它是变量成员的类型时，直接使用结构类型。间接使用是通过指向结构的指针产生的。也就是说，当使用不完整的结构有效时，使用是间接的。一个例子是结构一直接;结构二*间接。’.</p>
<p>可选的第二个字将规范限制为普通结构（’ord:’）或通用结构（’gen:’）。通用结构解释起来有些复杂。对于C ++，这些是模板类或上述非模板类的非显式专业。其他编程语言具有泛型，但是-femit-struct-debug-detailed目前尚未实施。</p>
<p>第三个单词指定编译器应为其发出调试信息的那些结构的源文件。价值 ‘none’和’any具有正常含义。价值 ‘base’表示出现类型声明的文件的名称基数必须与主编译文件名称的基数相匹配。实际上，这意味着在编译时foo.c，将为该文件中声明的类型生成调试信息，然后foo.h，而不是其他头文件。价值 ‘sys“表示满足”的类型base’或在系统或编译器标头中声明。</p>
<p>您可能需要进行试验,以确定您的应用程序的最佳设置。</p>
<p>默认为-femit-struct-debug-detailed=all.</p>
<p>该选项仅对DWARF调试输出有效。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>no-dwarf2-cfi-asm</var></span></kbd></dt>
<dd><p>将DWARF展开信息作为编译器生成的 .eh_frame 节而不是使用GAS .cfi_* 指令发送。</p>
</dd>
<dt><kbd><span class="option">-f<var>no-eliminate-unused-debug-types</var></span></kbd></dt>
<dd><p>通常情况下,在产生DWARF输出时,GCC会避免为那些在被编译的源文件中根本没有使用的类型产生调试符号输出。有时,让GCC为编译单元中声明的所有类型发出调试信息是很有用的,不管它们是否在该编译单元中被实际使用,例如,如果在调试器中,你想将一个值投向一个在你的程序中没有实际使用(但被声明了)的类型。然而,更多的时候,这会导致大量的空间浪费。</p>
</dd>
</dl>
</div>
<div class="section" id="id7">
<h2>控制优化的选项<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>这些选项控制各种优化。</p>
<p>没有任何优化选项，编译器的目标是降低编译成本并使调试产生预期的结果。语句是独立的：如果您在语句之间使用断点来停止程序，则可以将新值分配给任何变量，或者将程序计数器更改为函数中的任何其他语句，并从源代码中准确获取期望的结果。</p>
<p>开启优化标志使编译器试图以牺牲编译时间和可能的程序调试能力为代价来提高性能和/或代码大小。</p>
<p>编译器根据它对程序的了解进行优化。一次编译多个文件到一个输出文件模式,编译器在编译每个文件时,可以使用从所有文件中获得的信息。</p>
<p>并非所有的优化都直接由标志控制。本节只列出了有标志的优化。</p>
<p>大多数优化在-O0或如果-O级别不在命令行中设置,即使指定了单个优化标志。同样地。-Og抑制了许多优化通道。</p>
<p>根据目标和GCC的配置方式,可能会在每一个-O的水平。您可以用-Q –help =优化程序找出在每个级别启用的确切优化集。有关示例，请参见总体选项。</p>
<p>-O
-O1</p>
<blockquote>
<div><p>优化。优化编译需要更多的时间,对于一个大函数来说,需要更多的内存。</p>
<p>With-O，编译器会尝试减少代码大小和执行时间，而不执行任何占用大量编译时间的优化。</p>
<p>-O开启以下优化标志。</p>
</div></blockquote>
<p>-O2</p>
<blockquote>
<div><blockquote>
<div><p>优化更多。GCC几乎执行了所有支持的优化,不涉及空间速度的折衷。与-O，此选项会增加编译时间和所生成代码的性能。</p>
<p>-O2打开所有由-O。它还打开以下优化标志：</p>
</div></blockquote>
<div class="literal-block-wrapper docutils container" id="id391">
<div class="code-block-caption"><span class="caption-text">可以指定的语言</span><a class="headerlink" href="#id391" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span> 请注意以下警告-fgcse关于调用-O2在使用计算的 gotos 的程序上。
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
<p>-O3</p>
<blockquote>
<div><p>再优化一下。-O3打开所有由-O2并同时开启以下优化标志。</p>
</div></blockquote>
<p>-O0</p>
<blockquote>
<div><p>减少编译时间,使调试产生预期的结果。这是默认的。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-O<var>s</var></span></kbd></dt>
<dd><p>优化尺寸。-Os使所有-O2除了那些经常增加代码大小的优化。</p>
<p>它还使-finline-functions，导致编译器调整代码大小而不是执行速度，并执行旨在减小代码大小的进一步优化。</p>
</dd>
<dt><kbd><span class="option">-O<var>fast</var></span></kbd></dt>
<dd><p>无视严格的标准遵守。-Ofast使所有-O3优化。它还可以实现并非对所有符合标准的程序有效的优化。它开启了-ffast-math,-fallow-store-data-races和Fortran专用的-fstack-arrays，除非-fmax-stack-var-size是指定的,并且-fno-protect-parens.</p>
</dd>
<dt><kbd><span class="option">-O<var>g</var></span></kbd></dt>
<dd><p>优化调试体验。-Og应该是标准编辑-编译-调试周期的优化级别选择,在提供合理的优化级别的同时,保持快速编译和良好的调试体验。它比-O0因为一些收集调试信息的编译器通道在-O0.</p>
<p>Like-O0,-Og完全禁用一些优化通道,这样控制它们的各个选项就不会有任何影响。否则-Og使所有-O1除了那些可能干扰调试的优化标志。</p>
</dd>
</dl>
<p>如果您使用多个-O选项,无论是否有等级号,最后一个这样的选项都是有效的。</p>
<p>形式的选项-fflag指定与机器无关的标志。大多数标志有正和负两种形式;负形式的-ffoois-fno-foo。在下表中，仅列出其中一种形式，即您通常使用的一种形式。您可以通过删除“no-或添加它。</p>
<p>以下是控制特定优化的选项。它们可以通过以下方式激活-O选项或与之相关。在极少数情况下，需要对执行的优化进行“微调”时，可以使用以下标志。</p>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>no-defer-pop</var></span></kbd></dt>
<dd><p>对于必须在函数调用后弹出参数的机器,总是在每个函数返回时立即弹出参数。在级别-O1及以上。-fdefer-pop是默认值;这允许编译器让参数在堆栈上累积数次函数调用,并一次性弹出所有参数。</p>
</dd>
<dt><kbd><span class="option">-f<var>forward-propagate</var></span></kbd></dt>
<dd><p>在RTL上执行前向传播传递。该通证尝试将两条指令合并,并检查结果是否可以简化。如果循环展开是活动的,则执行两次传递,第二次传递安排在循环展开之后。</p>
<p>该选项默认在优化级别启用-O,-O2,-O3,-Os.</p>
</dd>
</dl>
<p>-ffp-contract=style</p>
<blockquote>
<div><p>-ffp-contract=off禁用浮点表达式收缩。-ffp-contract=fast启用浮点表达式收缩功能,例如,如果目标有本地支持的乘加运算,则可以形成融合的乘加运算。-ffp-contract=on如果语言标准允许,可以启用浮点表达式收缩。这一点目前还没有实现,它与-ffp-contract=off.</p>
<p>默认为-ffp-contract=fast.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>omit-frame-pointer</var></span></kbd></dt>
<dd><p>在不需要一个的函数中省略框架指针。这避免了保存，设置和恢复帧指针的指令。在许多目标上，它还提供了一个额外的寄存器。</p>
<p>在某些目标上,这个标志没有效果,因为标准调用序列总是使用帧指针,所以不能省略。</p>
<p>请注意-fno-omit-frame-pointer不能保证所有功能都使用了框架指针。在叶子函数中，几个目标总是省略帧指针。</p>
<p>默认情况下,在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>optimize-sibling-calls</var></span></kbd></dt>
<dd><p>优化同级和尾部递归调用。</p>
<p>启用的级别-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>optimize-strlen</var></span></kbd></dt>
<dd><p>将各种标准C字符串函数（例如 strlen ， strchr 或 strcpy ）及其 _FORTIFY_SOURCE 对应项优化为更快的替代方案。</p>
<p>启用的级别-O2,-O3.</p>
</dd>
<dt><kbd><span class="option">-f<var>no-inline</var></span></kbd></dt>
<dd><p>除了标有 always_inline 属性的功能外，请勿展开任何内联功能。这是未优化时的默认设置。</p>
<p>通过使用 noinline 属性标记单个函数，可以免除它们的内联。</p>
</dd>
<dt><kbd><span class="option">-f<var>inline-small-functions</var></span></kbd></dt>
<dd><p>当函数的主体比预期的函数调用代码小时,将函数集成到它们的调用器中(所以程序的整体大小变小)。编译器会启发式地决定哪些函数足够简单,值得用这种方式集成。这种内联适用于所有函数,即使是那些没有内联声明的函数。</p>
<p>启用的级别-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>indirect-inlining</var></span></kbd></dt>
<dd><p>内联还包括在编译时由于之前的内联而被发现的间接调用。这个选项只有当内联本身由-finline-functionsor-finline-small-functionsoptions.</p>
<p>启用的级别-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>inline-functions</var></span></kbd></dt>
<dd><p>考虑所有函数进行内联,即使它们没有被声明为内联。编译器以启发式的方式决定哪些函数值得以这种方式集成。</p>
<p>如果集成了对给定函数的所有调用，并且将该函数声明为 static ，则该函数通常不会单独以汇编代码的形式输出。</p>
<p>启用的级别-O2,-O3,-Os。也被启用-fprofile-useand-fauto-profile.</p>
</dd>
<dt><kbd><span class="option">-f<var>inline-functions-called-once</var></span></kbd></dt>
<dd><p>考虑所有一次调用的 static 函数以内联到其调用方中，即使它们未标记为 inline 。如果集成了对给定函数的调用，则该函数本身不会作为汇编代码输出。</p>
<p>启用的级别-O1,-O2,-O3and-Os， 但不是-Og.</p>
</dd>
<dt><kbd><span class="option">-f<var>early-inlining</var></span></kbd></dt>
<dd><p>以 always_inline 标记的内联函数以及其主体似乎小于该函数的函数会在执行之前提早调用开销-fprofile-generate工具和真正的内联传递。这样做使得剖析的成本大大降低,而且通常在有大量嵌套包装函数链的程序中内联速度更快。</p>
<p>默认为已启用。</p>
</dd>
<dt><kbd><span class="option">-f<var>ipa-sra</var></span></kbd></dt>
<dd><p>进行程序间的标量替换集合,删除未使用的参数,用值传递的参数替换引用传递的参数。</p>
<p>启用的级别-O2,-O3and-Os.</p>
</dd>
</dl>
<p>-finline-limit=n</p>
<blockquote>
<div><p>默认情况下，GCC限制可以内联的函数的大小。该标志允许对该限制进行粗略控制。 n 是可以内嵌在伪指令数量中的函数的大小。</p>
<p>内嵌实际上是由一些参数控制的,这些参数可以通过使用–param name = value。这-finline-limit=n选项对其中一些参数的设置如下:</p>
<p>max-inline-insns-single</p>
<blockquote>
<div><p>设置为 n / 2。</p>
</div></blockquote>
<p>max-inline-insns-auto</p>
<blockquote>
<div><p>设置为 n / 2。</p>
</div></blockquote>
<p>关于控制内联的各个参数和这些参数的默认值,请看下面的文档。</p>
<p>注意：可能没有任何价值-finline-limit导致默认行为的。</p>
<p>注意：在此特定上下文中，伪指令表示函数大小的抽象度量。它绝不代表汇编指令的数量，因此其确切含义可能会从一个发行版更改为另一个发行版。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>no-keep-inline-dllexport</var></span></kbd></dt>
<dd><p>这是一个更精细的版本。-fkeep-inline-functions，仅适用于使用 dllexport 属性或declspec 声明的函数。请参见声明函数的属性。</p>
</dd>
<dt><kbd><span class="option">-f<var>keep-inline-functions</var></span></kbd></dt>
<dd><p>在C语言中，发出被 inline 声明到目标文件中的 static 函数，即使该函数已内联到其所有调用程序中。此开关不影响使用GNU C90中的 extern inline 扩展名的功能。在C ++中，将任何和所有内联函数发送到目标文件中。</p>
</dd>
<dt><kbd><span class="option">-f<var>keep-static-functions</var></span></kbd></dt>
<dd><p>将 static 函数发送到目标文件中，即使从未使用过该函数也是如此。</p>
</dd>
<dt><kbd><span class="option">-f<var>keep-static-consts</var></span></kbd></dt>
<dd><p>在未启用优化的情况下，即使未引用变量，也要发出声明为 static const 的变量。</p>
<p>GCC默认启用这个选项。如果你想强制编译器检查一个变量是否被引用,不管是否开启了优化,请使用-fno-keep-static-constsoption.</p>
</dd>
<dt><kbd><span class="option">-f<var>merge-constants</var></span></kbd></dt>
<dd><p>试图将相同的常量(字符串常量和浮点常量)合并到不同的编译单元。</p>
<p>如果汇编器和链接器支持,这个选项是优化编译的默认选项。使用-fno-merge-constants来抑制这种行为。</p>
<p>启用的级别-O,-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>merge-all-constants</var></span></kbd></dt>
<dd><p>试图合并相同的常量和相同的变量。</p>
<p>该选项意味着-fmerge-constants。此外-fmerge-constants这考虑了诸如常量初始化的数组或初始化的积分或浮点类型的常量变量。像C或C++这样的语言要求每个变量,包括在递归调用中同一个变量的多个实例,都要有不同的位置,所以使用这个选项会导致不符合要求的行为。</p>
</dd>
<dt><kbd><span class="option">-f<var>modulo-sched</var></span></kbd></dt>
<dd><p>在第一个调度通道之前立即执行摆动模数调度。这个通道查看最内部的循环,并通过重叠不同的迭代来重新排序它们的指令。</p>
</dd>
<dt><kbd><span class="option">-f<var>modulo-sched-allow-regmoves</var></span></kbd></dt>
<dd><p>执行更积极的基于SMS的模数调度,允许寄存器移动。通过设置这个标志,某些反依赖边会被删除,从而触发基于生命范围分析的reg-moves的生成。该选项仅在以下情况下有效-fmodulo-schedenabled.</p>
</dd>
<dt><kbd><span class="option">-f<var>no-branch-count-reg</var></span></kbd></dt>
<dd><p>禁用用于扫描在计数寄存器上使用“减量和转移”指令的机会的优化过程，而不是对减量寄存器进行比较的指令序列，将其与零进行比较，然后根据结果进行转移。该选项仅对支持此类指令的体系结构有意义，这些体系结构包括x86，PowerPC，IA-64和S / 390。请注意-fno-branch-count-reg选项不会从其他优化遍次引入的生成的指令流中删除减量和分支指令。</p>
<p>默认为-fbranch-count-regat-O1及以上,除-Og.</p>
</dd>
<dt><kbd><span class="option">-f<var>no-function-cse</var></span></kbd></dt>
<dd><p>不要将功能地址放在寄存器中；使每个调用常量函数的指令显式包含该函数的地址。</p>
<p>这个选项会导致代码效率降低,但一些改变汇编器输出的奇怪黑客可能会被不使用这个选项时执行的优化所迷惑。</p>
<p>默认为-ffunction-cse</p>
</dd>
<dt><kbd><span class="option">-f<var>no-zero-initialized-in-bss</var></span></kbd></dt>
<dd><p>如果目标支持BSS部分,GCC默认将初始化为0的变量放入BSS。这可以节省生成代码的空间。</p>
<p>此选项关闭了此行为，因为某些程序明确依赖于进入数据部分的变量，例如，以便所生成的可执行文件可以找到该部分的开头和/或基于此进行假设。</p>
<p>默认为-fzero-initialized-in-bss.</p>
</dd>
<dt><kbd><span class="option">-f<var>thread-jumps</var></span></kbd></dt>
<dd><p>执行优化,检查是否跳转分支到了被第一个分支所包含的另一个比较的位置。如果是这样,第一个分支将被重定向到第二个分支的目的地或紧随其后的一个点,这取决于已知条件是真还是假。</p>
<p>启用的级别-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>split-wide-types</var></span></kbd></dt>
<dd><p>当使用占用多个寄存器的类型时（例如在32位系统上为 long long ，请将寄存器分开并独立分配。这通常会为这些类型生成更好的代码，但可能会使调试更加困难。</p>
<p>启用的级别-O,-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>split-wide-types-early</var></span></kbd></dt>
<dd><p>早期完全分割宽类型,而不是很晚。这个选项没有效果,除非-fsplit-wide-types是打开的。</p>
<p>这是某些目标的默认值。</p>
</dd>
<dt><kbd><span class="option">-f<var>cse-follow-jumps</var></span></kbd></dt>
<dd><p>在通用子表达式消除（CSE）中，当任何其他路径都未达到跳转目标时，请扫描跳转指令。例如，当CSE遇到带有 else 子句的 if 语句时，当测试的条件为false时，CSE跟随跳转。</p>
<p>启用的级别-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>cse-skip-blocks</var></span></kbd></dt>
<dd><p>这类似于-fcse-follow-jumps，但会导致CSE跟随有条件跳过块的跳转。当CSE遇到一个没有else子句的简单 if 语句时，-fcse-skip-blocks使CSE跟随 if 主体周围的跳转。</p>
<p>启用的级别-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>rerun-cse-after-loop</var></span></kbd></dt>
<dd><p>进行循环优化后,重新运行普通子表达式消除。</p>
<p>启用的级别-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>gcse</var></span></kbd></dt>
<dd><p>执行全局通用子表达式消除传递。该通证还执行全局常量和复制传播。</p>
<p>注意：当使用计算得到的goto（GCC扩展）编译程序时，如果通过添加以下内容来禁用全局通用子表达式消除过程，则可能会获得更好的运行时性能：-fno-gcse到命令行。</p>
<p>启用的级别-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>gcse-lm</var></span></kbd></dt>
<dd><p>When-fgcse-lm启用,全局共同的子表达式消除试图将仅被存储杀死的负载移入自己。这使得包含负载/存储序列的循环可以改为循环外的负载,以及循环内的复制/存储。</p>
<p>在以下情况下默认为启用-fgcse启用。</p>
</dd>
<dt><kbd><span class="option">-f<var>gcse-sm</var></span></kbd></dt>
<dd><p>When-fgcse-sm启用后,在全局共同的子表达式消除后会运行一个存储运动传递。该传递试图将存储从循环中移出。当与-fgcse-lm，可以将包含加载/存储序列的循环更改为循环之前的加载，并将其更改为循环之后的存储。</p>
<p>不在任何优化级别启用。</p>
</dd>
<dt><kbd><span class="option">-f<var>gcse-las</var></span></kbd></dt>
<dd><p>When-fgcse-las启用后,全局通用的子表达式消除通证会消除存储到同一内存位置后的冗余负载(包括部分冗余和完全冗余)。</p>
<p>不在任何优化级别启用。</p>
</dd>
<dt><kbd><span class="option">-f<var>gcse-after-reload</var></span></kbd></dt>
<dd><p>When-fgcse-after-reload启用,重装后会执行冗余负载消除传递。该通道的目的是清理冗余溢出。</p>
<p>通过以下方式启用-fprofile-useand-fauto-profile.</p>
</dd>
<dt><kbd><span class="option">-f<var>aggressive-loop-optimizations</var></span></kbd></dt>
<dd><p>这个选项告诉循环优化器使用语言约束来计算循环的迭代次数。这假定循环代码不会引起未定义的行为,例如导致有符号的整数溢出或超出边界的数组访问。循环的迭代次数的界限用于指导循环的展开和剥离以及循环退出测试的优化。这个选项默认是启用的。</p>
</dd>
<dt><kbd><span class="option">-f<var>unconstrained-commons</var></span></kbd></dt>
<dd><p>这个选项告诉编译器,在普通块中声明的变量(例如Fortran)以后可以用较长的尾部数组覆盖。这就防止了某些依赖于知道数组边界的优化。</p>
</dd>
<dt><kbd><span class="option">-f<var>crossjumping</var></span></kbd></dt>
<dd><p>进行交叉跳转变换。这种转换统一了等价代码,节省了代码大小。由此产生的代码可能比没有交叉跳跃的代码性能更好,也可能没有。</p>
<p>启用的级别-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>auto-inc-dec</var></span></kbd></dt>
<dd><p>将地址的增量或减量与内存访问相结合。在没有指令支持这个功能的架构上,这个通道总是被跳过。默认情况下,在-O和更高的架构上支持。</p>
</dd>
<dt><kbd><span class="option">-f<var>dce</var></span></kbd></dt>
<dd><p>在RTL上执行死码消除(DCE)。默认在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>dse</var></span></kbd></dt>
<dd><p>在RTL上执行死存储消除(DSE)。默认在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>if-conversion</var></span></kbd></dt>
<dd><p>试图将条件跳转转化为无分支的等价物。这包括使用条件移动、最小、最大、设置标志和abs指令,以及一些可以通过标准算术来实现的技巧。在可以使用条件执行的芯片上,条件执行的使用是由以下控制的-fif-conversion2.</p>
<p>启用的级别-O,-O2,-O3,-Os，但不能-Og.</p>
</dd>
<dt><kbd><span class="option">-f<var>if-conversion2</var></span></kbd></dt>
<dd><p>使用条件执行(在可用的情况下)将条件跳转转化为无分支的等价物。</p>
<p>启用的级别-O,-O2,-O3,-Os，但不能-Og.</p>
</dd>
<dt><kbd><span class="option">-f<var>declone-ctor-dtor</var></span></kbd></dt>
<dd><p>C++ABI要求构造函数和析构函数有多个入口点:一个是基底子对象,一个是完整对象,一个是虚拟析构函数,之后调用运算符删除。对于有虚拟基的层次结构,基子和完整变体是克隆的,也就是两个函数的副本。通过这个选项,基础变体和完整变体被改为调用共同实现的thunks。</p>
<p>通过以下方式启用-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>delete-null-pointer-checks</var></span></kbd></dt>
<dd><p>假设程序不能安全地去引用空指针,并且没有代码或数据元素驻留在零地址。这个选项可以在所有优化级别上实现简单的常量折叠优化。此外,GCC中的其他优化通道使用这个标志来控制全局数据流分析,以消除对空指针的无用检查;这些假设对地址为零的内存访问总是导致陷阱,因此如果一个指针在已经被解除引用后被检查,它就不能是空指针。</p>
<p>但请注意,在某些环境下,这个假设并不正确。使用-fno-delete-null-pointer-checks为依赖该行为的程序禁用该优化。</p>
<p>在大多数目标上,该选项默认为启用。在Nios II ELF上,它默认为关闭。在AVR、CR16和MSP430上,该选项完全被禁用。</p>
<p>使用数据流信息的通道在不同的优化级别上独立启用。</p>
</dd>
<dt><kbd><span class="option">-f<var>devirtualize</var></span></kbd></dt>
<dd><p>试图将对虚拟函数的调用转换为直接调用。这既可以在存储过程中进行,也可以作为间接内联的一部分在过程间进行(-findirect-inlining）和过程间常数传播（-fipa-cp）。在级别启用-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>devirtualize-speculatively</var></span></kbd></dt>
<dd><p>尝试将对虚拟函数的调用转换为投机性直接调用。根据对类型继承图的分析,确定给定调用的可能目标集。如果该集合很小,最好是大小为1,则将调用改为有条件的决定直接调用和间接调用。投机调用可以实现更多的优化,比如内联。当它们在进一步优化后显得无用时,就会被转换回原始形式。</p>
</dd>
<dt><kbd><span class="option">-f<var>devirtualize-at-ltrans</var></span></kbd></dt>
<dd><p>在本地转换模式下运行链路时间优化器时,流化激进的去虚拟化所需的额外信息。该选项可以实现更多的虚拟化,但会显著增加流数据的大小。因此,默认情况下,该选项是禁用的。</p>
</dd>
<dt><kbd><span class="option">-f<var>expensive-optimizations</var></span></kbd></dt>
<dd><p>进行一些相对昂贵的小优化。</p>
<p>启用的级别-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>ree</var></span></kbd></dt>
<dd><p>试图删除多余的扩展指令。这对x86-64架构特别有帮助,因为x86-64架构在写到64位寄存器的下半部分32位后,会隐式地在64位寄存器中进行零扩展。</p>
<p>在Alpha,AArch64和x86级别启用。-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>no-lifetime-dse</var></span></kbd></dt>
<dd><p>在C++中,对象的值只受其生命期内的变化影响:当构造函数开始时,对象的值是不确定的,当对象被销毁时,对象生命期内的任何变化都是死的。通常死存储消除会利用这一点;如果你的代码依赖于对象存储的值在对象的生命期之后持久存在,你可以使用这个标志来禁用这个优化。要在构造函数启动前保留存储(例如,因为你的操作符new清除了对象存储),但在destructor之后仍然将对象视为死存储,你可以使用-flifetime-dse=1。可以使用以下命令显式选择默认行为-flifetime-dse=2.-flifetime-dse=0相当于-fno-lifetime-dse.</p>
</dd>
<dt><kbd><span class="option">-f<var>live-range-shrinkage</var></span></kbd></dt>
<dd><p>试图通过收缩寄存器活区来降低寄存器压力。这对具有小型或中等规模寄存器集的快速处理器很有帮助。</p>
</dd>
</dl>
<p>-fira-algorithm=algorithm</p>
<blockquote>
<div><p>对集成寄存器分配器使用指定的着色算法。该 algorithm 参数可以是“priority’，它指定Chow的优先着色，或’CB’，用于指定Chaitin-Briggs着色。Chaitin-Briggs着色并非针对所有体系结构都实现，但是对于支持该着色的目标，它是默认设置，因为它会生成更好的代码。</p>
</div></blockquote>
<p>-fira-region=region</p>
<blockquote>
<div><p>将指定的区域用于集成寄存器分配器。该 region 参数应该是以下情况之一：</p>
<p>‘all’</p>
<blockquote>
<div><p>将所有循环作为寄存器分配区域。这对于小的和/或不规则的寄存器集的机器来说,可以得到最好的结果。</p>
</div></blockquote>
<p>‘mixed’</p>
<blockquote>
<div><p>使用除寄存器压力小的循环外的所有循环作为区域。这个值通常在大多数情况下为大多数架构提供了最好的结果,并且在编译速度优化时默认启用 (-O,-O2，…）。</p>
</div></blockquote>
<p>‘one’</p>
<blockquote>
<div><p>将所有函数作为单一区域使用。这通常会导致最小的代码大小,并且默认为-Osor-O0.</p>
</div></blockquote>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>ira-hoist-pressure</var></span></kbd></dt>
<dd><p>使用 IRA 在代码提升通道中评估寄存器压力,以决定提升表达式。这个选项通常会导致更小的代码,但它会拖慢编译器的速度。</p>
<p>该选项在以下级别启用-Os对所有目标。</p>
</dd>
<dt><kbd><span class="option">-f<var>ira-loop-pressure</var></span></kbd></dt>
<dd><p>使用IRA评估循环中的寄存器压力，以决定是否移动循环不变式。此选项通常会导致在具有大寄存器文件（&gt; = 32个寄存器）的机器上生成更快，更小的代码，但是它可能会使编译器变慢。</p>
<p>该选项在以下级别启用-O3对于一些目标。</p>
</dd>
<dt><kbd><span class="option">-f<var>no-ira-share-save-slots</var></span></kbd></dt>
<dd><p>禁用共享用于保存调用使用的硬寄存器的堆栈槽。每个硬寄存器都有一个单独的堆栈槽,因此函数的堆栈框架更大。</p>
</dd>
<dt><kbd><span class="option">-f<var>no-ira-share-spill-slots</var></span></kbd></dt>
<dd><p>禁用为伪寄存器分配的栈槽的共享。每个没有得到硬寄存器的伪寄存器都会得到一个单独的堆栈槽,因此函数堆栈帧较大。</p>
</dd>
<dt><kbd><span class="option">-f<var>lra-remat</var></span></kbd></dt>
<dd><p>在LRA中启用对CFG敏感的再材料化。如果有利可图,LRA会尝试重新材料化(重新计算),而不是加载溢出的伪值。</p>
<p>启用的级别-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>delayed-branch</var></span></kbd></dt>
<dd><p>如果目标机器支持,则尝试重新排序指令,以利用延迟分支指令后可用的指令槽。</p>
<p>启用的级别-O,-O2,-O3,-Os，但不在-Og.</p>
</dd>
<dt><kbd><span class="option">-f<var>schedule-insns</var></span></kbd></dt>
<dd><p>如果目标机器支持,则尝试重新排序指令,以消除由于所需数据不可用而导致的执行停滞。这有助于那些浮点或内存加载指令速度较慢的机器,因为它允许发出其他指令,直到需要加载或浮点指令的结果。</p>
<p>启用的级别-O2,-O3.</p>
</dd>
<dt><kbd><span class="option">-f<var>schedule-insns2</var></span></kbd></dt>
<dd><p>类似于-fschedule-insns，但在完成寄存器分配后，要求通过另一次指令调度。这在寄存器数量相对较少且内存加载指令占用一个以上周期的机器上尤其有用。</p>
<p>启用的级别-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>no-sched-interblock</var></span></kbd></dt>
<dd><p>禁用跨基本块的指令调度,通常在寄存器分配前进行调度时启用,即用-fschedule-insns或者-O2或更高。</p>
</dd>
<dt><kbd><span class="option">-f<var>no-sched-spec</var></span></kbd></dt>
<dd><p>禁用非负载指令的推测运动,通常在寄存器分配前调度时启用,即用-fschedule-insns或者-O2或更高。</p>
</dd>
<dt><kbd><span class="option">-f<var>sched-pressure</var></span></kbd></dt>
<dd><p>在寄存器分配前启用寄存器压力敏感的insn调度。只有在启用了寄存器分配前的调度时,这才是有意义的,即在使用-fschedule-insns或者-O2或更高。使用该选项可以改善生成的代码,并通过防止寄存器压力增加超过可用的硬寄存器数量和随后的寄存器分配溢出来减小代码大小。</p>
</dd>
<dt><kbd><span class="option">-f<var>sched-spec-load</var></span></kbd></dt>
<dd><p>允许一些加载指令的投机运动。这只有在寄存器分配前进行调度时才有意义,即用-fschedule-insns或者-O2或更高。</p>
</dd>
<dt><kbd><span class="option">-f<var>sched-spec-load-dangerous</var></span></kbd></dt>
<dd><p>允许更多负载指令的投机运动。这只有在寄存器分配前进行调度时才有意义,即用-fschedule-insns或者-O2或更高。</p>
</dd>
</dl>
<p>-fsched-stalled-insns
-fsched-stalled-insns=n</p>
<blockquote>
<div><p>定义在第二次调度过程中,有多少insn(如果有的话)可以从停滞的insn队列中提前移动到准备好的列表中。-fno-sched-stalled-insns意味着没有过早地移动ins。-fsched-stalled-insns=0意味着对排队的ins可以提前移动的数量没有限制。-fsched-stalled-insns无值等于-fsched-stalled-insns=1.</p>
</div></blockquote>
<p>-fsched-stalled-insns-dep
-fsched-stalled-insns-dep=n</p>
<blockquote>
<div><p>定义有多少个insn组(周期)会被检查,以确定是否依赖于停滞的insn,该停滞的insn是过早从停滞的insn队列中移除的候选者。这只有在第二个调度通道中才会产生影响,并且只有在以下情况下才会产生影响-fsched-stalled-insns是用。-fno-sched-stalled-insns-dep相当于-fsched-stalled-insns-dep=0.-fsched-stalled-insns-dep无值等于-fsched-stalled-insns-dep=1.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>sched2-use-superblocks</var></span></kbd></dt>
<dd><p>在寄存器分配后进行调度时,使用超级块调度。这样可以跨越基本块边界进行运动,从而实现更快的调度。这个选项是试验性的,因为并不是所有GCC使用的机器描述都对CPU进行了足够紧密的建模,以避免算法的结果不可靠。</p>
<p>这只有在寄存器分配后进行调度时才有意义,即用-fschedule-insns2或者-O2或更高。</p>
</dd>
<dt><kbd><span class="option">-f<var>sched-group-heuristic</var></span></kbd></dt>
<dd><p>启用调度器中的组启发式。这个启发式方法有利于属于调度组的指令。当调度被启用时,即在使用-fschedule-insnsor-fschedule-insns2或者-O2或更高。</p>
</dd>
<dt><kbd><span class="option">-f<var>sched-critical-path-heuristic</var></span></kbd></dt>
<dd><p>在调度器中启用关键路径启发式。这个启发式方法倾向于关键路径上的指令。当启用调度时,即使用-fschedule-insnsor-fschedule-insns2或者-O2或更高。</p>
</dd>
<dt><kbd><span class="option">-f<var>sched-spec-insn-heuristic</var></span></kbd></dt>
<dd><p>启用调度器中的推测性指令启发式。这个启发式指令倾向于依赖性更弱的推测性指令。当调度被启用时,即在使用-fschedule-insnsor-fschedule-insns2或者-O2或更高。</p>
</dd>
<dt><kbd><span class="option">-f<var>sched-rank-heuristic</var></span></kbd></dt>
<dd><p>启用调度器中的等级启发式。这个启发式倾向于属于基本块的指令,其大小或频率更高。当启用调度时,默认启用该功能,即使用-fschedule-insnsor-fschedule-insns2或者-O2或更高。</p>
</dd>
<dt><kbd><span class="option">-f<var>sched-last-insn-heuristic</var></span></kbd></dt>
<dd><p>启用调度器中的最后一条指令启发式。这个启发式方法倾向于对最后一条调度指令依赖性较小的指令。当启用了调度时,即使用了-fschedule-insnsor-fschedule-insns2或者-O2或更高。</p>
</dd>
<dt><kbd><span class="option">-f<var>sched-dep-count-heuristic</var></span></kbd></dt>
<dd><p>启用调度器中的依赖数量启发式。这个启发式方法倾向于有更多指令依赖的指令。当启用了调度时,即使用了-fschedule-insnsor-fschedule-insns2或者-O2或更高。</p>
</dd>
<dt><kbd><span class="option">-f<var>reschedule-modulo-scheduled-loops</var></span></kbd></dt>
<dd><p>模数调度是在传统调度之前进行的。如果一个循环是模数调度,那么以后的调度可能会改变它的计划。使用这个选项可以控制这种行为。</p>
</dd>
<dt><kbd><span class="option">-f<var>selective-scheduling</var></span></kbd></dt>
<dd><p>使用选择性调度算法调度指令。选择性调度代替第一道调度程序运行。</p>
</dd>
<dt><kbd><span class="option">-f<var>selective-scheduling2</var></span></kbd></dt>
<dd><p>使用选择性调度算法调度指令。选择性调度代替第二道调度程序运行。</p>
</dd>
<dt><kbd><span class="option">-f<var>sel-sched-pipelining</var></span></kbd></dt>
<dd><p>在选择性调度期间,启用最内部循环的软件流水线。这个选项没有效果,除非有以下情况之一-fselective-schedulingor-fselective-scheduling2是打开的。</p>
</dd>
<dt><kbd><span class="option">-f<var>sel-sched-pipelining-outer-loops</var></span></kbd></dt>
<dd><p>当在选择性调度期间对循环进行流水线处理时,也会对外循环进行流水线处理。这个选项没有效果,除非-fsel-sched-pipelining是打开的。</p>
</dd>
<dt><kbd><span class="option">-f<var>semantic-interposition</var></span></kbd></dt>
<dd><p>有些对象格式,如ELF,允许动态链接器对符号进行穿插。这意味着对于从DSO导出的符号,编译器不能在预期有关函数或变量可能发生变化的情况下进行程序间传播、内联和其他优化。虽然这个功能很有用,例如,由调试实现重写内存分配函数,但从代码质量的角度来看,这个功能是昂贵的。有了-fno-semantic-interposition编译器假定,如果函数发生互置,覆盖函数将具有完全相同的语义(和副作用)。同样,如果变量发生了互置,变量的构造函数也将是相同的。该标志对于显式声明为内联的函数(这里绝不允许互置改变语义)和显式声明为弱的符号没有影响。</p>
</dd>
<dt><kbd><span class="option">-f<var>shrink-wrap</var></span></kbd></dt>
<dd><p>只在需要函数序言的部分之前,而不是在函数的顶部,才会发出函数序言。这个标志默认在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>shrink-wrap-separate</var></span></kbd></dt>
<dd><p>分别收缩包装序幕和尾声的各个部分,以便这些部分只在需要时才执行。这个选项默认是打开的,但没有任何效果,除非-fshrink-wrap也被打开,目标也支持。</p>
</dd>
<dt><kbd><span class="option">-f<var>caller-saves</var></span></kbd></dt>
<dd><p>通过发出额外的指令来保存和恢复这些调用周围的寄存器,从而实现对被函数调用占用的寄存器的值分配。只有当这种分配似乎能带来更好的代码时,才会进行这种分配。</p>
<p>这个选项在某些机器上总是默认启用,通常是那些没有调用保留寄存器的机器。</p>
<p>启用的级别-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>combine-stack-adjustments</var></span></kbd></dt>
<dd><p>追踪堆栈调整(推送和弹出)和堆栈内存引用,然后尝试找到结合它们的方法。</p>
<p>默认情况下,在-O1及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>ipa-ra</var></span></kbd></dt>
<dd><p>如果这些寄存器不被任何被调用的函数使用,则使用调用者保存寄存器进行分配。在这种情况下,没有必要在调用时保存和恢复它们。只有当被调用的函数与当前函数属于同一个编译单元,并且它们在函数之前被编译时,才可以这样做。</p>
<p>启用的级别-O2,-O3,-Os，但是如果将对生成的代码进行性能分析（-p， 或者-pg），或者无法确切了解被调用方的注册使用情况（这种情况发生在未公开RTL中的序言和结语的目标上）。</p>
</dd>
<dt><kbd><span class="option">-f<var>conserve-stack</var></span></kbd></dt>
<dd><p>试图尽量减少堆栈的使用。编译器试图使用更少的堆栈空间,即使这会使程序更慢。这个选项意味着将large-stack-frame参数为100,并将large-stack-frame-growth参数为400。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-reassoc</var></span></kbd></dt>
<dd><p>在树上执行重新关联。这个标志默认在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>code-hoisting</var></span></kbd></dt>
<dd><p>执行代码提升。代码提升试图将所有路径上执行的表达式的评估尽可能早地移到函数出口。这对于优化代码大小特别有用,但也有助于提高代码速度。这个标志默认在-O2及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-pre</var></span></kbd></dt>
<dd><p>在树上执行部分冗余消除(PRE)。这个标志默认在-O2and-O3.</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-partial-pre</var></span></kbd></dt>
<dd><p>使部分冗余消除(PRE)更加积极。该标志默认在-O3.</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-forwprop</var></span></kbd></dt>
<dd><p>在树上执行前向传播。这个标志默认在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-fre</var></span></kbd></dt>
<dd><p>对树进行全冗余消除(FRE)。FRE和PRE的区别在于,FRE只考虑在所有通往冗余计算的路径上计算的表达式。这种分析比PRE快,尽管它暴露的冗余更少。这个标志默认在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-phiprop</var></span></kbd></dt>
<dd><p>从树上的条件指针执行负载提升。这个通道默认在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>hoist-adjacent-loads</var></span></kbd></dt>
<dd><p>如果负载来自同一结构中的相邻位置,并且目标架构有条件移动指令,则从if-then-else的两个分支中随机提升负载。这个标志默认在-O2及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-copy-prop</var></span></kbd></dt>
<dd><p>对树进行复制传播。这个传递可以消除不必要的复制操作。这个标志默认在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>ipa-pure-const</var></span></kbd></dt>
<dd><p>发现哪些函数是纯函数或常量函数。默认在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>ipa-reference</var></span></kbd></dt>
<dd><p>发现哪些静态变量不逃逸编译单元。默认在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>ipa-reference-addressable</var></span></kbd></dt>
<dd><p>发现只读、只写和不可寻址的静态变量。默认在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>ipa-stack-alignment</var></span></kbd></dt>
<dd><p>尽可能减少调用站点的堆栈对齐。默认情况下已启用。</p>
</dd>
<dt><kbd><span class="option">-f<var>ipa-pta</var></span></kbd></dt>
<dd><p>执行程序间指针分析和程序间修改和引用分析。在大型编译单元上,该选项可能会导致内存和编译时的过度使用。在任何优化级别上,默认情况下都不启用该选项。</p>
</dd>
<dt><kbd><span class="option">-f<var>ipa-profile</var></span></kbd></dt>
<dd><p>执行过程间轮廓传播。仅从冷函数调用的函数标记为冷。还可以识别一次执行的函数（例如 cold ， noreturn ，static构造函数或析构函数）。然后对冷函数和循环执行的函数的较少部分进行大小优化。默认情况下启用-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>ipa-modref</var></span></kbd></dt>
<dd><p>进行程序间mod/ref分析。这种优化分析了函数的副作用(被修改或引用的内存位置),并使整个函数调用边界得到更好的优化。这个标志在默认情况下被启用,在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>ipa-cp</var></span></kbd></dt>
<dd><p>进行程序间常量传播。该优化分析程序以确定何时传递给函数的值是常量,然后进行相应的优化。如果应用程序有常量传递给函数,这种优化可以大幅提高性能。该标志默认在-O2,-Osand-O3。也可以通过启用-fprofile-useand-fauto-profile.</p>
</dd>
<dt><kbd><span class="option">-f<var>ipa-cp-clone</var></span></kbd></dt>
<dd><p>执行函数克隆,使程序间常数传播更强。启用后,当外部可见的函数可以用常量参数调用时,程序间常量传播会执行函数克隆。由于该优化可以创建多个函数的副本,因此可能会显著增加代码大小(见–param ipa-cp-unit-growth=value）。默认情况下，此标志处于启用状态-O3。也可以通过启用-fprofile-useand-fauto-profile.</p>
</dd>
<dt><kbd><span class="option">-f<var>ipa-bit-cp</var></span></kbd></dt>
<dd><p>启用时,执行程序间位常数传播。该标志默认在-O2并以-fprofile-useand-fauto-profile。它要求-fipa-cp启用。</p>
</dd>
<dt><kbd><span class="option">-f<var>ipa-vrp</var></span></kbd></dt>
<dd><p>启用时,执行程序间的值范围传播。该标志默认在-O2。它要求-fipa-cp启用。</p>
</dd>
<dt><kbd><span class="option">-f<var>ipa-icf</var></span></kbd></dt>
<dd><p>对函数和只读变量进行相同代码折叠。该优化减少了代码大小,并且可能会通过用不同名称的等价函数替换函数来扰乱解卷堆栈。启用链接时间优化后,该优化更有效。</p>
<p>尽管其行为类似于Gold Linker的ICF优化，但GCC ICF的工作水平不同，因此优化也不相同-有些等效项仅由GCC查找，而等效项仅由Gold查找。</p>
<p>该标志默认在-O2and-Os.</p>
</dd>
</dl>
<p>-flive-patching=level</p>
<blockquote>
<div><p>控制GCC的优化以产生适合实时修补的输出。</p>
<p>如果编译器的优化使用函数的主体或从其主体中提取的信息来优化/更改另一个函数，则后者称为前者的受影响函数。如果对功能进行了修补，则其受影响的功能也应进行修补。</p>
<p>受影响的功能由编译器的过程间优化确定。例如，在将函数内联到其调用方，克隆函数并更改其调用方以调用此新克隆，或提取函数的纯净度/常数信息以优化其直接或间接调用方时，调用方会受到影响。</p>
<p>通常情况下,启用的IPA优化越多,每个函数受影响的函数数量就越多。为了控制受影响函数的数量和更容易计算受影响函数的列表,可以在两个不同的层次上部分启用IPA优化。</p>
<p>该 level 参数应该是以下情况之一：</p>
<p>‘inline-clone’</p>
<blockquote>
<div><p>仅启用内联和克隆优化，包括内联，克隆，聚合过程间标量替换和部分内联。结果，在修补功能时，其所有调用者及其克隆的调用者都会受到影响，因此也需要进行修补。</p>
<p>-flive-patching=inline-clone禁用以下优化标志。</p>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>whole-program</var></span></kbd></dt>
<dd><dl class="option-list">
<dt><kbd><span class="option">-f<var>ipa-pta</var></span></kbd></dt>
<dd><dl class="option-list">
<dt><kbd><span class="option">-f<var>ipa-reference</var></span></kbd></dt>
<dd><p>-fipa-ra</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt><kbd><span class="option">-f<var>ipa-icf</var></span></kbd></dt>
<dd><dl class="option-list">
<dt><kbd><span class="option">-f<var>ipa-icf-functions</var></span></kbd></dt>
<dd><p>-fipa-icf-variables</p>
</dd>
</dl>
</dd>
<dt><kbd><span class="option">-f<var>ipa-bit-cp</var></span></kbd></dt>
<dd><dl class="option-list">
<dt><kbd><span class="option">-f<var>ipa-vrp</var></span></kbd></dt>
<dd><dl class="option-list">
<dt><kbd><span class="option">-f<var>ipa-pure-const</var></span></kbd></dt>
<dd><p>-fipa-reference-addressable</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>-fipa-stack-alignment -fipa-modref</p>
</div></blockquote>
<p>‘inline-only-static’</p>
<blockquote>
<div><p>只启用静态函数的内联。因此,当对静态函数打补丁时,它的所有调用者都会受到影响,因此也需要打补丁。</p>
<p>除了所有的旗帜之外-flive-patching=inline-clonedisables,-flive-patching=inline-only-static禁用以下额外的优化标志。</p>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>ipa-cp-clone</var></span></kbd></dt>
<dd><dl class="option-list">
<dt><kbd><span class="option">-f<var>ipa-sra</var></span></kbd></dt>
<dd><dl class="option-list">
<dt><kbd><span class="option">-f<var>partial-inlining</var></span></kbd></dt>
<dd><p>-fipa-cp</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>When-flive-patching指定为没有任何值，默认值为 inline-clone 。</p>
<p>该标志默认为禁用。</p>
<p>请注意-flive-patching不支持链接时间优化(-flto).</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>isolate-erroneous-paths-dereference</var></span></kbd></dt>
<dd><p>侦测由于去引用空指针而触发错误或未定义行为的路径。将这些路径从主控制流中分离出来,并将具有错误或未定义行为的语句变成一个陷阱。这个标志默认在-O2和更高,取决于-fdelete-null-pointer-checks也正在启用。</p>
</dd>
<dt><kbd><span class="option">-f<var>isolate-erroneous-paths-attribute</var></span></kbd></dt>
<dd><p>检测由于 returns_nonnull 或 nonnull 属性禁止使用空值而导致触发错误或未定义行为的路径。从主控制流中隔离这些路径，并将具有错误或未定义行为的语句转换为陷阱。目前尚未启用，但可以通过以下方式启用-O2在未来。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-sink</var></span></kbd></dt>
<dd><p>在树上执行正向存储运动。这个标志默认在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-bit-ccp</var></span></kbd></dt>
<dd><p>在树上执行稀疏的条件位常数传播,传播指针对齐信息。这个通道只对局部标量变量进行操作,默认在-O1及以上,除-Og。它要求-ftree-ccp启用。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-ccp</var></span></kbd></dt>
<dd><p>在树上执行稀疏的条件常量传播(CCP)。这个通道只对局部标量变量进行操作,默认在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>ssa-backprop</var></span></kbd></dt>
<dd><p>为了简化定义,在定义链上传播关于一个值的使用信息。例如,如果一个值的符号从来都不重要,那么这个传递就会剥离符号操作。该标志默认在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>ssa-phiopt</var></span></kbd></dt>
<dd><p>在SSA PHI节点上执行模式匹配以优化条件代码。该通道默认在-O1及以上,除-Og.</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-switch-conversion</var></span></kbd></dt>
<dd><p>将开关中的简单初始化转换为标量数组的初始化。这个标志默认在-O2及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-tail-merge</var></span></kbd></dt>
<dd><p>寻找相同的代码序列。找到后,用跳转代替一个。这种优化被称为尾部合并或交叉跳转。这个标志默认在-O2及以上。在这个通道中的编译时间可以通过使用max-tail-merge-comparisons参数和max-tail-merge-iterationsparameter.</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-dce</var></span></kbd></dt>
<dd><p>在树上执行死码消除(DCE)。这个标志默认在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-builtin-call-dce</var></span></kbd></dt>
<dd><p>对可能设置 errno 但没有副作用的内置函数的调用执行条件死代码消除（DCE）。默认情况下，此标志处于启用状态-O2和更高,如果-Os也没有规定。</p>
</dd>
<dt><kbd><span class="option">-f<var>finite-loops</var></span></kbd></dt>
<dd><p>假设一个有退出的循环最终会把退出,而不是无限循环。这使得编译器可以删除原本没有副作用的循环,而不考虑最终的无尽循环。</p>
<p>该选项默认在-O2对于C++来说,-std=c++11或更高。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-dominator-opts</var></span></kbd></dt>
<dd><p>基于主宰树遍历执行各种简单的标量清理(常量/副本传播、冗余消除、范围传播和表达式简化)。这也会执行跳线程(以减少跳转到跳转)。这个标志默认在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-dse</var></span></kbd></dt>
<dd><p>对树进行死存储消除(DSE)。死存储是指进入内存位置的存储,后来被另一个存储覆盖,没有任何中间的负载。在这种情况下,先前的存储可以被删除。默认情况下,这个标志在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-ch</var></span></kbd></dt>
<dd><p>对树进行循环头复制。这是有益的,因为它增加了代码运动优化的有效性。它还节省了一次跳转。这个标志默认在-O及以上。它不能用于-Os，因为它通常会增加代码大小。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-loop-optimize</var></span></kbd></dt>
<dd><p>对树进行循环优化。这个标志默认在-O及以上。</p>
</dd>
</dl>
<p>-ftree-loop-linear
-floop-strip-mine
-floop-block</p>
<blockquote>
<div><p>进行循环嵌套优化。同-floop-nest-optimize。要使用此代码转换，必须将GCC配置为–with-isl以实现石墨循环转换基础设施。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>graphite-identity</var></span></kbd></dt>
<dd><p>启用石墨的身份转换。对于每一个SCoP,我们都会生成多面体表示并将其转换回gimple。使用-fgraphite-identity我们可以检查GIMPLE-&gt; GRAPHITE-&gt; GIMPLE转换的成本或收益。代码生成器isl还会执行一些最小的优化，例如索引拆分和循环中死代码的消除。</p>
</dd>
<dt><kbd><span class="option">-f<var>loop-nest-optimize</var></span></kbd></dt>
<dd><p>启用基于isl的循环嵌套优化器。这是一个基于Pluto优化算法的通用循环嵌套优化器。它计算一个针对数据定位和并行性优化的循环结构。这个选项是试验性的。</p>
</dd>
<dt><kbd><span class="option">-f<var>loop-parallelize-all</var></span></kbd></dt>
<dd><p>使用 Graphite 数据依赖性分析来确定可以并行化的循环。在不检查并行化循环是否有利可图的情况下,对所有可以分析的循环进行并行化,以不包含循环携带的依赖性。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-coalesce-vars</var></span></kbd></dt>
<dd><p>在将程序从SSA表示法中转换出来时,尝试通过凝聚不同用户定义变量的版本来减少复制,而不仅仅是编译器的临时变量。这可能会严重限制调试一个以-fno-var-tracking-assignments。在否定形式下，此标志防止SSA合并用户变量。如果启用了优化，则默认情况下会启用此选项，否则不会执行任何操作。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-loop-if-convert</var></span></kbd></dt>
<dd><p>试图将最内部循环中的条件跳转转化为无分支的等价物。这样做的目的是为了去除最内部循环中的控制流,以提高矢量化传递处理这些循环的能力。如果启用了向量化,则默认启用该功能。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-loop-distribution</var></span></kbd></dt>
<dd><p>执行循环分布。这个标志可以提高大循环体的缓存性能,并允许进行进一步的循环优化,如并行化或矢量化。例如,循环的</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>tree-loop-distribute-patterns</var></span></kbd></dt>
<dd><p>对可以通过调用库生成的代码的模式进行循环分配。这个标志默认在-O2及以上,并通过-fprofile-useand-fauto-profile.</p>
<p>这个通证分配初始化循环,并产生对memset zero的调用。例如,循环</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>loop-interchange</var></span></kbd></dt>
<dd><p>在石墨之外执行循环互换。这个标志可以提高循环嵌套的缓存性能,并允许进行进一步的循环优化,比如矢量化。例如,循环</p>
</dd>
</dl>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>loop-unroll-and-jam</var></span></kbd></dt>
<dd><p>在可行的循环上应用展开和卡位变换。在一个循环嵌套中,这将外循环按一定的系数展开,并将产生的多个内循环融合。这个标志默认在-O3。也可以通过启用-fprofile-useand-fauto-profile.</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-loop-im</var></span></kbd></dt>
<dd><p>在树上执行循环不变性运动。这个通道只移动那些在RTL级别难以处理的不变量(函数调用、扩展到非平凡的ins序列的操作)。有了-funswitch-loops它还将条件不变的操作数移出了循环,这样我们在循环解开关中就可以只用琐碎的不变性分析。通证还包括存储运动。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-loop-ivcanon</var></span></kbd></dt>
<dd><p>在确定迭代次数需要复杂分析的循环中,为迭代次数创建一个规范的计数器。之后的优化可以很容易地确定迭代次数。特别是在展开循环时有用。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-scev-cprop</var></span></kbd></dt>
<dd><p>进行终值替换。如果一个变量在循环中被修改,以致于它退出循环时的值只能用它的初始值和循环迭代次数来确定,那么用这样的计算来替换最终值的使用,只要它足够便宜。这减少了数据的依赖性,可能允许进一步简化。默认在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>ivopts</var></span></kbd></dt>
<dd><p>对树进行诱导变量优化(强度降低、诱导变量合并和诱导变量消除)。</p>
</dd>
</dl>
<p>-ftree-parallelize-loops=n</p>
<blockquote>
<div><p>并行化循环,即分割其迭代空间以n个线程运行。这只适用于迭代独立且可以任意重新排序的循环。只有在多处理器机器上,对于CPU密集型的循环,而不是受内存带宽等限制的循环,这种优化才是有利的。这个选项意味着-pthread，因此仅在具有以下功能的目标上受支持-pthread.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>tree-pta</var></span></kbd></dt>
<dd><p>在树上执行函数局部点对点分析。这个标志默认在-O1及以上,除-Og.</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-sra</var></span></kbd></dt>
<dd><p>对聚合体进行标量替换。这个传递将结构引用替换为标量,以防止过早地将结构提交到内存中。这个标志默认在-O1及以上,除-Og.</p>
</dd>
<dt><kbd><span class="option">-f<var>store-merging</var></span></kbd></dt>
<dd><p>执行窄存储合并到连续的内存地址。该通道将比字更窄的即时值的连续存储合并到更少的宽存储中,以减少指令数量。默认情况下,该功能在-O2和更高以及-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-ter</var></span></kbd></dt>
<dd><p>在SSA-&gt;正常阶段执行临时表达式替换。一次性使用/单一定义临时对象在其使用位置被其定义表达式替换。这将导致生成非GIMPLE代码，但使扩展器可以处理更多复杂的树，从而更好地生成RTL。默认情况下启用-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-slsr</var></span></kbd></dt>
<dd><p>对树进行直线强度还原。这可以识别涉及乘法的相关表达式,并在可能的情况下用较便宜的计算来代替它们。这在默认情况下是在-O及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-vectorize</var></span></kbd></dt>
<dd><p>对树进行矢量化。这个标志使-ftree-loop-vectorizeand-ftree-slp-vectorize如果没有明确规定,则可使用。</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-loop-vectorize</var></span></kbd></dt>
<dd><p>在树上执行循环矢量化。这个标志默认在-O3并以-ftree-vectorize,-fprofile-use， 和-fauto-profile.</p>
</dd>
<dt><kbd><span class="option">-f<var>tree-slp-vectorize</var></span></kbd></dt>
<dd><p>在树上执行基本的块向量化。这个标志默认在-O3并以-ftree-vectorize,-fprofile-use， 和-fauto-profile.</p>
</dd>
</dl>
<p>-fvect-cost-model=model</p>
<blockquote>
<div><p>更改用于向量化的成本模型。该 model 参数应该是一个“unlimited’，’dynamic’，’cheap’ 要么 ‘very-cheap’。与“unlimited’假定矢量化代码路径为模型，而使用’dynamic模拟运行时检查会保护矢量化代码路径，使其仅对可能比执行原始标量循环执行得更快的迭代计数启用它。’cheap’模型会禁用循环的矢量化，在这种情况下，这样做会导致成本高昂，例如，由于需要进行运行时检查数据相关性或对齐方式而导致的费用高昂，否则等于’dynamic’ 模型。这 ‘very-cheap’ 模型仅在矢量代码将完全替换正在矢量化的标量代码时才允许矢量化。例如，如果矢量化循环的每次迭代只能处理标量循环的四次迭代，则 ‘very-cheap’ 模型仅在已知标量迭代计数为 4 的倍数时才允许矢量化。</p>
<p>默认成本模型取决于其他优化标志并且是 ‘dynamic’ 要么 ‘cheap’.</p>
</div></blockquote>
<p>-fsimd-cost-model=model</p>
<blockquote>
<div><p>更改用于对带有OpenMP simd指令标记的循环进行矢量化处理的成本模型。该 model 参数应该是一个“unlimited’，’dynamic’，’cheap’。 model 所有值具有与-fvect-cost-model而默认情况下,成本模型定义为-fvect-cost-model是用。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>tree-vrp</var></span></kbd></dt>
<dd><p>对树进行值范围传播。这与常量传播传递类似,但传播的不是值,而是值的范围。这允许优化器删除不必要的范围检查,如数组绑定检查和空指针检查。这在默认情况下是启用的-O2及以上。只有在以下情况下才会进行空指针检查消除-fdelete-null-pointer-checks启用。</p>
</dd>
<dt><kbd><span class="option">-f<var>split-paths</var></span></kbd></dt>
<dd><p>分割路径导致循环后缀。这可以改善死代码的消除和普通子表达式的消除。默认情况下,这个功能在-O3及以上。</p>
</dd>
<dt><kbd><span class="option">-f<var>split-ivs-in-unroller</var></span></kbd></dt>
<dd><p>使得在以后的未滚动循环迭代中,可以使用第一次迭代中的值来表达感应变量的值。这样可以打破长长的依赖链,从而提高调度通道的效率。</p>
<p>组合-fweb和CSE往往足以获得同样的效果。但是,在循环体比单个基本块更复杂的情况下,这并不可靠。由于CSE通证的限制,在某些架构上也完全不起作用。</p>
<p>该优化在默认情况下是启用的。</p>
</dd>
<dt><kbd><span class="option">-f<var>variable-expansion-in-unroller</var></span></kbd></dt>
<dd><p>有了这个选项,编译器在展开循环时,会创建一些局部变量的多份拷贝,这可以使代码更加优秀。</p>
<p>对于PowerPC目标,该优化默认为启用,否则默认为禁用。</p>
</dd>
<dt><kbd><span class="option">-f<var>partial-inlining</var></span></kbd></dt>
<dd><p>函数的内联部分。这个选项只有当内联本身由-finline-functionsor-finline-small-functionsoptions.</p>
<p>启用的级别-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>predictive-commoning</var></span></kbd></dt>
<dd><p>进行预测性的共通优化,即重复使用在之前的循环迭代中进行的计算(特别是内存加载和存储)。</p>
<p>该选项在以下级别启用-O3。也可以通过启用-fprofile-useand-fauto-profile.</p>
</dd>
<dt><kbd><span class="option">-f<var>prefetch-loop-arrays</var></span></kbd></dt>
<dd><p>如果目标机器支持,生成预取内存的指令,以提高访问大型数组的循环的性能。</p>
<p>这个选项可能会产生更好或更差的代码;结果高度依赖于源代码中循环的结构。</p>
<p>伤残等级-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>no-printf-return-value</var></span></kbd></dt>
<dd><p>不要用常量代替格式化输出函数的已知返回值，例如 sprintf ， snprintf ， vsprintf 和 vsnprintf （但不要用 fprintf 的 printf ）。这种转换允许GCC根据这些函数的已知返回值优化或消除分支，这些函数的返回值是恒定的，或者已知其值在可以确定确切返回值的范围内。例如，当-fprintf-return-value实际上， if i 是32位或更小的整数，则可以优化if语句的分支和主体（但不能调用 snprint ），因为保证返回值最大为8。</p>
</dd>
</dl>
<p>-fno-peephole
-fno-peephole2</p>
<blockquote>
<div><p>禁用任何特定机器的窥视孔优化。之间的区别-fno-peepholeand-fno-peephole2是在编译器中如何实现的,有些目标使用一个,有些使用另一个,少数目标两者都使用。</p>
<p>-fpeephole默认情况下是启用的。-fpeephole2启用的级别-O2,-O3,-Os.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>no-guess-branch-probability</var></span></kbd></dt>
<dd><p>不要用启发式方法猜测分支概率。</p>
<p>GCC使用启发式方法来猜测分支概率,如果它们不是由剖析反馈提供的(-fprofile-arcs）。这些启发式方法基于控制流程图。如果 __builtin_expect 指定了一些分支概率，则在考虑 __builtin_expect 信息的情况下，将使用启发式方法来猜测其余控制流程图的分支概率。启发式方法和 __builtin_expect 之间的交互可能很复杂，在某些情况下，禁用启发式方法可能很有用，以便使 __builtin_expect 的效果更容易理解。</p>
<p>也可以使用 __builtin_expect_with_probability 内置函数指定表达式的预期概率。</p>
<p>默认为-fguess-branch-probability在各级-O,-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>reorder-blocks</var></span></kbd></dt>
<dd><p>对编译函数中的基本块进行重新排序,以减少被占用的分支数量,提高代码的局部性。</p>
<p>启用的级别-O,-O2,-O3,-Os.</p>
</dd>
</dl>
<p>-freorder-blocks-algorithm=algorithm</p>
<blockquote>
<div><p>使用指定的算法进行基本块重新排序。该 algorithm 参数可以是“simple’，它不会增加代码的大小（除非有时由于对齐等次要影响而导致），或者stc”，即“软件跟踪缓存”算法，该算法尝试将所有经常执行的代码放在一起，通过制作额外的代码副本来最大程度地减少执行的分支数量。</p>
<p>默认值为“simple’级-O,-Os和’stc’级-O2,-O3.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>reorder-blocks-and-partition</var></span></kbd></dt>
<dd><p>除了对编译函数中的基本块进行重新排序外,为了减少所取的分支数量,还将热基本块和冷基本块划分到装配体的不同部分,并将这些基本块分成不同的部分。.o文件,以提高分页和缓存定位性能。</p>
<p>在存在异常处理或unwind表的情况下,该优化会自动关闭(在使用setjump/longjump或目标特定方案的目标上),对于linkonce部分,对于具有用户定义部分属性的函数,以及在任何不支持命名部分的架构上。当-fsplit-stack使用这个选项时,默认情况下不会启用(以避免链接器出错),但可以显式启用(如果使用的是工作链接器)。</p>
<p>启用x86的级别-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>reorder-functions</var></span></kbd></dt>
<dd><p>在目标文件中对函数进行重新排序，以提高代码的局部性。这是通过对最常执行的功能使用特殊的 .text.hot .text.unlikely 对不太可能执行的功能使用.text。小节来实现的。链接器完成了重新排序，因此目标文件格式必须支持命名节，并且链接器必须以合理的方式放置它们。</p>
<p>除非您提供个人资料反馈，否则此选项无效（请参阅-fprofile-arcs（有关详细信息）或使用 hot 属性或 cold 属性手动注释函数（请参见通用函数属性）。</p>
<p>启用的级别-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>strict-aliasing</var></span></kbd></dt>
<dd><p>允许编译器采用适用于所编译语言的最严格的别名规则。对于C（和C ++），这会根据表达式的类型激活优化。特别是，除非类型几乎相同，否则假定一种类型的对象永远不会与其他类型的对象位于相同的地址。例如， unsigned int 可以为 int 别名，但不能为 void* 或 double 别名。字符类型可以别名任何其他类型。</p>
<p>要特别注意这样的代码。</p>
</dd>
</dl>
<p>-falign-functions
-falign-functions=n
-falign-functions=n:m
-falign-functions=n:m:n2
-falign-functions=n:m:n2:m2</p>
<blockquote>
<div><p>将函数的开头与下一个大于或等于 n 的2的幂次对齐，最多跳过 m -1个字节。这样确保了CPU可以至少获取函数的前 m 个字节，而不会跨越 n 个字节的对齐边界。</p>
<p>如果未指定 m ，则默认为 n 。</p>
<p>Examples:-falign-functions=32将函数对齐到下一个32字节边界。-falign-functions=24只有在跳过23个字节或更少的情况下,才会与下一个32字节的边界对齐。-falign-functions=32:7只有在跳过6个字节或更少的情况下,才会与下一个32字节的边界对齐。</p>
<p>第二对 n2 ： m2 值使您可以指定辅助对齐方式：-falign-functions=64:7:32:3如果可以跳过6个字节或更少的字节，则与下一个64字节边界对齐；如果可以跳过2个字节或更少的字节，则与下一个32字节边界对齐。如果未指定 m2 ，则默认为 n2 。</p>
<p>某些汇编程序仅在 n 为2的幂时才支持此标志。在这种情况下，将其四舍五入。</p>
<p>-fno-align-functionsand-falign-functions=1是等价的,意味着函数不对齐。</p>
<p>如果未指定 n 或为n，则使用与机器有关的默认值。 n 选项的最大允许值为65536。</p>
<p>启用的级别-O2,-O3.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>limit-function-alignment</var></span></kbd></dt>
<dd><p>如果启用这个选项,编译器就会尝试避免不必要的过度对齐函数。它试图指示汇编器按照由-falign-functions，但不要跳过比函数大小更多的字节。</p>
</dd>
</dl>
<p>-falign-labels
-falign-labels=n
-falign-labels=n:m
-falign-labels=n:m:n2
-falign-labels=n:m:n2:m2</p>
<blockquote>
<div><p>将所有的分支目标对准二幂的边界。</p>
<p>这个选项的参数类似于-falign-functionsoption.-fno-align-labelsand-falign-labels=1是等价的,意味着标签不对齐。</p>
<p>If-falign-loopsor-falign-jumps是适用的,并且大于这个值,那么就用它们的值代替。</p>
<p>如果未指定 n 或为n，请使用与机器相关的默认值，该默认值很可能是’1’，表示不对齐。 n 选项的最大允许值为65536。</p>
<p>启用的级别-O2,-O3.</p>
</div></blockquote>
<p>-falign-loops
-falign-loops=n
-falign-loops=n:m
-falign-loops=n:m:n2
-falign-loops=n:m:n2:m2</p>
<blockquote>
<div><p>将循环对齐到二的幂级边界。如果循环被多次执行,这将弥补任何执行的虚填充指令。</p>
<p>If-falign-labels大于此值,则用其值代替。</p>
<p>这个选项的参数类似于-falign-functionsoption.-fno-align-loopsand-falign-loops=1是等效的，表示循环未对齐。 n 选项的最大允许值为65536。</p>
<p>如果未指定 n 或为n，则使用与机器有关的默认值。</p>
<p>启用的级别-O2,-O3.</p>
</div></blockquote>
<p>-falign-jumps
-falign-jumps=n
-falign-jumps=n:m
-falign-jumps=n:m:n2
-falign-jumps=n:m:n2:m2</p>
<blockquote>
<div><p>将分支目标对准二的幂级边界,对于只有通过跳跃才能到达目标的分支目标。在这种情况下,不需要执行虚操作。</p>
<p>If-falign-labels大于此值,则用其值代替。</p>
<p>这个选项的参数类似于-falign-functionsoption.-fno-align-jumpsand-falign-jumps=1是等价的,意味着循环不对齐。</p>
<p>如果未指定 n 或为n，则使用与机器有关的默认值。 n 选项的最大允许值为65536。</p>
<p>启用的级别-O2,-O3.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>no-allocation-dce</var></span></kbd></dt>
<dd><p>在消除死代码时不要删除未使用的C++分配。</p>
</dd>
<dt><kbd><span class="option">-f<var>allow-store-data-races</var></span></kbd></dt>
<dd><p>允许编译器执行可能在存储上引入新的数据竞赛的优化,而不证明该变量不能被其他线程并发访问。不影响本地数据的优化。如果知道全局数据不会被多个线程访问,使用这个选项是安全的。</p>
<p>启用的优化实例-fallow-store-data-races包括hoisting或if-conversions,它们可能导致已经在内存中的值被重新写成相同的值。这种重写在单线程环境下是安全的,但在多线程环境下可能是不安全的。请注意,在某些处理器上,为了实现矢量化,可能需要进行if转换。</p>
<p>启用的级别-Ofast.</p>
</dd>
<dt><kbd><span class="option">-f<var>unit-at-a-time</var></span></kbd></dt>
<dd><p>由于兼容性的原因,此选项被保留。-funit-at-a-time没有影响,而-fno-unit-at-a-timeimplies-fno-toplevel-reorderand-fno-section-anchors.</p>
<p>默认为已启用。</p>
</dd>
<dt><kbd><span class="option">-f<var>no-toplevel-reorder</var></span></kbd></dt>
<dd><p>不要对顶级函数，变量和 asm 语句重新排序。按照它们在输入文件中出现的顺序输出它们。使用此选项时，不会删除未引用的静态变量。此选项旨在支持依赖特定顺序的现有代码。对于新代码，最好尽可能使用属性。</p>
<p>-ftoplevel-reorder是默认的,在-O1及以上,以及在-O0if-fsection-anchors是明确要求的。此外-fno-toplevel-reorderimplies-fno-section-anchors.</p>
</dd>
<dt><kbd><span class="option">-f<var>web</var></span></kbd></dt>
<dd><p>构造通常用于寄存器分配目的的网络，并为每个网络分配单独的伪寄存器。这使寄存器分配过程可以直接对伪操作进行操作，还可以增强其他一些优化过程，例如CSE，循环优化器和琐碎的死代码清除器。但是，由于变量不再保留在“本地寄存器”中，因此它可能使调试变得不可能。</p>
<p>默认启用-funroll-loops.</p>
</dd>
<dt><kbd><span class="option">-f<var>whole-program</var></span></kbd></dt>
<dd><p>假定当前的编译单元代表正在编译的整个程序。除 main 以外的所有公共函数和变量，以及由属性 externally_visible 合并的那些公共函数和变量，都变为静态函数，实际上是由过程间优化器更积极地优化的。</p>
<p>此选项不应与-flto。相反，依靠链接器插件应该提供更安全，更准确的信息。</p>
</dd>
</dl>
<p>-flto[=n]</p>
<blockquote>
<div><p>此选项运行标准的链接时间优化器。用源代码调用时，它会生成GIMPLE（GCC的内部表示形式之一）并将其写入目标文件中的特殊ELF节。将目标文件链接在一起时，将从这些ELF节中读取所有功能体，并将其实例化，就好像它们已属于同一翻译单元一样。</p>
<p>要使用链接时间优化器。-flto和优化选项应该在编译时和最终链接时指定。建议你用相同的选项编译所有参与同一链接的文件,并在链接时也指定这些选项。例如</p>
<p>gcc -c -O2 -flto foo.c
gcc -c -O2 -flto bar.c
gcc -o myprog -flto -O2 foo.o bar.o</p>
<p>对GCC的前两次调用将GIMPLE的字节码表示保存到特殊的ELF部分,在foo.oandbar.o。最后的调用从中读取GIMPLE字节码foo.oandbar.o，将这两个文件合并为一个内部映像，然后照常编译结果。由于两者foo.oandbar.o合并为一个单一的图像,这使得GCC中所有的程序间分析和优化在两个文件之间工作,就像它们是一个单一的文件一样。这意味着,例如,内联程序能够内联在bar.o变成功能,在foo.o反之亦然。</p>
<p>另一种(更简单的)启用链接时间优化的方法是:。</p>
<p>gcc -o myprog -flto -O2 foo.c bar.c</p>
<p>以上生成的字节码为foo.candbar.c，将它们合并为一个GIMPLE表示形式，并照常对其进行优化以生成myprog.</p>
<p>需要注意的是,要启用链接时间优化,需要使用GCC驱动来执行链接步骤。如果所涉及的任何对象是用GCC驱动编译的,GCC会自动执行链接时间优化。-flto命令行选项。你总是可以通过传入-fno-lto到链接命令。</p>
<p>要想使整个程序优化有效,就必须进行一定的整体程序假设。编译器需要知道链接时优化单元之外的库和运行时可以访问哪些函数和变量。当链接器支持时,链接器插件(见-fuse-linker-plugin）将已使用和外部可见符号传递给编译器的信息。当链接器插件不可用时，-fwhole-program应该用来允许编译器做出这些假设,这将导致更积极的优化决策。</p>
<p>当一个文件被编译成-fltowithout-fuse-linker-plugin，则生成的目标文件要比常规目标文件大，因为它包含GIMPLE字节码和通常的最终代码（请参见-ffat-lto-objects）。这意味着带有 LTO 信息的目标文件可以作为普通目标文件进行链接；如果-fno-lto传递给链接器,不应用程序间优化。请注意,当-fno-fat-lto-objects启用后,编译阶段的速度会更快,但你不能对它们进行常规的非LTO链接。</p>
<p>在生成最终的二进制文件时,GCC 只对那些包含字节码的文件进行链接时间优化。因此,您可以将对象文件和库与 GIMPLE 字节码和最终的对象代码进行混合和匹配。GCC 会自动选择哪些文件要在 LTO 模式下进行优化,哪些文件无需进一步处理即可链接。</p>
<p>一般来说,在链接时指定的选项会覆盖在编译时指定的选项,尽管在某些情况下,GCC会尝试从编译输入文件的设置中推断链接时的选项。</p>
<p>如果您没有指定优化级别选项-O选项,那么GCC就使用编译对象文件时使用的最高优化级别。需要注意的是,只在链接时指定优化级别选项而不在编译时指定优化级别选项通常是无效的,原因有二:一是不进行优化的编译会抑制在链接时收集有效优化所需信息的编译器通道。首先,不进行优化的编译会抑制在链接时收集有效优化所需信息的编译器通证。第二,一些早期的优化通道只能在编译时执行,而不能在链接时执行。</p>
<p>在生成字节码时,GCC保留了一些代码生成标志,因为在最后的链接过程中需要用到这些标志。目前,以下选项及其设置是从第一个明确指定它们的对象文件中提取的。-fcommon,-fexceptions,-fnon-call-exceptions,-fgnu-tm以及所有-m目标标志。</p>
<p>以下选项-fPIC,-fpic,-fpieand-fPIE根据以下方案进行组合。</p>
<p>-fPIC + -fpic = -fpic
-fPIC + -fno-pic = -fno-pic
-fpic/-fPIC + (no option) = (no option)
-fPIC + -fPIE = -fPIE
-fpic + -fPIE = -fpie
-fPIC/-fpic + -fpie = -fpie</p>
<p>某些ABI变化的标志在所有编译单元中都需要匹配,在链接时试图用一个冲突的值来覆盖这个标志会被忽略。这包括一些选项,如-freg-struct-returnand-fpcc-struct-return.</p>
<p>其他选项,如-ffp-contract,-fno-strict-overflow,-fwrapv,-fno-trapvor-fno-strict-aliasing被传递到链接阶段,并对冲突的翻译单元进行保守的合并。具体来说-fno-strict-overflow,-fwrapvand-fno-trapv为先;又如-ffp-contract=off先于-ffp-contract=fast。您可以在链接时覆盖它们。</p>
<p>诊断选项,如-Wstringop-overflow被传递到链接阶段,它们的设置与编译阶段的函数粒度相匹配。请注意,这只对优化过程中发出的诊断有影响。请注意,如果代码与编译时的设置不一致,代码转换(如内联)会导致区域的警告被启用或禁用。</p>
<p>当你需要将选项通过-Waor-Xassembler确保在编译这样的翻译单元时,要用-fno-lto或在所有翻译单元上一致使用相同的汇编器选项。您也可以在LTO链接时指定汇编器选项。</p>
<p>要启用调试信息生成,您需要提供以下信息-g在编译时。如果任何输入文件在链接时是在启用调试信息生成的情况下建立的,那么链接也会启用调试信息生成。任何复杂的调试信息设置,如矮人级别的-gdwarf-5需要在链接器命令行明确重复,并且不鼓励在不同翻译单元中混合不同的设置。</p>
<p>如果LTO在单独的翻译单元中遇到用不兼容类型声明的C链接对象要链接在一起(根据ISO C99 6.2.7,行为未定义),可能会发出一个非致命的诊断。该行为在运行时仍未定义。对于其他语言,可能会发出类似的诊断。</p>
<p>LTO的另一个特点是可以对用不同语言编写的文件进行程序间优化。</p>
<p>gcc -c -flto foo.c
g++ -c -flto bar.cc
gfortran -c -flto baz.f90
g++ -o myprog -flto -O3 foo.o bar.o baz.o -lgfortran</p>
<p>请注意，最终链接是使用 g++ 完成的，以获取C ++运行时库和-lgfortran是为了获取Fortran运行时库而添加的。一般来说,在LTO模式下混合语言时,应该使用与常规(非LTO)编译中混合语言时相同的链接命令选项。</p>
<p>如果包含 GIMPLE 字节码的对象文件存储在库存档中,比如说libfoo.a，如果您使用支持插件的链接器，则可以在LTO链接中提取和使用它们。要创建适用于LTO的静态库，请使用 gcc-ar 和 gcc-ranlib 代替 ar 和 ranlib ；要显示具有GIMPLE字节码的目标文件的符号，请使用 gcc-nm 。这些命令要求使用插件支持编译 ar ， ranlib 和 nm 。在链接时，使用标志-fuse-linker-plugin以确保该库参与LTO优化过程。</p>
<p>gcc -o myprog -O2 -flto -fuse-linker-plugin a.o b.o -lfoo</p>
<p>启用链接器插件后,链接器会将所需的 GIMPLE 文件从libfoo.a并将它们传递给正在运行的 GCC,使它们成为要优化的聚合 GIMPLE 映像的一部分。</p>
<p>如果你没有使用支持插件的链接器和/或没有启用链接器插件,那么在libfoo.a被提取出来,并像往常一样进行链接,但它们不参与LTO优化过程。为了使一个静态库既适合LTO优化,又适合通常的链接,编译它的对象文件时要用-flto -ffat-lto-objects.</p>
<p>链接时间优化不需要整个程序的存在才能操作。如果程序不需要输出任何符号,则可以结合-fltoand-fwhole-program以允许程序间优化器使用更激进的假设,这可能会带来更好的优化机会。使用-fwhole-program当链接器插件处于活动状态时不需要(见-fuse-linker-plugin).</p>
<p>目前LTO的实现并没有尝试生成可在不同类型主机之间移植的字节码。字节码文件是有版本的,并且有严格的版本检查,所以在一个版本的GCC中生成的字节码文件不能在旧版本或新版本的GCC中使用。</p>
<p>除了使用ELF和DWARF组合的系统外,链接时间优化在生成调试信息方面效果不佳。</p>
<p>如果指定了可选的 n ，则通过使用已安装的 make 程序，使用 n 个并行作业并行执行链接时完成的优化和代码生成。环境变量 MAKE 可用于覆盖所使用的程序。</p>
<p>您也可以指定-flto=jobserver使用GNU make的作业服务器模式来确定并行作业的数量。当调用GCC的Makefile已经并行执行时，这很有用。您必须在前面加上“+’才能在父Makefile中的命令配方中使用。仅当 MAKE 是GNU make时，此选项才可能起作用。即使没有选项值，GCC也会尝试自动检测正在运行的GNU make的作业服务器。</p>
<p>Use-flto=auto使用GNU make的作业服务器（如果有），或者以其他方式退回到自动检测系统中存在的CPU线程数的方式。</p>
</div></blockquote>
<p>-flto-partition=alg</p>
<blockquote>
<div><p>指定链接时间优化器使用的分区算法。该值可以是“1to1’以指定镜像原始源文件的分区，或’balanced’以指定划分为大小相等的块（如果可能）或’max’在可能的情况下为每个符号创建新的分区。指定“none作为一种算法，将完全禁用分区和流传输。默认值为“balanced’。而“1to1可以用作各种代码排序问题的解决方法，max分区仅用于内部测试。价值 ‘one’指定应该使用一个分区，而值’none绕过分区，直接从WPA阶段执行链接时间优化步骤。</p>
</div></blockquote>
<p>-flto-compression-level=n</p>
<blockquote>
<div><p>这个选项指定了写到LTO对象文件中的中间语言所使用的压缩程度,并且只在与LTO模式(-flto）。 GCC 目前支持两种 LTO 压缩算法。对于 zstd，有效值为 0（无压缩）到 19（最大压缩），而 zlib 支持从 0 到 9 的值。超出此范围的值被限制为支持值的最小值或最大值。如果未给出该选项，则使用默认的平衡压缩设置。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>use-linker-plugin</var></span></kbd></dt>
<dd><p>在链接时间优化期间启用链接器插件。这个选项依赖于链接器中的插件支持,在gold或GNU ld 2.21或更新版本中可用。</p>
<p>此选项可以从库存档中提取带有 GIMPLE 字节码的对象文件。这可以通过将更多代码暴露给链接时间优化器来提高优化质量。这些信息指定了哪些符号可以从外部访问(通过非LTO对象或在动态链接期间)。结果在二进制文件(和使用隐藏可见性的共享库)上的代码质量改进类似于-fwhole-program。看到-flto以了解该标志的效果和使用方法。</p>
<p>当GCC中的LTO支持被启用,并且GCC被配置为与支持插件的链接器(GNU ld 2.21或更新版或gold)一起使用时,该选项默认被启用。</p>
</dd>
<dt><kbd><span class="option">-f<var>fat-lto-objects</var></span></kbd></dt>
<dd><p>胖LTO对象是包含中间语言和对象代码的对象文件。这使得它们既可以用于LTO链接,也可以用于普通链接。这个选项只有在编译时使用-flto并在链接时被忽略。</p>
<p>-fno-fat-lto-objects与普通的LTO相比，可以缩短编译时间，但是需要完整的工具链来了解LTO。它要求具有链接器插件支持功能的链接器具有基本功能。此外， nm ， ar 和 ranlib 需要支持链接器插件，以允许使用功能全面的构建环境（能够构建静态库等）。GCC提供了 gcc-ar ， gcc-nm 和 gcc-ranlib 包装器，以将正确的选项传递给这些工具。对于非胖LTO makefile，需要对其进行修改以使用它们。</p>
<p>注意,现代的binutils提供了插件自动加载机制。将链接器插件安装到$libdir/bfd-plugins与使用命令包装程序（ gcc-ar ， gcc-nm 和 gcc-ranlib ）具有相同的效果。</p>
<p>默认为-fno-fat-lto-objects在支持链接器插件的目标上。</p>
</dd>
<dt><kbd><span class="option">-f<var>compare-elim</var></span></kbd></dt>
<dd><p>在寄存器分配和寄存器分配后的指令拆分后,确定计算处理器标志的算术指令,类似于基于该算术的比较操作。如果可能的话,取消明确的比较操作。</p>
<p>这个通道只适用于某些目标,在寄存器分配完成之前,不能明确表示比较操作。</p>
<p>启用的级别-O,-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>cprop-registers</var></span></kbd></dt>
<dd><p>在寄存器分配和寄存器分配后的指令拆分后,进行复制传播传递,尽量减少调度依赖性,偶尔消除复制。</p>
<p>启用的级别-O,-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>profile-correction</var></span></kbd></dt>
<dd><p>对于多线程程序,使用工具化二进制程序收集的配置文件可能会因为错过计数器更新而导致不一致。当指定此选项时,GCC使用启发式方法来纠正或消除这种不一致。默认情况下,当检测到不一致的配置文件时,GCC会发出一条错误信息。</p>
<p>启用该选项的方法是-fauto-profile.</p>
</dd>
<dt><kbd><span class="option">-f<var>profile-partial-training</var></span></kbd></dt>
<dd><p>使用 -fprofile-use 时，火车运行期间未执行的所有程序部分都会针对大小而非速度进行积极优化。在某些情况下，在程序中训练所有可能的热路径是不切实际的。（例如，程序可能包含特定于给定硬件的功能，并且trianing可能无法覆盖程序在其上运行的所有硬件配置。）使用 -fprofile-partial-training 配置文件，对于在运行它们时导致未执行的所有功能的反馈将被忽略进行优化，就像在没有配置文件反馈的情况下进行编译一样。当列车运行不具有代表性时，这会导致更好的性能，但也会导致代码大得多。</p>
</dd>
</dl>
<p>-fprofile-use
-fprofile-use=path</p>
<blockquote>
<div><p>启用配置文件反馈导向的优化,以及以下优化,很多优化一般只有在有配置文件反馈的情况下才能盈利。</p>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>branch-probabilities</var></span></kbd></dt>
<dd><p>-fprofile-values</p>
</dd>
<dt><kbd><span class="option">-f<var>unroll-loops</var></span></kbd></dt>
<dd><dl class="option-list">
<dt><kbd><span class="option">-f<var>peel-loops</var></span></kbd></dt>
<dd><dl class="option-list">
<dt><kbd><span class="option">-f<var>tracer</var></span></kbd></dt>
<dd><p>-fvpt</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt><kbd><span class="option">-f<var>inline-functions</var></span></kbd></dt>
<dd><dl class="option-list">
<dt><kbd><span class="option">-f<var>ipa-cp</var></span></kbd></dt>
<dd><dl class="option-list">
<dt><kbd><span class="option">-f<var>ipa-cp-clone</var></span></kbd></dt>
<dd><p>-fipa-bit-cp</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt><kbd><span class="option">-f<var>predictive-commoning</var></span></kbd></dt>
<dd><dl class="option-list">
<dt><kbd><span class="option">-f<var>split-loops</var></span></kbd></dt>
<dd><p>-funswitch-loops</p>
</dd>
</dl>
</dd>
<dt><kbd><span class="option">-f<var>gcse-after-reload</var></span></kbd></dt>
<dd><dl class="option-list">
<dt><kbd><span class="option">-f<var>tree-loop-vectorize</var></span></kbd></dt>
<dd><p>-ftree-slp-vectorize</p>
</dd>
</dl>
</dd>
</dl>
<p>-fvect-cost-model=dynamic  -ftree-loop-distribute-patterns
-fprofile-reorder-functions</p>
<p>使用此选项之前，必须首先生成分析信息。有关的信息，请参见工具选项。-fprofile-generateoption.</p>
<p>默认情况下,如果反馈配置文件与源代码不匹配,GCC会发出一条错误信息。这个错误可以通过使用-Wno-error=coverage-mismatch。请注意，这可能会导致代码优化不佳。此外，默认情况下，如果反馈配置文件不存在，GCC也会发出警告消息（请参阅-Wmissing-profile).</p>
<p>如果 path 指定，GCC着眼于 path 寻找配置文件反馈数据文件。看到-fprofile-dir.</p>
</div></blockquote>
<p>-fauto-profile
-fauto-profile=path</p>
<blockquote>
<div><p>启用基于采样的反馈导向优化,以及以下优化,其中很多优化一般只有在有剖面反馈的情况下才能盈利。</p>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>branch-probabilities</var></span></kbd></dt>
<dd><p>-fprofile-values</p>
</dd>
<dt><kbd><span class="option">-f<var>unroll-loops</var></span></kbd></dt>
<dd><dl class="option-list">
<dt><kbd><span class="option">-f<var>peel-loops</var></span></kbd></dt>
<dd><dl class="option-list">
<dt><kbd><span class="option">-f<var>tracer</var></span></kbd></dt>
<dd><p>-fvpt</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt><kbd><span class="option">-f<var>inline-functions</var></span></kbd></dt>
<dd><dl class="option-list">
<dt><kbd><span class="option">-f<var>ipa-cp</var></span></kbd></dt>
<dd><dl class="option-list">
<dt><kbd><span class="option">-f<var>ipa-cp-clone</var></span></kbd></dt>
<dd><p>-fipa-bit-cp</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt><kbd><span class="option">-f<var>predictive-commoning</var></span></kbd></dt>
<dd><dl class="option-list">
<dt><kbd><span class="option">-f<var>split-loops</var></span></kbd></dt>
<dd><p>-funswitch-loops</p>
</dd>
</dl>
</dd>
<dt><kbd><span class="option">-f<var>gcse-after-reload</var></span></kbd></dt>
<dd><dl class="option-list">
<dt><kbd><span class="option">-f<var>tree-loop-vectorize</var></span></kbd></dt>
<dd><p>-ftree-slp-vectorize</p>
</dd>
</dl>
</dd>
</dl>
<p>-fvect-cost-model=dynamic  -ftree-loop-distribute-patterns
-fprofile-correction</p>
<p>path 是包含AutoFDO配置文件信息的文件的名称。如果省略，则默认为fbdata.afdo在当前目录下。</p>
<p>产生AutoFDO配置文件数据文件需要在支持的GNU / Linux目标系统上使用 perf 实用程序运行程序。有关更多信息，请参见https://perf.wiki.kernel.org/。</p>
<p>E.g.</p>
<dl class="simple">
<dt>perf record -e br_inst_retired:near_taken -b -o perf.data </dt><dd><p>– your_program</p>
</dd>
</dl>
<p>然后使用 create_gcov 工具将原始配置文件数据转换为GCC可以使用的格式。您还必须将程序的未剥离二进制文件提供给此工具。参见https://github.com/google/autofdo。</p>
<p>E.g.</p>
</div></blockquote>
<p>以下是控制编译器对浮点运算行为的选项。这些选项可以在速度和正确性之间进行权衡。所有的选项都必须特别启用。</p>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>float-store</var></span></kbd></dt>
<dd><p>不要将浮点变量存储在寄存器中,并抑制其他可能改变浮点值是来自寄存器还是内存的选项。</p>
<p>此选项可防止在诸如68000之类的机器上产生不必要的过高精度，例如6881，其浮动寄存器（68881）保持的精度比原本应该 double 精度高。对于x86体系结构也是如此。对于大多数程序而言，多余的精度只会发挥作用，但是有些程序依赖于IEEE浮点数的精确定义。用-ffloat-store对这些程序进行修改,将所有相关的中间计算存储到变量中。</p>
</dd>
</dl>
<p>-fexcess-precision=style</p>
<blockquote>
<div><p>当浮点运算的格式比IEEE标准的精度或范围更大时,该选项可以进一步控制过高的精度,并且可以互换浮点类型。默认情况下。-fexcess-precision=fast是有效的;这意味着,如果这样做会使代码速度更快,那么可以用比源码中指定的类型更宽的精度来进行操作,而且当四舍五入到源码中指定的类型时,是不可预知的。在编译C语言时,如果-fexcess-precision=standard指定了,那么多余的精度就会遵循ISO C99中指定的规则;特别是,转置和赋值都会导致值被四舍五入到它们的语义类型(而-ffloat-store只影响赋值)。)如果C语言有严格的一致性选项,如-std=c99是用。-ffast-mathenables-fexcess-precision=fast默认情况下,无论是否使用严格遵从选项。</p>
<p>-fexcess-precision=standard对于C语言以外的其他语言没有实现。在x86上,如果是-mfpmath=sseor-mfpmath=sse+387是指定的;在前一种情况下,IEEE语义适用,没有多余的精度,而在后一种情况下,四舍五入是不可预知的。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>fast-math</var></span></kbd></dt>
<dd><p>设置选项-fno-math-errno,-funsafe-math-optimizations,-ffinite-math-only,-fno-rounding-math,-fno-signaling-nans,-fcx-limited-rangeand-fexcess-precision=fast.</p>
<p>此选项将导致定义预处理程序宏 __FAST_MATH__ 。</p>
<p>该选项没有被任何-O外的选择-Ofast因为对于依赖于IEEE或ISO数学函数规则/规范的精确实现的程序,它可能会导致不正确的输出。然而,对于不需要这些规范保证的程序,它可能会产生更快的代码。</p>
</dd>
<dt><kbd><span class="option">-f<var>no-math-errno</var></span></kbd></dt>
<dd><p>调用用单个指令执行的数学函数（例如 sqrt )后，请勿设置 errno 。依赖IEEE异常进行数学错误处理的程序可能希望将此标志用于速度，同时保持IEEE算术兼容性。</p>
<p>该选项没有被任何-O选项,因为对于依赖于IEEE或ISO数学函数规则/规范的精确实现的程序,它可能会导致不正确的输出。然而,对于不需要这些规范保证的程序,它可能会产生更快的代码。</p>
<p>默认为-fmath-errno.</p>
<p>在达尔文系统上，数学库从不设置 errno 。因此，编译器没有理由考虑它可能的可能性，并且-fno-math-errno是默认的。</p>
</dd>
<dt><kbd><span class="option">-f<var>unsafe-math-optimizations</var></span></kbd></dt>
<dd><p>允许对浮点算术进行优化,(a)假设参数和结果有效,(b)可能违反IEEE或ANSI标准。在链接时使用时,它可能包括改变默认FPU控制字或其他类似优化的库或启动文件。</p>
<p>该选项没有被任何-O选项,因为对于依赖于IEEE或ISO数学函数规则/规范的精确实现的程序,它可能会导致不正确的输出。但是,对于不需要这些规范保证的程序,它可能会产生更快的代码。启用-fno-signed-zeros,-fno-trapping-math,-fassociative-mathand-freciprocal-math.</p>
<p>默认为-fno-unsafe-math-optimizations.</p>
</dd>
<dt><kbd><span class="option">-f<var>associative-math</var></span></kbd></dt>
<dd><p>允许在一系列浮点运算中重新关联操作数。通过可能更改计算结果，这违反了ISO C和C ++语言标准。注意：重新排序可能会更改零的符号，并忽略NaN并抑制或创建下溢或上溢（因此不能用于依赖舍入行为的代码，例如 (x + 2**52) - 2**52 可能还会对浮点比较进行重新排序，因此在需要进行顺序比较时可能无法使用。-fno-signed-zerosand-fno-trapping-math生效。而且，这与-frounding-math。对于Fortran，当两个-fno-signed-zerosand-fno-trapping-math是有效的。</p>
<p>默认为-fno-associative-math.</p>
</dd>
<dt><kbd><span class="option">-f<var>reciprocal-math</var></span></kbd></dt>
<dd><p>如果启用优化，则允许使用值的倒数而不是除以该值。例如 x / y 可以替换为 x * (1/y) ，如果这是有用的 (1/y) 是受公共子表达式消除。请注意，这会失去精度，并增加了根据该值进行操作的触发器数量。</p>
<p>默认为-fno-reciprocal-math.</p>
</dd>
<dt><kbd><span class="option">-f<var>finite-math-only</var></span></kbd></dt>
<dd><p>允许对浮点运算进行优化,假设参数和结果不是NaNs或+Infs。</p>
<p>该选项没有被任何-O选项,因为对于依赖于IEEE或ISO数学函数规则/规范的精确实现的程序,它可能会导致不正确的输出。然而,对于不需要这些规范保证的程序,它可能会产生更快的代码。</p>
<p>默认为-fno-finite-math-only.</p>
</dd>
<dt><kbd><span class="option">-f<var>no-signed-zeros</var></span></kbd></dt>
<dd><p>允许对浮点算术进行优化,忽略零的符号性。IEEE算术规定了不同的+0.0和-0.0值的行为,这就禁止简化表达式,如x+0.0或0.0*x(即使是在使用了-ffinite-math-only）。此选项表示结果为零的符号不重要。</p>
<p>默认为-fsigned-zeros.</p>
</dd>
<dt><kbd><span class="option">-f<var>no-trapping-math</var></span></kbd></dt>
<dd><p>编译代码时假设浮点运算不会产生用户可见的陷阱,这些陷阱包括零除、溢出、底溢、不完全结果和无效运算。这些陷阱包括:零除、溢出、底溢、不精确结果和无效操作。该选项要求-fno-signaling-nans生效。例如，如果一个选项依赖“不间断” IEEE算术，则设置此选项可以允许更快的代码。</p>
<p>任何情况下都不应该开启该选项。-O选项,因为对于依赖于IEEE或ISO数学函数规则/规范的精确实现的程序来说,它可能导致不正确的输出。</p>
<p>默认为-ftrapping-math.</p>
</dd>
<dt><kbd><span class="option">-f<var>rounding-math</var></span></kbd></dt>
<dd><p>禁用假设默认浮点取整行为的转换和优化。对于所有的浮点到整数的转换都是四舍五入,对于所有其他的算术截断都是四舍五入。对于动态改变FP舍入模式的程序,或者可能以非默认舍入模式执行的程序,应该指定这个选项。这个选项禁止在编译时对浮点表达式进行恒定的折叠(可能会受到四舍五入模式的影响),也禁止在符号相关的四舍五入模式下进行不安全的算术变换。</p>
<p>默认为-fno-rounding-math.</p>
<p>此选项是实验性的，当前不保证禁用所有受舍入模式影响的GCC优化。将来的GCC版本可以使用C99的 FENV_ACCESS 编译指示更好地控制此设置。此命令行选项将用于指定 FENV_ACCESS 的默认状态。</p>
</dd>
<dt><kbd><span class="option">-f<var>signaling-nans</var></span></kbd></dt>
<dd><p>编译代码时假设IEEE信号NaNs在浮点运算时可能产生用户可见的陷阱。设置该选项可以禁止可能改变信号NaNs可见异常数量的优化。这个选项意味着,在编译代码时,要考虑到IEEE信号NaN可能会在浮点运算时产生用户可见的陷阱。-ftrapping-math.</p>
<p>此选项将导致定义预处理程序宏 __SUPPORT_SNAN__ 。</p>
<p>默认为-fno-signaling-nans.</p>
<p>这个选项是实验性的,目前并不能保证禁用所有影响信令NaN行为的GCC优化。</p>
</dd>
<dt><kbd><span class="option">-f<var>no-fp-int-builtin-inexact</var></span></kbd></dt>
<dd><p>不允许内置函数 ceil ， floor ， round 和 trunc 以及它们的 float 和 long double 变体生成用于引发非整数参数“ inexact”浮点异常的代码。ISO C99和C11允许这些功能引发“ inexact”异常，但是ISO / IEC TS 18661-1：2014（集成到ISO C2X中的对IEEE 754-2008的C绑定）不允许这些功能这样做。</p>
<p>默认为-ffp-int-builtin-inexact，除非选择了C2X或更高版本的C标准，否则允许引发异常。该选项不执行任何操作，除非-ftrapping-math是有效的。</p>
<p>即使-fno-fp-int-builtin-inexact如果使用函数，则如果函数生成对库函数的调用，则如果库实现不遵循TS 18661，则可能引发“ inexact”异常。</p>
</dd>
<dt><kbd><span class="option">-f<var>single-precision-constant</var></span></kbd></dt>
<dd><p>将浮点常量作为单精度常量处理,而不是将其隐式转换为双精度常量。</p>
</dd>
<dt><kbd><span class="option">-f<var>cx-limited-range</var></span></kbd></dt>
<dd><p>启用后，此选项表明执行复杂除法时不需要范围缩小步骤。此外，也没有检查复数乘法或除法的结果是否为 NaN + I*NaN ，从而试图挽救这种情况。默认是-fno-cx-limited-range，但已启用-ffast-math.</p>
<p>此选项控制ISO C99 CX_LIMITED_RANGE 编译指示的默认设置。但是，该选项适用于所有语言。</p>
</dd>
<dt><kbd><span class="option">-f<var>cx-fortran-rules</var></span></kbd></dt>
<dd><p>复杂的乘法和除法遵循Fortran规则。范围缩小是复数除法的一部分，但是没有检查复数乘法或除法的结果是否为 NaN + I*NaN ，从而试图挽救这种情况。</p>
<p>默认为-fno-cx-fortran-rules.</p>
</dd>
</dl>
<p>以下选项控制了可能会提高性能的优化,但不是由任何一个选项启用的-O选项。本节包括可能会产生错误代码的实验性选项。</p>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>branch-probabilities</var></span></kbd></dt>
<dd><p>在运行一个用-fprofile-arcs（请参见Instrumentation Options），您可以使用进行第二次编译-fbranch-probabilities，以根据每个分支的使用次数来改善优化。当程序编译时-fprofile-arcs退出时,它将弧线执行次数保存到一个名为sourcename.gcda为每个源文件。这个数据文件中的信息非常依赖于生成代码的结构,所以你必须在两个编译中使用相同的源代码和相同的优化选项。</p>
<p>With-fbranch-probabilities，GCC将“REG_BR_PROB’每个注’JUMP_INSN’和’CALL_INSN’。这些可以用来改善优化。当前，它们仅在一个地方使用：reorg.c，而不是猜测分支最有可能采用的路径，REG_BR_PROB值用于准确确定更常采用的路径。</p>
<p>通过以下方式启用-fprofile-useand-fauto-profile.</p>
</dd>
<dt><kbd><span class="option">-f<var>profile-values</var></span></kbd></dt>
<dd><p>如果结合-fprofile-arcs，它添加了代码，以便收集有关程序中表达式值的一些数据。</p>
<p>With-fbranch-probabilities，它会读取从表达式的分析值收集的数据，以用于优化。</p>
<p>通过以下方式启用-fprofile-generate,-fprofile-use， 和-fauto-profile.</p>
</dd>
<dt><kbd><span class="option">-f<var>profile-reorder-functions</var></span></kbd></dt>
<dd><p>基于剖面仪的函数重排序收集函数的首次执行时间,并按升序排列这些函数。</p>
<p>启用了-fprofile-use.</p>
</dd>
<dt><kbd><span class="option">-f<var>vpt</var></span></kbd></dt>
<dd><p>如果结合-fprofile-arcs，此选项指示编译器添加代码以收集有关表达式值的信息。</p>
<p>With-fbranch-probabilities，它会回读收集到的数据，并根据这些数据实际执行优化。当前，优化包括使用有关分母值的知识来进行除法运算的专业化。</p>
<p>启用了-fprofile-useand-fauto-profile.</p>
</dd>
<dt><kbd><span class="option">-f<var>rename-registers</var></span></kbd></dt>
<dd><p>尝试通过使用寄存器分配后剩余的寄存器来避免调度代码中的虚假依赖关系。这种优化最有利于拥有大量寄存器的处理器。但是，根据目标采用的调试信息格式，由于变量不再停留在“本地寄存器”中，它可能使调试变得不可能。</p>
<p>默认启用-funroll-loops.</p>
</dd>
<dt><kbd><span class="option">-f<var>schedule-fusion</var></span></kbd></dt>
<dd><p>在指令流上执行目标依赖性传递,将相同类型的指令调度在一起,因为目标机如果在指令流中相邻,可以更有效地执行这些指令。</p>
<p>启用的级别-O2,-O3,-Os.</p>
</dd>
<dt><kbd><span class="option">-f<var>tracer</var></span></kbd></dt>
<dd><p>进行尾部复制,扩大超级块的大小。这种转换简化了函数的控制流程,使其他优化工作能够更好地进行。</p>
<p>通过以下方式启用-fprofile-useand-fauto-profile.</p>
</dd>
<dt><kbd><span class="option">-f<var>unroll-loops</var></span></kbd></dt>
<dd><p>释放循环,其迭代次数可以在编译时或进入循环时确定。-funroll-loopsimplies-frerun-cse-after-loop,-fweband-frename-registers。它还打开了完整的循环剥离（即以少量恒定的迭代次数完全除去循环）。此选项使代码更大，并且可能会或可能不会使它运行得更快。</p>
<p>通过以下方式启用-fprofile-useand-fauto-profile.</p>
</dd>
<dt><kbd><span class="option">-f<var>unroll-all-loops</var></span></kbd></dt>
<dd><p>释放所有的循环,即使在进入循环时它们的迭代次数不确定。这通常会使程序运行更慢。-funroll-all-loops意味着同样的选择-funroll-loops.</p>
</dd>
<dt><kbd><span class="option">-f<var>peel-loops</var></span></kbd></dt>
<dd><p>剥离那些有足够信息表明它们不会滚动的环路(从轮廓反馈或静态分析)。它还可以开启完整的环路剥离(即用少量的恒定迭代次数完全去除环路)。</p>
<p>通过以下方式启用-O3,-fprofile-use， 和-fauto-profile.</p>
</dd>
<dt><kbd><span class="option">-f<var>move-loop-invariants</var></span></kbd></dt>
<dd><p>启用RTL循环优化器中的循环不变运动通道。启用级别-O1及以上,除-Og.</p>
</dd>
<dt><kbd><span class="option">-f<var>split-loops</var></span></kbd></dt>
<dd><p>如果循环包含一个条件，该条件对于迭代空间的一侧始终为true，而对于另一侧则始终为false，则将其分为两部分。</p>
<p>通过以下方式启用-fprofile-useand-fauto-profile.</p>
</dd>
<dt><kbd><span class="option">-f<var>unswitch-loops</var></span></kbd></dt>
<dd><p>将具有循环不变条件的分支移出循环,两个分支上的循环重复(根据条件的结果修改)。</p>
<p>通过以下方式启用-fprofile-useand-fauto-profile.</p>
</dd>
<dt><kbd><span class="option">-f<var>version-loops-for-strides</var></span></kbd></dt>
<dd><p>如果一个循环在一个有变量跨度的数组上迭代,那么创建另一个版本的循环,假设跨度总是1。例如:如果在一个数组上迭代一个变量stride,那么创建另一个版本的循环,假设stride总是一。</p>
</dd>
</dl>
<p>-ffunction-sections
-fdata-sections</p>
<blockquote>
<div><p>如果目标支持任意部分，则将每个函数或数据项放入输出文件中其自己的部分中。函数的名称或数据项的名称决定了输出文件中该节的名称。</p>
<p>在链接器可以进行优化以提高指令空间中引用的位置性的系统上使用这些选项。大多数使用ELF对象格式的系统的链接器都具有这样的优化功能。在AIX上,链接器会根据调用图重新排列部分(CSECT)。对性能的影响各不相同。</p>
<p>再加上链接器的垃圾收集(linker–gc-sections选项)这些选项可能会导致更小的静态链接的可执行文件(剥离后)。</p>
<p>在ELF/DWARF系统上,这些选项不会降低调试信息的质量。其他对象文件/调试信息格式可能会有问题。</p>
<p>只有在这样做有显著好处的时候才使用这些选项。当你指定这些选项时,汇编器和链接器会创建较大的对象文件和可执行文件,而且速度也较慢。这些选项会影响代码的生成。它们防止编译器和汇编器使用翻译单元内的相对位置进行优化,因为在链接时间之前,这些位置是未知的。这种优化的一个例子是放宽对短调用指令的调用。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>stdarg-opt</var></span></kbd></dt>
<dd><p>优化变量参数函数的序言,对这些参数的用法进行优化。</p>
</dd>
<dt><kbd><span class="option">-f<var>section-anchors</var></span></kbd></dt>
<dd><p>通过使用共享的“锚点”符号来寻址附近的对象，尝试减少符号地址的计算数量。这种转换可以帮助减少某些目标上的GOT条目和GOT访问次数。</p>
<p>例如，执行以下函数 foo ：</p>
</dd>
</dl>
<p>-fzero-call-used-regs=choice</p>
<blockquote>
<div><p>在函数返回时调用的寄存器为零,通过减轻面向返回的编程(ROP)攻击或防止通过寄存器的信息泄漏来提高程序的安全性。</p>
<p>choice 的可能值与 zero_call_used_regs 属性相同（请参阅函数属性）。默认值为 ‘skip’.</p>
<p>您可以通过使用函数属性 zero_call_used_regs （请参阅函数属性）来控制特定函数的此行为。</p>
</div></blockquote>
<p>–param name=value</p>
<blockquote>
<div><p>在某些地方,GCC使用各种常量来控制优化的数量。例如,GCC不内联包含超过一定数量指令的函数。您可以在命令行中使用–paramoption.</p>
<p>特定参数的名称和值的含义与编译器的内部结构有关,在未来的版本中可能会发生变化,恕不另行通知。</p>
<p>为了获得参数的最小值、最大值和默认值,可以使用–help =参数-Qoptions.</p>
<p>在每种情况下，该 value 整数。所有目标均可识别以下 name 选择：</p>
<p>predictable-branch-outcome</p>
<blockquote>
<div><p>当预测采取分支的概率低于这个阈值(单位:%)时,则认为其可预测性良好。</p>
</div></blockquote>
<p>max-rtl-if-conversion-insns</p>
<blockquote>
<div><p>RTL if-conversion 试图删除一个块周围的条件分支,并用条件执行的指令替换它们。这个参数给出了一个块中应该被考虑进行if转换的最大指令数。编译器也会使用其他的启发式方法来决定if-conversion是否可能有利可图。</p>
</div></blockquote>
<p>max-rtl-if-conversion-predictable-cost</p>
<blockquote>
<div><p>RTL if-conversion将尝试删除块周围的条件分支,并用条件执行的指令替换。这些参数给出了if-conversion生成的序列的最大允许成本,这取决于分支是否被静态确定为可预测。这个参数的单位与GCC内部的seq_cost度量的单位相同。编译器将尝试使用BRANCH_COST目标宏为这个参数提供一个合理的默认值。</p>
</div></blockquote>
<p>max-crossjump-edges</p>
<blockquote>
<div><p>考虑交叉跳转的最大传入边数。使用的算法是-fcrossjumping传入每个块的边数为O（N ^ 2）。值的增加意味着更积极的优化，从而使编译时间增加，而可执行文件的大小可能略有改善。</p>
</div></blockquote>
<p>min-crossjump-insns</p>
<blockquote>
<div><p>在对两个块进行交叉跳转之前,必须在两个块的末尾匹配的指令的最少数量。在交叉跳转的块中所有指令都被匹配的情况下,该值被忽略。</p>
</div></blockquote>
<p>max-grow-copy-bb-insns</p>
<blockquote>
<div><p>复制基本块而不是跳转时的最大代码大小扩展因子。膨胀系数是相对于跳转指令而言的。</p>
</div></blockquote>
<p>max-goto-duplication-insns</p>
<blockquote>
<div><p>复制到跳转到计算的goto的块的最大指令数。为了避免多次通过O（N ^ 2）行为，GCC因子会在编译过程的早期就计算出goto，并尽可能晚地取消分解。仅在基本块末尾的计算跳转（不超过max-goto-duplication-insns）是未分解的。</p>
</div></blockquote>
<p>max-delay-slot-insn-search</p>
<blockquote>
<div><p>寻找填补延迟槽的指令时,要考虑的最大指令数。如果搜索的指令数量超过这个任意数量,那么填补延迟槽所节省的时间就微乎其微,所以停止搜索。数值越大,意味着更积极的优化,使得编译时间增加,而执行时间可能改善不大。</p>
</div></blockquote>
<p>max-delay-slot-live-search</p>
<blockquote>
<div><p>当试图填补延迟槽时,搜索具有有效实时寄存器信息的块时,要考虑的最大指令数。增加这个任意选择的值意味着更积极的优化,增加编译时间。当重写延迟槽代码以保持控制流图时,应删除该参数。</p>
</div></blockquote>
<p>max-gcse-memory</p>
<blockquote>
<div><p>可以分配以执行全局公共子表达式消除优化的近似最大内存量（以 kB 为单位）。如果需要比指定更多的内存，则不会进行优化。</p>
</div></blockquote>
<p>max-gcse-insertion-ratio</p>
<blockquote>
<div><p>如果对任何表达式来说,表达式插入与删除的比例大于这个值,那么RTL PRE就会插入或删除表达式,从而在指令流中留下部分冗余计算。</p>
</div></blockquote>
<p>max-pending-list-length</p>
<blockquote>
<div><p>在刷新当前状态并重新开始之前,调度允许的最大挂起依赖数量。分支或调用较少的大型函数可能会创建过大的列表,从而无谓地消耗内存和资源。</p>
</div></blockquote>
<p>max-modulo-backtrack-attempts</p>
<blockquote>
<div><p>调度器在模数调度一个循环时,应该进行的最大回溯尝试次数。数值越大,编译时间就会成倍增加。</p>
</div></blockquote>
<p>max-inline-insns-single</p>
<blockquote>
<div><p>几个参数控制GCC中使用的树内衬。此数字设置树内联器考虑用于内联的单个函数中的最大指令数（以GCC内部表示方式计数）。这仅影响内联声明的函数和在类声明（C ++）中实现的方法。</p>
</div></blockquote>
<p>max-inline-insns-auto</p>
<blockquote>
<div><p>当你使用-finline-functions（包括在-O3），研究了编译器本来不会考虑进行内联的许多函数。与内联声明的函数相比，可以对这些函数应用不同的（更严格的）限制（–param max-inline-insns-auto).</p>
</div></blockquote>
<p>max-inline-insns-small</p>
<blockquote>
<div><p>这个约束适用于被认为是相关的调用与-finline-small-functions.</p>
</div></blockquote>
<p>max-inline-insns-size</p>
<blockquote>
<div><p>这适用于对大小进行优化的调用。小规模的增长可能是可取的,以预测内联所带来的优化机会。</p>
</div></blockquote>
<p>uninlined-function-insns</p>
<blockquote>
<div><p>inliner占函数开销的指令数,如函数序幕和尾声。</p>
</div></blockquote>
<p>uninlined-function-time</p>
<blockquote>
<div><p>额外的时间由inliner计入函数开销,如执行函数序幕和尾声所需的时间。</p>
</div></blockquote>
<p>inline-heuristics-hint-percent</p>
<blockquote>
<div><p>适用于以下方面的比额表(百分比)inline-insns-single,inline-insns-single-O2,inline-insns-auto当内联式启发式提示内联式非常有利可图时(将实现后期优化)。</p>
</div></blockquote>
<p>uninlined-thunk-insns
uninlined-thunk-time</p>
<blockquote>
<div><p>同理–param内联函数-insnsand–param内联函数时间但适用于函数thunks</p>
</div></blockquote>
<p>inline-min-speedup</p>
<blockquote>
<div><p>当估计的调用者+被调用者运行时间的性能提升超过这个阈值(百分比)时,函数可以内联,而不考虑对该函数的限制。–param max-inline-insns-单and–param max-inline-insns-auto.</p>
</div></blockquote>
<p>large-function-insns</p>
<blockquote>
<div><p>指定真正大函数的限制。对于内联后大于此限值的函数,内联的限制条件是–param大功能增长。该参数主要用于避免后端使用的非线性算法导致的过度编译时间。</p>
</div></blockquote>
<p>large-function-growth</p>
<blockquote>
<div><p>指定由内衬引起的大函数的最大增长,单位为百分数。例如,参数值100限制大函数增长到原来的2.0倍。</p>
</div></blockquote>
<p>large-unit-insns</p>
<blockquote>
<div><p>指定大翻译单位的限制。大于此限制的单位内嵌引起的增长受以下限制–param inline-unit-growth。对于小型单元，这可能太紧了。例如，考虑一个由内联函数A和仅调用A三次的B组成的单元。如果B相对于A小，则单位增长率为300％，但是这种内联非常理智。但是，对于由小的可内联函数组成的非常大的单元，需要整个单元的增长限制，以避免代码大小呈指数级增长。因此，对于较小的单元，尺寸会增加到–param large-unit-insns申请前–param inline-unit-growth.</p>
</div></blockquote>
<p>lazy-modules</p>
<blockquote>
<div><p>懒惰加载时并发打开的C++模块文件的最大数量。</p>
</div></blockquote>
<p>inline-unit-growth</p>
<blockquote>
<div><p>指定内联导致的编译单元的最大整体增长。例如,参数值20限制了单元增长到原始大小的1.2倍。冷函数(通过属性或配置文件反馈标记为冷函数)不计入单元大小。</p>
</div></blockquote>
<p>ipa-cp-unit-growth</p>
<blockquote>
<div><p>指定由程序间常数传播引起的编译单元的最大整体增长。例如,参数值10将单位增长限制为原始大小的1.1倍。</p>
</div></blockquote>
<p>ipa-cp-large-unit-insns</p>
<blockquote>
<div><p>IPA-CP通认为大的翻译单元的大小。</p>
</div></blockquote>
<p>large-stack-frame</p>
<blockquote>
<div><p>规定大堆栈框架的限制。在内联时,算法尽量不要超过这个限制太多。</p>
</div></blockquote>
<p>large-stack-frame-growth</p>
<blockquote>
<div><p>以百分比为单位,指定由inlining引起的大堆栈框架的最大增长。例如,参数值1000限制了大堆栈框架的增长,使其达到原始大小的11倍。</p>
</div></blockquote>
<p>max-inline-insns-recursive
max-inline-insns-recursive-auto</p>
<blockquote>
<div><p>指定自递归内联函数的行外副本通过执行递归内联可以成长为的最大指令数。</p>
<p class="attribution">—param max-inline-insns-递归适用于内联声明的函数。对于没有内联声明的函数,递归内联只在以下情况下发生-finline-functions（包括在-O3）已启用；–param max-inline-insns-递归自动取而代之的是适用。</p>
</div></blockquote>
<p>max-inline-recursive-depth
max-inline-recursive-depth-auto</p>
<blockquote>
<div><p>指定用于递归内联的最大递归深度。</p>
<p class="attribution">—param max-inline-递归深度适用于内联声明的函数。对于没有内联声明的函数,递归内联只在以下情况下发生-finline-functions（包括在-O3）已启用；–param max-inline-递归深度自动取而代之的是适用。</p>
</div></blockquote>
<p>min-inline-recursive-probability</p>
<blockquote>
<div><p>递归内联只对平均递归程度较深的函数有利,对于递归程度不深的函数,由于增加了函数体的序幕大小或复杂度,会对其他优化器造成伤害。</p>
<p>当配置文件反馈可用时(见-fprofile-generate）的实际递归深度可以通过函数通过给定调用表达式递归的概率来猜测。此参数仅将内联限制为概率超过给定阈值（以百分比为单位）的调用表达式。</p>
</div></blockquote>
<p>early-inlining-insns</p>
<blockquote>
<div><p>指定早期内联器可以做出的增长。实际上,它增加了具有较大抽象惩罚的代码的内联量。</p>
</div></blockquote>
<p>max-early-inliner-iterations</p>
<blockquote>
<div><p>早期内联器的迭代限制。这基本上限制了早期内联器可以解析的嵌套间接调用的次数。更深的链仍由后期内联处理。</p>
</div></blockquote>
<p>comdat-sharing-probability</p>
<blockquote>
<div><p>具有comdat可见性的C++内联函数被多个编译单元共享的概率(百分比)。</p>
</div></blockquote>
<p>modref-max-bases
modref-max-refs
modref-max-accesses</p>
<blockquote>
<div><p>指定通过mod/ref分析为单个函数存储的基础指针、引用和访问的最大数量。</p>
</div></blockquote>
<p>modref-max-tests</p>
<blockquote>
<div><p>指定alias oracle使用mod/ref信息对内存位置进行区分的最大测试数量。这个参数应该大于–param modref-max-basesand–param modref-max-refs.</p>
</div></blockquote>
<p>modref-max-depth</p>
<blockquote>
<div><p>指定modref逃逸分析所使用的DFS行走的最大深度。设置为0可以完全禁用该分析。</p>
</div></blockquote>
<p>modref-max-escape-points</p>
<blockquote>
<div><p>指定每个SSA名称中由modref追踪的最大逃逸点数量。</p>
</div></blockquote>
<p>profile-func-internal-id</p>
<blockquote>
<div><p>一个参数,用于控制是否在配置文件数据库查询中使用函数内部id。如果值为0,编译器会使用一个基于函数汇编器名和文件名的id,这使得旧的profile数据对函数重新排序等源码变化的容忍度更高。</p>
</div></blockquote>
<p>min-vect-loop-bound</p>
<blockquote>
<div><p>循环不被矢量化的最小迭代次数,当-ftree-vectorize被使用。矢量化后的迭代次数需要大于这个选项指定的值,才能允许矢量化。</p>
</div></blockquote>
<p>gcse-cost-distance-ratio</p>
<blockquote>
<div><p>GCSE优化计算一个表达式可以移动的最大距离时的缩放因子。目前只在代码提升通证中支持。比值越大,对于简单的表达式,即成本小于的表达式,代码提升越积极。gcse-unrestricted-cost。指定0将禁用简单表达式的提升。</p>
</div></blockquote>
<p>gcse-unrestricted-cost</p>
<blockquote>
<div><p>成本,大致以单条典型机器指令的成本来衡量,在这个成本下,GCSE优化不会约束一个表达式可以走的距离。目前只在代码提升通中支持。成本越小,代码提升越激进。指定0可以让所有的表达式走过的距离不受限制。</p>
</div></blockquote>
<p>max-hoist-depth</p>
<blockquote>
<div><p>在主导树中搜索要提升的表达式的深度。这个值是用来避免葫芦算法中的二次元行为。值为0不会限制搜索深度,但可能会减慢巨大函数的编译速度。</p>
</div></blockquote>
<p>max-tail-merge-comparisons</p>
<blockquote>
<div><p>比较相似的bbs的最大数量。这是为了避免树尾合并中的二次元行为。</p>
</div></blockquote>
<p>max-tail-merge-iterations</p>
<blockquote>
<div><p>pass over函数的最大迭代量。用于限制树尾合并的编译时间。</p>
</div></blockquote>
<p>store-merging-allow-unaligned</p>
<blockquote>
<div><p>在合法的情况下,允许店铺合并通引入不结盟店铺。</p>
</div></blockquote>
<p>max-stores-to-merge</p>
<blockquote>
<div><p>门店合并通行证中尝试合并成更广泛的门店的最大数量。</p>
</div></blockquote>
<p>max-store-chains-to-track</p>
<blockquote>
<div><p>在商店合并通道中试图将其合并为更广泛的商店时,同时追踪的最大商店链的数量。</p>
</div></blockquote>
<p>max-stores-to-track</p>
<blockquote>
<div><p>在商店合并过程中试图将它们合并成更大的商店时,同时追踪的最大商店数量。</p>
</div></blockquote>
<p>max-unrolled-insns</p>
<blockquote>
<div><p>一个循环可能要被展开的最大指令数。如果一个循环被展开,这个参数也决定了循环代码被展开的次数。</p>
</div></blockquote>
<p>max-average-unrolled-insns</p>
<blockquote>
<div><p>循环可能要被取消滚动的最大指令数,偏重于其执行的概率。如果一个循环被展开,这个参数也决定了循环代码被展开的次数。</p>
</div></blockquote>
<p>max-unroll-times</p>
<blockquote>
<div><p>单个循环的最大开卷次数。</p>
</div></blockquote>
<p>max-peeled-insns</p>
<blockquote>
<div><p>一个循环可能需要剥离的最大指令数。如果一个循环被剥离,这个参数也决定了循环代码被剥离的次数。</p>
</div></blockquote>
<p>max-peel-times</p>
<blockquote>
<div><p>单个环路的最大剥皮次数。</p>
</div></blockquote>
<p>max-peel-branches</p>
<blockquote>
<div><p>通过剥离序列的热路径上的最大分支数。</p>
</div></blockquote>
<p>max-completely-peeled-insns</p>
<blockquote>
<div><p>一个完全剥离的循环的最大ins数。</p>
</div></blockquote>
<p>max-completely-peel-times</p>
<blockquote>
<div><p>循环的最大迭代次数,以适合完全剥离。</p>
</div></blockquote>
<p>max-completely-peel-loop-nest-depth</p>
<blockquote>
<div><p>适宜完全剥离的环形窝的最大深度。</p>
</div></blockquote>
<p>max-unswitch-insns</p>
<blockquote>
<div><p>一个无开关环路的最大insn数。</p>
</div></blockquote>
<p>max-unswitch-level</p>
<blockquote>
<div><p>单个回路中未切换的最大分支数。</p>
</div></blockquote>
<p>lim-expensive</p>
<blockquote>
<div><p>循环不变运动中昂贵的表达方式的最小成本。</p>
</div></blockquote>
<p>min-loop-cond-split-prob</p>
<blockquote>
<div><p>当有FDO资料时。min-loop-cond-split-prob指定触发循环拆分的半不变条件语句概率的最小阈值。</p>
</div></blockquote>
<p>iv-consider-all-candidates-bound</p>
<blockquote>
<div><p>归纳变量候选数的约束,低于此数的候选数在归纳变量优化中的每次使用都会被考虑。如果候选变量的数量多于此数,则只考虑最相关的候选变量,以避免二次元时间的复杂性。</p>
</div></blockquote>
<p>iv-max-considered-uses</p>
<blockquote>
<div><p>归纳变量优化放弃了包含较多归纳变量用法的循环。</p>
</div></blockquote>
<p>iv-always-prune-cand-set-bound</p>
<blockquote>
<div><p>如果集合中的候选人数量小于这个值,在添加新的候选人时,一定要尽量从集合中删除不必要的ivs。</p>
</div></blockquote>
<p>avg-loop-niter</p>
<blockquote>
<div><p>循环的平均迭代次数。</p>
</div></blockquote>
<p>dse-max-object-size</p>
<blockquote>
<div><p>通过消除死存储逐个跟踪的对象的最大尺寸(字节)。值越大,编译时间越长。</p>
</div></blockquote>
<p>dse-max-alias-queries-per-store</p>
<blockquote>
<div><p>每个存储对别名oracle的最大查询次数。数值越大,编译时间越长,可能导致更多的死存储被删除。</p>
</div></blockquote>
<p>scev-max-expr-size</p>
<blockquote>
<div><p>对标量演化分析器中使用的表达式大小进行约束。大的表达式会减慢分析器的速度。</p>
</div></blockquote>
<p>scev-max-expr-complexity</p>
<blockquote>
<div><p>对标量演化分析器中表达式的复杂性进行约束。复杂的表达式会减慢分析器的速度。</p>
</div></blockquote>
<p>max-tree-if-conversion-phi-args</p>
<blockquote>
<div><p>如果转换的话,TREE支持的PHI中的最大参数数,除非循环用simd pragma标记。</p>
</div></blockquote>
<p>vect-max-version-for-alignment-checks</p>
<blockquote>
<div><p>在向量器中进行循环版本对齐时,可以执行的最大运行时检查次数。</p>
</div></blockquote>
<p>vect-max-version-for-alias-checks</p>
<blockquote>
<div><p>在向量器中对别名进行循环版本化时,可以执行的最大运行时检查次数。</p>
</div></blockquote>
<p>vect-max-peeling-for-alignment</p>
<blockquote>
<div><p>循环剥离的最大次数,用于增强向量器的访问对齐。值-1表示没有限制。</p>
</div></blockquote>
<p>max-iterations-to-track</p>
<blockquote>
<div><p>循环的最大迭代次数的蛮力算法分析循环的迭代次数尝试评估。</p>
</div></blockquote>
<p>hot-bb-count-fraction</p>
<blockquote>
<div><p>在整个程序中,基本块的最大执行次数的分数1/n的分母n,一个基本块至少需要有这个分母才能被认为是热块。默认值是10000,也就是说,如果一个基本块的执行数大于最大执行数的1/10000,则被认为是热块。0意味着它永远不会被认为是热块,在非LTO模式下使用。在非LTO模式下使用。</p>
</div></blockquote>
<p>hot-bb-count-ws-permille</p>
<blockquote>
<div><p>基本块的执行次数必须是整个程序的最多执行次数的permilles的一部分,范围从0到1000不等,才能被认为是热块。默认值是990,这意味着如果一个基本块的执行次数占整个程序的上990个permilles,或者说占整个程序的99.0%,那么它就被认为是热块。0意味着它永远不会被认为是热块。在LTO模式下使用。</p>
</div></blockquote>
<p>hot-bb-frequency-fraction</p>
<blockquote>
<div><p>函数入口块执行频率的分数1/n的分母n,这个函数的基本块至少需要有这个分母才能被认为是热块。默认值为1000,即如果一个基本块的执行频率超过函数入口块频率的1/1000,则该函数中的基本块被认为是热的。0意味着它永远不会被认为是热函数。</p>
</div></blockquote>
<p>unlikely-bb-count-fraction</p>
<blockquote>
<div><p>整个程序的运行次数的分数1/n的分母n,基本块的执行次数必须低于这个分数,才能认为基本块不太可能被执行。默认值是20,这意味着如果一个基本块的执行次数少于程序运行次数的1/20,或5%,则被认为不太可能被执行。0意味着它总是被认为不可能被执行。</p>
</div></blockquote>
<p>max-predicted-iterations</p>
<blockquote>
<div><p>我们静态预测的最大循环迭代次数。这在一个函数包含一个已知边界的单循环和另一个未知边界的循环的情况下很有用。已知的迭代次数被正确预测,而未知的迭代次数平均约为10。这意味着,相对于另一个循环,没有边界的循环显得人为地冷清。</p>
</div></blockquote>
<p>builtin-expect-probability</p>
<blockquote>
<div><p>控制表达式具有指定值的概率。该参数采用百分比(即0 …100)作为输入。</p>
</div></blockquote>
<p>builtin-string-cmp-inline-length</p>
<blockquote>
<div><p>符合内联条件的内置字符串cmp调用的常量字符串的最大长度。</p>
</div></blockquote>
<p>align-threshold</p>
<blockquote>
<div><p>选择函数中基本块的最大执行频率的分数来对齐基本块。</p>
</div></blockquote>
<p>align-loop-iterations</p>
<blockquote>
<div><p>一个预期至少迭代选定次数的循环是对齐的。</p>
</div></blockquote>
<p>tracer-dynamic-coverage
tracer-dynamic-coverage-feedback</p>
<blockquote>
<div><p>这个值用于限制超级块的形成,一旦覆盖给定百分比的已执行指令。这限制了不必要的代码大小扩展。</p>
<p>Thetracer-dynamic-coverage-feedback参数仅在有剖面反馈时使用。真实的剖面(与静态估计的剖面相比)的平衡性要小得多,允许阈值较大。</p>
</div></blockquote>
<p>tracer-max-code-growth</p>
<blockquote>
<div><p>一旦代码增长达到给定的百分比,就停止尾部重复。这是一个相当人为的限制,因为大部分的重复都会在以后的交叉跳转中被消除,所以它可能被设置为比期望的代码增长高得多的值。</p>
</div></blockquote>
<p>tracer-min-branch-ratio</p>
<blockquote>
<div><p>当最佳边缘的反向概率小于此阈值时,停止反向增长(单位:%)。</p>
</div></blockquote>
<p>tracer-min-branch-probability
tracer-min-branch-probability-feedback</p>
<blockquote>
<div><p>如果最佳边缘的概率低于这个阈值,则停止向前生长。</p>
<p>类似于tracer-dynamic-coverage提供了两个参数。tracer-min-branch-probability-feedback用于编译时,有轮廓反馈和tracer-min-branch-probability编译没有。有剖面反馈的编译值需要更保守(更高),以使跟踪器有效。</p>
</div></blockquote>
<p>stack-clash-protection-guard-size</p>
<blockquote>
<div><p>将操作系统提供的堆栈保护的大小指定为2（增加到 num 个字节）。较高的值可能会减少显式探针的数量，但是该值大于操作系统提供的保护措施后，将使代码容易受到堆栈冲突样式攻击。</p>
</div></blockquote>
<p>stack-clash-protection-probe-interval</p>
<blockquote>
<div><p>堆栈冲突保护涉及在分配堆栈空间时对其进行探测。该参数控制探针到堆栈中的最大距离，将2提升到 num 个字节。较高的值可能会减少显式探针的数量，但是该值大于操作系统提供的保护措施后，将使代码容易受到堆栈冲突样式攻击。</p>
</div></blockquote>
<p>max-cse-path-length</p>
<blockquote>
<div><p>CSE考虑的路径上的最大基本块数。</p>
</div></blockquote>
<p>max-cse-insns</p>
<blockquote>
<div><p>冲洗前CSE处理的最大指令数。</p>
</div></blockquote>
<p>ggc-min-expand</p>
<blockquote>
<div><p>GCC使用垃圾回收器来管理自己的内存分配。此参数指定允许垃圾收集器的堆在收集之间扩展的最小百分比。进行调整可以提高编译速度；它对代码生成没有影响。</p>
<p>当RAM&gt; = 1GB时，默认值为30％+ 70％<a href="#id8"><span class="problematic" id="id9">*</span></a>（RAM / 1GB），上限为100％。如果 getrlimit 可用，则“ RAM”的概念是实际RAM和 RLIMIT_DATA 或 RLIMIT_AS 中的最小值。如果GCC无法在特定平台上计算RAM，则使用30％的下限。设置此参数和ggc-min-heapsize为零会导致每一次机会都会发生完整的收集。这非常慢,但对调试很有用。</p>
</div></blockquote>
<p>ggc-min-heapsize</p>
<blockquote>
<div><p>垃圾收集器开始费心收集垃圾之前的最小大小。第一个集合发生在堆扩展为ggc-min-expand超出％ggc-min-heapsize。同样，对此进行调整可以提高编译速度，并且对代码生成没有影响。</p>
<p>默认值是RAM/8、RLIMIT_RSS或试图确保不超过RLIMIT_DATA或RLIMIT_AS的限制中的较小值,但下限为4096(4兆),上限为131072(128兆)。如果GCC无法计算特定平台上的RAM,则使用下限。把这个参数设置得非常大,就会有效地禁止垃圾收集。设置这个参数和ggc-min-expand为零会导致每一次机会都会发生全面收集。</p>
</div></blockquote>
<p>max-reload-search-insns</p>
<blockquote>
<div><p>指令重载的最大次数应该向后看等效寄存器。增加数值意味着更积极的优化,使得编译时间增加,性能可能稍好。</p>
</div></blockquote>
<p>max-cselib-memory-locations</p>
<blockquote>
<div><p>cselib应该考虑的最大内存位置数。增加这个值意味着更积极的优化,使得编译时间增加,但性能可能略微提高。</p>
</div></blockquote>
<p>max-sched-ready-insns</p>
<blockquote>
<div><p>调度器在第一次调度时,在任何给定的时间都应该考虑的准备发出的指令的最大数量。增加数值意味着更彻底的搜索,使得编译时间增加,但可能没有什么好处。</p>
</div></blockquote>
<p>max-sched-region-blocks</p>
<blockquote>
<div><p>一个区域内考虑区块间调度的最大区块数。</p>
</div></blockquote>
<p>max-pipeline-region-blocks</p>
<blockquote>
<div><p>选择性调度器中考虑流水线的区域的最大块数。</p>
</div></blockquote>
<p>max-sched-region-insns</p>
<blockquote>
<div><p>一个区域内考虑进行区块间调度的最大insn数量。</p>
</div></blockquote>
<p>max-pipeline-region-insns</p>
<blockquote>
<div><p>在选择性调度器中,一个区域内考虑流水线的最大insn数量。</p>
</div></blockquote>
<p>min-spec-prob</p>
<blockquote>
<div><p>块间投机调度达到源块的最小概率(百分比)。</p>
</div></blockquote>
<p>max-sched-extend-regions-iters</p>
<blockquote>
<div><p>通过CFG扩展区域的最大迭代次数。值为0时,禁止扩展区域。</p>
</div></blockquote>
<p>max-sched-insn-conflict-delay</p>
<blockquote>
<div><p>在推测性动议中考虑的最大冲突延迟。</p>
</div></blockquote>
<p>sched-spec-prob-cutoff</p>
<blockquote>
<div><p>投机成功的最小概率(百分数),这样投机ins就被安排了。</p>
</div></blockquote>
<p>sched-state-edge-prob-cutoff</p>
<blockquote>
<div><p>一个边缘保存其状态的最小概率。</p>
</div></blockquote>
<p>sched-mem-true-dep-cost</p>
<blockquote>
<div><p>针对相同内存位置的存储和负载之间的最小距离(以CPU周期为单位)。</p>
</div></blockquote>
<p>selsched-max-lookahead</p>
<blockquote>
<div><p>选择性调度的看前窗口的最大尺寸。它是对可用指令的搜索深度。</p>
</div></blockquote>
<p>selsched-max-sched-times</p>
<blockquote>
<div><p>在选择性调度期间,指令的最大调度次数。这是对指令可以通过流水线的迭代次数的限制。</p>
</div></blockquote>
<p>selsched-insns-to-rename</p>
<blockquote>
<div><p>准备就绪列表中,在选择性调度器中考虑重命名的最佳指令的最大数量。</p>
</div></blockquote>
<p>sms-min-sc</p>
<blockquote>
<div><p>摆动模数调度器产生的阶段数的最小值。</p>
</div></blockquote>
<p>max-last-value-rtl</p>
<blockquote>
<div><p>伪寄存器的最后一个已知值,在组合器的表达式中,以可以记录的RTL数量衡量的最大尺寸。</p>
</div></blockquote>
<p>max-combine-insns</p>
<blockquote>
<div><p>RTL组合器尝试组合的最大指令数。</p>
</div></blockquote>
<p>integer-share-limit</p>
<blockquote>
<div><p>小整数常量可以使用共享的数据结构，从而减少了编译器的内存使用量并提高了速度。这将设置共享整数常量的最大值。</p>
</div></blockquote>
<p>ssp-buffer-size</p>
<blockquote>
<div><p>砸堆保护时,缓冲区(即数组)的最小尺寸。-fstack-protection是用。</p>
</div></blockquote>
<p>min-size-for-stack-sharing</p>
<blockquote>
<div><p>不优化时参加栈槽共享的变量的最小尺寸。</p>
</div></blockquote>
<p>max-jump-thread-duplication-stmts</p>
<blockquote>
<div><p>线程跳转时,一个块中允许重复的语句的最大数量。</p>
</div></blockquote>
<p>max-fields-for-field-sensitive</p>
<blockquote>
<div><p>在指针分析过程中,结构中以字段敏感方式处理的最大字段数。</p>
</div></blockquote>
<p>prefetch-latency</p>
<blockquote>
<div><p>估算预取结束前平均执行的指令数。前面预取的距离与这个常数成正比。增加这个数字也可能会导致预取的指令流减少(参见simultaneous-prefetches).</p>
</div></blockquote>
<p>simultaneous-prefetches</p>
<blockquote>
<div><p>可同时运行的最大预取数。</p>
</div></blockquote>
<p>l1-cache-line-size</p>
<blockquote>
<div><p>L1数据缓存中缓存行的大小,单位:字节。</p>
</div></blockquote>
<p>l1-cache-size</p>
<blockquote>
<div><p>L1数据缓存的大小,以千字节为单位。</p>
</div></blockquote>
<p>l2-cache-size</p>
<blockquote>
<div><p>L2数据缓存的大小,以千字节为单位。</p>
</div></blockquote>
<p>prefetch-dynamic-strides</p>
<blockquote>
<div><p>循环数组预取通是否应该对非恒定的跨步发出软件预取提示。在某些情况下,这样做可能是有益的,不过由于步长是非恒定的,所以很难预测何时发出这些提示有明显的好处。</p>
<p>设置为1,如果对非恒定步长发出预取提示。设置为0,如果只对已知的恒定和低于恒定的步长发出预取提示。prefetch-minimum-stride.</p>
</div></blockquote>
<p>prefetch-minimum-stride</p>
<blockquote>
<div><p>开始使用预取提示的最小常数跨度,以字节为单位。如果步长小于这个阈值,将不会发出预取提示。</p>
<p>这个设置对于有硬件预取器的处理器很有用,在这种情况下,硬件预取器和软件预取器之间可能会有冲突。如果硬件预取器有其能处理的最大步长,则应在此使用,以提高软件预取器的使用率。</p>
<p>值为-1表示我们没有阈值，因此可以为任何恒定步幅发出预取提示。</p>
<p>这个设置只对已知和恒定的步幅有用。</p>
</div></blockquote>
<p>loop-interchange-max-num-stmts</p>
<blockquote>
<div><p>循环中最大可交换的stmts数量。</p>
</div></blockquote>
<p>loop-interchange-stride-ratio</p>
<blockquote>
<div><p>两环之间的最小步距比,换乘才会有利可图。</p>
</div></blockquote>
<p>min-insn-to-prefetch-ratio</p>
<blockquote>
<div><p>指令数与预取数之间的最小比率,以实现循环中的预取。</p>
</div></blockquote>
<p>prefetch-min-insn-to-mem-ratio</p>
<blockquote>
<div><p>指令数和内存引用数之间的最小比率,以实现循环中的预取。</p>
</div></blockquote>
<p>use-canonical-types</p>
<blockquote>
<div><p>编译器是否应使用“规范”类型系统。应该始终为1，它使用更有效的内部机制来比较C ++和Objective-C ++中的类型。但是，如果规范类型系统中的错误导致编译失败，请将此值设置为0以禁用规范类型。</p>
</div></blockquote>
<p>switch-conversion-max-branch-ratio</p>
<blockquote>
<div><p>交换机初始化转换拒绝创建大于switch-conversion-max-branch-ratio乘以开关中的分支数。</p>
</div></blockquote>
<p>max-partial-antic-length</p>
<blockquote>
<div><p>在树部分冗余消除优化过程中计算出的部分反集的最大长度(-ftree-pre）在优化时-O3及以上。对于某些类型的源代码,增强型部分冗余消除优化可能会跑掉,消耗主机上所有的可用内存。这个参数设置了计算集的长度限制,可以防止失控行为。将该参数的值设置为0,可以实现无限制的集合长度。</p>
</div></blockquote>
<p>rpo-vn-max-loop-depth</p>
<blockquote>
<div><p>最佳数值编号的最大循环深度。当极限达到时，最内层的 rpo-vn-max-loop-depth 循环和最外层的循环嵌套中的值被乐观地编号，其余的则没有。</p>
</div></blockquote>
<p>sccvn-max-alias-queries-per-access</p>
<blockquote>
<div><p>在寻找负载和存储的冗余时,我们执行的别名-Oracle查询的最大次数。如果达到这个限制,搜索将被中止,负载或存储不被认为是冗余的。查询的次数在算法上被限制在从负载到函数条目的所有路径上的存储数量。</p>
</div></blockquote>
<p>ira-max-loops-num</p>
<blockquote>
<div><p>IRA默认使用区域寄存器分配。如果一个函数包含的循环数量超过了这个参数所给的数量,那么最多只有给定数量的最频繁执行的循环才会形成区域寄存器分配的区域。</p>
</div></blockquote>
<p>ira-max-conflict-table-size</p>
<blockquote>
<div><p>虽然IRA使用了一种复杂的算法来压缩冲突表,但对于巨大的函数来说,该表仍然需要过多的内存。如果一个函数的冲突表可能超过这个参数给出的MB大小,寄存器分配器就会使用更快、更简单、更低质量的算法,不需要建立伪寄存器冲突表。</p>
</div></blockquote>
<p>ira-loop-reserved-regs</p>
<blockquote>
<div><p>IRA可以用来评估环路中更精确的寄存器压力,以决定移动环路不变量(见图3)。-O3）。该参数给出了为其他目的保留的可用寄存器的数量。参数的默认值是从大量实验中得出的最佳值。</p>
</div></blockquote>
<p>lra-inheritance-ebb-probability-cutoff</p>
<blockquote>
<div><p>LRA试图在后续的ins中重用寄存器中的值。这种优化称为继承。EBB被用作一个区域来做这个优化。该参数定义了一个最小的落空边缘概率,以百分比为单位,用于在LRA中把BB添加到继承EBB中。默认值是从x86-64上SPEC2000的大量运行中选择的。</p>
</div></blockquote>
<p>loop-invariant-max-bbs-in-loop</p>
<blockquote>
<div><p>循环不变运动在编译时和所需的编译时内存量方面都非常昂贵，并且循环很大。基本块数超过此参数的循环将不会对其执行循环不变运动优化。</p>
</div></blockquote>
<p>loop-max-datarefs-for-datadeps</p>
<blockquote>
<div><p>对于非常大的循环来说,建立数据依赖性是很昂贵的。这个参数限制了在数据依赖性分析中考虑的循环中数据引用的数量。使用循环数据依赖的优化不会处理这些大型循环。</p>
</div></blockquote>
<p>max-vartrack-size</p>
<blockquote>
<div><p>设置在对任何函数进行变量跟踪数据流分析时使用的最大哈希表槽数。如果在启用变量跟踪赋值时超过了这个限制,那么在删除函数中的所有调试ins后,将在不使用该限制的情况下重试该函数的分析。如果在没有调试insns的情况下也超过了这个限制,则该函数的变量跟踪分析将被完全禁用。将该参数设置为0,则该参数不受限制。</p>
</div></blockquote>
<p>max-vartrack-expr-depth</p>
<blockquote>
<div><p>设置当试图将变量名或调试临时变量映射到值表达式时,递归级别的最大数量。这样可以用编译时间换取更完整的调试信息。如果这个值设置得太低,可用的、可以在调试信息中表示的值表达式可能最终不会被使用;设置得更高,可以使编译器找到更复杂的调试表达式,但编译时间和内存使用量可能会增加。</p>
</div></blockquote>
<p>max-debug-marker-count</p>
<blockquote>
<div><p>设置调试标记的数量阈值(例如:begin stmt标记),以避免在内联或扩展到RTL时出现复杂性爆炸。如果一个函数有更多这样的 gimple stmts 超过设定的限制,这些 stmts 将从函数的内联副本和 RTL 扩展中删除。</p>
</div></blockquote>
<p>min-nondebug-insn-uid</p>
<blockquote>
<div><p>对非调试ns使用以该参数开始的ids。该参数下面的范围是专门为由-fvar-tracking-assignments，但如果保留范围已用尽，则调试insns可能会在其上面获得（非重叠）uid。</p>
</div></blockquote>
<p>ipa-sra-ptr-growth-factor</p>
<blockquote>
<div><p>IPA-SRA只有当一个或多个新参数的累积大小小于或等于ipa-sra-ptr-growth-factor乘以原始指针参数的大小。</p>
</div></blockquote>
<p>ipa-sra-max-replacements</p>
<blockquote>
<div><p>IPA-SRA跟踪的集合的最大件数。因此,它也是一个形式参数的最大替换次数。</p>
</div></blockquote>
<p>sra-max-scalarization-size-Ospeed
sra-max-scalarization-size-Osize</p>
<blockquote>
<div><p>聚合体的两个标量缩减通道(SRA和IPA-SRA)旨在用独立标量变量的使用来替换聚合体的标量部分。这些参数控制了编译速度时考虑替换的聚合的最大尺寸,以存储单位为单位 (sra-max-scalarization-size-Ospeed）或尺寸（sra-max-scalarization-size-Osize） 分别。</p>
</div></blockquote>
<p>sra-max-propagations</p>
<blockquote>
<div><p>Scalar Replacement of Aggregates (SRA)为了便于复制传播,每一个局部变量将跟踪的最大人工访问次数。</p>
</div></blockquote>
<p>tm-max-aggregate-size</p>
<blockquote>
<div><p>当在事务中复制线程本地变量时,该参数指定了与保存/恢复代码序列对相比,变量与日志函数保存后的字节大小。这个选项只适用于在使用-fgnu-tm.</p>
</div></blockquote>
<p>graphite-max-nb-scop-params</p>
<blockquote>
<div><p>为了避免石墨环路变换中的指数效应,静态控制部分(SCoP)中的参数数量是有边界的。零的值可以用来解除这个约束。一个在编译时数值未知且在SCoP之外定义的变量是SCoP的参数。</p>
</div></blockquote>
<p>loop-block-tile-size</p>
<blockquote>
<div><p>循环阻断或带状开采变换,可通过以下方式实现。-floop-blockor-floop-strip-mine，以给定的迭代次数剥离循环嵌套中的每个循环。可以使用loop-block-tile-sizeparameter.</p>
</div></blockquote>
<p>ipa-jump-function-lookups</p>
<blockquote>
<div><p>指定发现跳转函数偏移时访问的语句数量。</p>
</div></blockquote>
<p>ipa-cp-value-list-size</p>
<blockquote>
<div><p>IPA-CP尝试跟踪传递给函数参数的所有可能的值和类型，以传播它们并执行虚拟化。ipa-cp-value-list-size是指它每一个函数的形式参数所存储的最大数值和类型数。</p>
</div></blockquote>
<p>ipa-cp-eval-threshold</p>
<blockquote>
<div><p>IPA-CP计算自己的克隆盈利启发式得分,并执行那些得分超过的克隆机会ipa-cp-eval-threshold.</p>
</div></blockquote>
<p>ipa-cp-max-recursive-depth</p>
<blockquote>
<div><p>自递归函数的最大深度递归克隆。</p>
</div></blockquote>
<p>ipa-cp-min-recursive-probability</p>
<blockquote>
<div><p>只有当调用被执行的概率超过参数时,才会递归克隆。</p>
</div></blockquote>
<p>ipa-cp-recursion-penalty</p>
<blockquote>
<div><p>当递归函数被评估为克隆时,它们将收到的惩罚百分比。</p>
</div></blockquote>
<p>ipa-cp-single-call-penalty</p>
<blockquote>
<div><p>包含对另一个函数的单次调用的函数在被评估为克隆函数时将收到的惩罚百分比。</p>
</div></blockquote>
<p>ipa-max-agg-items</p>
<blockquote>
<div><p>IPA-CP也能够传播一些集合中传递的标量值。ipa-max-agg-items控制每个参数的最大数值。</p>
</div></blockquote>
<p>ipa-cp-loop-hint-bonus</p>
<blockquote>
<div><p>当IPA-CP确定一个克隆候选者会使一个循环的迭代次数已知时,它就会增加一个额外的ipa-cp-loop-hint-bonus到考生的盈利能力得分。</p>
</div></blockquote>
<p>ipa-max-loop-predicates</p>
<blockquote>
<div><p>IPA将使用不同的谓词的最大数量来描述一个函数中的循环何时具有已知属性。</p>
</div></blockquote>
<p>ipa-max-aa-steps</p>
<blockquote>
<div><p>在分析函数体的过程中,IPA-CP采用了别名分析,以跟踪函数参数所指向的值。为了不花太多时间分析庞大的函数,它在检查完之后就放弃了,认为所有的内存都被抢光了。ipa-max-aa-steps修改内存的语句。</p>
</div></blockquote>
<p>ipa-max-switch-predicate-bounds</p>
<blockquote>
<div><p>switch 语句的 case 范围的最大边界端点数。对于超过这个限制的开关,IPA-CP将不会为开关语句的默认情况构建克隆成本谓词,该谓词用于估计克隆收益。</p>
</div></blockquote>
<p>ipa-max-param-expr-ops</p>
<blockquote>
<div><p>IPA-CP会对引用某个函数参数的条件语句进行分析,根据某个常量值来估计克隆的收益。但如果参数表达式中的操作次数超过了ipa-max-param-expr-ops，该表达式被视为复杂的表达式，无法通过IPA分析进行处理。</p>
</div></blockquote>
<p>lto-partitions</p>
<blockquote>
<div><p>指定在WHOPR编译过程中产生的分区数量。分区的数量应该超过用于编译的CPU数量。</p>
</div></blockquote>
<p>lto-min-partition</p>
<blockquote>
<div><p>WHOPR最小分区的大小(以估计指令为单位)。这可以避免将很小的程序分割到太多的分区。</p>
</div></blockquote>
<p>lto-max-partition</p>
<blockquote>
<div><p>WHOPR 的最大分区大小(以估计指令为单位),用于提供单个分区大小的上限。仅用于平衡分区。</p>
</div></blockquote>
<p>lto-max-streaming-parallelism</p>
<blockquote>
<div><p>用于LTO流的最大并行进程数。</p>
</div></blockquote>
<p>cxx-max-namespaces-for-diagnostic-help</p>
<blockquote>
<div><p>当一个标识符的C++名称查找失败时,可参考建议的名称空间的最大数量。</p>
</div></blockquote>
<p>sink-frequency-threshold</p>
<blockquote>
<div><p>目标块相对于语句的原始块的最大相对执行频率（以百分比为单位），以允许语句下沉一条语句。较大的数字会导致更激进的语句下沉。对于具有内存操作数的语句，将进行少量的正调整，因为这些语句甚至更有利可图，因此容易下沉。</p>
</div></blockquote>
<p>max-stores-to-sink</p>
<blockquote>
<div><p>可以下沉的条件存储对的最大数量。设为0,如果矢量化(-ftree-vectorize）或if-conversion（-ftree-loop-if-convert） 被禁用。</p>
</div></blockquote>
<p>case-values-threshold</p>
<blockquote>
<div><p>最好使用跳转表而不是条件分支树的不同值的最小数量。如果数值为0,则使用机器的默认值。</p>
</div></blockquote>
<p>jump-table-max-growth-ratio-for-size</p>
<blockquote>
<div><p>扩展到跳转表时的最大代码大小增长比率(百分比)。该参数在优化大小时使用。</p>
</div></blockquote>
<p>jump-table-max-growth-ratio-for-speed</p>
<blockquote>
<div><p>扩展到跳转表时的最大代码大小增长比率(百分比)。该参数在优化速度时使用。</p>
</div></blockquote>
<p>tree-reassoc-width</p>
<blockquote>
<div><p>设置重关联树中并行执行的最大指令数。如果该值不为零,该参数将覆盖默认使用的目标依赖性启发式算法。</p>
</div></blockquote>
<p>sched-pressure-algorithm</p>
<blockquote>
<div><p>在两个可用的-fsched-pressure。算法1是原始的实现，并且更有可能防止对指令进行重新排序。算法2设计为在算法1采取的相对保守方法与默认调度程序采取的比较激进的方法之间做出折衷。它更依赖于具有常规的寄存器文件和准确的寄存器压力等级。看到haifa-sched.c在海湾合作委员会的来源中了解更多细节。</p>
<p>默认选择取决于目标。</p>
</div></blockquote>
<p>max-slsr-cand-scan</p>
<blockquote>
<div><p>设置在寻求新的直线减员候选者基础时,考虑现有候选者的最大数量。</p>
</div></blockquote>
<p>asan-globals</p>
<blockquote>
<div><p>启用全局对象的缓冲区溢出检测。如果您使用了-fsanitize=address选项来禁用全局对象保护。要禁用全局对象保护,请使用–param asan-globals = 0.</p>
</div></blockquote>
<p>asan-stack</p>
<blockquote>
<div><p>启用堆栈对象的缓冲区溢出检测。这种保护默认在使用-fsanitize=address。要禁用堆栈保护，请使用–param asan-stack = 0option.</p>
</div></blockquote>
<p>asan-instrument-reads</p>
<blockquote>
<div><p>启用内存读取的缓冲区溢出检测。这种保护默认在使用-fsanitize=address。禁用内存读取保护使用–param asan-instrument-reads = 0.</p>
</div></blockquote>
<p>asan-instrument-writes</p>
<blockquote>
<div><p>启用内存写入的缓冲区溢出检测。这种保护默认在使用-fsanitize=address。禁用内存写保护使用–param asan-instrument-writes = 0option.</p>
</div></blockquote>
<p>asan-memintrin</p>
<blockquote>
<div><p>启用内置功能的检测。当您使用-fsanitize=address。要禁用内置功能保护，请使用–param asan-memintrin = 0.</p>
</div></blockquote>
<p>asan-use-after-return</p>
<blockquote>
<div><p>启用检测返回后的使用。这种保护在使用-fsanitize=address选项。要禁用它,请使用–param asan-use-after-return = 0.</p>
<p>注意：默认情况下，该检查在运行时处于禁用状态。要启用它，请将 detect_stack_use_after_return=1 添加到环境变量 ASAN_OPTIONS 中。</p>
</div></blockquote>
<p>asan-instrumentation-with-call-threshold</p>
<blockquote>
<div><p>如果被检测的函数的内存访问次数大于或等于这个数字,则使用回调代替内联检查。例如,如果要禁用内联代码,可以使用 “回调 “来代替内联检查。–param asan仪器调用阈值= 0.</p>
</div></blockquote>
<p>hwasan-instrument-stack</p>
<blockquote>
<div><p>启用静态大小的堆栈分配的变量的hwasan工具。这种仪器化在使用-fsanitize=hwaddress并在使用时默认禁用-fsanitize=kernel-hwaddress.禁用堆栈检测使用–param hwasan-instrument-stack=0，并启用它使用–param hwasan-instrument-stack=1.</p>
</div></blockquote>
<p>hwasan-random-frame-tag</p>
<blockquote>
<div><p>当使用堆栈仪表时,为堆栈变量决定标签,使用一个确定性的序列,从每一帧的随机标签开始。在这个参数下,未设置的标签使用相同的序列选择,但从1开始。-fsanitize=hwaddress并且不能用于-fsanitize=kernel-hwaddress. 要禁用它，请使用–param hwasan-random-frame-tag=0.</p>
</div></blockquote>
<p>hwasan-instrument-allocas</p>
<blockquote>
<div><p>启用动态大小的堆栈分配的变量的hwasan工具。这种仪器化在使用-fsanitize=hwaddress并在使用时默认禁用-fsanitize=kernel-hwaddress. 要禁用此类变量的检测，请使用–param hwasan-instrument-allocas=0，并启用它使用–param hwasan-instrument-allocas=1.</p>
</div></blockquote>
<p>hwasan-instrument-reads</p>
<blockquote>
<div><p>启用对内存读取的hwasan检查。读取的仪器化在默认情况下为以下两种情况所启用-fsanitize=hwaddressand-fsanitize=kernel-hwaddress. 禁用检查内存读取使用–param hwasan-instrument-reads=0.</p>
</div></blockquote>
<p>hwasan-instrument-writes</p>
<blockquote>
<div><p>启用对内存写入的hwasan检查。默认情况下,写的仪器化功能在以下两种情况下是启用的-fsanitize=hwaddressand-fsanitize=kernel-hwaddress. 要禁用检查内存写入使用–param hwasan-instrument-writes=0.</p>
</div></blockquote>
<p>hwasan-instrument-mem-intrinsics</p>
<blockquote>
<div><p>启用内置函数的hwasan仪器化。默认情况下,这些内置函数的仪器化在以下两种情况下被启用-fsanitize=hwaddressand-fsanitize=kernel-hwaddress. 要禁用内置函数的检测，请使用–param hwasan-instrument-mem-intrinsics=0.</p>
</div></blockquote>
<p>use-after-scope-direct-emission-threshold</p>
<blockquote>
<div><p>如果一个局部变量的字节大小小于或等于这个数字,直接毒害(或解除毒害)影子内存,而不是使用运行时回调。</p>
</div></blockquote>
<p>tsan-distinguish-volatile</p>
<blockquote>
<div><p>排放特殊的仪器,以获取挥发性物质。</p>
</div></blockquote>
<p>tsan-instrument-func-entry-exit</p>
<blockquote>
<div><p>释放对__tsan_func_entry()和__tsan_func_exit()的仪表调用。</p>
</div></blockquote>
<p>max-fsm-thread-path-insns</p>
<blockquote>
<div><p>在有限状态自动机跳线程路径上复制块时,复制的最大指令数。</p>
</div></blockquote>
<p>max-fsm-thread-length</p>
<blockquote>
<div><p>有限状态自动机跳线程路径上基本块的最大数量。</p>
</div></blockquote>
<p>max-fsm-thread-paths</p>
<blockquote>
<div><p>为有限状态自动机创建的新跳线程路径的最大数量。</p>
</div></blockquote>
<p>parloops-chunk-size</p>
<blockquote>
<div><p>通过parloops并行化的循环的OMP计划的Chunk大小。</p>
</div></blockquote>
<p>parloops-schedule</p>
<blockquote>
<div><p>omp调度类型的循环并行的parloops(静态、动态、引导、自动、运行时)。</p>
</div></blockquote>
<p>parloops-min-per-thread</p>
<blockquote>
<div><p>最内侧的并行化循环每线程的最小迭代次数,对于这些循环,并行化变体比单线程更受欢迎。请注意,对于一个并行化循环嵌套,最外侧循环每线程的最小迭代次数是两次。</p>
</div></blockquote>
<p>max-ssa-name-query-depth</p>
<blockquote>
<div><p>当在诸如折叠例程中查询SSA名的属性时,递归的最大深度。一级递归对应于跟随一个使用定义链。</p>
</div></blockquote>
<p>max-speculative-devirt-maydefs</p>
<blockquote>
<div><p>我们分析的最大数量的may-def,当寻找一个must-def指定一个对象的动态类型,调用虚拟调用时,我们可能会猜测性地devirtualize。</p>
</div></blockquote>
<p>max-vrp-switch-assertions</p>
<blockquote>
<div><p>在VRP期间,沿着交换机语句的默认边缘添加的最大断言数量。</p>
</div></blockquote>
<p>evrp-mode</p>
<blockquote>
<div><p>指定Early VRP应该在什么模式下运行。</p>
</div></blockquote>
<p>unroll-jam-min-percent</p>
<blockquote>
<div><p>必须优化掉的内存引用的最小百分比,以使 “滚动-卡姆 “转换被视为有利可图。</p>
</div></blockquote>
<p>unroll-jam-max-unroll</p>
<blockquote>
<div><p>通过展开-卡姆变换,外循环应展开的最大次数。</p>
</div></blockquote>
<p>max-rtl-if-conversion-unpredictable-cost</p>
<blockquote>
<div><p>对于一个被认为是不可预测的分支,RTL if转换传递所产生的序列的最大允许成本。</p>
</div></blockquote>
<p>max-variable-expansions-in-unroller</p>
<blockquote>
<div><p>If-fvariable-expansion-in-unroller是指在循环展开过程中,单个变量的最大展开次数。</p>
</div></blockquote>
<p>tracer-min-branch-probability-feedback</p>
<blockquote>
<div><p>如果最佳边缘的概率小于该阈值(百分比),则停止向前生长。当有轮廓反馈时使用。</p>
</div></blockquote>
<p>partial-inlining-entry-probability</p>
<blockquote>
<div><p>分割区域入口BB的最大概率(相对于函数入口BB的百分比),使部分内联发生。</p>
</div></blockquote>
<p>max-tracked-strlens</p>
<blockquote>
<div><p>strlen优化通道将跟踪字符串长度的最大数量。</p>
</div></blockquote>
<p>gcse-after-reload-partial-fraction</p>
<blockquote>
<div><p>重载后执行部分冗余消除的阈值比。</p>
</div></blockquote>
<p>gcse-after-reload-critical-fraction</p>
<blockquote>
<div><p>允许在重载后执行冗余消除的关键边缘执行数的阈值比。</p>
</div></blockquote>
<p>max-loop-header-insns</p>
<blockquote>
<div><p>复制循环头传递的循环头中重复的最大insn数量。</p>
</div></blockquote>
<p>vect-epilogues-nomask</p>
<blockquote>
<div><p>使用较小的向量大小启用循环尾声向量化。</p>
</div></blockquote>
<p>vect-partial-vector-usage</p>
<blockquote>
<div><p>控制循环向量器何时考虑使用部分向量加载和存储,以替代回落到标量代码。0阻止矢量器使用部分矢量加载和存储。1允许部分矢量加载和存储,如果矢量化消除了代码迭代的需要。2允许在所有循环中使用部分向量加载和存储。该参数只对支持部分向量加载和存储的目标有影响。</p>
</div></blockquote>
<p>avoid-fma-max-bits</p>
<blockquote>
<div><p>我们避免创建FMA的最大位数。</p>
</div></blockquote>
<p>sms-loop-average-count-threshold</p>
<blockquote>
<div><p>摆动模数调度器考虑的平均循环次数的阈值。</p>
</div></blockquote>
<p>sms-dfa-history</p>
<blockquote>
<div><p>使用DFA检查冲突时,摆动模数调度器考虑的周期数。</p>
</div></blockquote>
<p>max-inline-insns-recursive-auto</p>
<blockquote>
<div><p>通过递归内联,非内联函数可以增长到的最大指令数。</p>
</div></blockquote>
<p>graphite-allow-codegen-errors</p>
<blockquote>
<div><p>在以下情况下,codegen错误是否应该是ICEs?-fchecking.</p>
</div></blockquote>
<p>sms-max-ii-factor</p>
<blockquote>
<div><p>用于调整摆动模数调度器用于调度循环的上界的因素。</p>
</div></blockquote>
<p>lra-max-considered-reload-pseudos</p>
<blockquote>
<div><p>溢出非重装伪装时考虑的最大重装伪装数量。</p>
</div></blockquote>
<p>max-pow-sqrt-depth</p>
<blockquote>
<div><p>用实常数合成指数时,使用的sqrt链的最大深度。</p>
</div></blockquote>
<p>max-dse-active-local-stores</p>
<blockquote>
<div><p>在RTL死店淘汰中,本地活跃店铺的最大数量。</p>
</div></blockquote>
<p>asan-instrument-allocas</p>
<blockquote>
<div><p>启用asan allocas/VLAs保护。</p>
</div></blockquote>
<p>max-iterations-computation-cost</p>
<blockquote>
<div><p>对计算迭代次数的表达式的成本进行约束。</p>
</div></blockquote>
<p>max-isl-operations</p>
<blockquote>
<div><p>最大的isl操作次数,0表示无限制。</p>
</div></blockquote>
<p>graphite-max-arrays-per-scop</p>
<blockquote>
<div><p>每个scop的最大阵列数。</p>
</div></blockquote>
<p>max-vartrack-reverse-op-size</p>
<blockquote>
<div><p>应该添加反向操作的loc列表的最大尺寸。</p>
</div></blockquote>
<p>tracer-dynamic-coverage-feedback</p>
<blockquote>
<div><p>按执行频率加权的函数百分比,必须由跟踪形成覆盖。当有轮廓反馈时使用。</p>
</div></blockquote>
<p>max-inline-recursive-depth-auto</p>
<blockquote>
<div><p>非内联函数递归内联的最大深度。</p>
</div></blockquote>
<p>fsm-scale-path-stmts</p>
<blockquote>
<div><p>当比较线程路径中的语句数量和(比例)块数量时,应用的比例因子。</p>
</div></blockquote>
<p>fsm-maximum-phi-arguments</p>
<blockquote>
<div><p>一个PHI在FSM线程器不尝试穿行它的块之前可能拥有的最大参数数。</p>
</div></blockquote>
<p>uninit-control-dep-attempts</p>
<blockquote>
<div><p>在未初始化变量分析过程中,搜索控制依赖关系的最大嵌套调用次数。</p>
</div></blockquote>
<p>sra-max-scalarization-size-Osize</p>
<blockquote>
<div><p>聚合体的最大尺寸,以存储单位为单位,在编译尺寸时,应考虑其标量化。</p>
</div></blockquote>
<p>fsm-scale-path-blocks</p>
<blockquote>
<div><p>当比较(缩放)语句的数量时,应用于线程路径中块的数量的缩放因子。</p>
</div></blockquote>
<p>sched-autopref-queue-depth</p>
<blockquote>
<div><p>硬件自动预取程序调度程序模型控制标志。模型研究的超前循环次数；在“”仅启用指令排序启发式。</p>
</div></blockquote>
<p>loop-versioning-max-inner-insns</p>
<blockquote>
<div><p>一个内部循环在循环版本传递认为它太大而无法复制之前可以拥有的最大指令数。</p>
</div></blockquote>
<p>loop-versioning-max-outer-insns</p>
<blockquote>
<div><p>一个外循环在循环版本化通证认为它太大而无法复制之前可以拥有的最大指令数,不考虑内部循环中任何直接受益于版本化的指令。</p>
</div></blockquote>
<p>ssa-name-def-chain-limit</p>
<blockquote>
<div><p>在确定一个变量的属性(如其值)时要遵循的SSA_NAME赋值的最大次数。这限制了GCC在优化某些语句或在发出诊断程序之前确定其有效性时执行的迭代或递归调用的次数。</p>
</div></blockquote>
<p>store-merging-max-size</p>
<blockquote>
<div><p>单个存储合并区域的最大尺寸,单位为字节。</p>
</div></blockquote>
<p>hash-table-verification-limit</p>
<blockquote>
<div><p>对每个搜索到的元素进行哈希表验证的元素数量。</p>
</div></blockquote>
<p>max-find-base-term-values</p>
<blockquote>
<div><p>在单次find_base_term调用中处理的最大value数量。</p>
</div></blockquote>
<p>analyzer-max-enodes-per-program-point</p>
<blockquote>
<div><p>分析器内每个程序点在终止分析该点之前的最大爆炸节点数。</p>
</div></blockquote>
<p>analyzer-max-constraints</p>
<blockquote>
<div><p>每个状态的最大约束数。</p>
</div></blockquote>
<p>analyzer-min-snodes-for-call-summary</p>
<blockquote>
<div><p>一个函数内的超节点的最少数量,以便分析器考虑总结其在调用站点的效果。</p>
</div></blockquote>
<p>analyzer-max-enodes-for-full-dump</p>
<blockquote>
<div><p>在切换到不太详细的格式之前,点状转储中应该出现的最大深度的爆炸节点。</p>
</div></blockquote>
<p>analyzer-max-recursion-depth</p>
<blockquote>
<div><p>在分析器内的调用堆栈中,一个调用点在终止分析一个会再深层递归的调用之前,可以出现的最大次数。</p>
</div></blockquote>
<p>analyzer-max-svalue-depth</p>
<blockquote>
<div><p>符号值的最大深度,在将该值近似为未知值之前。</p>
</div></blockquote>
<p>analyzer-max-infeasible-edges</p>
<blockquote>
<div><p>在宣布一个诊断为不可行之前要拒绝的最大数量的不可行边。</p>
</div></blockquote>
<p>gimple-fe-computed-hot-bb-threshold</p>
<blockquote>
<div><p>被认为是热块的基本块的执行次数。该参数仅在GIMPLE FE中使用。</p>
</div></blockquote>
<p>analyzer-bb-explosion-factor</p>
<blockquote>
<div><p>终止分析之前，每个超节点在分析器中“超节点之后”爆炸节点的最大数量。</p>
</div></blockquote>
<p>ranger-logical-depth</p>
<blockquote>
<div><p>在评估出场边缘范围时,ranger会查看逻辑表达式评估的最大深度。</p>
</div></blockquote>
<p>openacc-kernels</p>
<blockquote>
<div><p>指定 OpenACC“内核”构造处理的模式。和–param=openacc-kernels=decompose，OpenACC“内核”结构被分解为多个部分，即一系列计算结构，然后单独处理每个部分。这是正在进行中的工作。和–param=openacc-kernels=parloops, OpenACC“内核”结构由“parloops’通过，整体。这是当前的默认设置。</p>
</div></blockquote>
<p>在AArch64目标上可以使用以下 name 选择：</p>
<p>aarch64-sve-compare-costs</p>
<blockquote>
<div><p>当对SVE进行矢量化时，请考虑对较小的元素使用“解压缩”矢量，并使用成本模型来选择最便宜的方法。还可以使用成本模型在SVE和Advanced SIMD矢量化之间进行选择。</p>
<p>使用未打包的向量包括将较小的元素存储在较大的容器中,并通过扩展载荷和截断存储来访问元素。</p>
</div></blockquote>
<p>aarch64-float-recp-precision</p>
<blockquote>
<div><p>用于计算浮点类型的倒数的牛顿迭代次数。启用除法近似时,除法的精度与此参数成正比。默认值为1。</p>
</div></blockquote>
<p>aarch64-double-recp-precision</p>
<blockquote>
<div><p>用于计算双倍型倒数的牛顿迭代次数。启用除法近似时,除法的精度与此参数相关。默认值为2。</p>
</div></blockquote>
<p>aarch64-autovec-preference</p>
<blockquote>
<div><p>强制执行自动矢量化的ISA选择策略。接受从0到4的值,包括在内。</p>
<p>‘0’</p>
<blockquote>
<div><p>使用默认的启发式方法。</p>
</div></blockquote>
<p>‘1’</p>
<blockquote>
<div><p>只使用高级SIMD进行自动矢量化。</p>
</div></blockquote>
<p>‘2’</p>
<blockquote>
<div><p>只使用SVE进行自动矢量化。</p>
</div></blockquote>
<p>‘3’</p>
<blockquote>
<div><p>同时使用高级SIMD和SVE。当成本被认为相等时,更倾向于高级SIMD。</p>
</div></blockquote>
<p>‘4’</p>
<blockquote>
<div><p>同时使用高级SIMD和SVE。当成本被认为相等时,更倾向于SVE。</p>
</div></blockquote>
<p>默认值为0。</p>
</div></blockquote>
<p>aarch64-loop-vect-issue-rate-niters</p>
<blockquote>
<div><p>在决定是使用 SVE 对循环进行矢量化、使用高级 SIMD 进行矢量化还是根本不进行矢量化时，对某些 AArch64 CPU 的调整尝试同时考虑延迟和问题率。如果此参数设置为 n ，对于已知执行次数少于 n 次高级 SIMD 迭代的循环，GCC 将不会使用此启发式方法。</p>
</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="id10">
<h2>程序工具选项(3.12)<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>GCC支持许多命令行选项,这些选项可以控制在它通常生成的代码中添加运行时工具。例如,工具化的一个目的是收集剖析统计数据,用于查找程序热点、代码覆盖率分析或剖析引导的优化。另一类程序工具化是增加运行时检查,以检测程序错误,如无效指针取消引用或越界数组访问,以及故意的敌对攻击,如堆栈粉碎或C++vtable hijacking。还有一个通用的钩子,可以用来实现其他形式的跟踪或函数级工具,以达到调试或程序分析的目的。</p>
<p>-p
-pg</p>
<blockquote>
<div><p>生成额外的代码以编写适合分析程序 prof 配置文件信息（用于-p）或 gprof （用于-pg）。编译要用于数据的源文件时，必须使用此选项，并且在链接时也必须使用它。</p>
<p>使用这些选项进行编译时，可以使用函数属性 no_instrument_function 禁止对单个函数进行性能分析。请参阅通用功能属性。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>profile-arcs</var></span></kbd></dt>
<dd><p>添加代码，以便检测程序流弧。在执行期间，程序记录每个分支和调用执行了多少次，以及执行或返回了多少次。在支持具有优先级支持的构造函数的目标上，性能分析可以正确处理用作全局变量类型的类的构造函数，析构函数和C ++构造函数（和析构函数）。</p>
<p>当编译后的程序退出时,它将这些数据保存到一个名为auxname.gcda每个源文件的数据。这些数据可用于配置文件导向的优化 (-fbranch-probabilities），或用于测试覆盖率分析（-ftest-coverage）。每个目标文件的 auxname 由输出文件的名称生成（如果已明确指定），它不是最终的可执行文件，否则它是源文件的基本名称。在这两种情况下，都删除了任何后缀（例如，foo.gcda用于输入文件dir/foo.c， 或者dir/foo.gcda的输出文件,指定为-o目录/foo.o）。请参阅交叉分析。</p>
</dd>
<dt><kbd><span class="option">--coverage</span></kbd></dt>
<dd><p>这个选项用于编译和链接被检测到的代码以进行覆盖率分析。该选项是以下选项的同义词-fprofile-arcs -ftest-coverage（编译时）和-lgcov（链接时）。有关更多选项，请参阅这些选项的文档。</p>
<blockquote>
<div><p>编译源文件时使用-fprofile-arcs加上优化和代码生成选项。对于测试覆盖率分析,使用附加的-ftest-coverage选项。您不需要对程序中的每个源文件进行配置文件。
编译源文件,另外用-fprofile-abs-path中创建绝对路径名。.gcno文件。这使 gcov 可以在使用不同工作目录进行编译的项目中找到正确的源。
将您的对象文件与-lgcovor-fprofile-arcs（后者暗示前者）。
以代表性的工作量运行该程序以生成电弧轮廓信息。可以重复多次。您可以运行程序的并发实例，并且如果文件系统支持锁定，则将正确更新数据文件。除非执行严格的ISO C语言方言，否则将检测到 fork 调用并对其进行正确处理而无需重复计算。
对于配置文件导向的优化,使用相同的优化和代码生成选项再编译一次源文件,加上-fbranch-probabilities（请参阅控制优化的选项）。
为了进行测试覆盖率分析，请使用 gcov 从.gcnoand.gcda文件。有关更多信息，请参阅 gcov 文档。</p>
</div></blockquote>
<p>With-fprofile-arcs，对于您程序的每个功能，GCC都会创建一个程序流程图，然后为该图找到一个生成树。只需要检测不在生成树上的弧：编译器添加代码以计算这些弧的执行次数。当圆弧是某个块的唯一出口或唯一入口时，可以将检测代码添加到该块；否则，必须创建一个新的基本块来保存检测代码。</p>
</dd>
<dt><kbd><span class="option">-f<var>test-coverage</var></span></kbd></dt>
<dd><p>生成一个注释文件， gcov 代码覆盖率实用程序（请参阅 gcov —测试覆盖率程序）可用于显示程序覆盖率。每个源文件的注释文件称为auxname.gcno。请参阅-fprofile-arcs上面的选项可提供关于 auxname 的说明以及有关如何生成测试覆盖率数据的说明。如果不进行优化，覆盖率数据将与源文件更紧密地匹配。</p>
</dd>
<dt><kbd><span class="option">-f<var>profile-abs-path</var></span></kbd></dt>
<dd><p>自动将相对的源文件名转换为绝对路径名。.gcno文件。这使 gcov 可以在使用不同工作目录进行编译的项目中找到正确的源。</p>
</dd>
</dl>
<p>-fprofile-dir=path</p>
<blockquote>
<div><p>设置目录以在 path 中搜索概要文件数据文件。此选项仅影响由…生成的配置文件数据-fprofile-generate,-ftest-coverage,-fprofile-arcs并用于-fprofile-useand-fbranch-probabilities及其相关选项。绝对路径和相对路径均可使用。默认情况下，GCC使用当前目录作为 path ，因此概要文件数据文件与目标文件出现在同一目录中。为了防止文件名冲突，如果目标文件名不是绝对路径，我们会修改目标文件的绝对路径。sourcename.gcda文件,并将其作为一个文件名的.gcda文件。参见类似选项-fprofile-note.</p>
<p>在大规模并行环境中运行可执行文件时，建议将配置文件保存到其他文件夹中。这可以通过在运行时导出的 path 中的变量来完成：</p>
<p>%p</p>
<blockquote>
<div><p>进程ID:</p>
</div></blockquote>
<p>%q{VAR}</p>
<blockquote>
<div><p>环境变量 VAR 的值</p>
</div></blockquote>
</div></blockquote>
<p>-fprofile-generate
-fprofile-generate=path</p>
<blockquote>
<div><p>启用通常用于工具应用程序的选项,以产生对以后重新编译有用的基于配置文件反馈的优化的配置文件。您必须使用-fprofile-generate在编译和链接你的程序时都是如此。</p>
<p>启用了以下选项:-fprofile-arcs,-fprofile-values,-finline-functions， 和-fipa-bit-cp.</p>
<p>如果 path 指定，GCC着眼于 path 寻找配置文件反馈数据文件。看到-fprofile-dir.</p>
<p>要根据收集到的资料信息优化程序,请使用以下方法。-fprofile-use。有关更多信息，请参见优化选项。</p>
</div></blockquote>
<p>-fprofile-info-section
-fprofile-info-section=name</p>
<blockquote>
<div><p>在指定的部分中注册配置文件信息，而不是使用构造函数/析构函数。如果指定，则部分名称为 name ，否则部分名称默认为 .gcov_info 。指向由生成的配置文件信息的指针-fprofile-arcsor-ftest-coverage被放置在每个翻译单元的指定部分。该选项通过构造函数禁用配置文件信息注册,通过析构函数禁用配置文件信息处理。这个选项不打算在GNU/Linux这样的托管环境中使用。它的目标是资源有限,不支持构造函数和析构函数的系统。链接器可以在一个连续的内存块中收集输入部分并定义开始和结束符号。运行时支持可以在程序终止时将该链接器集注册的剖析信息转储到一个串行线上,例如。下面是一个GNU链接器脚本的例子,它定义了一个链接器输出部分。</p>
<p>.gcov_info      :
{</p>
<blockquote>
<div><p>PROVIDE (__gcov_info_start = .);
KEEP (<a href="#id11"><span class="problematic" id="id12">*</span></a>(.gcov_info))
PROVIDE (__gcov_info_end = .);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>-fprofile-note=path</p>
<blockquote>
<div><p>如果指定了 path ，则GCC会保存.gcno文件放入 path 位置。如果您将此选项与多个源文件结合使用，.gcno文件将被覆盖。</p>
</div></blockquote>
<p>-fprofile-prefix-path=path</p>
<blockquote>
<div><p>此选项可与profile-generate=profile_dir 和profile-use=profile_dir 通知GCC内置源代码树的基本目录在哪里。默认情况下， profile_dir 将包含构建项目中所有目标文件的绝对路径都经过修饰的文件。当用于构建检测二进制文件的目录与用于通过概要文件反馈优化的二进制文件的目录不同时，这是不希望的，因为在优化的构建过程中将找不到概要文件数据。在这样的设置中-fprofile-prefix-path=path 带有指向构建的基本目录的路径的 path 可以用于剥离路径的不相关部分，并使所有文件名都相对于主构建目录。</p>
</div></blockquote>
<p>-fprofile-update=method</p>
<blockquote>
<div><p>为基于概要文件反馈优化的应用程序更改更新方法。所述 method 参数应该是一个’single’，’atomic’ 要么 ‘prefer-atomic’。第一个对单线程应用程序很有用，而第二个通过发出线程安全代码来防止配置文件损坏。</p>
<p>警告：如果应用程序未正确加入所有线程（或创建了分离的线程），则配置文件仍可能损坏。</p>
<p>使用“prefer-atomic’将被转换为’atomic’，如果有目标支持，则为’single’ 除此以外。GCC驱动程序会自动选择“prefer-atomic’ 什么时候-pthread在命令行中存在。</p>
</div></blockquote>
<p>-fprofile-filter-files=regex</p>
<blockquote>
<div><p>只对名称与任何一个正则表达式(用分号分隔)相匹配的文件中的函数进行测量。</p>
<p>例如:-fprofile-filter-files=main.c;module.*.c只会工具main.c以及所有以“模块”开头的C文件。</p>
</div></blockquote>
<p>-fprofile-exclude-files=regex</p>
<blockquote>
<div><p>只对名称与任何正则表达式不匹配的文件中的函数进行测量(用分号分隔)。</p>
<p>例如:-fprofile-exclude-files=/usr/.*将阻止对所有位于/usr/folder.</p>
</div></blockquote>
<p>-fprofile-reproducible=[multithreaded|parallel-runs|serial]</p>
<blockquote>
<div><p>-fprofile-generate 收集的配置文件可再现性的控制级别。这样就可以重建具有相同结果的程序，这对于分发程序包很有用。</p>
<p>With-fprofile-reproducible=serial采集的资料-fprofile-generate如果训练的程序在每次火车运行时都表现出相同的行为，则它是可重现的，它不是多线程的，并且概要文件数据流总是以相同的顺序进行。请注意，配置文件流式传输发生在程序运行结束时，但在调用 fork 函数之前也是如此。</p>
<p>请注意，程序某些部分的执行次数通常取决于例如临时文件名的长度或内存空间随机化（这可能会影响哈希表冲突率），这是很常见的。程序的此类不可复制部分可以通过 no_instrument_function 函数属性进行注释。 gcov-dump 与-l可以用来转储收集到的数据,并验证它们是否真的可以重现。</p>
<p>With-fprofile-reproducible=parallel-runs无论将数据流传输到gcda文件的顺序如何，收集的配置文件均保持可重复性。通过此设置，可以并行运行已检测程序的多个实例（例如，使用 make -j ）。这降低了收集数据的质量，特别是间接调用分析的质量。</p>
</div></blockquote>
<p>-fsanitize=address</p>
<blockquote>
<div><p>启用快速内存错误检测器AddressSanitizer。对内存访问指令进行检测,以检测越界和使用后的错误。该选项可以启用-fsanitize-address-use-after-scope。有关更多详细信息，请参见https://github.com/google/sanitizers/wiki/AddressSanitizer。可以使用 ASAN_OPTIONS 环境变量来影响运行时行为。当设置为 help=1 时，可用的选项将在检测程序启动时显示。有关受支持的选项的列表，请参见https://github.com/google/sanitizers/wiki/AddressSanitizerFlags#run-time-flags。该选项不能与-fsanitize=threador-fsanitize=hwaddress. 注意唯一的目标-fsanitize=hwaddress目前支持的系统是AArch64。</p>
</div></blockquote>
<p>-fsanitize=kernel-address</p>
<blockquote>
<div><p>为 Linux 内核启用 AddressSanitizer。有关更多详细信息，请参阅https://github.com/google/kasan。</p>
</div></blockquote>
<p>-fsanitize=hwaddress</p>
<blockquote>
<div><p>启用硬件辅助的AddressSanitizer,它使用硬件能力来忽略指针的顶部字节,允许以低内存开销检测内存错误。对内存访问指令进行检测,以发现越界和用完即走的错误。该选项使-fsanitize-address-use-after-scope. 有关更多详细信息，请参阅https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html。可以使用 HWASAN_OPTIONS 环境变量影响运行时行为。当设置为 help=1 时，可用选项将在检测程序启动时显示。该选项不能与-fsanitize=threador-fsanitize=address，目前仅在 AArch64 上可用。</p>
</div></blockquote>
<p>-fsanitize=kernel-hwaddress</p>
<blockquote>
<div><p>启用硬件辅助的AddressSanitizer来编译Linux内核。类似于-fsanitize=kernel-address但使用的是另一种仪器设备方法,并类似于-fsanitize=hwaddress但在编译Linux内核时有必要对仪器进行调整。这些差异是为了避免hwasan库的初始化调用,并说明堆栈指针在其顶部字节有不同的值。</p>
<p>注意：此选项具有不同的默认值-fsanitize=hwaddress. 默认情况下不会检测堆栈和 alloca 调用，但仍然可以通过指定命令行选项–param hwasan-instrument-stack=1and–param hwasan-instrument-allocas=1分别。使用随机帧标签并没有为内核仪器化实现。</p>
</div></blockquote>
<p>-fsanitize=pointer-compare</p>
<blockquote>
<div><p>带有指针操作数的仪器比较操作（&lt;，&lt;=，&gt;，&gt; =）。该选项必须与以下任意一项结合使用-fsanitize=kernel-addressor-fsanitize=address该选项不能与-fsanitize=thread。注意：默认情况下，该检查在运行时处于禁用状态。要启用它，请将 detect_invalid_pointer_pairs=2 添加到环境变量 ASAN_OPTIONS 。仅当两个指针都不为空时，使用 detect_invalid_pointer_pairs=1 才能检测到无效操作。</p>
</div></blockquote>
<p>-fsanitize=pointer-subtract</p>
<blockquote>
<div><p>用指针操作数进行仪器减法。这个选项必须与-fsanitize=kernel-addressor-fsanitize=address该选项不能与-fsanitize=thread。注意：默认情况下，该检查在运行时处于禁用状态。要启用它，请将 detect_invalid_pointer_pairs=2 添加到环境变量 ASAN_OPTIONS 。仅当两个指针都不为空时，使用 detect_invalid_pointer_pairs=1 才能检测到无效操作。</p>
</div></blockquote>
<p>-fsanitize=thread</p>
<blockquote>
<div><p>启用ThreadSanitizer，一种快速的数据竞争检测器。内存访问指令用于检测数据争用错误。有关更多详细信息，请参见https://github.com/google/sanitizers/wiki#threadsanitizer。可以使用 TSAN_OPTIONS 环境变量来影响运行时行为。有关受支持的选项的列表，请参见https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags。该选项不能与-fsanitize=address,-fsanitize=leak.</p>
<p>请注意,当在无效内存地址上操作时,经过消毒的原子内建不能抛出非调用异常(-fnon-call-exceptions).</p>
</div></blockquote>
<p>-fsanitize=leak</p>
<blockquote>
<div><p>启用内存泄漏检测器LeakSanitizer。此选项仅对链接可执行文件很重要，并且可执行文件是针对覆盖 malloc 和其他分配程序功能的库的。有关更多详细信息，请参见https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer。可以使用 LSAN_OPTIONS 环境变量来影响运行时行为。该选项不能与-fsanitize=thread.</p>
</div></blockquote>
<p>-fsanitize=undefined</p>
<blockquote>
<div><p>启用UndefinedBehaviorSanitizer,一个快速的未定义行为检测器。在运行时通过各种计算工具来检测未定义的行为。当前的子选项有:</p>
<p>-fsanitize=shift</p>
<blockquote>
<div><p>通过这个选项可以检查移位操作的结果是不是未定义的。请注意,到底什么是未定义,在C和C++之间,以及在ISO C90和C99等之间都略有不同。这个选项有两个子选项。-fsanitize=shift-baseand-fsanitize=shift-exponent.</p>
</div></blockquote>
<p>-fsanitize=shift-exponent</p>
<blockquote>
<div><p>通过这个选项,可以检查移位操作的第二个参数是否为负值,是否小于被推广的第一个参数的精度。</p>
</div></blockquote>
<p>-fsanitize=shift-base</p>
<blockquote>
<div><p>如果移位操作的第二个参数在范围内,则检查移位操作的结果是否为未定义。需要注意的是,到底什么是未定义,在C和C++之间,以及ISO C90和C99等之间都略有不同。</p>
</div></blockquote>
<p>-fsanitize=integer-divide-by-zero</p>
<blockquote>
<div><p>检测整数除以零以及 INT_MIN / -1 除。</p>
</div></blockquote>
<p>-fsanitize=unreachable</p>
<blockquote>
<div><p>使用此选项，编译器会将 __builtin_unreachable 调用转换为诊断消息调用。到达 __builtin_unreachable 调用时，该行为是不确定的。</p>
</div></blockquote>
<p>-fsanitize=vla-bound</p>
<blockquote>
<div><p>这个选项指示编译器检查可变长度数组的大小是否为正值。</p>
</div></blockquote>
<p>-fsanitize=null</p>
<blockquote>
<div><p>这个选项可以启用指针检查。特别是,当应用程序试图取消引用一个NULL指针时,或者当一个引用(可能是一个rvalue引用)被绑定到一个NULL指针上时,或者当一个方法被调用到一个NULL指针指向的对象上时,使用该选项构建的应用程序将发出错误信息。</p>
</div></blockquote>
<p>-fsanitize=return</p>
<blockquote>
<div><p>这个选项可以启用返回语句检查。启用该选项后,当程序在没有实际返回值的情况下到达一个非void函数的终点时,会发出错误信息。这个选项只在C++中有效。</p>
</div></blockquote>
<p>-fsanitize=signed-integer-overflow</p>
<blockquote>
<div><p>此选项启用有符号整数溢出检查。我们检查 + ， * 以及一元和二进制的结果 - 不会在有符号算术中溢出。注意，必须考虑整数促销规则。也就是说，以下不是溢出：</p>
<p>signed char a = SCHAR_MAX;
a++;</p>
</div></blockquote>
<p>-fsanitize=bounds</p>
<blockquote>
<div><p>这个选项可以实现对阵列边界的检测。检测各种越界访问。灵活的数组成员,灵活的类似数组成员的数组,以及具有静态存储的变量的初始化器都不会被检测到。</p>
</div></blockquote>
<p>-fsanitize=bounds-strict</p>
<blockquote>
<div><p>这个选项可以对数组边界进行严格的检测。大多数越界访问都会被检测到,包括灵活的数组成员和灵活的数组成员类数组。静态存储变量的初始化器不会被检测到。</p>
</div></blockquote>
<p>-fsanitize=alignment</p>
<blockquote>
<div><p>这个选项可以检查指针的对齐情况,当指针被解除引用时,或者当引用被绑定到未充分对齐的目标时,或者当方法或构造函数被调用到未充分对齐的对象上时。</p>
</div></blockquote>
<p>-fsanitize=object-size</p>
<blockquote>
<div><p>此选项使用 __builtin_object_size 函数启用对内存引用的检测。检测到各种超出范围的指针访问。</p>
</div></blockquote>
<p>-fsanitize=float-divide-by-zero</p>
<blockquote>
<div><p>检测浮点除以零。与其他类似选项不同。-fsanitize=float-divide-by-zero不启用-fsanitize=undefined，因为将浮点数除以零可能是获得无穷大和NaN的合法方法。</p>
</div></blockquote>
<p>-fsanitize=float-cast-overflow</p>
<blockquote>
<div><p>这个选项可以进行浮点型到整数型的转换检查。我们检查转换结果是否溢出。与其他类似选项不同。-fsanitize=float-cast-overflow不启用-fsanitize=undefined。启用了 FE_INVALID 异常后，此选项不能很好地工作。</p>
</div></blockquote>
<p>-fsanitize=nonnull-attribute</p>
<blockquote>
<div><p>此选项启用调用检测，检查是否将null值不传递给 nonnull 函数属性标记为需要非null值的参数。</p>
</div></blockquote>
<p>-fsanitize=returns-nonnull-attribute</p>
<blockquote>
<div><p>通过此选项，可以在标记有 returns_nonnull 函数属性的函数中检测return语句，以检测从此类函数返回空值。</p>
</div></blockquote>
<p>-fsanitize=bool</p>
<blockquote>
<div><p>这个选项可以从bool中对负载进行仪表化。如果加载的值不是0/1,则会发出运行时错误。</p>
</div></blockquote>
<p>-fsanitize=enum</p>
<blockquote>
<div><p>这个选项可以对来自枚举类型的负载进行仪表化。如果加载的数值超出了枚举类型的数值范围,则会发出运行时错误。</p>
</div></blockquote>
<p>-fsanitize=vptr</p>
<blockquote>
<div><p>这个选项可以对C++成员函数调用、成员访问以及基类和派生类的指针之间的一些转换进行仪器检测,以验证被引用对象的动态类型是否正确。</p>
</div></blockquote>
<p>-fsanitize=pointer-overflow</p>
<blockquote>
<div><p>这个选项可以实现指针算术的仪器化。如果指针算术溢出,就会发出一个运行时错误。</p>
</div></blockquote>
<p>-fsanitize=builtin</p>
<blockquote>
<div><p>此选项启用对选定内置函数的参数的检测。如果将无效值传递给此类参数，则会发出运行时错误。例如，将0用作 __builtin_ctz 或 __builtin_clz 的参数，则会调用未定义的行为，并通过此选项进行诊断。</p>
</div></blockquote>
<p>While-ftrapv导致发出签名溢出的陷阱。-fsanitize=undefined提供了一个诊断信息。目前这只适用于C语言家族。</p>
</div></blockquote>
<p>-fno-sanitize=all</p>
<blockquote>
<div><p>此选项可禁用所有之前启用的消毒器。-fsanitize=all是不允许的,因为有些消毒剂不能一起使用。</p>
</div></blockquote>
<p>-fasan-shadow-offset=number</p>
<blockquote>
<div><p>这个选项强制GCC在AddressSanitizer检查中使用自定义影子偏移。这对于在Kernel AddressSanitizer中试验不同的影子内存布局很有用。</p>
</div></blockquote>
<p>-fsanitize-sections=s1,s2,…</p>
<blockquote>
<div><p>在选定的用户定义部分中清除全局变量。 si 可能包含通配符。</p>
</div></blockquote>
<p>-fsanitize-recover[=opts]</p>
<blockquote>
<div><p>-fsanitize-recover=控制 opts 逗号分隔列表中提到的消毒剂的错误恢复模式。为消毒组件启用此选项会使它尝试继续运行程序，就好像没有发生错误一样。这意味着可以在单个程序运行中报告多个运行时错误，并且即使报告了错误，程序的退出代码也可能表示成功。的-fno-sanitize-recover=选项可以用来改变这种行为:只报告第一次检测到的错误,然后程序以一个非零的退出代码退出。</p>
<p>目前该功能只适用于-fsanitize=undefined（及其子选项除外-fsanitize=unreachableand-fsanitize=return),-fsanitize=float-cast-overflow,-fsanitize=float-divide-by-zero,-fsanitize=bounds-strict,-fsanitize=kernel-addressand-fsanitize=address。对于这些消毒器，默认情况下会打开错误恢复功能，但-fsanitize=address，此功能是实验性的。-fsanitize-recover=alland-fno-sanitize-recover=all也是被接受的,前者可以使所有支持它的消毒剂恢复,后者可以使所有支持它的消毒剂停止恢复。</p>
<p>即使在编译器端启用了恢复模式，也需要在运行时库端启用它，否则失败仍然是致命的。对于ThreadSanitizer和UndefinedBehaviorSanitizer，运行时库的默认值为 halt_on_error=0 ，而AddressSanitizer的默认值为 halt_on_error=1 。可以通过在相应的环境变量中设置 halt_on_error 标志来覆盖它。</p>
<p>不建议使用不带显式 opts 参数的语法。它相当于指定 opts 的列表：</p>
<p>undefined,float-cast-overflow,float-divide-by-zero,bounds-strict</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>sanitize-address-use-after-scope</var></span></kbd></dt>
<dd><p>启用局部变量的净化,以检测使用范围后的错误。该选项设置了-fstack-reuse至 ‘none’.</p>
</dd>
<dt><kbd><span class="option">-f<var>sanitize-undefined-trap-on-error</var></span></kbd></dt>
<dd><p>The-fsanitize-undefined-trap-on-error选项指示编译器使用 __builtin_trap 而不是 libubsan 库例程报告未定义的行为。这样做的好处是不需要 libubsan 库，也不会链接libubsan库，因此即使在独立环境中也可以使用libubsan库。</p>
</dd>
</dl>
<p>-fsanitize-coverage=trace-pc</p>
<blockquote>
<div><p>启用覆盖率指导的模糊代码检测。 __sanitizer_cov_trace_pc 的调用插入到每个基本块中。</p>
</div></blockquote>
<p>-fsanitize-coverage=trace-cmp</p>
<blockquote>
<div><p>启用数据流引导的模糊代码检测。插入到一个呼叫 __sanitizer_cov_trace_cmp1 ， __sanitizer_cov_trace_cmp2 ， __sanitizer_cov_trace_cmp4 或 __sanitizer_cov_trace_cmp8 用于与这两个操作数的变量或积分比较 __sanitizer_cov_trace_const_cmp1 ， __sanitizer_cov_trace_const_cmp2 ， __sanitizer_cov_trace_const_cmp4 或 __sanitizer_cov_trace_const_cmp8 用于与一个操作数常数，积分比较 __sanitizer_cov_trace_cmpf 或 __sanitizer_cov_trace_cmpd 浮法或双比较和 __sanitizer_cov_trace_switch 用于switch语句。</p>
</div></blockquote>
<p>-fcf-protection=[full|branch|return|none|check]</p>
<blockquote>
<div><p>通过检查控制流转移指令(如间接函数调用、函数返回、间接跳转)的目标地址是否有效,启用控制流转移的代码仪表,以提高程序的安全性。这样可以防止将控制流转移到一个意想不到的目标。这样做的目的是为了防止诸如面向返回的编程(ROP),以及类似于面向调用/jmp的编程(COP/JOP)等威胁。</p>
<p>值 branch 告诉编译器在间接分支指令（即调用/ jmp指令）处执行控制流传输的有效性检查。值 return 在从函数返回时实现有效性检查。 full 值是用于指定 branch 和 return 的别名。该值 none 关闭仪器。</p>
<p>值 check 用于具有链接时间优化 (LTO) 的最终链接。如果 LTO 目标文件使用不同的编译器编译，则会发出错误-fcf-protection值。在编译时忽略值 check 。</p>
<p>宏 __CET__ 在以下情况下定义-fcf-protection用来。的第一比特 __CET__ 被设置为1的值 branch 和所述第二位 __CET__ 被设置为1的 return 。</p>
<p>您还可以使用 nocf_check 属性来确定应从检测中跳过哪些函数和调用（请参见函数属性）。</p>
<p>目前x86 GNU/Linux目标提供了基于Intel控制流执行技术(CET)的实现。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>stack-protector</var></span></kbd></dt>
<dd><p>发出额外的代码以检查缓冲区溢出，例如堆栈破坏攻击。这是通过向具有易受攻击对象的函数添加一个保护变量来完成的。这包括调用 alloca 的函数以及缓冲区大于或等于8个字节的函数。在进入功能时初始化防护，然后在功能退出时检查。如果防护检查失败，则会打印一条错误消息，并退出程序。仅考虑实际分配在堆栈上的变量，优化后的变量或寄存器中分配的变量不计算在内。</p>
</dd>
<dt><kbd><span class="option">-f<var>stack-protector-all</var></span></kbd></dt>
<dd><p>Like-fstack-protector除了所有功能都受到保护。</p>
</dd>
<dt><kbd><span class="option">-f<var>stack-protector-strong</var></span></kbd></dt>
<dd><p>Like-fstack-protector但包括要保护的其他功能-具有本地数组定义或引用本地帧地址的功能。仅考虑实际分配在堆栈上的变量，优化后的变量或寄存器中分配的变量不计算在内。</p>
</dd>
<dt><kbd><span class="option">-f<var>stack-protector-explicit</var></span></kbd></dt>
<dd><p>Like-fstack-protector但仅保护那些具有 stack_protect 属性的函数。</p>
</dd>
<dt><kbd><span class="option">-f<var>stack-check</var></span></kbd></dt>
<dd><p>生成代码来验证你是否没有超出栈的边界。如果你运行在有多个线程的环境中,你应该指定这个标志,但在单线程环境中,你只需要很少指定这个标志,因为如果只有一个栈,几乎所有系统都会自动检测到栈溢出。</p>
<p>请注意,这个开关实际上并不引起检查,操作系统或语言运行时必须这样做。这个开关会导致代码的生成,以确保它们看到堆栈被扩展。</p>
<p>您还可以指定一个字符串参数：’no’表示不检查，’generic’表示强制使用旧式检查，’specific’表示使用最佳检查方法，相当于裸露-fstack-check.</p>
<p>旧式检查是一种通用机制,在编译器中不需要特定的目标支持,但有以下缺点。</p>
<blockquote>
<div><p>修改了大对象的分配策略:如果大对象的大小超过了一个固定的阈值,那么它们总是被动态分配。注意这可能会改变一些代码的语义。
修正了对函数静态帧大小的限制:当它被某个函数顶住时,堆栈检查不可靠,编译器会发出警告。
效率低下:由于修改后的分配策略和通用实现,代码性能受到影响。</p>
</div></blockquote>
<p>请注意，旧式堆栈检查也是“specific’如果没有在编译器中添加目标支持。</p>
<p>‘-fstack-check=’是专为Ada检测无限递归和堆栈溢出的需求而设计的。’specific’是编译Ada代码时的绝佳选择。通常，仅靠防御堆栈冲突攻击还不够。为了保护自己免受想要的伤害，-fstack-clash-protection’.</p>
</dd>
<dt><kbd><span class="option">-f<var>stack-clash-protection</var></span></kbd></dt>
<dd><p>生成代码以防止堆栈冲突式攻击。启用该选项后,编译器每次只分配一页堆栈空间,且每一页在分配后立即被访问。因此,它可以防止分配跳过操作系统提供的任何堆栈保护页。</p>
<p>大多数目标不完全支持堆栈冲突保护。然而,在这些目标上-fstack-clash-protection将保护动态栈分配。-fstack-clash-protection也可以为静态栈分配提供有限的保护,如果目标支持-fstack-check=specific.</p>
</dd>
</dl>
<p>-fstack-limit-register=reg
-fstack-limit-symbol=sym
-fno-stack-limit</p>
<blockquote>
<div><p>生成代码,以确保堆栈的增长不超过某个值,无论是寄存器的值还是符号的地址。如果需要更大的栈,在运行时就会发出信号。对于大多数目标来说,信号会在堆栈超过边界之前就被提出,因此可以不采取特殊的预防措施来捕捉信号。</p>
<p>例如，如果堆栈从绝对地址’开始0x80000000并向下生长，您可以使用标志-fstack-limit-symbol=__stack_limitand-Wl,–defsym,__stack_limit=0x7ffe0000来执行128KB的堆栈限制。注意,这可能只适用于GNU链接器。</p>
<p>您可以使用 no_stack_limit 函数属性在本地覆盖堆栈限制检查（请参见函数属性）。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>split-stack</var></span></kbd></dt>
<dd><p>生成代码,在堆栈溢出之前自动分割堆栈。生成的程序有一个不连续的栈,只有在程序无法分配更多的内存时才会溢出。这在运行线程程序时最为有用,因为它不再需要为每个线程计算一个好的堆栈大小。目前只有运行GNU/Linux的x86目标才会实现这个功能。</p>
<p>当代码用-fsplit-stack调用不含-fsplit-stack，可能没有太多堆栈空间可用于运行后面的代码。如果使用编译所有代码，包括库代码-fsplit-stack不是一个选项,那么链接器可以修正这些调用,这样编译后的代码就不会有-fsplit-stack总是有一个大的栈。在GNU binutils 2.21及以后的版本中的gold linker中实现了这一支持。</p>
</dd>
</dl>
<p>-fvtable-verify=[std|preinit|none]</p>
<blockquote>
<div><p>这个选项只在编译C++代码时可用。它可以打开(或关闭,如果使用-fvtable-verify=none）在运行时针对每个虚拟调用进行验证的安全功能，通过该vtable指针进行的调用对于该对象的类型有效，并且未被破坏或覆盖。如果在运行时检测到无效的vtable指针，则会报告错误，并立即停止执行程序。</p>
<p>此选项导致在程序启动时构建运行时数据结构，该结构用于验证vtable指针。选项“std’和’preinit控制构建这些数据结构的时间。在这两种情况下，数据结构都是在执行到达 main 之前构建的。使用-fvtable-verify=std导致数据结构在共享库被加载和初始化后被建立。-fvtable-verify=preinit导致它们在共享库被加载和初始化之前被构建。</p>
<p>如果此选项在命令行中多次出现且指定了不同的值，则“none’两者都享有最高优先级’std’和’preinit’; ‘preinit“优先于”std’.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>vtv-debug</var></span></kbd></dt>
<dd><p>当与-fvtable-verify=stdor-fvtable-verify=preinit，导致调用vtable验证功能的运行时功能的调试版本。此标志还使编译器记录有关为每个类找到哪个vtable指针的信息。此信息将写入一个名为vtv_set_ptr_data.log在环境变量 VTV_LOGS_DIR 命名的目录中（如果已定义），否则在当前工作目录中。</p>
<p>注意：此功能会将数据附加到日志文件。如果您想要一个新的日志文件，请确保删除任何现有的日志文件。</p>
</dd>
<dt><kbd><span class="option">-f<var>vtv-counts</var></span></kbd></dt>
<dd><p>这是一个调试标志。当与-fvtable-verify=stdor-fvtable-verify=preinit，这会使编译器跟踪其遇到的虚拟调用总数以及插入的验证次数。它还计算插入的某些运行时库函数的调用次数，并为每个编译单元记录此信息。编译器将此信息写到名为vtv_count_data.log在环境变量 VTV_LOGS_DIR 命名的目录中（如果已定义），否则在当前工作目录中。它还计算每个类的vtable指针集的大小，并将此信息写入vtv_class_set_sizes.log在同一目录下。</p>
<p>注意：此功能会将数据追加到日志文件。要获取新的日志文件，请确保删除任何现有的日志文件。</p>
</dd>
<dt><kbd><span class="option">-f<var>instrument-functions</var></span></kbd></dt>
<dd><p>生成用于调用和退出函数的检测调用。在函数进入之后和函数退出之前，将使用当前函数的地址及其调用位置来调用以下概要分析函数。（在某些平台上， __builtin_return_address 在当前功能之外无法正常工作，因此，否则分析功能可能无法使用呼叫站点信息。）</p>
<dl class="simple">
<dt>void __cyg_profile_func_enter (void <a href="#id13"><span class="problematic" id="id14">*</span></a>this_fn,</dt><dd><p>void <a href="#id15"><span class="problematic" id="id16">*</span></a>call_site);</p>
</dd>
<dt>void __cyg_profile_func_exit  (void <a href="#id17"><span class="problematic" id="id18">*</span></a>this_fn,</dt><dd><p>void <a href="#id19"><span class="problematic" id="id20">*</span></a>call_site);</p>
</dd>
</dl>
<p>第一个参数是当前函数的起始地址,可在符号表中准确查找。</p>
<p>对于在其他功能中内联扩展的功能，也可以使用此工具。分析调用指示概念上内联函数的输入和退出位置。这意味着此类功能的可寻址版本必须可用。如果您对函数的所有使用都被内联扩展，则可能意味着代码大小的其他扩展。如果在C代码中使用 extern inline ，则必须提供此类函数的可寻址版本。 （无论如何通常都是这种情况，但是如果您很幸运，并且优化器总是内联扩展功能，则可能不提供静态副本就已经放弃了。）</p>
<p>可以为函数赋予属性 no_instrument_function ，在这种情况下，不会执行此检测。例如，这可用于上面列出的性能分析函数，高优先级中断例程以及无法安全地从中调用性能概要分析功能的任何函数（如果性能概要分析例程生成输出或分配内存，则可能是信号处理程序）。请参阅通用功能属性。</p>
</dd>
</dl>
<p>-finstrument-functions-exclude-file-list=file,file,…</p>
<blockquote>
<div><p>设置被排除在仪器仪表之外的函数列表(请参见-finstrument-functions）。如果包含函数定义的 file 与file之一匹配，则不检测该函数。匹配是在子字符串上完成的：如果 file 参数是文件名的子字符串，则认为是匹配项。</p>
<p>例如:</p>
<p>-finstrument-functions-exclude-file-list=/bits/stl,include/sys</p>
<p>排除任何定义在文件路径名中含有/bits/stlorinclude/sys.</p>
<p>如果出于某种原因要添加字母“,’以 sym 之一写’,’。例如，-finstrument-functions-exclude-file-list=’,,tmp’（请注意选项周围的单引号）。</p>
</div></blockquote>
<p>-finstrument-functions-exclude-function-list=sym,sym,…</p>
<blockquote>
<div><p>这类似于-finstrument-functions-exclude-file-list，但此选项设置要从检测中排除的功能名称列表。要匹配的函数名称是其用户可见的名称，例如 vector&lt;int&gt; blah(const vector&lt;int&gt; &amp;) ，而不是内部错误的名称（例如 _Z4blahRSt6vectorIiSaIiEE ）。匹配是在子字符串上完成的：如果 sym 参数是函数名称的子字符串，则认为它是匹配项。对于C99和C ++扩展标识符，函数名称必须以UTF-8给出，而不是使用通用字符名称。</p>
</div></blockquote>
<p>-fpatchable-function-entry=N[,M]</p>
<blockquote>
<div><p>在每个函数的开头立即生成 N 个 NOP，函数入口点位于第 M 个NOP 之前。如果省略 M ，则默认为 0 ,因此函数条目指向第一个NOP处的地址。 NOP指令保留了额外的空间，只要代码段可写，就可以在运行时修补任何所需的仪器。空间的数量可以通过NOP的数量间接控制；使用的NOP指令对应于内部GCC后端接口 gen_nop 发出的指令。此行为是特定于目标的，并且还可能取决于体系结构变体和/或其他编译选项。</p>
<p>为了进行运行时识别，这些区域的起始地址（对应于它们各自的功能条目 M ）将另外收集在生成的二进制文件的 __patchable_function_entries 部分中。</p>
<p>请注意 __attribute__ ((patchable_function_entry (N,M))) 的值优先于命令行选项-fpatchable-function-entry=N,M。可以使用它来增加区域大小或在单个功能上将其完全删除。如果 N=0 ，则不记录打击垫位置。</p>
<p>NOP指令甚至在序言之前，也可能根据功能 M 插入到函数入口地址（可能取决于M）之前。</p>
<p>N 和 M 的最大值为 65535。</p>
</div></blockquote>
</div>
<div class="section" id="id21">
<h2>控制预处理器的选项<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h2>
<p>这些选项控制了C预处理器,它在实际编译之前在每个C源文件上运行。</p>
<p>如果您使用-E选项,除了预处理之外,什么都不做。其中一些选项只有与-E因为它们会导致预处理器的输出不适合实际编译。</p>
<p>除了此处列出的选项外，还有许多选项可控制“ 目录选项”中记录的包含文件的搜索路径。警告选项中列出了用于控制预处理器诊断的选项。</p>
<dl class="option-list">
<dt><kbd><span class="option">-D <var>name</var></span></kbd></dt>
<dd><p>将 name 预定义为宏，定义为 1 。</p>
</dd>
</dl>
<p>-D name=definition</p>
<blockquote>
<div><p>对 definition 的内容进行标记和处理，就像它们出现在翻译的第三阶段中，#define指令。特别是，该定义将被嵌入的换行符截断。</p>
<p>如果要从Shell或类似Shell的程序中调用预处理器，则可能需要使用Shell的引号语法来保护字符（例如在Shell语法中具有含义的空格）。</p>
<p>如果要在命令行上定义类似函数的宏，请在等号之前（如果有的话）在参数列表中加上括号。括号对大多数shell有意义，因此您应该引用该选项。使用 sh 和 csh ，-D’name(args…)=definition’works.</p>
<p>-Dand-U选项的处理顺序是在命令行中给出的。所有的-imacros fileand-include file选项在处理完所有的-Dand-Uoptions.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-U <var>name</var></span></kbd></dt>
<dd><p>取消 name 的任何以前的定义，该定义是内置的或随附的-Doption.</p>
</dd>
</dl>
<p>-include file</p>
<blockquote>
<div><p>处理 file ，就好像 #include “file” 出现在主要源文件的第一行一样。但是，搜索 file 的第一个目录是预处理程序的工作目录，而不是包含主源文件的目录。如果未在此处找到，则照常在 #include “…” 搜索链的其余部分中进行搜索。</p>
<p>如果多个-include选项,文件将按照它们在命令行中出现的顺序被包含。</p>
</div></blockquote>
<p>-imacros file</p>
<blockquote>
<div><p>就像…-include，除了将丢弃扫描 file 产生的任何输出。它定义的宏保持定义。这使您可以从标头获取所有宏，而无需处理其声明。</p>
<p>指定的所有文件-imacros指定的所有文件之前处理。-include.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-u<var>ndef</var></span></kbd></dt>
<dd><p>不要预先定义任何系统专用或GCC专用宏。标准的预定义宏仍然被定义。</p>
</dd>
<dt><kbd><span class="option">-p<var>thread</var></span></kbd></dt>
<dd><p>定义使用POSIX线程库所需的附加宏。你应该在编译和链接时一致使用这个选项。这个选项在GNU/Linux目标机、大多数其他Unix衍生产品以及x86 Cygwin和MinGW目标机上都受到支持。</p>
</dd>
<dt><kbd><span class="option">-M</span></kbd></dt>
<dd><p>而不是输出预处理结果，而是输出适用于 make 描述主源文件的依赖关系的规则。预处理器输出一个 make 规则，其中包含该源文件的目标文件名，一个冒号以及所有包含的文件的名称，包括那些来自-includeor-imacros命令行选项。</p>
<p>除非明确规定(用-MTor-MQ），目标文件名由源文件名组成，后缀替换为目标文件后缀，并且前导目录部分已删除。如果包含许多文件，则使用’将规则分为几行'-新队。该规则没有命令。</p>
<p>此选项不会取消预处理器的调试输出，例如-dM。为避免将此类调试输出与依赖项规则混合使用，应使用以下命令显式指定依赖项输出文件：-MF，或使用 DEPENDENCIES_OUTPUT 之类的环境变量（请参阅环境变量）。调试输出仍将照常发送到常规输出流。</p>
<p>Passing-M对司机来说,意味着-E，并使用隐式禁止显示警告-w.</p>
</dd>
<dt><kbd><span class="option">-M<var>M</var></span></kbd></dt>
<dd><p>Like-M但不提系统头目录中的头文件,也不提直接或间接从这种头文件中包含的头文件。</p>
<p>这表示在’中选择尖括号或双引号#include’指令本身并不能确定该标头是否出现在-MM依赖性输出。</p>
</dd>
</dl>
<p>-MF file</p>
<blockquote>
<div><p>搭配使用时-Mor-MM，指定要写入依赖项的文件。如果不-MF开关给定后,预处理器会将规则发送到与预处理输出相同的地方。</p>
<p>当与驱动程序选项一起使用时-MDor-MMD,-MF覆盖默认的依赖性输出文件。</p>
<p>如果 file 是-，然后将依赖项写入stdout.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-M<var>G</var></span></kbd></dt>
<dd><p>与以下选项相结合,如-M请求生成依赖关系。-MG假定缺少的头文件是生成的文件，并将它们添加到依赖项列表中而不会引发错误。依赖文件名直接从 #include 指令获取，而无需添加任何路径。-MG也抑制了预处理的输出,因为缺少头文件会使其失去作用。</p>
<p>这个功能用于自动更新makefile。</p>
</dd>
<dt><kbd><span class="option">-M<var>no-modules</var></span></kbd></dt>
<dd><p>禁用编译模块接口的依赖性生成。</p>
</dd>
<dt><kbd><span class="option">-M<var>P</var></span></kbd></dt>
<dd><p>此选项指示CPP为除主文件以外的每个依赖项添加一个假目标，从而使每个依赖项均不依赖任何内容。这些假规则将避开错误 make 给人如果删除头文件时不更新Makefile来配合。</p>
<p>这是典型的输出。</p>
<p>test.o: test.c test.h</p>
<p>test.h:</p>
</dd>
</dl>
<p>-MT target</p>
<blockquote>
<div><p>更改依赖项生成所发出的规则的目标。默认情况下，CPP使用主输入文件的名称，删除所有目录组件和任何文件后缀，例如“.c”，并附加平台的常用对象后缀。结果就是目标。</p>
<p>An-MT选项将目标设置为您指定的字符串。如果你想要多个目标,你可以将它们作为一个参数指定给-MT，或使用多个-MToptions.</p>
<p>例如， -MT ‘$(objpfx)foo.o’ 可能会给出</p>
<p>$(objpfx)foo.o: foo.c</p>
</div></blockquote>
<p>-MQ target</p>
<blockquote>
<div><p>同理-MT，但引用了Make特殊的任何字符。 -MQ ‘$(objpfx)foo.o’ 给出</p>
<p>$$(objpfx)foo.o: foo.c</p>
<p>默认的目标是自动引用的,就像用-MQ.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-M<var>D</var></span></kbd></dt>
<dd><p>-MD相当于-M -MF file， 除了那个-E不暗示。该驱动程序确定 file 基于是否-o选项是否给定。如果有,驱动程序就会使用它的参数,但后缀为.d，否则它将使用输入文件的名称，删除所有目录组件和后缀，并应用.dsuffix.</p>
<p>If-MD搭配-E， 任何-o可以将switch理解为指定依赖项输出文件（请参阅-MF），但是如果不使用-E， 每个-o可以理解为指定一个目标对象文件。</p>
<p>Since-E并不意味着。-MD可以用来生成依赖性输出文件,作为编译过程的一个副作用。</p>
</dd>
<dt><kbd><span class="option">-M<var>MD</var></span></kbd></dt>
<dd><p>Like-MD除了只提用户头文件,不提系统头文件。</p>
</dd>
<dt><kbd><span class="option">-f<var>preprocessed</var></span></kbd></dt>
<dd><p>向预处理器表明输入文件已经被预处理。这将抑制诸如宏扩展、三段式转换、转义换行拼接以及大多数指令的处理。预处理器仍然会识别和删除注释,因此你可以将一个已经用-C到编译器,而不会出现问题。在这种模式下,集成的预处理器不过是一个前端的标记器。</p>
<p>-fpreprocessed如果输入文件具有扩展名之一，则为隐式.i’，’.ii’ 要么 ‘.mi’。这些是GCC用于由创建的预处理文件的扩展名-save-temps.</p>
</dd>
<dt><kbd><span class="option">-f<var>directives-only</var></span></kbd></dt>
<dd><p>预处理时,处理指令,但不要展开宏。</p>
<p>该选项的行为取决于-Eand-fpreprocessedoptions.</p>
<p>With-E，预处理被限制为指示诸如的处理 #define ， #ifdef 来，和 #error 。不执行其他预处理器操作，例如宏扩展和三字图转换。除此之外-dD选项是隐式启用的。</p>
<p>With-fpreprocessed，命令行和大多数内置宏的预定义已禁用。上下文相关的宏（如 __LINE__ ）可以正常处理。这样可以编译以前用 -E -fdirectives-only 预处理过的文件。</p>
<p>有了这两个-Eand-fpreprocessed，规则-fpreprocessed取得优先权。这样可以对以前使用 -E -fdirectives-only 进行过预处理的文件进行全面预处理。</p>
</dd>
<dt><kbd><span class="option">-f<var>dollars-in-identifiers</var></span></kbd></dt>
<dd><p>接受“$’在标识符中。</p>
</dd>
<dt><kbd><span class="option">-f<var>extended-identifiers</var></span></kbd></dt>
<dd><p>在标识符中接受通用字符名和扩展字符。对于C99(及以后的C标准版本)和C++来说,这个选项是默认启用的。</p>
</dd>
<dt><kbd><span class="option">-f<var>no-canonical-system-headers</var></span></kbd></dt>
<dd><p>预处理时,不要用规范化缩短系统头路径。</p>
</dd>
</dl>
<p>-fmax-include-depth=depth</p>
<blockquote>
<div><p>设置嵌套#include的最大深度。默认为200。</p>
</div></blockquote>
<p>-ftabstop=width</p>
<blockquote>
<div><p>设置制表符停止符之间的距离。这有助于预处理器在警告或错误中报告正确的列号,即使行上出现制表符。如果该值小于1或大于100,该选项将被忽略。默认值是8。</p>
</div></blockquote>
<p>-ftrack-macro-expansion[=level]</p>
<blockquote>
<div><p>在宏扩展中跟踪令牌的位置。当宏扩展中发生编译错误时，这允许编译器发出有关当前宏扩展堆栈的诊断。使用此选项会使预处理器和编译器消耗更多的内存。的 level 的参数可以用于选择的因此降低了存储器消耗如果需要令牌位置跟踪的精度水平。价值’0level ‘ 禁用此选项。价值’1为了最小化内存开销，“”以降级模式跟踪令牌位置。在这种模式下，由函数式宏的参数扩展产生的所有标记都具有相同的位置。价值’2’完全跟踪令牌位置。此值是最消耗内存的。如果不给此选项提供参数，则默认参数值为’2’.</p>
<p>请注意，默认情况下 -ftrack-macro-expansion=2 被激活。</p>
</div></blockquote>
<p>-fmacro-prefix-map=old=new</p>
<blockquote>
<div><p>当预处理目录下的文件时。old，展开 __FILE__ 和 __BASE_FILE__ 宏，就像文件位于目录中一样new来代替。这可以用来将绝对路径改为相对路径,使用.对于 new ，可以生成与位置无关的更可复制的版本。此选项还会在编译期间影响 __builtin_FILE() 。也可以看看-ffile-prefix-map.</p>
</div></blockquote>
<p>-fexec-charset=charset</p>
<blockquote>
<div><p>设置执行字符集，用于字符串和字符常量。默认值为UTF-8。 charset 可以是系统的 iconv 库例程支持的任何编码。</p>
</div></blockquote>
<p>-fwide-exec-charset=charset</p>
<blockquote>
<div><p>设置宽执行字符集，用于宽字符串和字符常量。缺省值为UTF-32或UTF-16，与 wchar_t 的宽度相对应。与-fexec-charset， charset 可以由系统支持的任何编码 iconv 库程序; 但是，您将遇到与 wchar_t 不完全匹配的编码问题。</p>
</div></blockquote>
<p>-finput-charset=charset</p>
<blockquote>
<div><p>设置输入字符集，用于将输入文件的字符集转换为GCC使用的源字符集。如果未指定语言环境，或者GCC无法从语言环境获取此信息，则默认值为UTF-8。可以通过语言环境或此命令行选项来覆盖它。当前，如果有冲突，则命令行选项优先。 charset 可以是系统的 iconv 库例程支持的任何编码。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>pch-deps</var></span></kbd></dt>
<dd><p>使用预编译头文件时（请参见Precompiled Headers），此标志使依赖项输出标志也列出来自预编译头文件的依赖项的文件。如果未指定，则仅列出预编译的标头，而不列出用于创建它的文件，因为在使用预编译的标头时不会查询这些文件。</p>
</dd>
<dt><kbd><span class="option">-f<var>pch-preprocess</var></span></kbd></dt>
<dd><p>此选项允许将预编译头（请参阅预编译头）与-E。它将在输出中插入特殊的 #pragma ， #pragma GCC pch_preprocess “filename” ，以标记发现预编译标头的位置及其 filename 。什么时候-fpreprocessed在使用中，GCC会识别出此 #pragma 并加载PCH。</p>
<p>这个选项默认是关闭的,因为最终的预处理输出只适合作为GCC的输入。这个选项可以通过-save-temps.</p>
<p>您不应在自己的代码中编写此 #pragma ，但如果PCH文件在其他位置可用，则可以安全地编辑文件名。文件名可以是绝对文件名，也可以是相对于GCC当前目录的文件名。</p>
</dd>
<dt><kbd><span class="option">-f<var>working-directory</var></span></kbd></dt>
<dd><p>在预处理器输出中启用行标记的生成，使编译器在预处理时知道当前的工作目录。启用此选项后，预处理器将在初始行标记之后发出第二个行标记，其中第二行标记带有当前工作目录，后跟两个斜杠。当该目录存在于预处理输入中时，GCC使用该目录作为某些调试信息格式作为当前工作目录发出的目录。如果启用了调试信息，则隐式启用此选项，但是可以使用反数形式将其禁止-fno-working-directory。如果-P命令行中存在标记，此选项无效，因为不会发出任何 #line 指令。</p>
</dd>
</dl>
<p>-A predicate=answer</p>
<blockquote>
<div><p>用谓词 predicate 并 answer 。此表格优于旧表格- predicate （ answer ），仍受支持，因为它不使用shell特殊字符。</p>
</div></blockquote>
<p>-A -predicate=answer</p>
<blockquote>
<div><p>取消与谓词断言 predicate 和答案 answer 。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-C</span></kbd></dt>
<dd><p>不要丢弃注释。所有的注释都会被传递到输出文件中,但经过处理的指令中的注释除外,这些注释会和指令一起被删除。</p>
<p>您应该准备好在使用-C; 它使预处理器本身将注释视为标记。例如，在指令行的开头出现的注释会将其变成普通的源代码行，因为该行上的第一个标记不再是’#’.</p>
</dd>
<dt><kbd><span class="option">-C<var>C</var></span></kbd></dt>
<dd><p>不要丢弃评论,包括在宏扩展期间。这就像-C，但宏中包含的注释也会传递到扩展宏的输出文件中。</p>
<p>的副作用。-C选项,该-CC选项会使宏中所有C++风格的注释转换为C风格的注释。这是为了防止以后使用该宏时无意中注释了源行的剩余部分。</p>
<p>The-CC选项一般用于支持lint注释。</p>
</dd>
<dt><kbd><span class="option">-P</span></kbd></dt>
<dd><p>禁止在预处理器的输出中生成行标记。当预处理器在非C代码上运行时,这可能是有用的,因为预处理器将被发送到一个可能会被行标记所混淆的程序。</p>
</dd>
</dl>
<p>-traditional
-traditional-cpp</p>
<blockquote>
<div><p>尽量模仿前标准C预处理器的行为,而不是ISO C预处理器。详见GNU CPP手册。</p>
<p>请注意,GCC并不试图模拟一个预标准的C编译器,而这些选项只有在使用了-E开关时,或显式调用CPP时。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-t<var>rigraphs</var></span></kbd></dt>
<dd><p>支持ISO C三部曲。这些是三个字符的序列，都以“??’，由ISO C定义以代表单个字符。例如， ‘??/’ 代表 ‘'，所以’’??/n’’是换行符的字符常量。</p>
<p>九宫格及其替代物为</p>
<p>Trigraph:       ??(  ??)  ??&lt;  ??&gt;  ??=  ??/  ??’  ??!  ??-
Replacement:      [    ]    {    }    #       ^    |    ~</p>
<p>默认情况下,GCC会忽略三角图,但在符合标准的模式下,它会转换三角图。参见-stdand-ansioptions.</p>
</dd>
<dt><kbd><span class="option">-r<var>emap</var></span></kbd></dt>
<dd><p>启用特殊代码,以绕过只允许非常短的文件名的文件系统,如MS-DOS。</p>
</dd>
<dt><kbd><span class="option">-H</span></kbd></dt>
<dd><p>除其他正常活动外，还打印所使用的每个头文件的名称。每个名称都会缩进，以显示“#include”“是的。预编译的头文件也会被打印，即使发现它们是无效的也是如此。无效的预编译头文件带有’…x’，以及带有’…!’。</p>
</dd>
<dt><kbd><span class="option">-d<var>letters</var></span></kbd></dt>
<dd><p>表示按照 letters 指定的方式在编译过程中进行调试转储。此处记录的标志是与预处理器相关的标志。其他 letters 由编译器自行解释，或保留给以后的GCC版本，因此将被静默忽略。如果指定行为冲突的 letters ，则结果是不确定的。有关更多信息，请参见开发人员选项。</p>
<dl class="option-list">
<dt><kbd><span class="option">-d<var>M</var></span></kbd></dt>
<dd><p>代替正常输出，生成一个“#define’指令，用于在预处理器执行期间定义的所有宏，包括预定义的宏。这使您可以找到预处理器版本中预定义的内容。假设您没有文件foo.h， 命令</p>
<p>touch foo.h; cpp -dM foo.h</p>
<p>显示所有预定义的宏。</p>
<p>如果您使用-dM橆-Eoption,-dM的同义词。-fdump-rtl-mach. 请参阅(gcc) 开发人员选项。</p>
</dd>
<dt><kbd><span class="option">-d<var>D</var></span></kbd></dt>
<dd><p>Like-dM除了在两个方面：它不包括预定义的宏，并输出两者的’#define’指令和预处理结果。两种输出都进入标准输出文件。</p>
</dd>
<dt><kbd><span class="option">-d<var>N</var></span></kbd></dt>
<dd><p>Like-dD，但仅发出宏名称，而不发出其扩展名。</p>
</dd>
<dt><kbd><span class="option">-d<var>I</var></span></kbd></dt>
<dd><p>输出’#include’指令以及预处理结果。</p>
</dd>
<dt><kbd><span class="option">-d<var>U</var></span></kbd></dt>
<dd><p>Like-dD除了仅输出已扩展的宏或已在预处理程序指令中测试其定义性的宏之外；输出被延迟到使用或测试宏为止；和’#undef指令也会输出给测试过的宏，但当时未定义。</p>
</dd>
</dl>
</dd>
<dt><kbd><span class="option">-f<var>debug-cpp</var></span></kbd></dt>
<dd><p>这个选项只对调试GCC有用。当从CPP或与-E，它会转储有关位置图的调试信息。输出中的每个令牌都在其位置所属的地图转储之前。</p>
<p>当从GCC使用时,不需要-E，此选项无效。</p>
</dd>
</dl>
<p>-Wp,option</p>
<blockquote>
<div><p>您可以使用-Wp,option绕过编译器驱动程序并将 option 直接传递给预处理器。如果 option 包含逗号，则会在逗号处将其拆分为多个选项。但是，许多选项在传递给预处理器之前由编译器驱动程序进行了修改，翻译或解释，并且-Wp强制绕过此阶段。预处理程序的直接接口是未记录的，可能会发生更改，因此，应尽可能避免使用-Wp并让驱动程序来处理这些选项。</p>
</div></blockquote>
<p>-Xpreprocessor option</p>
<blockquote>
<div><p>通过 option 作为预处理器的选项。您可以使用它来提供GCC无法识别的特定于系统的预处理器选项。</p>
<p>如果你想传递一个接受参数的选项,你必须使用-Xpreprocessor两次,一次是选项,一次是参数。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-n<var>o-integrated-cpp</var></span></kbd></dt>
<dd><p>编译之前，将预处理作为单独的过程进行。默认情况下，GCC将预处理作为输入标记和解析的集成部分。如果这个选项被提供时，相应的语言前端（ cc1 ， cc1plus ，或 cc1obj 为C，C ++，和Objective-C，分别地）代替调用两次，一次仅用于预处理，一次用于预处理输入的实际编译。此选项可能与-Bor-wrapper选项来指定一个备用的预处理器,或在正常的预处理和编译之间对程序源进行额外的处理。</p>
</dd>
<dt><kbd><span class="option">-f<var>large-source-files</var></span></kbd></dt>
<dd><p>调整GCC以期待大的源文件,代价是较慢的编译速度和较高的内存使用率。</p>
<p>具体来说,GCC通常会跟踪源文件中的列号和行号,并且通常会在诊断中打印出这两个数字。然而,一旦它处理了一定数量的源代码行,它就会停止追踪列号,而只追踪行号。这意味着后面的行的诊断程序不包括列号。这也意味着,像-Wmisleading-indentation在这一点上停止工作,尽管如果发生这种情况,编译器会打印一个注释。传递-flarge-source-files大大增加了GCC在停止追踪列之前所能处理的源代码行数。</p>
</dd>
</dl>
</div>
<div class="section" id="id22">
<h2>将选项传递给汇编器<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h2>
<p>你可以将选项传递给汇编器。</p>
<p>-Wa,option</p>
<blockquote>
<div><p>通过 option 作为一个选项，以汇编。如果 option 包含逗号，则会在逗号处将其拆分为多个选项。</p>
</div></blockquote>
<p>-Xassembler option</p>
<blockquote>
<div><p>通过 option 作为一个选项，以汇编。您可以使用它来提供GCC无法识别的系统特定的汇编器选项。</p>
<p>如果你想传递一个接受参数的选项,你必须使用-Xassembler两次,一次是选项,一次是参数。</p>
</div></blockquote>
</div>
<div class="section" id="id23">
<h2>链接选项<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h2>
<p>当编译器将对象文件链接到可执行输出文件时,这些选项就会发挥作用。如果编译器不进行链接步骤,这些选项就没有意义。</p>
<p>object-file-name</p>
<blockquote>
<div><p>文件名如果不以特殊认可的后缀结尾,则被认为是对象文件或库的名称(对象文件和库由链接器根据文件内容区分)。(对象文件与库的区别是由链接器根据文件内容来区分的。)如果进行链接,这些对象文件将作为链接器的输入。</p>
</div></blockquote>
<p>-c
-S
-E</p>
<blockquote>
<div><p>如果使用这些选项中的任何一个，则不会运行链接器，并且不应将目标文件名用作参数。请参阅总体选项。</p>
</div></blockquote>
<p>-flinker-output=type</p>
<blockquote>
<div><p>这个选项控制链接时间优化器的代码生成。默认情况下,链接器的输出是由链接器插件自动决定的。对于编译器的调试,以及如果需要用非LTO对象文件进行增量链接,可能需要手动控制类型。</p>
<p>如果 type 为“exec’，代码生成会生成静态二进制文件。在这种情况下-fpicand-fpie都是禁用的。</p>
<p>如果 type 为“dyn’，代码生成产生一个共享库。在这种情况下-fpicor-fPIC被保留,但不会自动启用。这允许在可能的架构上,例如在x86上,构建共享库,而不需要独立于位置的代码。</p>
<p>如果 type 为“pie’，代码生成会产生一个-fpie可执行文件。这样会产生与“exec’ 除了那个-fpie如果在编译时指定,则不会被禁用。</p>
<p>如果 type 为“rel’，编译器假定已完成增量链接。包含用于链接时优化的中间代码的部分将合并，预先优化，然后输出到生成的目标文件中。另外，如果-ffat-lto-objects指定了二进制代码,为将来的非LTO链接生成二进制代码。通过增量链接产生的对象文件比由相同对象文件产生的静态库要小。在链接时,假设库中的大部分对象都被使用,增量链接的结果加载速度也比静态库快。</p>
<p>最后’nolto-rel将编译器配置为增量链接，其中强制执行代码生成，生成最终的二进制文件，并剥离用于后续链接时间优化的中间代码。当将多个目标文件链接在一起时，与禁用链接时优化（例如，发生跨模块内联）相比，对结果代码的优化效果更好，但是整个程序优化的大部分好处都将丢失。</p>
<p>在增量环节(由-r）链接器插件默认为rel。但是，使用GNU Binutils的当前接口，不可能将LTO对象和非LTO对象增量链接到单个混合对象文件中。如果增量链接中的任何目标文件不能用于链接时间优化，则链接器插件会发出警告并使用“nolto-rel’。为了保持整个程序的优化，建议将此类对象链接到静态库中。另外，也可以将HJ Lu的binutils与混合对象一起使用。</p>
</div></blockquote>
<p>-fuse-ld=bfd</p>
<blockquote>
<div><p>使用 bfd 链接器而不是默认链接器。</p>
</div></blockquote>
<p>-fuse-ld=gold</p>
<blockquote>
<div><p>使用 gold 链接器而不是默认链接器。</p>
</div></blockquote>
<p>-fuse-ld=lld</p>
<blockquote>
<div><p>使用LLVM lld 链接器代替默认链接器。</p>
</div></blockquote>
<p>-llibrary
-l library</p>
<blockquote>
<div><p>链接时搜索名为 library 的库。（使用库作为单独参数的第二种替代方法仅是为了符合POSIX，不建议这样做。）</p>
<p>The-l选项是由GCC直接传递给链接器的。具体细节请参考你的链接器文档。下面的一般描述适用于GNU链接器。</p>
<p>链接器为库搜索一个标准的目录列表。搜索的目录包括几个标准的系统目录和任何你用-L.</p>
<p>静态库是对象文件的归档,文件名有如liblibrary.a。一些目标还支持共享库，这些共享库的名称通常如下liblibrary.so。如果同时找到静态库和共享库，则链接器将优先选择与共享库链接，除非-static选项被使用。</p>
<p>在命令中写入此选项的位置会有所不同；链接器按照指定的顺序搜索和处理库和目标文件。因此，foo.o -lz bar.o。“搜索库”z’文件后foo.o但在bar.o。如果bar.o指的是“z’，则可能不会加载这些功能。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-l<var>objc</var></span></kbd></dt>
<dd><p>你需要这种特殊情况下的-l选项,以链接一个Objective-C或Objective-C++程序。</p>
</dd>
<dt><kbd><span class="option">-n<var>ostartfiles</var></span></kbd></dt>
<dd><p>链接时不要使用标准系统启动文件。标准系统库是正常使用的,除非-nostdlib,-nolibc， 或者-nodefaultlibs是用。</p>
</dd>
<dt><kbd><span class="option">-n<var>odefaultlibs</var></span></kbd></dt>
<dd><p>链接时不要使用标准的系统库。只有你指定的库才会传递给链接器,而指定系统库链接的选项,如-static-libgccor-shared-libgcc，将被忽略。正常使用标准启动文件，除非-nostartfiles是用。</p>
<p>编译器可能会生成对 memcmp ， memset ， memcpy 和 memmove 的调用。这些条目通常由libc中的条目解析。指定此选项后，应通过其他某种机制来提供这些入口点。</p>
</dd>
<dt><kbd><span class="option">-n<var>olibc</var></span></kbd></dt>
<dd><p>链接时不要使用C库或与之紧密耦合的系统库。还是用启动文件链接。libgcc或工具链提供的语言支持库,如libgnat,libgfortranorlibstdc++除非同时使用了防止其被包含的选项。这通常会删除-lc以及通常与它一起使用的系统库,当假定没有C库时,这些系统库就变得毫无意义,如-lpthreador-lm在某些配置中。这是为裸板目标设计的,当确实没有C库可用时。</p>
</dd>
<dt><kbd><span class="option">-n<var>ostdlib</var></span></kbd></dt>
<dd><p>链接时不要使用标准的系统启动文件或库。没有启动文件,只把你指定的库传递给链接器,而指定系统库链接的选项,如-static-libgccor-shared-libgcc，将被忽略。</p>
<p>编译器可能会生成对 memcmp ， memset ， memcpy 和 memmove 的调用。这些条目通常由libc中的条目解析。指定此选项后，应通过其他某种机制来提供这些入口点。</p>
<p>绕过的一个标准库-nostdliband-nodefaultlibsislibgcc.a，一个内部子程序库，GCC 使用它来克服特定机器的缺点，或某些语言的特殊需求。（参见GNU Compiler Collection (GCC) Internals 中的GCC 输出接口，了解更多关于libgcc.a。）在大多数情况下，您需要libgcc.a即使你想避开其他标准库。换句话说,当你指定-nostdlibor-nodefaultlibs你通常应该指定-lgcc以及。这确保您没有对内部 GCC 库子例程的未解析引用。（此类内部子例程的一个示例是 __main ，用于确保调用 C++ 构造函数；请参阅GNU Compiler Collection (GCC) Internals 中的 collect2 。）</p>
</dd>
</dl>
<p>-e entry
–entry=entry</p>
<blockquote>
<div><p>指定程序入口点为 entry 。参数由链接器解释；GNU链接器接受符号名称或地址。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-p<var>ie</var></span></kbd></dt>
<dd><p>在支持它的目标上生成一个动态链接的独立于位置的可执行文件。为了获得可预测的结果,您还必须指定用于编译的同一组选项 (-fpie,-fPIE，或模型子选项）。</p>
</dd>
<dt><kbd><span class="option">-n<var>o-pie</var></span></kbd></dt>
<dd><p>不要产生动态链接的位置无关可执行文件。</p>
</dd>
<dt><kbd><span class="option">-s<var>tatic-pie</var></span></kbd></dt>
<dd><p>在支持静态位置独立的目标上生成一个静态位置独立的可执行文件。静态位置独立的可执行文件类似于静态可执行文件,但可以在任何地址加载,而不需要动态链接器。为了获得可预测的结果,您还必须指定用于编译的同一组选项(-fpie,-fPIE，或模型子选项）。</p>
</dd>
<dt><kbd><span class="option">-p<var>thread</var></span></kbd></dt>
<dd><p>与POSIX线程库链接。这个选项在GNU/Linux目标机、大多数其他Unix衍生产品以及x86的Cygwin和MinGW目标机上都得到了支持。在一些目标机上,这个选项也会为预处理器设置标志,所以在编译和链接时应该一致使用。</p>
</dd>
<dt><kbd><span class="option">-r</span></kbd></dt>
<dd><p>产生一个可重定位的对象作为输出。这也就是所谓的部分链接。</p>
</dd>
<dt><kbd><span class="option">-r<var>dynamic</var></span></kbd></dt>
<dd><p>传旗-export-dynamic到支持它的目标上的ELF链接器。这指示链接器将所有符号（不仅是已使用的符号）添加到动态符号表中。对于 dlopen 的某些用法或允许从程序内部获取回溯，此选项是必需的。</p>
</dd>
<dt><kbd><span class="option">-s</span></kbd></dt>
<dd><p>从可执行文件中删除所有符号表和重定位信息。</p>
</dd>
<dt><kbd><span class="option">-s<var>tatic</var></span></kbd></dt>
<dd><p>在支持动态链接的系统中,这将取代-pie并防止与共享库链接。在其他系统中,这个选项没有任何效果。</p>
</dd>
<dt><kbd><span class="option">-s<var>hared</var></span></kbd></dt>
<dd><p>生成一个共享对象,然后可以与其他对象链接,形成一个可执行文件。并非所有系统都支持这个选项。为了获得可预测的结果,您还必须指定用于编译的同一组选项(-fpic,-fPIC，或模型子选项）。1个</p>
</dd>
</dl>
<p>-shared-libgcc
-static-libgcc</p>
<blockquote>
<div><p>关于系统,提供libgcc作为共享库,这些选项分别强制使用共享或静态版本。如果没有共享版本的libgcc是在编译器配置时建立的,这些选项没有效果。</p>
<p>有几种情况下,应用程序应该使用共享的libgcc而不是静态版本。其中最常见的是当应用程序希望在不同的共享库中抛出和捕获异常。在这种情况下,每个库以及应用程序本身都应该使用共享的libgcc.</p>
<p>因此,G++驱动会自动添加-shared-libgcc每当你构建一个共享库或主可执行文件时,因为C++程序通常使用异常,所以这是正确的做法。</p>
<p>如果您使用GCC驱动程序来创建共享库,您可能会发现它们并不总是与共享的libgcc。如果GCC在配置时发现您有一个非GNU链接程序或不支持选项的GNU链接程序–eh-frame-hdr，它链接了的共享版本libgcc到共享库中,默认情况下,它利用链接器的优势,优化了与共享库的链接。否则,它就会利用链接器的优势,优化与共享版本的libgcc，默认情况下链接到静态版本的libgcc。这允许异常通过此类共享库传播，而不会在库加载时招致重定位成本。</p>
<p>但是,如果一个库或主可执行文件应该抛出或捕获异常,你必须使用G++驱动或使用选项-shared-libgcc，使其与共享链接libgcc.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-s<var>tatic-libasan</var></span></kbd></dt>
<dd><p>当-fsanitize=address选项来链接程序,GCC驱动程序会自动与以下选项进行链接。libasan。如果libasan是作为共享库提供的,而-static选项不被使用,那么这将链接到共享版本的libasan。这-static-libasan选项指示GCC驱动程序链接到libasan静态地,而不一定要静态地链接其他库。</p>
</dd>
<dt><kbd><span class="option">-s<var>tatic-libtsan</var></span></kbd></dt>
<dd><p>当-fsanitize=thread选项来链接程序,GCC驱动程序会自动与以下选项进行链接。libtsan。如果libtsan是作为共享库提供的,而-static选项不被使用,那么这将链接到共享版本的libtsan。这-static-libtsan选项指示GCC驱动程序链接到libtsan静态地,而不一定要静态地链接其他库。</p>
</dd>
<dt><kbd><span class="option">-s<var>tatic-liblsan</var></span></kbd></dt>
<dd><p>当-fsanitize=leak选项来链接程序,GCC驱动程序会自动与以下选项进行链接。liblsan。如果liblsan是作为共享库提供的,而-static选项不被使用,那么这将链接到共享版本的liblsan。这-static-liblsan选项指示GCC驱动程序链接到liblsan静态地,而不一定要静态地链接其他库。</p>
</dd>
<dt><kbd><span class="option">-s<var>tatic-libubsan</var></span></kbd></dt>
<dd><p>当-fsanitize=undefined选项来链接程序,GCC驱动程序会自动与以下选项进行链接。libubsan。如果libubsan是作为共享库提供的,而-static选项不被使用,那么这将链接到共享版本的libubsan。这-static-libubsan选项指示GCC驱动程序链接到libubsan静态地,而不一定要静态地链接其他库。</p>
</dd>
</dl>
<p>-static-libstdc++</p>
<blockquote>
<div><p>使用 g++ 程序链接C ++程序时，通常会自动链接到libstdc++。如果libstdc++是作为共享库提供的,而-static选项不被使用,那么这将链接到共享版本的libstdc++。通常没关系。不过，冻结版本有时会很有用libstdc++由程序使用,而不需要一直走到完全静态的链接。该-static-libstdc++选项指示 g++ 驱动程序链接libstdc++静态地,而不一定要静态地链接其他库。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-s<var>ymbolic</var></span></kbd></dt>
<dd><p>构建共享对象时,将引用绑定到全局符号。对任何未解决的引用发出警告(除非被链接编辑器选项覆盖-Xlinker -z -Xlinker defs）。只有少数系统支持此选项。</p>
</dd>
<dt><kbd><span class="option">-T <var>script</var></span></kbd></dt>
<dd><p>使用 script 作为链接描述文件。大多数使用GNU链接器的系统都支持此选项。在某些目标上，例如没有操作系统的裸板目标，-T链接时可能需要使用该选项,以避免引用未定义的符号。</p>
</dd>
</dl>
<p>-Xlinker option</p>
<blockquote>
<div><p>通过 option 作为链接器的选项。您可以使用它来提供GCC无法识别的特定于系统的链接器选项。</p>
<p>如果你想传递一个需要单独参数的选项,你必须使用-Xlinker两次,一次是选项,一次是参数。例如,要传递断言定义，您必须写-Xlinker -assert -Xlinker定义。不能写-Xlinker“声明定义”，因为这会将整个字符串作为单个参数传递，这不是链接程序所期望的。</p>
<p>当使用GNU链接器时,通常更方便的做法是使用option=value语法,而不是作为单独的参数。例如,你可以指定-Xlinker -Map = output.map而非-Xlinker -Map -Xlinker output.map。其他链接器可能不支持命令行选项的此语法。</p>
</div></blockquote>
<p>-Wl,option</p>
<blockquote>
<div><p>通过 option 作为链接器的选项。如果 option 包含逗号，则会在逗号处将其拆分为多个选项。您可以使用此语法将参数传递给选项。例如，-Wl,-Map,output.mappasses地图输出.map到链接器上。当使用GNU链接器时,你也可以通过使用-Wl,-Map=output.map.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-u <var>symbol</var></span></kbd></dt>
<dd><p>假设符号 symbol 未定义，以强制链接库模块对其进行定义。您可以使用-u多次使用不同的符号来强制加载额外的库模块。</p>
</dd>
<dt><kbd><span class="option">-z <var>keyword</var></span></kbd></dt>
<dd><p>-z与关键字 keyword 一起直接传递给链接器。有关允许的值及其含义，请参见链接器文档中的部分。</p>
</dd>
</dl>
<p>Footnotes
(1)</p>
<p>在某些系统上，gcc -shared需要构建补充存根代码以使构造函数正常工作。在多库系统上，gcc -shared’必须选择正确的支持库进行链接。不提供正确的标志可能会导致细微的缺陷。在不需要它们的情况下提供它们是无害的。</p>
</div>
<div class="section" id="id24">
<h2>目录搜索选项<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h2>
<p>这些选项指定了要搜索头文件、库和编译器部分的目录。</p>
<p>-I dir
-iquote dir
-isystem dir
-idirafter dir</p>
<blockquote>
<div><p>将目录 dir 添加到要在预处理过程中搜索头文件的目录列表中。如果 dir 以’=或 $SYSROOT ，然后是’=’或 $SYSROOT 替换为sysroot前缀；看到–sysrootand-isysroot.</p>
<p>指定的目录,用-iquote仅适用于指令 #include “file” 的引用形式。指定目录-I,-isystem， 或者-idirafter适用于同时查找 #include “file” 和 #include &lt;file&gt; 指令。</p>
<p>您可以在命令行中指定这些选项的任意数量或组合,以搜索多个目录中的头文件。查找顺序如下。</p>
<blockquote>
<div><p>对于引用形式的include指令,会先搜索当前文件的目录。
对于include指令的引用形式,由-iquote选项按照命令行中出现的从左到右的顺序进行搜索。
指定的目录,用-I选项按从左到右的顺序扫描。
指定的目录,用-isystem选项按从左到右的顺序扫描。
扫描标准系统目录。
指定的目录,用-idirafter选项按从左到右的顺序扫描。</p>
</div></blockquote>
<p>您可以使用-I来覆盖系统头文件,替换您自己的版本,因为这些目录会在标准系统头文件目录之前被搜索。然而,你不应该使用这个选项来添加包含供应商提供的系统头文件的目录;使用-isystem为此。</p>
<p>The-isystemand-idirafter选项还将该目录标记为系统目录,使其得到与标准系统目录相同的特殊处理。</p>
<p>如果是标准的系统包含目录,或者是用-isystem，也指定了-I， 这-I选项将被忽略。该目录仍在搜索，但作为系统目录位于系统包含链中的正常位置。这是为了确保不会错误地更改GCC修正错误的系统标题的过程以及 #include_next 指令的顺序。如果您确实需要更改系统目录的搜索顺序，请使用-nostdincand/or-isystemoptions.</p>
</div></blockquote>
<p>-I-</p>
<blockquote>
<div><p>分割包含路径。这个选项已经被废止。请使用-iquote取而代之-I前的目录。-I-并去除-I-option.</p>
<p>任何用-I选项前-I-仅搜索 #include “file” 请求的标头; 他们不会搜索 #include &lt;file&gt; 。如果指定了其他目录-I后的选项-I-，则在这些目录中搜索所有“#include’指令。</p>
<p>此外:-I-禁止将当前文件目录的目录用作 #include “file” 的第一个搜索目录。无法覆盖这种影响-I-.</p>
</div></blockquote>
<p>-iprefix prefix</p>
<blockquote>
<div><p>指定 prefix 作为后续的前缀-iwithprefix选项。如果前缀代表目录，则应在最后加上“/’.</p>
</div></blockquote>
<p>-iwithprefix dir
-iwithprefixbefore dir</p>
<blockquote>
<div><p>将 dir 附加到先前指定的前缀-iprefix，然后将结果目录添加到包含搜索路径。-iwithprefixbefore把它放在同一个地方-Iwould;-iwithprefix放在-idirafterwould.</p>
</div></blockquote>
<p>-isysroot dir</p>
<blockquote>
<div><p>这个选项就像–sysroot选项,但只适用于头文件(但达尔文目标除外,它同时适用于头文件和库)。参见–sysroot选项获取更多信息。</p>
</div></blockquote>
<p>-imultilib dir</p>
<blockquote>
<div><p>将 dir 用作包含特定于目标的C ++标头的目录的子目录。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-n<var>ostdinc</var></span></kbd></dt>
<dd><p>不要在标准系统目录中搜索头文件。只搜索用-I,-iquote,-isystem和/或-idirafter选项(以及当前文件的目录,如果合适的话)进行搜索。</p>
</dd>
</dl>
<p>-nostdinc++</p>
<blockquote>
<div><p>不搜索C++专用标准目录中的头文件,但仍搜索其他标准目录。(此选项在构建C++库时使用。)</p>
</div></blockquote>
<p>-iplugindir=dir</p>
<blockquote>
<div><p>设置搜索目录,以搜索由-fplugin=name而不是-fplugin=path/name.so。此选项不是供用户使用，而是仅由驱动程序传递。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-L<var>dir</var></span></kbd></dt>
<dd><p>将目录 dir 添加到要搜索的目录列表中-l.</p>
</dd>
<dt><kbd><span class="option">-B<var>prefix</var></span></kbd></dt>
<dd><p>这个选项指定在哪里可以找到编译器本身的可执行文件、库、包含文件和数据文件。</p>
<p>编译器驱动程序运行一个或多个子程序 cpp ， cc1 ， as 和 ld 。它尝试将 prefix 作为尝试运行的每个程序的前缀，无论是否使用’machine/version/’表示对应的目标机器和编译器版本。</p>
<p>对于每个要运行的子程序,编译器驱动程序首先会尝试使用-B前缀,如果有的话。如果没有找到该名称,或者如果-B未指定,驱动程序会尝试两个标准前缀。/usr/lib/gcc/and/usr/local/lib/gcc/。如果这些都不导致找到文件名，则使用 PATH 环境变量中指定的目录搜索未修改的程序名。</p>
<p>编译器检查是否由-B指的是一个目录,必要时它会在路径末尾添加一个目录分隔符。</p>
<p>-B有效指定目录名的前缀也适用于链接器中的库,因为编译器会将这些选项翻译成-L选项的链接器。它们也适用于预处理器中的包含文件,因为编译器会将这些选项翻译成-isystem预处理程序的选项。在这种情况下，编译器会附加“include’作为前缀。</p>
<p>运行时支持文件libgcc.a也可以使用-B前缀,如果需要的话。如果在那里找不到,就会尝试上面的两个标准前缀,仅此而已。如果通过这些方法找不到文件,则该文件就会被排除在链接之外。</p>
<p>另一种指定前缀的方式很像-B前缀是使用环境变量 GCC_EXEC_PREFIX 。请参阅环境变量。</p>
<p>作为一个特殊的小工具,如果路径由-Bis[dir/]stageN/，其中 N 是0到9之间的数字，然后将其替换为[dir/]include。这是为了帮助引导编译器。</p>
</dd>
<dt><kbd><span class="option">-n<var>o-canonical-prefixes</var></span></kbd></dt>
<dd><p>请勿展开任何符号链接，而是将对“/../’ 要么 ‘/./’，或在生成相对前缀时将路径设为绝对路径。</p>
</dd>
<dt><kbd><span class="option">--sysroot=<var>dir</var></span></kbd></dt>
<dd><p>使用 dir 作为标头和库的逻辑根目录。例如，如果编译器通常在以下位置搜索标头/usr/include馆和图书馆/usr/lib，而是搜索dir/usr/includeanddir/usr/lib.</p>
<p>如果您同时使用该选项和-isysroot选项,然后是–sysroot选项适用于图书馆,但-isysroot选项适用于头文件。</p>
<p>GNU linker(从2.16版本开始)对这个选项有必要的支持。如果你的链接器不支持这个选项,则在–sysroot依然能用,但图书馆方面就不行了。</p>
</dd>
<dt><kbd><span class="option">--no-sysroot-suffix</span></kbd></dt>
<dd><p>对于某些目标,后缀会被添加到以–sysroot，具体取决于所使用的其他选项，因此可以在例如dir/suffix/usr/include而不是dir/usr/include。此选项禁用添加此类后缀。</p>
</dd>
</dl>
</div>
<div class="section" id="id25">
<h2>代码生成约定的选项:<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h2>
<p>这些与机器无关的选项控制了代码生成中使用的接口约定。</p>
<p>它们大多有积极和消极两种形式,消极形式的有-ffoois-fno-foo。在下表中，仅列出了一种形式-不是默认形式。您可以通过删除“no-或添加它。</p>
<p>-fstack-reuse=reuse-level</p>
<blockquote>
<div><p>此选项控制用户声明的局部/自动变量和编译器生成的临时变量的堆栈空间重用。 reuse_level 可以是“all’，’named_vars’， 要么 ‘none’。’all’启用所有局部变量和临时变量的堆栈重用，’named_vars’仅对具有名称的用户定义局部变量启用重用，并且’none’完全禁用堆栈重用。默认值为“all’。当程序将作用域范围内的局部变量的寿命延长或临时生成的编译器的寿命超出该语言定义的终点时，需要使用该选项。当变量的生存期结束时，并且如果该变量存在于内存中，则优化编译器可以自由地将其堆栈空间与其他临时变量或作用域范围不重叠的局部作用域局部变量重用。延长本地生存期的旧代码很可能会因堆栈重用优化而中断。</p>
<p>例如:</p>
<p>int <a href="#id26"><span class="problematic" id="id27">*</span></a>p;
{</p>
<blockquote>
<div><p>int local1;</p>
<p>p = &amp;local1;
local1 = 10;
….</p>
</div></blockquote>
<blockquote>
<div><p>int local2;
local2 = 20;
…</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>if (<a href="#id28"><span class="problematic" id="id29">*</span></a>p == 10)  // 超出范围使用local1</dt><dd><p>{</p>
<p>}</p>
</dd>
</dl>
<p>另一个例子:</p>
<p>struct A
{</p>
<blockquote>
<div><p>A(int k) : i(k), j(k) { }
int i;
int j;</p>
</div></blockquote>
<p>};</p>
<p>A <a href="#id30"><span class="problematic" id="id31">*</span></a>ap;</p>
<p>void foo(const A&amp; ar)
{</p>
<blockquote>
<div><p>ap = &amp;ar;</p>
</div></blockquote>
<p>}</p>
<p>void bar()
{</p>
<blockquote>
<div><p>foo(A(10)); // 当 foo 返回时临时对象的生命周期结束</p>
<dl class="simple">
<dt>{</dt><dd></dd>
</dl>
<p>}
ap-&gt;i+= 10;  // ap 引用超出范围 temp 的空间</p>
<blockquote>
<div><p>// 与 a 重用。ap-&gt;i 的值是多少？</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
<p>C ++标准很好地定义了编译器生成的临时文件的生命周期。当临时变量的生存期结束并且临时变量驻留在内存中时，优化编译器可以自由地将其堆栈空间与其他临时变量或作用域范围不重叠的局部作用域局部变量重用。但是，某些遗留代码依赖于较旧的编译器的行为，在这些行为中，临时器的堆栈空间未得到重用，激进的堆栈重用会导致运行时错误。此选项用于控制临时堆栈重用优化。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>trapv</var></span></kbd></dt>
<dd><p>这个选项会在加减乘除操作时产生有符号溢出的陷阱。选项-ftrapvand-fwrapv互相覆盖,所以使用-ftrapv -fwrapv命令行的结果是-fwrapv是有效的。请注意,只有活动选项才会覆盖,所以使用-ftrapv -fwrapv -fno-wrapv命令行的结果是-ftrapv是有效的。</p>
</dd>
<dt><kbd><span class="option">-f<var>wrapv</var></span></kbd></dt>
<dd><p>这个选项指示编译器假设加、减、乘法的有符号算术溢出使用双补码表示。这个标志可以启用一些优化,禁用其他优化。选项-ftrapvand-fwrapv互相覆盖,所以使用-ftrapv -fwrapv命令行的结果是-fwrapv是有效的。请注意,只有活动选项才会覆盖,所以使用-ftrapv -fwrapv -fno-wrapv命令行的结果是-ftrapv是有效的。</p>
</dd>
<dt><kbd><span class="option">-f<var>wrapv-pointer</var></span></kbd></dt>
<dd><p>这个选项指示编译器假设加减法的指针算术溢出使用双补码表示。这个标志可以禁用一些假设指针溢出无效的优化。</p>
</dd>
<dt><kbd><span class="option">-f<var>strict-overflow</var></span></kbd></dt>
<dd><p>该选项意味着-fno-wrapv -fno-wrapv-pointer而当被否定时,意味着-fwrapv -fwrapv-pointer.</p>
</dd>
<dt><kbd><span class="option">-f<var>exceptions</var></span></kbd></dt>
<dd><p>启用异常处理。生成传播异常所需的额外代码。对于某些目标，这意味着GCC会为所有功能生成帧展开信息，尽管这不会影响执行，但可能会产生大量的数据大小开销。如果未指定此选项，则默认情况下，GCC对通常要求例外处理的C ++语言启用它，而对于通常不要求其处理的C语言，则禁用它。但是，在编译需要与用C ++编写的异常处理程序正确互操作的C代码时，可能需要启用此选项。如果您正在编译不使用异常处理的较旧的C ++程序，则还可能希望禁用此选项。</p>
</dd>
<dt><kbd><span class="option">-f<var>non-call-exceptions</var></span></kbd></dt>
<dd><p>生成允许捕获指令引发异常的代码。请注意，这需要特定于平台的运行时支持，而该支持并非在每个地方都存在。此外，它仅允许陷阱指令引发异常，即内存引用或浮点指令。它不允许从任意信号处理程序（例如 SIGALRM )引发异常。</p>
</dd>
<dt><kbd><span class="option">-f<var>delete-dead-exceptions</var></span></kbd></dt>
<dd><p>考虑可能会抛出异常但对程序执行没有其他贡献的指令可以被优化掉。在 Ada 语言规范允许的情况下，默认情况下为 Ada 编译器启用此选项。导致死异常被删除的优化通道在不同的优化级别独立启用。</p>
</dd>
<dt><kbd><span class="option">-f<var>unwind-tables</var></span></kbd></dt>
<dd><p>类似于-fexceptions，只是它会生成任何所需的静态数据，而不会以任何其他方式影响生成的代码。您通常不需要启用此选项；相反，需要这种处理的语言处理器会代您启用它。</p>
</dd>
<dt><kbd><span class="option">-f<var>asynchronous-unwind-tables</var></span></kbd></dt>
<dd><p>如果目标机器支持,生成DWARF格式的解卷表。该表在每个指令边界处都是精确的,所以它可以用于异步事件(如调试器或垃圾收集器)的堆栈解卷。</p>
</dd>
<dt><kbd><span class="option">-f<var>no-gnu-unique</var></span></kbd></dt>
<dd><p>在具有最新GNU汇编器和C库的系统上，C ++编译器使用 STB_GNU_UNIQUE 绑定来确保即使在存在 RTLD_LOCAL 的情况下，内联函数中模板静态数据成员和静态局部变量的定义也是唯一的；为了避免两个不同的 RTLD_LOCAL 插件使用一个库而出现问题，这取决于其中一个的定义，因此对于另一个关于符号绑定的观点存在分歧，这是必要的。但是，这会使受影响的DSO忽略 dlclose 。如果您的程序依赖于通过 dlclose 和 dlopen 重新初始化DSO ，则可以使用-fno-gnu-unique.</p>
</dd>
<dt><kbd><span class="option">-f<var>pcc-struct-return</var></span></kbd></dt>
<dd><p>像较长的 struct 和 union 值一样，在内存中返回“短” 结构和联合值，而不是在寄存器中。该约定的效率较低，但是具有允许GCC编译的文件与其他编译器（尤其是可移植C编译器（pcc））编译的文件之间的可调用性的优点。</p>
<p>返回内存中结构的精确约定取决于目标配置宏。</p>
<p>短结构和联合体是指那些大小和对齐方式与某个整数类型相匹配的结构。</p>
<p>警告：使用-fpcc-struct-return开关与用-freg-struct-return开关。用它来符合非默认的应用二进制接口。</p>
</dd>
<dt><kbd><span class="option">-f<var>reg-struct-return</var></span></kbd></dt>
<dd><p>如果可能，在寄存器中返回 struct 和 union 值。对于小型结构，这比-fpcc-struct-return.</p>
<p>如果您既没有指定-fpcc-struct-returnnor-freg-struct-return，GCC会默认使用该目标的标准约定。如果没有标准约定，则GCC默认为-fpcc-struct-return，但以GCC为主要编译器的目标除外。在这些情况下，我们可以选择标准，然后选择更有效的寄存器返回替代方法。</p>
<p>警告：使用-freg-struct-return开关与用-fpcc-struct-return开关。用它来符合非默认的应用二进制接口。</p>
</dd>
<dt><kbd><span class="option">-f<var>short-enums</var></span></kbd></dt>
<dd><p>仅为声明的可能值范围分配一个 enum 类型所需的字节数。具体来说， enum 类型等效于具有足够空间的最小整数类型。</p>
<p>警告：在-fshort-enums开关会导致GCC生成的代码与没有该开关的代码不二进制兼容。使用它来符合一个非默认的应用程序二进制接口。</p>
</dd>
<dt><kbd><span class="option">-f<var>short-wchar</var></span></kbd></dt>
<dd><p>覆盖基础类型 wchar_t 的是 short unsigned int ，而不是目标的缺省值。此选项对于构建要在WINE下运行的程序很有用。</p>
<p>警告：在-fshort-wchar开关会导致GCC生成的代码与没有该开关的代码不二进制兼容。使用它来符合一个非默认的应用程序二进制接口。</p>
</dd>
<dt><kbd><span class="option">-f<var>common</var></span></kbd></dt>
<dd><p>在C代码中，此选项控制在没有初始化程序的情况下定义的全局变量的放置，在C标准中称为临时定义。临时定义不同于使用 extern 关键字声明的变量，后者不分配存储空间。</p>
<p>默认为-fno-common，它指定编译器将未初始化的全局变量放在目标文件的BSS节中。这会阻止链接程序合并暂定定义，因此，如果在多个编译单元中意外定义了同一变量，则会出现多定义错误。</p>
<p>The-fcommon将未初始化的全局变量放在一个共同的块中。这使得链接器可以将同一变量在不同编译单元中的所有暂定定义解析为同一个对象,或者解析为一个非暂定定义。这种行为与C++不一致,在许多目标上意味着对全局变量引用的速度和代码大小的惩罚。它的主要作用是使遗留代码能够无误地链接。</p>
</dd>
<dt><kbd><span class="option">-f<var>no-ident</var></span></kbd></dt>
<dd><p>忽略 #ident 指令。</p>
</dd>
<dt><kbd><span class="option">-f<var>inhibit-size-directive</var></span></kbd></dt>
<dd><p>不要输出 .size 汇编程序指令，否则不要输出任何其他会导致问题的结果，如果函数在中间被拆分，并且两半放在内存中相距较远的位置。编译时使用此选项crtstuff.c; 您无需将其用于其他任何用途。</p>
</dd>
<dt><kbd><span class="option">-f<var>verbose-asm</var></span></kbd></dt>
<dd><p>在生成的汇编代码中放入额外的注释信息,使其更易读。这个选项通常只对那些真正需要阅读生成的汇编代码的人有用(也许在调试编译器本身时)。</p>
<p>-fno-verbose-asm（默认值）会导致多余的信息被忽略，并且在比较两个汇编文件时非常有用。</p>
<p>增加的意见包括:</p>
<blockquote>
<div><p>关于编译器版本和命令行选项的信息。
与汇编指令相关联的源代码行,形式为FILENAME:LINENUMBER:CONTENT OF LINE。
提示哪些高级表达式对应各种汇编指令操作码。</p>
</div></blockquote>
<p>例如,给定这个C源文件。</p>
<p>int test (int n)
{</p>
<blockquote>
<div><p>int i;
int total = 0;</p>
<dl class="simple">
<dt>for (i = 0; i &lt; n; i++)</dt><dd><p>total += i * i;</p>
</dd>
</dl>
<p>return total;</p>
</div></blockquote>
<p>}</p>
<p>编译为(x86_64)汇编,通过-S并将结果直接发送到stdout,通过-o -</p>
<p>gcc -S test.c -fverbose-asm -Os -o -</p>
<p>给出类似于这样的输出。</p>
<p>.file       “test.c”
# GNU C11 (GCC) version 7.0.0 20160809 (experimental) (x86_64-pc-linux-gnu)</p>
<blockquote>
<div><p>[…snip…]</p>
</div></blockquote>
<dl>
<dt># 选项通过：</dt><dd><p>[…snip…]</p>
<blockquote>
<div><p>.text
.globl  test
.type   test, &#64;function</p>
</div></blockquote>
</dd>
</dl>
<p>test:
.LFB0:</p>
<blockquote>
<div><p>.cfi_startproc</p>
</div></blockquote>
<dl class="simple">
<dt># test.c:4:   int total = 0;</dt><dd><p>xorl    %eax, %eax      # &lt;retval&gt;</p>
</dd>
<dt># test.c:6:   for (i = 0; i &lt; n; i++)</dt><dd><p>xorl    %edx, %edx      # i</p>
</dd>
</dl>
<p>.L2:
# test.c:6:   for (i = 0; i &lt; n; i++)</p>
<blockquote>
<div><p>cmpl    %edi, %edx      ＃ 你
jge     .L5     #,</p>
</div></blockquote>
<dl class="simple">
<dt># test.c:7:     total += i * i;</dt><dd><p>movl    %edx, %ecx      #我，tmp92
imull   %edx, %ecx      #我，tmp92</p>
</dd>
<dt># test.c:6:   for (i = 0; i &lt; n; i++)</dt><dd><p>incl    %edx    # i</p>
</dd>
<dt># test.c:7:     total += i * i;</dt><dd><p>addl    %ecx, %eax      # tmp92, &lt;retval&gt;
jmp     .L2     #</p>
</dd>
</dl>
<p>.L5:
# test.c:10: }</p>
<blockquote>
<div><p>ret
.cfi_endproc</p>
</div></blockquote>
<dl class="simple">
<dt>.LFE0:</dt><dd><p>.size   test, .-test
.ident  “GCC: (GNU) 7.0.0 20160809 (experimental)”
.section        .note.GNU-stack,””,&#64;progbits</p>
</dd>
</dl>
<p>评论的对象是人而不是机器,因此评论的精确格式可能会发生变化。</p>
</dd>
<dt><kbd><span class="option">-f<var>record-gcc-switches</var></span></kbd></dt>
<dd><p>这个开关导致用于调用编译器的命令行被记录到正在创建的对象文件中。这个开关只在某些目标上实现,记录的确切格式取决于目标和二进制文件格式,但它通常采取包含ASCII文本的部分形式。这个开关与-fverbose-asm开关,但该开关只在汇编器输出文件中以注释的形式记录信息,所以它从未到达对象文件。参见-grecord-gcc-switches以获得另一种将编译器选项存储到对象文件中的方法。</p>
</dd>
<dt><kbd><span class="option">-f<var>pic</var></span></kbd></dt>
<dd><p>生成适合在共享库中使用的位置无关代码(PIC),如果目标机器支持的话。这种代码通过全局偏移表(GOT)访问所有常数地址。动态加载器在程序启动时解析GOT条目(动态加载器不是GCC的一部分,它是操作系统的一部分)。如果被链接的可执行文件的GOT大小超过了特定机器的最大大小,你会从链接器中得到一条错误信息,表明-fpic不起作用;在这种情况下,用-fPIC而不是。这些最大值在SPARC上是8k,在AArch64上是28k,在m68k和RS/6000上是32k。x86则没有这样的限制。)</p>
<p>与位置无关的代码需要特殊的支持,因此只适用于某些机器。对于x86,GCC支持System V的PIC,但不支持Sun 386i。为IBM RS/6000生成的代码总是与位置无关的。</p>
<p>设置此标志后，宏 __pic__ 和 __PIC__ 被定义为1。</p>
</dd>
<dt><kbd><span class="option">-f<var>PIC</var></span></kbd></dt>
<dd><p>如果目标机器支持,则发出与位置无关的代码,适用于动态链接,避免对全局偏移表的大小进行任何限制。这个选项在 AArch64、m68k、PowerPC 和 SPARC 上有区别。</p>
<p>与位置无关的代码需要特殊的支持,因此只能在某些机器上工作。</p>
<p>设置此标志后，宏 __pic__ 和 __PIC__ 被定义为2。</p>
</dd>
</dl>
<p>-fpie
-fPIE</p>
<blockquote>
<div><p>这些选项类似于-fpicand-fPIC，但是生成的位置无关代码只能链接到可执行文件中。通常，这些选项用于编译将使用-pie海合会选项:</p>
<p>-fpieand-fPIE都定义了 __pie__ 和 __PIE__ 宏。宏的值1-fpie和2个-fPIE.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>no-plt</var></span></kbd></dt>
<dd><p>不要在与位置无关的代码中使用PLT进行外部函数调用。相反,从GOT中加载调用站点的被叫者地址,并对其进行分支。这样可以消除PLT存根,并将GOT负载暴露给优化,从而提高代码效率。在32位x86等架构上,PLT存根期望GOT指针在特定寄存器中,这给编译器提供了更多的寄存器分配自由度。懒惰绑定需要使用PLT;有了-fno-plt所有的外部符号都在加载时被解析。</p>
<p>或者，可以使用函数属性 noplt 来避免通过PLT调用特定的外部函数。</p>
<p>在位置相关的代码中,少数目标也会将对那些标记为不使用PLT的函数的调用转换为使用GOT来代替。</p>
</dd>
<dt><kbd><span class="option">-f<var>no-jump-tables</var></span></kbd></dt>
<dd><p>即使在比其他代码生成策略更有效的情况下,也不要对开关语句使用跳表。这个选项与-fpicor-fPIC用于构建构成动态链接器一部分的代码,并且不能引用跳表的地址。在某些目标上,跳转表不需要GOT,因此不需要这个选项。</p>
</dd>
<dt><kbd><span class="option">-f<var>no-bit-tests</var></span></kbd></dt>
<dd><p>不要对switch语句使用位测试,即使它比其他代码生成策略更有效。</p>
</dd>
<dt><kbd><span class="option">-f<var>fixed-reg</var></span></kbd></dt>
<dd><p>将名为 reg 的寄存器视为固定寄存器；生成的代码永远不要引用它（除了可能是堆栈指针，帧指针或其他固定角色之外）。</p>
<p>reg 必须是寄存器的名称。接受的寄存器名称是特定于计算机的，并且在计算机描述宏文件的 REGISTER_NAMES 宏中定义。</p>
<p>这个标志没有负形式,因为它指定了一个三方选择。</p>
</dd>
<dt><kbd><span class="option">-f<var>call-used-reg</var></span></kbd></dt>
<dd><p>将名为 reg 的寄存器视为可被函数调用破坏的可分配寄存器。它可以分配给不存在于调用中的临时变量或变量。用这种方式编译的函数不会保存和恢复寄存器 reg 。</p>
<p>将此标志与帧指针或堆栈指针一起使用是错误的。对于在机器的执行模型中具有固定普遍作用的其他寄存器使用此标志会产生灾难性的结果。</p>
<p>这个标志没有负形式,因为它指定了一个三方选择。</p>
</dd>
<dt><kbd><span class="option">-f<var>call-saved-reg</var></span></kbd></dt>
<dd><p>将名为 reg 的寄存器视为函数保存的可分配寄存器。甚至可以为整个调用中存在的临时变量或变量分配它。以这种方式编译的函数在使用寄存器 reg 时会保存并恢复它们。</p>
<p>将此标志与帧指针或堆栈指针一起使用是错误的。对于在机器的执行模型中具有固定普遍作用的其他寄存器使用此标志会产生灾难性的结果。</p>
<p>如果对一个可以返回函数值的寄存器使用这个标志,就会造成另一种灾难。</p>
<p>这个标志没有负形式,因为它指定了一个三方选择。</p>
</dd>
</dl>
<p>-fpack-struct[=n]</p>
<blockquote>
<div><p>在没有指定数值的情况下,将所有结构成员打包在一起,不打孔。当指定一个值时(必须是二的小倍数),按照这个值打包结构成员,代表最大对齐度(即默认对齐度要求大于这个值的对象在下一个拟合位置输出可能不对齐。</p>
<p>警告：在-fpack-struct开关会导致GCC生成的代码与没有该开关生成的代码在二进制上不兼容。此外,它还会使代码变得不理想。使用它来符合一个非默认的应用程序二进制接口。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>leading-underscore</var></span></kbd></dt>
<dd><p>这个选项及其对应的。-fno-leading-underscore，强制更改C符号在目标文件中的表示方式。一种用途是帮助链接旧的汇编代码。</p>
<p>警告：在-fleading-underscore开关会导致GCC生成的代码与没有该开关的代码不二进制兼容。使用它来符合一个非默认的应用程序二进制接口。并非所有的目标都对这个开关提供完整的支持。</p>
</dd>
</dl>
<p>-ftls-model=model</p>
<blockquote>
<div><p>更改要使用的线程本地存储模型（请参阅Thread-Local）。该 model 参数应该是一个“global-dynamic’，’local-dynamic’，’initial-exec’ 要么 ‘local-exec’。请注意，此选择有待优化：编译器可以对翻译单元外部不可见的符号使用更有效的模型，或者-fpic命令行上没有给出。</p>
<p>默认不含-fpic是’initial-exec’; 与-fpic默认值为“global-dynamic’.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>trampolines</var></span></kbd></dt>
<dd><p>对于那些通常需要使用嵌套函数的目标,总是生成它们而不是使用描述符。否则,对于不需要它们的目标,如HP-PA或IA-64,什么也不做。</p>
<p>蹦床是运行时在栈上取嵌套函数地址时产生的一小段代码,用于间接调用嵌套函数。因此,它需要使堆栈可以执行,程序才能正常运行。</p>
<p>-fno-trampolines是默认启用的,如果编译器认为这样做是安全的,就会让编译器避免生成它们,而用描述符代替它们。描述符只由数据组成,但生成的代码必须准备好处理它们。截至本文撰写时。-fno-trampolines默认情况下,仅对Ada启用。</p>
<p>此外,用-ftrampolines和用-fno-trampolines如果存在嵌套函数,则不兼容二进制。因此,这个选项必须在整个程序中使用,并且要非常小心地操作。</p>
</dd>
</dl>
<p>-fvisibility=[default|internal|hidden|protected]</p>
<blockquote>
<div><p>将默认的ELF图像符号可见性设置为指定的选项-除非代码中覆盖了所有符号，否则所有符号都以此标记。使用此功能可以极大地改善共享库的链接和加载时间，生成更优化的代码，提供接近完美的API导出并防止符号冲突。这是强烈建议您在您分发的任何共享对象使用。</p>
<p>尽管有术语，“default总是意味着公开；即，可用于从共享库外部进行链接。’protected’和’internal’在实际使用中几乎没有用，因此唯一的其他常用选项是’hidden’。默认为-fvisibility未指定为“default’，即公开每个符号。</p>
<p>Ulrich Drepper的“如何编写共享库”（可以在https://www.akkadia.org/drepper/上找到）对确保ELF符号具有正确的可见性所带来的好处进行了很好的解释。通过此选项可以在默认设置为public时将事物标记为隐藏的高级解决方案是将默认隐藏并标记为public。这是Windows和DLL上的规范-fvisibility=hidden和 __attribute__ ((visibility(“default”))) 而不是 __declspec(dllexport) ,您将获得具有相同语法的几乎相同的语义。对于那些从事跨平台项目的人来说，这是一个很大的福音。</p>
<p>对于为现有代码添加可见性支持的用户，您可能会发现 #pragma GCC visibility 使用的可见性。您可以使用 #pragma GCC visibility push(hidden) 和 #pragma GCC visibility pop 来封闭希望为其设置可见性的声明。请记住，应将符号可见性视为API接口协定的一部分，因此，所有新代码在不是默认值时都应始终指定可见性；即，仅在本地DSO中使用的声明应始终被显式标记为隐藏，以免发生PLT间接开销-使其充分清楚也有助于代码的可读性和自说明性。请注意，由于ISO C ++规范要求， operator new operator delete 符和操作符删除必须始终具有默认可见性。</p>
<p>请注意，项目外部的标头（尤其是系统标头和您使用的任何其他库的标头）可能不会期望使用默认值以外的可见性进行编译。在包含任何此类标头之前，您可能需要明确地说 #pragma GCC visibility push(default) 。</p>
<p>extern 声明不受以下影响-fvisibility，因此许多代码都可以重新编译-fvisibility=hidden没有任何修改。但是，这意味着对没有显式可见性的 extern 函数的调用将使用PLT，因此使用 __attribute ((visibility)) 和/或 #pragma GCC visibility 来告诉编译器哪些 extern 声明应视为隐藏的更为有效。</p>
<p>请注意-fvisibility确实会影响C ++模糊链接实体。这意味着，例如，必须在DSO之间抛出的异常类必须使用默认可见性明确标记，以便“type_infoDSO之间的节点是统一的。</p>
<p><a class="reference external" href="http://gcc.gnu.org/wiki/Visibility">http://gcc.gnu.org/wiki/Visibility</a> 上概述了这些技术、它们的好处以及如何使用它们。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>strict-volatile-bitfields</var></span></kbd></dt>
<dd><p>如果访问易失性位字段（或其他结构字段，尽管编译器通常会使用这些类型的字段）应使用该字段类型宽度的单个访问，并在可能的情况下对齐自然对齐，则应使用此选项。例如，具有存储器映射外设寄存器的目标可能要求所有此类访问的宽度均为16位。使用此标志，您可以将所有外设位字段声明为 unsigned short （假定这些目标上的short为16位），以强制GCC使用16位访问权限，而不是更有效的32位访问权限。</p>
<p>如果禁用这个选项,编译器就会使用效率最高的指令。在前面的例子中,这可能是一条32位的加载指令,尽管它访问的字节不包含位场的任何部分,或与被更新的寄存器无关的内存映射寄存器。</p>
<p>在某些情况下，例如，当将 packed 属性应用于结构字段时，可能无法使用针对目标计算机正确对齐的单个读取或写入来访问该字段。在这种情况下，GCC会退回到生成多个访问，而不是在运行时生成错误或截断结果的代码。</p>
<p>注意：由于C / C ++ 11内存模型的限制，不允许写访问接触非位字段成员。因此，建议将字段类型的所有位定义为位字段成员。</p>
<p>该选项的默认值由目标处理器的应用二进制接口决定。</p>
</dd>
<dt><kbd><span class="option">-f<var>sync-libcalls</var></span></kbd></dt>
<dd><p>此选项控制 __sync 函数系列的任何脱机实例是否可用于实现C ++ 11 __atomic 函数系列。</p>
<p>该选项的默认值是启用,因此该选项的唯一有用形式是-fno-sync-libcalls。此选项用于实施libatomic运行时库。</p>
</dd>
</dl>
<div class="section" id="gcc">
<h3>GCC开发人员选项<a class="headerlink" href="#gcc" title="Permalink to this headline">¶</a></h3>
<p>本节介绍了GCC开发人员主要感兴趣的命令行选项，包括支持编译器测试以及调查编译器错误和编译时性能问题的选项。这包括在编译的各个点产生调试转储的选项。打印统计信息，例如内存使用和执行时间；并打印有关GCC配置的信息，例如在何处搜索库。对于普通的编译和链接任务，您几乎不需要使用任何这些选项。</p>
<p>许多导致GCC将输出转储到文件中的开发人员选项都采用了可选的’=filename后缀。您可以指定“stdout’ 要么 ‘-‘转储到标准输出，和’stderr’为标准错误。</p>
<p>如果 ‘=filename省略了’，默认的转储文件名是通过将基本转储文件名，通过号，阶段字母和通过名连接在一起而构造的。基本转储文件名是编译器生成的输出文件的名称（如果显式指定），而不是可执行文件。否则为源文件名。通道号由在编译器的通道管理器中注册的订单通道确定。这通常与执行顺序相同，但是插件注册的通行证，特定于目标的通行证或否则注册较晚的通行证的编号高于名为“final’，即使它们执行得较早。相位字母是“i’（过程间分析），’l’（特定于语言），’r（（RTL）或’t’（树）。这些文件在输出文件的目录中创建。</p>
<p>-fcallgraph-info
-fcallgraph-info=MARKERS</p>
<blockquote>
<div><p>使编译器在每个对象文件的基础上输出程序的调用图信息。该信息以通用的VCG格式生成。如果另外指定了逗号分隔的标记列表，则可以使用附加的，按节点和/或按边缘的信息进行修饰。当指定了 su 标记时，将用堆栈使用信息装饰该调用图。它等效于-fstack-usage。当 da 指定标记，调用图装饰有大约动态分配对象的信息。</p>
<p>当使用-flto，没有调用图信息与目标文件一起输出。在LTO链接时间，-fcallgraph-info可以在中间LTO输出文件旁边生成多个callgraph信息文件。</p>
</div></blockquote>
<p>-dletters
-fdump-rtl-pass
-fdump-rtl-pass=filename</p>
<blockquote>
<div><p>表示在编译过程中按 letters 指定的时间进行调试转储。这用于调试基于RTL的编译器传递。</p>
<p>Some-dletters开关有不同的意义,当-E用于预处理。有关特定于预处理器的转储选项的信息，请参见预处理器选项。</p>
<p>调试转储可以通过-fdump-rtl开关-d选择 letters 。以下是 pass 和 letters 可能使用的字母及其含义：</p>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>dump-rtl-alignments</var></span></kbd></dt>
<dd><p>在计算完分支排列后进行转储。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-asmcons</var></span></kbd></dt>
<dd><p>修正有不满意的in/out约束的rtl语句后转储。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-auto_inc_dec</var></span></kbd></dt>
<dd><p>在发现auto-inc-dec后进行dump。这个通道只在有自动入库或自动出库指令的架构上运行。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-barriers</var></span></kbd></dt>
<dd><p>清理完障碍物后倾倒说明。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-bbpart</var></span></kbd></dt>
<dd><p>对冷热基本块进行分区后甩。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-bbro</var></span></kbd></dt>
<dd><p>块重新排序后的转储。</p>
</dd>
</dl>
<p>-fdump-rtl-btl1
-fdump-rtl-btl2</p>
<blockquote>
<div><p>-fdump-rtl-btl1and-fdump-rtl-btl2在两个分支目标负载优化通过后启用转储。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>dump-rtl-bypass</var></span></kbd></dt>
<dd><p>跳转旁路和控制流优化后的转储。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-combine</var></span></kbd></dt>
<dd><p>RTL指令组合通过后的Dump。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-compgotos</var></span></kbd></dt>
<dd><p>复制计算出的gotos后进行转储。</p>
</dd>
</dl>
<p>-fdump-rtl-ce1
-fdump-rtl-ce2
-fdump-rtl-ce3</p>
<blockquote>
<div><p>-fdump-rtl-ce1,-fdump-rtl-ce2， 和-fdump-rtl-ce3如果转换通过,则启用三后倾倒。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>dump-rtl-cprop_hardreg</var></span></kbd></dt>
<dd><p>硬寄存器拷贝传播后的转储。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-csa</var></span></kbd></dt>
<dd><p>合并堆栈调整后转储。</p>
</dd>
</dl>
<p>-fdump-rtl-cse1
-fdump-rtl-cse2</p>
<blockquote>
<div><p>-fdump-rtl-cse1and-fdump-rtl-cse2使得两个常见的子表达式消除通过后,可以进行转储。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>dump-rtl-dce</var></span></kbd></dt>
<dd><p>单机死码消除通过后,转储。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-dbr</var></span></kbd></dt>
<dd><p>延迟分支调度后的转储。</p>
</dd>
</dl>
<p>-fdump-rtl-dce1
-fdump-rtl-dce2</p>
<blockquote>
<div><p>-fdump-rtl-dce1and-fdump-rtl-dce2在两个死店消除通过后,启用倾销。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>dump-rtl-eh</var></span></kbd></dt>
<dd><p>在最终确定EH处理代码后,Dump。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-eh_ranges</var></span></kbd></dt>
<dd><p>EH处理范围区域转换后的转储。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-expand</var></span></kbd></dt>
<dd><p>RTL生成后的倾倒。</p>
</dd>
</dl>
<p>-fdump-rtl-fwprop1
-fdump-rtl-fwprop2</p>
<blockquote>
<div><p>-fdump-rtl-fwprop1and-fdump-rtl-fwprop2在两次正向传播后启用转储。</p>
</div></blockquote>
<p>-fdump-rtl-gcse1
-fdump-rtl-gcse2</p>
<blockquote>
<div><p>-fdump-rtl-gcse1and-fdump-rtl-gcse2在全局共同的子表达式消除后启用转储。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>dump-rtl-init-regs</var></span></kbd></dt>
<dd><p>寄存器初始化后的Dump。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-initvals</var></span></kbd></dt>
<dd><p>在计算完初始值集后进行转储。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-into_cfglayout</var></span></kbd></dt>
<dd><p>转换为cfglayout模式后的dump。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-ira</var></span></kbd></dt>
<dd><p>迭代寄存器分配后的转储。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-jump</var></span></kbd></dt>
<dd><p>二次跳转优化后的转储。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-loop2</var></span></kbd></dt>
<dd><p>-fdump-rtl-loop2在rtl循环优化通过后启用转储。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-mach</var></span></kbd></dt>
<dd><p>在执行依赖机器的重组通证后进行转储,如果该通证存在的话。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-mode_sw</var></span></kbd></dt>
<dd><p>去掉冗余模式开关后的转储。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-rnreg</var></span></kbd></dt>
<dd><p>在寄存器重新编号后进行转储。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-outof_cfglayout</var></span></kbd></dt>
<dd><p>从cfglayout模式转换后的dump。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-peephole2</var></span></kbd></dt>
<dd><p>在窥视孔通行证后倾倒。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-postreload</var></span></kbd></dt>
<dd><p>重载后优化后的转储。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-pro_and_epilogue</var></span></kbd></dt>
<dd><p>生成函数序言和尾声后的转储。</p>
</dd>
</dl>
<p>-fdump-rtl-sched1
-fdump-rtl-sched2</p>
<blockquote>
<div><p>-fdump-rtl-sched1and-fdump-rtl-sched2在基本区块调度通过后,启用转储。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>dump-rtl-ree</var></span></kbd></dt>
<dd><p>签/零延时消除后的倾销。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-seqabstr</var></span></kbd></dt>
<dd><p>普通序列发现后的转储。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-shorten</var></span></kbd></dt>
<dd><p>缩短枝条后倾倒。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-sibling</var></span></kbd></dt>
<dd><p>同级调用优化后的转储。</p>
</dd>
</dl>
<p>-fdump-rtl-split1
-fdump-rtl-split2
-fdump-rtl-split3
-fdump-rtl-split4
-fdump-rtl-split5</p>
<blockquote>
<div><p>这些选项可以在五轮指令拆分后进行转储。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>dump-rtl-sms</var></span></kbd></dt>
<dd><p>模数调度后的转储。这个通道只在某些架构上运行。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-stack</var></span></kbd></dt>
<dd><p>从GCC的“平面寄存器文件”寄存器转换为x87的类似堆栈的寄存器后转储。此过程仅在x86变体上运行。</p>
</dd>
</dl>
<p>-fdump-rtl-subreg1
-fdump-rtl-subreg2</p>
<blockquote>
<div><p>-fdump-rtl-subreg1and-fdump-rtl-subreg2使得在两个子规扩容通过后,可以进行转储。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>dump-rtl-unshare</var></span></kbd></dt>
<dd><p>在所有的rtl都被取消共享后,Dump。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-vartrack</var></span></kbd></dt>
<dd><p>变量跟踪后的转储。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-vregs</var></span></kbd></dt>
<dd><p>将虚拟寄存器转换为硬寄存器后的转储。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-rtl-web</var></span></kbd></dt>
<dd><p>活期范围分割后的转储。</p>
</dd>
</dl>
<p>-fdump-rtl-regclass
-fdump-rtl-subregs_of_mode_init
-fdump-rtl-subregs_of_mode_finish
-fdump-rtl-dfinit
-fdump-rtl-dfinish</p>
<blockquote>
<div><p>这些转储是被定义的,但总是产生空文件。</p>
</div></blockquote>
<p>-da
-fdump-rtl-all</p>
<blockquote>
<div><p>制作上述所有的转储。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-d<var>A</var></span></kbd></dt>
<dd><p>对汇编器输出的杂项调试信息进行注释。</p>
</dd>
<dt><kbd><span class="option">-d<var>D</var></span></kbd></dt>
<dd><p>转储所有宏定义,在预处理结束后,除正常输出外。</p>
</dd>
<dt><kbd><span class="option">-d<var>H</var></span></kbd></dt>
<dd><p>每当发生错误时,就会产生一个核心转储。</p>
</dd>
<dt><kbd><span class="option">-d<var>p</var></span></kbd></dt>
<dd><p>在汇编器输出中加注注释,说明使用了哪种模式和替代方案。每条指令的长度和成本也被打印出来。</p>
</dd>
<dt><kbd><span class="option">-d<var>P</var></span></kbd></dt>
<dd><p>将汇编器输出中的RTL作为注释在每条指令前倾倒。同时开启-dpannotation.</p>
</dd>
<dt><kbd><span class="option">-d<var>x</var></span></kbd></dt>
<dd><p>只是为一个函数生成RTL,而不是编译它。通常与-fdump-rtl-expand.</p>
</dd>
</dl>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>dump-debug</var></span></kbd></dt>
<dd><p>转储调试生成阶段产生的调试信息。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-earlydebug</var></span></kbd></dt>
<dd><p>转储早期调试生成阶段产生的调试信息。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-noaddr</var></span></kbd></dt>
<dd><p>在做调试转储时,抑制地址输出。这使得对不同编译器二进制文件和/或不同文本/bss/数据/堆/栈/dso起始位置的编译器调用,在调试转储时使用diff更加可行。</p>
</dd>
<dt><kbd><span class="option">-f<var>report-bug</var></span></kbd></dt>
<dd><p>如果发生内部编译器错误(ICE),收集并将调试信息转储到一个临时文件中。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-unnumbered</var></span></kbd></dt>
<dd><p>在做调试转储时,抑制指令号和地址输出。这使得在调试转储上使用diff对不同选项的编译器调用更加可行,特别是在有和无-g.</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-unnumbered-links</var></span></kbd></dt>
<dd><p>在做调试转储时(见-d选项),抑制序列中连接上一条和下一条指令的指令号。</p>
</dd>
</dl>
<p>-fdump-ipa-switch
-fdump-ipa-switch-options</p>
<blockquote>
<div><p>控制程序间分析语言树各阶段的转储到文件中。文件名通过在源文件名上附加开关专用后缀生成,文件与输出文件在同一目录下创建。可以进行以下转储。</p>
<p>‘all’</p>
<blockquote>
<div><p>启用所有程序间分析转储。</p>
</div></blockquote>
<p>‘cgraph’</p>
<blockquote>
<div><p>转储有关调用图优化、未使用的函数删除和内联决策的信息。</p>
</div></blockquote>
<p>‘inline’</p>
<blockquote>
<div><p>在函数内联后进行转储。</p>
</div></blockquote>
<p>此外,选项-optimized,-missed,-note， 和-all可以提供,其意义同于对-fopt-info，默认为-optimized.</p>
<p>例如:-fdump-ipa-inline-optimized-missed将发出已内嵌的呼叫点和未内嵌的呼叫点的信息。</p>
<p>默认情况下,dump将包含关于成功优化的消息(相当于-optimized）以及有关该分析的低级详细信息。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>dump-lang</var></span></kbd></dt>
<dd><p>倾倒语言的特定信息。文件名是通过附加上.lang到源文件名。</p>
</dd>
</dl>
<p>-fdump-lang-all
-fdump-lang-switch
-fdump-lang-switch-options
-fdump-lang-switch-options=filename</p>
<blockquote>
<div><p>控制特定语言信息的转储。的 options 和 filename 作为在所描述的行为的部分-fdump-tree选项。接受以下 switch 值：</p>
<p>‘all’</p>
<blockquote>
<div><p>启用所有特定语言的转储。</p>
</div></blockquote>
<p>‘class’</p>
<blockquote>
<div><p>转储类层次结构信息。发出虚拟表信息，除非“slim’已指定。此选项仅适用于C ++。</p>
</div></blockquote>
<p>‘module’</p>
<blockquote>
<div><p>倾倒模块信息。选项lineno(locations),graph(reachability),blocks(clusters),uid(serialization),alias(mergeable),asmname(Elrond),eh(mapper) &amp;vops（宏）可能会提供额外的信息。此选项仅适用于 C++。</p>
</div></blockquote>
<p>‘raw’</p>
<blockquote>
<div><p>转储原始内部树数据。这个选项只适用于C++。</p>
</div></blockquote>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>dump-passes</var></span></kbd></dt>
<dd><p>打印stderr通过当前命令行选项开启或关闭的优化通道列表。</p>
</dd>
<dt><kbd><span class="option">-f<var>dump-statistics-option</var></span></kbd></dt>
<dd><p>在单独的文件中启用和控制通过统计信息的转储。通过添加以’结尾的后缀来生成文件名.statistics到源文件名，然后在与输出文件相同的目录中创建文件。如果“-option“使用表格”-stats’使计数器在整个编译单元上求和，而’-details’在传递生成事件时将其丢弃。没有选项的默认值是对每个编译函数的计数器求和。</p>
</dd>
</dl>
<p>-fdump-tree-all
-fdump-tree-switch
-fdump-tree-switch-options
-fdump-tree-switch-options=filename</p>
<blockquote>
<div><p>在将中间语言树处理为文件的各个阶段，控制转储。如果“-options’使用表格， options 是’-分隔的选项可控制转储的详细信息。并非所有选项都适用于所有转储。那些没有意义的将被忽略。以下选项可用</p>
<p>‘address’</p>
<blockquote>
<div><p>打印每个节点的地址。通常这并没有什么意义,因为它根据环境和源文件的不同而变化。它的主要用途是用于绑定dump文件与调试环境。</p>
</div></blockquote>
<p>‘asmname’</p>
<blockquote>
<div><p>如果已为给定的decl设置了 DECL_ASSEMBLER_NAME ，请在转储中使用它而不是 DECL_NAME 。它的主要用途是易于使用，从汇编文件中的错误名称向后进行操作。</p>
</div></blockquote>
<p>‘slim’</p>
<blockquote>
<div><p>在转储前端中间表示时,禁止仅仅因为已经到达了函数的作用域或主体的成员而转储。只有当这些项目可以通过其他路径直接到达时,才会转储。</p>
<p>在倾倒漂亮的印刷树时,该选项抑制倾倒控制结构的主体。</p>
<p>当转储RTL时,以纤细(浓缩)的形式打印RTL,而不是默认的类似LISP的表示方式。</p>
</div></blockquote>
<p>‘raw’</p>
<blockquote>
<div><p>打印树的原始表示方式。默认情况下,树木是以类似C语言的方式打印的。</p>
</div></blockquote>
<p>‘details’</p>
<blockquote>
<div><p>启用更详细的转储(不是每个转储选项都会遵守)。还包括来自优化通道的信息。</p>
</div></blockquote>
<p>‘stats’</p>
<blockquote>
<div><p>启用转储关于通证的各种统计信息(并非每个转储选项都能兑现)。</p>
</div></blockquote>
<p>‘blocks’</p>
<blockquote>
<div><p>启用显示基本块边界(在原始转储中禁用)。</p>
</div></blockquote>
<p>‘graph’</p>
<blockquote>
<div><p>对于其他每个指定的转储文件(-fdump-rtl-pass），将适合用GraphViz查看的控制流程图的表示转储到file.passid.pass.dot。文件中的每个函数都漂亮地打印为子图，因此GraphViz可以在一个图中绘制所有函数。</p>
<p>这个选项目前只对RTL转储有效,而且RTL总是以纤细的形式转储。</p>
</div></blockquote>
<p>‘vops’</p>
<blockquote>
<div><p>启用显示每个语句的虚拟操作数。</p>
</div></blockquote>
<p>‘lineno’</p>
<blockquote>
<div><p>启用显示报表的行号。</p>
</div></blockquote>
<p>‘uid’</p>
<blockquote>
<div><p>启用显示每个变量的唯一ID（ DECL_UID ）。</p>
</div></blockquote>
<p>‘verbose’</p>
<blockquote>
<div><p>启用显示每个语句的树形转储。</p>
</div></blockquote>
<p>‘eh’</p>
<blockquote>
<div><p>启用显示持有每个报表的EH区域号。</p>
</div></blockquote>
<p>‘scev’</p>
<blockquote>
<div><p>启用显示标量演变分析细节。</p>
</div></blockquote>
<p>‘optimized’</p>
<blockquote>
<div><p>启用显示优化信息(仅在某些通道中可用)。</p>
</div></blockquote>
<p>‘missed’</p>
<blockquote>
<div><p>启用显示遗漏的优化信息(仅在某些通道中可用)。</p>
</div></blockquote>
<p>‘note’</p>
<blockquote>
<div><p>启用其他详细的优化信息(仅在某些通道中可用)。</p>
</div></blockquote>
<p>‘all’</p>
<blockquote>
<div><p>打开所有选项,除了raw,slim,verboseandlineno.</p>
</div></blockquote>
<p>‘optall’</p>
<blockquote>
<div><p>开启所有优化选项,即。optimized,missed， 和note.</p>
</div></blockquote>
<p>要确定有哪些树形转储,或找到感兴趣的转储,请按照以下步骤进行。</p>
<blockquote>
<div><p>用以下方式调用GCC-fdump-passes并在stderr输出查找与您感兴趣的传递相对应的代码。例如，代码 tree-evrp ， tree-vrp1 和 tree-vrp2 对应于三个“值范围传播”传递。末尾的数字区分同一遍的不同调用。
要启用转储文件的创建,请将密码附加到-fdump-选项前缀,并使用它来调用GCC。例如,如果要启用早期值范围传播传递的转储,调用GCC时应使用-fdump-tree-evrp选项。（可选）您可以指定转储文件的名称。如果您未指定，GCC将按如下所述创建。
在文件名中查找密码转储，该文件的名称由三个由句点分隔的部分组成：调用源文件GCC的名称进行编译，数字后缀表示密码，后跟字母’t’用于树木通行证（以及字母’r’（代表RTL通过），最后是密码。例如，Early VRP pass dump可能位于名为myfile.c.038t.evrp在当前工作目录下。请注意,数字代码并不稳定,可能会因GCC的不同版本而改变。</p>
</div></blockquote>
</div></blockquote>
<p>-fopt-info
-fopt-info-options
-fopt-info-options=filename</p>
<blockquote>
<div><p>控制来自各种优化过程的优化转储。如果“-options’使用表格， options 是’-‘分隔选项关键字以选择转储详细信息和优化。</p>
<p>该 options 可以分为三类：</p>
<blockquote>
<div><p>选项,描述应该发出何种信息。
选项描述了转储的字数,以及
选项,描述应该包含哪些优化。</p>
</div></blockquote>
<p>每个组的选项可以自由混合,因为它们是不重叠的。但是,如果有任何冲突,后面的选项将优先于命令行上的早期选项。</p>
<p>下面的选项控制了哪些类型的信息应该被发送。</p>
<p>‘optimized’</p>
<blockquote>
<div><p>当优化成功应用时,打印信息。由pass决定哪些信息是相关的。例如,矢量化器通证会打印成功矢量化的循环的源位置。</p>
</div></blockquote>
<p>‘missed’</p>
<blockquote>
<div><p>打印错过的优化信息。各个通道控制哪些信息要包含在输出中。</p>
</div></blockquote>
<p>‘note’</p>
<blockquote>
<div><p>打印有关优化的口头信息,如某些变换,更详细的决策信息等。</p>
</div></blockquote>
<p>‘all’</p>
<blockquote>
<div><p>打印详细的优化信息。这包括 ‘optimized’，’missed’和’note’.</p>
</div></blockquote>
<p>下面的选项可以控制转储的语气。</p>
<p>‘internals’</p>
<blockquote>
<div><p>默认情况下，仅发出“高级”消息。此选项启用其他更详细的消息，这些消息可能仅对GCC开发人员感兴趣。</p>
</div></blockquote>
<p>以下一个或多个选项关键字可以用来描述一组优化。</p>
<p>‘ipa’</p>
<blockquote>
<div><p>启用所有程序间优化的转储。</p>
</div></blockquote>
<p>‘loop’</p>
<blockquote>
<div><p>启用所有循环优化的转储。</p>
</div></blockquote>
<p>‘inline’</p>
<blockquote>
<div><p>启用所有内联优化的转储。</p>
</div></blockquote>
<p>‘omp’</p>
<blockquote>
<div><p>启用所有OMP(卸载和多处理)优化的转储。</p>
</div></blockquote>
<p>‘vec’</p>
<blockquote>
<div><p>启用所有矢量化优化的转储。</p>
</div></blockquote>
<p>‘optall’</p>
<blockquote>
<div><p>启用所有优化的转储。这是上述优化组的超集。</p>
</div></blockquote>
<p>如果省略 options ，则默认为’optimized-optall”，这意味着从所有过程中转储有关成功优化的消息，而忽略了被视为“内部”消息。</p>
<p>如果提供了 filename ，则来自所有适用优化的转储将串联到 filename 。否则将转储输出到stderr。虽然多个-fopt-info选项被接受，其中只有一个可以包含 filename 。如果提供了其他文件名，则将忽略除第一个此类选项外的所有文件名。</p>
<p>请注意，如果有多个翻译单元，则输出 filename 被覆盖。如果需要多个翻译单元的组合输出，stderr应改用。</p>
<p>在下面的例子中,优化信息被输出至stderr:</p>
<p>gcc -O3 -fopt-info</p>
<p>这个例子。</p>
<p>gcc -O3 -fopt-info-missed=missed.all</p>
<p>将所有通道的遗漏优化报告输出到missed.all， 还有这个：</p>
<p>gcc -O2 -ftree-vectorize -fopt-info-vec-missed</p>
<p>打印关于从矢量化传递中错过的优化机会的信息。stderr。注意-fopt-info-vec-missed相当于-fopt-info-missed-vec。后面列出的优化组名称和消息类型的顺序-fopt-info并不重要。</p>
<p>再举个例子:</p>
<p>gcc -O3 -fopt-info-inline-optimized-missed=inline.txt</p>
<p>将漏掉的优化信息以及所有内联传递中的优化位置输出至inline.txt.</p>
<p>最后,考虑:</p>
<p>gcc -fopt-info-vec-missed=vec.miss -fopt-info-loop-optimized=loop.opt</p>
<p>这里有两个输出文件名vec.missandloop.opt有冲突,因为只允许一个输出文件。在这种情况下,只有第一个选项生效,后续的选项被忽略。因此只有vec.miss生成,其中包含了来自向量器的关于错失机会的转储。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>save-optimization-record</var></span></kbd></dt>
<dd><p>写一个SRCFILE.opt-record.json.gz文件,详细说明进行了哪些优化,对于那些支持-fopt-info.</p>
<p>这个选项是试验性的,压缩后的JSON文件中的数据格式可能会改变。</p>
<p>它大致相当于一个机器可读版本的-fopt-info-all，作为具有源文件，行号和列号的消息的集合，每条消息具有以下附加数据：</p>
<blockquote>
<div><p>正在优化的代码的执行次数,以及关于这是否来自于实际的配置文件数据的元数据,或者只是一个估计,允许消费者根据代码的热度来确定消息的优先级。
正在优化的代码的函数名称(如适用)。
优化代码的“内联链”，以便在将函数内联到几个不同的位置（它们本身可能内联）时，读者可以区分出副本，
对象,标识出消息中引用表达式、语句或符号表节点的部分,它们是这些类别中的哪一类,如果有的话,还标识出它们的源代码位置。
发出该消息的GCC通证,以及
在GCC自己的代码中发出消息的位置</p>
</div></blockquote>
<p>此外,一些消息在逻辑上嵌套在其他消息中,反映了优化通道的实现细节。</p>
</dd>
</dl>
<p>-fsched-verbose=n</p>
<blockquote>
<div><p>在使用指令调度的目标上,这个选项控制调度器打印到转储文件的调试输出量。</p>
<p>对于大于零的 n-fsched-verbose输出的信息与-fdump-rtl-sched1and-fdump-rtl-sched2。对于大于1的 n ，它还输出基本块概率，详细的就绪列表信息和单位/插入信息。对于大于2的 n ，它包括中止点处的RTL，控制流和区域信息。对于四个以上的 n-fsched-verbose还包括依赖性信息。</p>
</div></blockquote>
<p>-fenable-kind-pass
-fdisable-kind-pass=range-list</p>
<blockquote>
<div><p>这是一组用于明确禁用/启用优化通道的选项。这些选项用于调试GCC。编译器用户应该使用常规选项来启用/禁用通证。</p>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>disable-ipa-pass</var></span></kbd></dt>
<dd><p>禁用IPA pass pass 。 pass 是通过名称。如果在编译器中多次静态调用同一遍，则遍历名称应附加从1开始的序列号。</p>
</dd>
</dl>
<p>-fdisable-rtl-pass
-fdisable-rtl-pass=range-list</p>
<blockquote>
<div><p>禁用RTL pass pass 。 pass 是通过名称。如果在编译器中多次静态调用同一遍，则遍历名称应附加一个从1开始的序号。range range-list 是用逗号分隔的函数范围或汇编程序名称列表。每个范围都是一个由冒号分隔的数字对。该范围包括两端。如果范围很小，则可以将数字对简化为单个数字。如果函数的调用图节点的 uid 处于指定范围之一内，则对该函数禁用 pass 。该 uid 示于转储文件的函数头，和通过名字可以通过使用选项被倾倒-fdump-passes.</p>
</div></blockquote>
<p>-fdisable-tree-pass
-fdisable-tree-pass=range-list</p>
<blockquote>
<div><p>禁用树 pass 。看到-fdisable-rtl关于选项参数的描述。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>enable-ipa-pass</var></span></kbd></dt>
<dd><p>启用IPA pass pass 。 pass 是通过名称。如果在编译器中多次静态调用同一遍，则遍历名称应附加从1开始的序列号。</p>
</dd>
</dl>
<p>-fenable-rtl-pass
-fenable-rtl-pass=range-list</p>
<blockquote>
<div><p>启用RTL pass pass 。看到-fdisable-rtl以获取选项参数描述和示例。</p>
</div></blockquote>
<p>-fenable-tree-pass
-fenable-tree-pass=range-list</p>
<blockquote>
<div><p>启用tree pass pass 。看到-fdisable-rtl关于选项参数的描述。</p>
</div></blockquote>
<p>下面是一些使用这些选项的例子。</p>
<dl class="simple">
<dt># disable ccp1 for all functions</dt><dd><p>-fdisable-tree-ccp1</p>
</dd>
<dt># disable complete unroll for function whose cgraph node uid is 1</dt><dd><p>-fenable-tree-cunroll=1</p>
</dd>
</dl>
<p># disable gcse2 for functions at the following ranges [1,1],
# [300,400], and [400,1000]
# disable gcse2 for functions foo and foo2</p>
<blockquote>
<div><p>-fdisable-rtl-gcse2=foo,foo2</p>
</div></blockquote>
<dl class="simple">
<dt># disable early inlining</dt><dd><p>-fdisable-tree-einline</p>
</dd>
<dt># disable ipa inlining</dt><dd><p>-fdisable-ipa-inline</p>
</dd>
<dt># enable tree full unroll</dt><dd><p>-fenable-tree-unroll</p>
</dd>
</dl>
</div></blockquote>
<p>-fchecking
-fchecking=n</p>
<blockquote>
<div><p>启用内部一致性检查。默认值取决于编译器的配置。-fchecking=2使得可能影响代码生成的进一步内部一致性检查成为可能。</p>
</div></blockquote>
<p>-frandom-seed=string</p>
<blockquote>
<div><p>这个选项提供了一个种子,GCC用它来代替随机数,生成某些在每个编译文件中必须不同的符号名。它还用于在覆盖率数据文件和生成它们的对象文件中放置唯一的标记。您可以使用-frandom-seed选项,以产生可复制的相同对象文件。</p>
<p>该 string 可以是数字（十进制，八进制或十六进制）或任意字符串（在这种情况下，可以通过计算CRC32将其转换为数字）。</p>
<p>对于您编译的每个文件， string 都应该不同。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-s<var>ave-temps</var></span></kbd></dt>
<dd><p>永久存储通常的“临时”中间文件；将它们命名为辅助输出文件，如下所述-dumpbaseand-dumpdir.</p>
<p>当结合使用-x命令行选项。-save-temps是足够明智的,以避免覆盖一个与中间文件具有相同扩展名的输入源文件。相应的中间文件可以通过重命名源文件获得,然后再使用-save-temps.</p>
</dd>
</dl>
<p>-save-temps=cwd</p>
<blockquote>
<div><p>相当于-save-temps -dumpdir ./.</p>
</div></blockquote>
<p>-save-temps=obj</p>
<blockquote>
<div><p>相当于-save-temps -dumpdiroutdir/，在哪里outdir/是指定的输出文件的目录,在-o选项,包括任何目录分隔符。如果-o选项,不使用-save-temps=obj开关的行为就像-save-temps=cwd.</p>
</div></blockquote>
<p>-time[=file]</p>
<blockquote>
<div><p>报告编译序列中每个子进程所花费的CPU时间。对于C语言源文件,这是指编译器本身和汇编器(如果进行了链接,还要加上链接器)。</p>
<p>如果不指定输出文件,输出结果是这样的。</p>
<p># cc1 0.12 0.01
# 作为 0.00 0.01</p>
<p>每行的第一个数字是“用户时间”，即执行程序本身所花费的时间。第二个数字是“系统时间”，代表该程序执行操作系统例程所花费的时间。两个数字都以秒为单位。</p>
<p>有了指定的输出文件,输出就会附加到命名的文件中,它的样子是这样的。</p>
<p>0.12 0.01 cc1 options
0.00 0.01 as options</p>
<p>将“用户时间”和“系统时间”移到程序名称之前，并显示传递给程序的选项，以便以后可以知道正在编译的文件以及使用的选项。</p>
</div></blockquote>
<p>-fdump-final-insns[=file]</p>
<blockquote>
<div><p>将最终的内部表示 (RTL) 转储到 file 。如果省略可选参数（或者如果 file 是 . ），则转储文件的名称通过将 .gkd 附加到转储基名称来确定，请参阅-dumpbase.</p>
</div></blockquote>
<p>-fcompare-debug[=opts]</p>
<blockquote>
<div><p>如果在编译过程中没有发生错误，请再次运行编译器，并添加 opts 和-fcompare-debug-second到传递给第二个编译的参数。在两个编译中转储最终的内部表示,如果它们不同,则打印错误。</p>
<p>如果省略等号,则默认为-gtoggle是用。</p>
<p>环境变量 GCC_COMPARE_DEBUG （如果已定义）非空且非零，则隐式启用-fcompare-debug。如果将 GCC_COMPARE_DEBUG 定义为以短划线开头的字符串，则将其用于 opts ，否则使用默认值-gtoggle是用。</p>
<p>-fcompare-debug=等号但不带 opts 的等价于-fno-compare-debug，它会禁止转储最终表示形式和第二次编译，从而甚至阻止了 GCC_COMPARE_DEBUG 生效。</p>
<p>核实期间的全覆盖-fcompare-debug测试，将 GCC_COMPARE_DEBUG 设置为-fcompare-debug-not-overridden，在任何实际的编译中（而不是预处理，汇编或链接），GCC都会将其视为无效选项。要仅获得警告， GCC_COMPARE_DEBUG 设置为“-w％n-fcompare-debug不被覆盖’ 会做。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>compare-debug-second</var></span></kbd></dt>
<dd><p>这个选项会被隐式地传递给编译器,以便在第二次编译时由-fcompare-debug，以及使警告静音的选项，并省略其他可能导致编译器产生副作用的选项，这些其他选项会导致编译器将输出生成到文件或标准输出。重命名转储文件和保留的临时文件，以便在第二次编译时包含 .gk 附加扩展名，以避免覆盖第一个编译时生成的扩展名。</p>
<p>当将此选项传递给编译器驱动程序时，它会导致第一个编译被跳过，这使其除调试适当的编译器外几乎无用。</p>
</dd>
<dt><kbd><span class="option">-g<var>toggle</var></span></kbd></dt>
<dd><p>关闭调试信息的生成,如果不使用这个选项会生成调试信息,否则在2级时打开。这个参数在命令行中的位置并不重要,它在处理完所有其他选项后才生效,而且无论给出多少次,它都只生效一次。这主要是为了与-fcompare-debug.</p>
</dd>
<dt><kbd><span class="option">-f<var>var-tracking-assignments-toggle</var></span></kbd></dt>
<dd><p>Toggle-fvar-tracking-assignments，就像-gtoggletoggles-g.</p>
</dd>
<dt><kbd><span class="option">-Q</span></kbd></dt>
<dd><p>让编译器在编译时打印出每个函数的名称,并在编译完成后打印一些关于每个通道的统计数据。</p>
</dd>
<dt><kbd><span class="option">-f<var>time-report</var></span></kbd></dt>
<dd><p>使编译器在结束时,打印一些关于每个通道所消耗的时间的统计数据。</p>
</dd>
<dt><kbd><span class="option">-f<var>time-report-details</var></span></kbd></dt>
<dd><p>分别记录基建部分每次通行所消耗的时间。</p>
</dd>
</dl>
<p>-fira-verbose=n</p>
<blockquote>
<div><p>控制集成寄存器分配器的转储文件的详细程度。默认值为5。如果值 n 大于或等于10，则转储输出将使用与 n 减10 相同的格式发送到stderr 。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>lto-report</var></span></kbd></dt>
<dd><p>打印一份关于链接时间优化器工作的内部细节报告。该报告的内容因版本而异。当GCC开发人员在LTO模式下处理对象文件(通过-flto).</p>
<p>默认情况下已禁用。</p>
</dd>
<dt><kbd><span class="option">-f<var>lto-report-wpa</var></span></kbd></dt>
<dd><p>Like-flto-report，但仅在链接时间优化的WPA阶段打印。</p>
</dd>
<dt><kbd><span class="option">-f<var>mem-report</var></span></kbd></dt>
<dd><p>让编译器在完成时打印一些关于永久内存分配的统计数据。</p>
</dd>
<dt><kbd><span class="option">-f<var>mem-report-wpa</var></span></kbd></dt>
<dd><p>使编译器只为WPA阶段打印一些关于永久内存分配的统计数据。</p>
</dd>
</dl>
<p>-fpre-ipa-mem-report
-fpost-ipa-mem-report</p>
<blockquote>
<div><p>使编译器打印一些关于程序间优化前后永久内存分配的统计数据。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-f<var>profile-report</var></span></kbd></dt>
<dd><p>使编译器打印一些关于(估计的)剖面图的一致性和各个通道的效果的统计数据。</p>
</dd>
<dt><kbd><span class="option">-f<var>stack-usage</var></span></kbd></dt>
<dd><p>使编译器以每个函数为基础输出程序的堆栈使用信息。转储的文件名是由附加的方式来制作的。.su到 auxname 。 auxname 是从输出文件的名称生成的（如果已明确指定），并且不是可执行文件，否则是源文件的基本名称。条目由三个字段组成：</p>
<blockquote>
<div><p>功能的名称。
一个字节的数量。
一个或多个限定符： static ， dynamic ， bounded 。</p>
</div></blockquote>
<p>限定符 static 表示该函数静态地操作堆栈：在函数入口为帧分配固定数量的字节，在函数出口将其释放；否则不会在函数中进行堆栈调整。第二个字段是此固定字节数。</p>
<p>限定符是 dynamic 意味着函数动态地操纵堆栈：除了上述静态分配之外，还在函数主体中进行了堆栈调整，例如，在函数调用周围推送/弹出参数。如果还存在限定符 bounded ，则这些调整的量在编译时限定，并且第二个字段是该函数使用的堆栈总数的上限。如果不存在，则这些调整的数量在编译时不受限制，并且第二个字段仅表示受限制的部分。</p>
</dd>
<dt><kbd><span class="option">-f<var>stats</var></span></kbd></dt>
<dd><p>在编译结束时发出有关前端处理的统计信息。这个选项只有C++前端支持,这些信息一般只对G++开发团队有用。</p>
</dd>
<dt><kbd><span class="option">-f<var>dbg-cnt-list</var></span></kbd></dt>
<dd><p>打印所有调试计数器的名称和计数器上界。</p>
</dd>
</dl>
<p>-fdbg-cnt=counter-value-list</p>
<blockquote>
<div><p>设置内部调试计数器的上限和下限。 counter-value-list 是逗号分隔的 name 列表： lower_bound1 - upper_bound1 [： lower_bound2 - upper_bound2 …]元组，它设置计数器的名称和关闭间隔的列表。该 lower_bound 是可选的，如果没有设置初始化为零。例如，-fdbg-cnt=dce:2-4:10-11,tail_call:10， dbg_cnt(dce) 仅对第二，第三，第四，第十和第十一次调用返回true。对于 dbg_cnt(tail_call) ，前10次调用返回true。</p>
</div></blockquote>
<p>-print-file-name=library</p>
<blockquote>
<div><p>打印链接时将使用的库文件 library 绝对全名，而无需执行其他任何操作。使用此选项，GCC不会编译或链接任何内容；它只是打印文件名。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-p<var>rint-multi-directory</var></span></kbd></dt>
<dd><p>打印与命令行中存在的任何其他开关选择的multilib对应的目录名称。该目录应该存在于 GCC_EXEC_PREFIX 中。</p>
</dd>
<dt><kbd><span class="option">-p<var>rint-multi-lib</var></span></kbd></dt>
<dd><p>打印从multilib目录名到启用它们的编译器开关的映射。目录名称与交换机之间用’分隔;’，并且每个开关均以’&#64;’而不是’-‘，多个开关之间没有空格。应该可以简化外壳处理。</p>
</dd>
<dt><kbd><span class="option">-p<var>rint-multi-os-directory</var></span></kbd></dt>
<dd><p>打印所选多库的操作系统库的路径,相对于某个lib子目录。如果OS库存在于lib子目录,而且没有使用multilibs,通常这只是.，如果OS库存在于libsuffix这将打印出兄弟姐妹的目录,如../lib64,../libor../lib32，或者如果存在OS库lib/subdir它打印的子目录,如amd64,sparcv9orev6.</p>
</dd>
<dt><kbd><span class="option">-p<var>rint-multiarch</var></span></kbd></dt>
<dd><p>打印所选多库的操作系统库的路径,相对于某个libsubdirectory.</p>
</dd>
</dl>
<p>-print-prog-name=program</p>
<blockquote>
<div><p>Like-print-file-name，但搜索诸如 cpp 之类的程序。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-p<var>rint-libgcc-file-name</var></span></kbd></dt>
<dd><p>同理-print-file-name=libgcc.a.</p>
<p>当你使用-nostdlibor-nodefaultlibs但你确实想与libgcc.a。你可以做：</p>
<p>gcc -nostdlib files… <cite>gcc -print-libgcc-file-name</cite></p>
</dd>
<dt><kbd><span class="option">-p<var>rint-search-dirs</var></span></kbd></dt>
<dd><p>打印已配置的安装目录的名称以及 gcc 搜索的程序和库目录的列表-请勿执行其他任何操作。</p>
<p>当 gcc 打印错误消息“安装问题,无法执行cpp0:没有这个文件或目录。’。要解决此问题，您要么需要cpp0以及其他 gcc 希望在其中找到它们的编译器组件，或者您可以将环境变量 GCC_EXEC_PREFIX 设置为安装它们的目录。不要忘记尾随的“/’。请参阅环境变量。</p>
</dd>
<dt><kbd><span class="option">-p<var>rint-sysroot</var></span></kbd></dt>
<dd><p>打印编译时使用的目标sysroot目录。这是在配置时或使用下面的命令指定的目标系统根目录。–sysroot选项,可能会有一个额外的后缀,这取决于编译选项。如果没有指定目标sysroot,则该选项不打印任何内容。</p>
</dd>
<dt><kbd><span class="option">-p<var>rint-sysroot-headers-suffix</var></span></kbd></dt>
<dd><p>搜索标题时，打印添加到目标sysroot的后缀，如果编译器未配置后缀，则显示错误，并且不要执行任何其他操作。</p>
</dd>
<dt><kbd><span class="option">-d<var>umpmachine</var></span></kbd></dt>
<dd><p>打印编译器的目标计算机（例如，“i686-pc-linux-gnu’），并且别无其他。</p>
</dd>
<dt><kbd><span class="option">-d<var>umpversion</var></span></kbd></dt>
<dd><p>打印编译器版本（例如， 3.0 ， 6.3.0 或 7 ） -和没有其他人做任何事情。这是文件系统路径和规范中使用的编译器版本。根据编译器的配置方式，它可以是一个数字（主要版本），两个以点分隔的数字（主要和次要版本）或三个以点分隔的数字（主要，次要和补丁程序版本）。</p>
</dd>
<dt><kbd><span class="option">-d<var>umpfullversion</var></span></kbd></dt>
<dd><p>打印完整的编译器版本-请勿执行其他任何操作。输出始终是三个数字，由点，主要，次要和补丁级别版本分隔。</p>
</dd>
<dt><kbd><span class="option">-d<var>umpspecs</var></span></kbd></dt>
<dd><p>打印编译器的内置规范，而不做其他任何事情。（在构建GCC本身时使用。）请参见Spec Files。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="id32">
<h2>机器相关的选项<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h2>
<div class="section" id="ebpf">
<h3>eBPF选项<a class="headerlink" href="#ebpf" title="Permalink to this headline">¶</a></h3>
<p>-mframe-limit=bytes</p>
<blockquote>
<div><p>这指定了帧大小的硬限制，以字节为单位。当前，可以指定的值应小于或等于’32767’。默认值为目标Linux内核版本强加的任何限制。</p>
</div></blockquote>
<p>-mkernel=version</p>
<blockquote>
<div><p>这指定将运行已编译程序的内核的最低版本。GCC使用此版本来确定要使用的指令，允许的内核助手等。当前，该 version 可以是“4.0’，’4.1’，’4.2’，’4.3’，’4.4’，’4.5’，’4.6’，’4.7’，’4.8’，’4.9’，’4.10’，’4.11’，’4.12’，’4.13’，’4.14’，’4.15’，’4.16’，’4.17’，’4.18’，’4.19’，’4.20’，’5.0’，’5.1’，’5.2’，’latest’和’native’.</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-m<var>big-endian</var></span></kbd></dt>
<dd><p>生成大段目标的代码。</p>
</dd>
<dt><kbd><span class="option">-m<var>little-endian</var></span></kbd></dt>
<dd><p>生成小段目标的代码。这是默认的。</p>
</dd>
<dt><kbd><span class="option">-m<var>xbpf</var></span></kbd></dt>
<dd><p>为BPF的扩展版本生成代码,该版本放宽了BPF架构的一些限制。</p>
<blockquote>
<div><ul class="simple">
<li><p>分别在函数进入和退出时保存和恢复被调用者保存的寄存器。</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</div>
<div class="section" id="x86-options">
<h3>x86 Options<a class="headerlink" href="#x86-options" title="Permalink to this headline">¶</a></h3>
<p>这些“-m’选项是为x86系列计算机定义的。</p>
<p>-march=cpu-type</p>
<blockquote>
<div><p>为机器类型 cpu-type 生成指令。与之相反-mtune=cpu-type，它仅会针对指定的 cpu-type 调整生成的代码，-march=cpu-type允许 GCC 生成的代码在指定处理器以外的处理器上可能根本无法运行。指定-march=cpu-typeimplies-mtune=cpu-type，除非另有说明。</p>
<p>cpu-type 的选择是：</p>
<p>‘native’</p>
<blockquote>
<div><p>在编译时,通过确定编译机的处理器类型来选择生成代码的CPU。使用-march=native启用本地机器支持的所有指令子集(因此结果可能无法在不同机器上运行)。使用-mtune=native在所选指令集的约束下,产生针对本地机器的优化代码。</p>
</div></blockquote>
<p>‘x86-64’</p>
<blockquote>
<div><p>64位扩展的通用CPU。</p>
</div></blockquote>
<p>‘x86-64-v2’
‘x86-64-v3’
‘x86-64-v4’</p>
<blockquote>
<div><p>这些 cpu-type 选择从 x86-64 psABI 中选择相应的微架构级别。在 x86-64 psABI 以外的 ABI 上，它们为特定的微架构级别选择与 x86-64 psABI 文档相同的 CPU 功能。</p>
<p>由于这些 cpu-type 值没有对应的-mtunesetting, using-march用这些值可以启用通用调谐。具体的调谐可以用-mtune=other-cpu-type具有适当 other-cpu-type 值的选项。</p>
</div></blockquote>
<p>‘i386’</p>
<blockquote>
<div><p>原装英特尔i386 CPU。</p>
</div></blockquote>
<p>‘i486’</p>
<blockquote>
<div><p>英特尔i486 CPU。(该芯片没有实现调度)。</p>
</div></blockquote>
<p>‘i586’
‘pentium’</p>
<blockquote>
<div><p>Intel Pentium CPU,不支持MMX。</p>
</div></blockquote>
<p>‘lakemont’</p>
<blockquote>
<div><p>英特尔拉克蒙MCU,基于英特尔奔腾CPU。</p>
</div></blockquote>
<p>‘pentium-mmx’</p>
<blockquote>
<div><p>英特尔奔腾MMX CPU,基于奔腾核心,支持MMX指令集。</p>
</div></blockquote>
<p>‘pentiumpro’</p>
<blockquote>
<div><p>Intel Pentium Pro CPU。</p>
</div></blockquote>
<p>‘i686’</p>
<blockquote>
<div><p>搭配使用时-march，因为使用了Pentium Pro指令集，所以代码可以在所有i686系列芯片上运行。当与-mtune，其含义与“generic’.</p>
</div></blockquote>
<p>‘pentium2’</p>
<blockquote>
<div><p>英特尔奔腾II CPU,基于奔腾Pro核心,支持MMX指令集。</p>
</div></blockquote>
<p>‘pentium3’
‘pentium3m’</p>
<blockquote>
<div><p>Intel Pentium III CPU,基于Pentium Pro核心,支持MMX和SSE指令集。</p>
</div></blockquote>
<p>‘pentium-m’</p>
<blockquote>
<div><p>Intel Pentium M;Intel Pentium III CPU的低功耗版本,支持MMX、SSE和SSE2指令集。由Centrino笔记本使用。</p>
</div></blockquote>
<p>‘pentium4’
‘pentium4m’</p>
<blockquote>
<div><p>Intel Pentium 4 CPU,支持MMX、SSE和SSE2指令集。</p>
</div></blockquote>
<p>‘prescott’</p>
<blockquote>
<div><p>Intel Pentium 4 CPU的改进版,支持MMX、SSE、SSE2和SSE3指令集。</p>
</div></blockquote>
<p>‘nocona’</p>
<blockquote>
<div><p>Intel Pentium 4 CPU的改进版,支持64位扩展、MMX、SSE、SSE2和SSE3指令集。</p>
</div></blockquote>
<p>‘core2’</p>
<blockquote>
<div><p>英特尔酷睿2 CPU,支持64位扩展,MMX、SSE、SSE2、SSE3和SSSE3指令集。</p>
</div></blockquote>
<p>‘nehalem’</p>
<blockquote>
<div><p>英特尔Nehalem CPU,支持64位扩展,MMX、SSE、SSE2、SSE3、SSE3、SSE4.1、SSE4.2和POPCNT指令集。</p>
</div></blockquote>
<p>‘westmere’</p>
<blockquote>
<div><p>英特尔Westmere CPU,支持64位扩展,MMX、SSE、SSE2、SSE3、SSE3、SSE4.1、SSE4.2、POPCNT、AES和PCLMUL指令集。</p>
</div></blockquote>
<p>‘sandybridge’</p>
<blockquote>
<div><p>英特尔Sandy Bridge CPU,支持64位扩展,MMX、SSE、SSE2、SSE3、SSE3、SSE4.1、SSE4.2,支持POPCNT、AVX、AES和PCLMUL指令集。</p>
</div></blockquote>
<p>‘ivybridge’</p>
<blockquote>
<div><p>Intel Ivy Bridge CPU,支持64位扩展,MMX、SSE、SSE2、SSE3、SSE3、SSE4.1、SSE4.2、POPCNT、AVX、AES、PCLMUL、FSGSBASE、RDRND和F16C指令集。</p>
</div></blockquote>
<p>‘haswell’</p>
<blockquote>
<div><p>英特尔Haswell CPU,支持64位扩展、MOVBE、MMX、SSE、SSE3、SSE4.1、SSE4.2、POPCNT、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2和F16C指令集。</p>
</div></blockquote>
<p>‘broadwell’</p>
<blockquote>
<div><p>英特尔Broadwell CPU具有64位扩展、MOVBE、MMX、SSE、SSE2、SSE3、SSE4.1、SSE4.2、POPCNT、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C、RDSEED ADCX 和PREFETCHW指令集支持。</p>
</div></blockquote>
<p>‘skylake’</p>
<blockquote>
<div><p>英特尔Skylake CPU的64位扩展,MOVBE、MMX、SSE、SSE2、SSE3、SSE4.1、SSE4.2、POPCNT、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C、RDSEED、ADCX、PREFETCHW、CLFLUSHOPT、XSAVEC和XSAVES指令集支持。</p>
</div></blockquote>
<p>‘bonnell’</p>
<blockquote>
<div><p>英特尔Bonnell CPU具有64位扩展功能,支持MOVBE、MMX、SSE、SSE2、SSE3和SSSE3指令集。</p>
</div></blockquote>
<p>‘silvermont’</p>
<blockquote>
<div><p>英特尔Silvermont CPU具有64位扩展、MOVBE、MMX、SSE、SSE2、SSE3、SSE4.1、SSE4.2、POPCNT、AES、PREFETCHW、PCLMUL和RDRND指令集支持。</p>
</div></blockquote>
<p>‘goldmont’</p>
<blockquote>
<div><p>英特尔Goldmont CPU具有64位扩展、MOVBE、MMX、SSE、SSE2、SSE3、SSE4.1、SSE4.2、POPCNT、AES、PREFETCHW、PCLMUL、RDRND、XSAVE、XSAVEC、XSAVES、XSAVEOPT和FSGSBASE指令集支持。</p>
</div></blockquote>
<p>‘goldmont-plus’</p>
<blockquote>
<div><p>英特尔Goldmont Plus CPU具有64位扩展、MOVBE、MMX、SSE、SSE2、SSE3、SSE4.1、SSE4.2、POPCNT、AES、PREFETCHW、PCLMUL、RDRND、XSAVE、XSAVEC、XSAVES、XSAVEOPT、FSGSBASE、PTWRITE、RDPID、SGX和UMIP指令集支持。</p>
</div></blockquote>
<p>‘tremont’</p>
<blockquote>
<div><p>带有64位扩展的Intel Tremont CPU,MOVBE,MMX,SSE,SSE2,SSE3,SSE4.1,SSE4。 2,POPCNT,AES,PREFETCHW,PCLMUL,RDRND,XSAVE,XSAVEC,XSAVES,XSAVEOPT,FSGSBASE,PTWRITE,RDPID,SGX,UMIP,GFNI-SSE,CLWB,MOVDIRI,MOVDIR64B,CLDEMOTE 和 WAITPKG 指令集支持。</p>
</div></blockquote>
<p>‘knl’</p>
<blockquote>
<div><p>Intel Knight’s Landing CPU 64 位扩展，MOVBE, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, POPCNT, AVX, AVX2, AES, PCLMUL, FSGSBASE, RDRND, FMA, BMI, BMI2, F16C、RDSEED、ADCX、PREFETCHW、PREFETCHWT1、AVX512F、AVX512PF、AVX512ER 和 AVX512CD 指令集支持。</p>
</div></blockquote>
<p>‘knm’</p>
<blockquote>
<div><p>带有64位扩展的英特尔Knights Mill CPU,MOVBE,MMX,SSE,SSE2,SSE3,SSE4.1,SSE4。 2,POPCNT,AVX,AVX2,AES,PCLMUL,FSGSBASE,RDRND,FMA,BMI,BMI2,F16C,RDSEED,ADCX,PREFETCHW,PREFETCHWT1,AVX512F,AVX512PF,AVX512ER,AVX512CD,AVX5124VNNIW,AVX5124FMAPS 和 AVX512VPOPCNTDQ 指令集支持。</p>
</div></blockquote>
<p>‘skylake-avx512’</p>
<blockquote>
<div><p>英特尔Skylake服务器CPU的64位扩展、MOVBE、MMX、SSE、SSE2、SSE3、SSE4.1、SSE4.2、POPCNT、PKU、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C、RDSEED、ADCX、PREFETCHW、CLFLUSHOPT、XSAVEC、XSAVES、AVX512F、CLWB、AVX512VL、AVX512BW、AVX512DQ和AVX512CD指令集支持。</p>
</div></blockquote>
<p>‘cannonlake’</p>
<blockquote>
<div><p>英特尔Cannonlake服务器CPU的64位扩展,MOVBE,MMX,SSE,SSE2,SSE3,SSE3,SSE4.1,SSE4.2,POPCNT,PKU,AVX,AVX2,AES,PCLMUL,FSGSBASE,RDRND,FMA,BMI,BMI2,F16C,RDSEED,ADC。 2、POPCNT、PKU、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C、RDSEED、ADCX、PREFETCHW、CLFLUSHOPT、XSAVEC。支持XSAVES、AVX512F、AVX512VL、AVX512BW、AVX512DQ、AVX512CD、AVX512VBMI、AVX512IFMA、SHA和UMIP指令集。</p>
</div></blockquote>
<p>‘icelake-client’</p>
<blockquote>
<div><p>英特尔Icelake客户端CPU的64位扩展,MOVBE,MMX,SSE,SSE2,SSE3,SSSE4.1,SSE4.2、POPCNT、PKU、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C、RDSEED、ADCX、PREFETCHW、CLFLUSHOPT、XSAVEC、XSAVES、AVX512F、AVX512VL、AVX512BW、AVX512DQ。支持AVX512CD、AVX512VBMI、AVX512IFMA、SHA、CLWB、UMIP、RDPID、GFNI、AVX512VBMI2、AVX512VPOPCNTDQ、AVX512BITALG、AVX512VNNI、VPCLMULQDQ、VAES指令集。</p>
</div></blockquote>
<p>‘icelake-server’</p>
<blockquote>
<div><p>英特尔Icelake服务器CPU的64位扩展,MOVBE,MMX,SSE,SSE2,SSE3,SSSE4.1,SSE4.2、POPCNT、PKU、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C、RDSEED、ADCX、PREFETCHW、CLFLUSHOPT、XSAVEC、XSAVES、AVX512F、AVX512VL、AVX512BW、AVX512DQ、AVX512CD。支持AVX512VBMI、AVX512IFMA、SHA、CLWB、UMIP、RDPID、GFNI、AVX512VBMI2、AVX512VPOPCNTDQ、AVX512BITALG、AVX512VNNI、VPCLMULQDQ、VAES、PCONFIG和WBNOINVD指令集。</p>
</div></blockquote>
<p>‘cascadelake’</p>
<blockquote>
<div><p>英特尔Cascadelake CPU的64位扩展,MOVBE,MMX,SSE,SSE2,SSE3,SSSE4.1,SSE4.2、POPCNT、PKU、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C、RDSEED、ADCX、PREFETCHW、CLFLUSHOPT、XSAVEC、XSAVES、AVX512F、CLWB、AVX512VL、AVX512BW、AVX512DQ、AVX512CD和AVX512VNNI指令集支持。</p>
</div></blockquote>
<p>‘cooperlake’</p>
<blockquote>
<div><p>Intel cooperlake CPU的64位扩展,MOVBE、MMX、SSE、SSE2、SSE3、SSE4.1、SSE4.2、POPCNT、PKU、AVX、AVX2、AES、PCLMUL、FSGSBASE、RDRND、FMA、BMI、BMI2、F16C、RDSEED、ADCX、PREFETCHW、CLFLUSHOPT。支持XSAVEC、XSAVES、AVX512F、CLWB、AVX512VL、AVX512BW、AVX512DQ、AVX512CD、AVX512VNNI和AVX512BF16指令集。</p>
</div></blockquote>
<p>‘tigerlake’</p>
<blockquote>
<div><p>英特尔Tigerlake CPU具有64位扩展,MOVBE,MMX,SSE,SSE2,SSE3,SSE4.1,SSE4.2,popcnt,pku,avx,avx2,aes,pclmul,fsgsbase,rdrnd,fma,bmi,bmi2,f16c,rdseed,adcx,prefetchw,clflushopt,xsavec,xsaves,avx512f,avx512vl,avx512bw,avx512dq,avx512cd,avx512vbmi,avx512ifma,支持SHA、CLWB、UMIP、RDPID、GFNI、AVX512VBMI2、AVX512VPOPCNTDQ、AVX512BITALG、AVX512VNNI、VPCLMULQDQ、VAES、PCONFIG、WBNOINVD、MOVDIRI、MOVDIR64B、AVX512VP2INTERSECT以及KEYLOCKER指令集。</p>
</div></blockquote>
<p>‘sapphirerapids’</p>
<blockquote>
<div><p>带有64位扩展的Intel sapphirapids CPU,MOVBE,MMX,SSE,SSE2,SSE3,SSE3,SSE4.1,SSE4。 2,popcnt,pku,avx,avx2,aes,pclmul,fsgsbase,rdrnd,fma,bmi,bmi2,f16c,rdseed,adcx,prefetchw,clflushopt,xsavec,xsaves,avx512f,clwb,avx512vl,avx512bw,avx512dq,avx512cd,AVX512VNNI、AVX512BF16、MOVDIRI、MOVDIR64B、AVX512VP2INTERSECT、ENQCMD、CLDEMOTE、PTWRITE、WAITPKG、SERIALIZE、TSXLDTRK、UINTR、AMX-BF16、AMX-TILE、AMX-INT8以及AVX-VNNI指令集支持。</p>
</div></blockquote>
<p>‘alderlake’</p>
<blockquote>
<div><p>英特尔Alderlake CPU带有64位扩展,MOVBE,MMX,SSE,SSE2,SSE3,SSE4.1,SSE4.2,popcnt,aes,prefetchw,pclmul,rdrnd,xsave,xsavec,xsaves,xsaveopt,fsgsbase,ptwrite,rdpid,sgx,umip,gfni-sse,clwb,movdiri,movdir64b,cldemote,WAITPKG,ADCX,AVX,AVX2,BMI,BMI2,F16C,FMA,LZCNT,PCONFIG,PKU,VAES,VPCLMULQDQ,SERIALIZE,HRESET,KL,WIDEKL 和 AVX-VNNI 指令集支持。</p>
</div></blockquote>
<p>‘rocketlake’</p>
<blockquote>
<div><p>英特尔Rocketlake CPU具有64位扩展,MOVBE,MMX,SSE,SSE2,SSE3,SSE4.1,SSE4。 2,popcnt,pku,avx,avx2,aes,pclmul,fsgsbase,rdrnd,fma,bmi,bmi2,f16c,rdseed,adcx,prefetchw,clflushopt,xsavec,xsaves,avx512f,avx512vl,avx512bw,avx512dq,AVX512CD,AVX512VBMI,AVX512IFMA,SHA,CLWB,UMIP,RDPID,GFNI,AVX512VBMI2,AVX512VPOPCNTDQ,AVX512BITALG,AVX512VNNI,VPCLMULQDQ,VAES 指令集支持。</p>
</div></blockquote>
<p>‘k6’</p>
<blockquote>
<div><p>AMD K6 CPU,支持MMX指令集。</p>
</div></blockquote>
<p>‘k6-2’
‘k6-3’</p>
<blockquote>
<div><p>改进版AMD K6 CPU,支持MMX和3DNow!指令集。</p>
</div></blockquote>
<p>‘athlon’
‘athlon-tbird’</p>
<blockquote>
<div><p>AMD Athlon CPU,支持MMX、3dNOW!、增强型3DNow!和SSE预取指令。</p>
</div></blockquote>
<p>‘athlon-4’
‘athlon-xp’
‘athlon-mp’</p>
<blockquote>
<div><p>改进的AMD Athlon CPU,具有MMX、3DNow!、增强的3DNow!和完整的SSE指令集支持。</p>
</div></blockquote>
<p>‘k8’
‘opteron’
‘athlon64’
‘athlon-fx’</p>
<blockquote>
<div><p>基于AMD K8内核的处理器,支持x86-64指令集,包括AMD Opteron、Athlon 64和Athlon 64 FX处理器。(这超越了MMX、SSE、SSE2、3DNow!、增强型3DNow!和64位指令集扩展)。</p>
</div></blockquote>
<p>‘k8-sse3’
‘opteron-sse3’
‘athlon64-sse3’</p>
<blockquote>
<div><p>改进版的AMD K8内核,支持SSE3指令集。</p>
</div></blockquote>
<p>‘amdfam10’
‘barcelona’</p>
<blockquote>
<div><p>基于AMD家族10h核心的CPU,支持x86-64指令集。(这超越了MMX、SSE、SSE2、SSE3、SSE4A、3DNow!、增强型3DNow!、ABM和64位指令集扩展)。</p>
</div></blockquote>
<p>‘bdver1’</p>
<blockquote>
<div><p>基于AMD家族15h核心的CPU,支持x86-64指令集。(这超越了FMA4、AVX、XOP、LWP、AES、PCLMUL、CX16、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM和64位指令集扩展。)</p>
</div></blockquote>
<p>‘bdver2’</p>
<blockquote>
<div><p>支持x86-64指令集的基于15h内核的AMD家族CPU。(这超越了BMI、TBM、F16C、FMA、FMA4、AVX、XOP、LWP、AES、PCLMUL、CX16、MMX、SSE、SSE2、SSE3、SSE4A、SSSE4.1、SSE4.2、ABM和64位指令集扩展。)</p>
</div></blockquote>
<p>‘bdver3’</p>
<blockquote>
<div><p>支持x86-64指令集的基于15h内核的AMD家族CPU。(这超越了BMI、TBM、F16C、FMA、FMA4、FSGSBASE、AVX、XOP、LWP、AES、PCLMUL、CX16、MMX、SSE、SSE2、SSE3、SSE4A、SSE3、SSE4.1、SSE4.2、ABM和64位指令集扩展。)</p>
</div></blockquote>
<p>‘bdver4’</p>
<blockquote>
<div><p>支持x86-64指令集的基于AMD家族15h内核的CPU。(这超越了BMI、BMI2、TBM、F16C、FMA、FMA4、FSGSBASE、AVX、AVX2、XOP、LWP、AES、PCLMUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SSE4A、SSSE3、SSE4.1、SSE4.2、ABM和64位指令集扩展。)</p>
</div></blockquote>
<p>‘znver1’</p>
<blockquote>
<div><p>基于AMD家族17h核的CPU,支持x86-64指令集。(该指令集超越了BMI、BMI2、F16C、FMA、FSGSBASE、AVX、AVX2、ADCX、RDSEED、MWAITX、SHA、CLZERO、AES、PCLMUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SS4A、SSSE3、SSE4.1、SSE4.2、ABM、XSAVEC、XSAVES、CLFLUSHOPT、POPCNT和64位指令集扩展)。)</p>
</div></blockquote>
<p>‘znver2’</p>
<blockquote>
<div><p>基于AMD家族17h核的CPU,支持x86-64指令集。(这超前了BMI、BMI2、CLWB、F16C、FMA、FSGSBASE、AVX、AVX2、ADCX、RDSEED、MWAITX、SHA、CLZERO、AES、PCLMUL、CX16、MOVBE、MMX、SSE、SSE2、SSE3、SSE4A、SSSE4.1、SSE4.2、ABM、XSAVEC、XSAVES、CLFLUSHOPT、POPCNT、RDPID、WBNOINVD以及64位指令集扩展)。)</p>
</div></blockquote>
<p>‘znver3’</p>
<blockquote>
<div><p>基于AMD家族19h核心的CPU,支持x86-64指令集。(这取代了BMI,BMI2,CLWB,F16C,FMA,FSGSBASE,AVX,AVX2,ADCX,RDSEED,MWAITX,SHA,CLZERO,AES,PCLMUL,CX16,MOVBE,MMX,SSE,SSE2,SSE3,SSE4A,SSSE3,SSE4.1,SSE4.2,ABM,XSAVEC,XSAVES,CLFLUSHOPT,POPCNT,RDPID,WBNOINVD,PKU,VPCLMULQDQ,VAES,和64位指令集扩展。)</p>
</div></blockquote>
<p>‘btver1’</p>
<blockquote>
<div><p>基于AMD家族14h核心的CPU,支持x86-64指令集。(这超越了MMX、SSE、SSE2、SSE3、SSE3、SSE4A、CX16、ABM和64位指令集扩展)。</p>
</div></blockquote>
<p>‘btver2’</p>
<blockquote>
<div><p>基于AMD家族16h内核的CPU,支持x86-64指令集。包括MOVBE、F16C、BMI、AVX、PCLMUL、AES、SSE4.2、SSE4.1、CX16、ABM、SSE4A、SSE3、SSE3、SSE2、SSE、MMX和64位指令集扩展。</p>
</div></blockquote>
<p>‘winchip-c6’</p>
<blockquote>
<div><p>IDT WinChip C6 CPU,处理方式与i486相同,但增加了MMX指令集支持。</p>
</div></blockquote>
<p>‘winchip2’</p>
<blockquote>
<div><p>IDT WinChip 2 CPU,处理方式与i486相同,额外支持MMX和3DNow!指令集。</p>
</div></blockquote>
<p>‘c3’</p>
<blockquote>
<div><p>威盛C3 CPU,支持MMX和3DNow!指令集。(该芯片没有实现调度。)</p>
</div></blockquote>
<p>‘c3-2’</p>
<blockquote>
<div><p>威盛C3-2(Nehemiah/C5XL)CPU,支持MMX和SSE指令集。(该芯片没有实现调度。)</p>
</div></blockquote>
<p>‘c7’</p>
<blockquote>
<div><p>威盛C7(Esther)CPU,支持MMX、SSE、SSE2和SSE3指令集。(该芯片没有实现调度。)</p>
</div></blockquote>
<p>‘samuel-2’</p>
<blockquote>
<div><p>VIA Eden Samuel 2 CPU,支持MMX和3DNow!指令集。(该芯片没有实现调度。)</p>
</div></blockquote>
<p>‘nehemiah’</p>
<blockquote>
<div><p>威盛Eden Nehemiah CPU,支持MMX和SSE指令集。(该芯片没有实现调度。)</p>
</div></blockquote>
<p>‘esther’</p>
<blockquote>
<div><p>威盛Eden Esther CPU,支持MMX、SSE、SSE2和SSE3指令集。(该芯片没有实现调度。)</p>
</div></blockquote>
<p>‘eden-x2’</p>
<blockquote>
<div><p>威盛Eden X2 CPU,支持x86-64、MMX、SSE、SSE2和SSE3指令集。(该芯片没有实现调度)。</p>
</div></blockquote>
<p>‘eden-x4’</p>
<blockquote>
<div><p>威盛Eden X4 CPU,支持x86-64、MMX、SSE、SSE2、SSE3、SSE3、SSE4.1、SSE4.2、AVX和AVX2指令集。(该芯片没有实现调度)。</p>
</div></blockquote>
<p>‘nano’</p>
<blockquote>
<div><p>通用的威盛Nano CPU,支持x86-64、MMX、SSE、SSE2、SSE3和SSSE3指令集。(该芯片没有实现调度。)</p>
</div></blockquote>
<p>‘nano-1000’</p>
<blockquote>
<div><p>威盛Nano 1xxx CPU,支持x86-64、MMX、SSE、SSE2、SSE3、SSSE3指令集。(该芯片没有实现调度。)</p>
</div></blockquote>
<p>‘nano-2000’</p>
<blockquote>
<div><p>威盛Nano 2xxx CPU,支持x86-64、MMX、SSE、SSE2、SSE3、SSSE3指令集。(该芯片没有实现调度。)</p>
</div></blockquote>
<p>‘nano-3000’</p>
<blockquote>
<div><p>威盛Nano 3xxx CPU,支持x86-64、MMX、SSE、SSE2、SSE3和SSE4.1指令集。(该芯片没有实现调度。)</p>
</div></blockquote>
<p>‘nano-x2’</p>
<blockquote>
<div><p>威盛Nano双核CPU,支持x86-64、MMX、SSE、SSE2、SSE3和SSE4.1指令集。(该芯片没有实现调度。)</p>
</div></blockquote>
<p>‘nano-x4’</p>
<blockquote>
<div><p>威盛Nano四核CPU,支持x86-64、MMX、SSE、SSE2、SSE3和SSE4.1指令集。(该芯片没有实现调度。)</p>
</div></blockquote>
<p>‘geode’</p>
<blockquote>
<div><p>AMD Geode嵌入式处理器,支持MMX和3DNow!指令集。</p>
</div></blockquote>
</div></blockquote>
<p>-mtune=cpu-type</p>
<blockquote>
<div><p>除ABI和可用指令集外，调整到 cpu-type 有关生成代码的所有适用内容。在为特定芯片选择合适的 cpu-type 计划时，编译器不会生成任何无法在默认计算机类型上运行的代码，除非您使用-march=cpu-type选项。例如,如果GCC是为i686-pc-linux-gnu配置的,那么就可以使用-mtune=pentium4生成针对奔腾4的代码,但仍然可以在i686机器上运行。</p>
<p>cpu-type 的选择与for 相同-march。此外，-mtune支持 cpu-type 的 2个额外选择：</p>
<p>‘generic’</p>
<blockquote>
<div><p>制作针对最常见的IA32/AMD64/EM64T处理器优化的代码。如果您知道您的代码将在哪个CPU上运行,那么您应该使用相应的-mtuneor-march选项而不是-mtune=generic。但是，如果您不确切知道应用程序将拥有哪些CPU用户，则应使用此选项。</p>
<p>随着市场上新处理器的部署,这个选项的行为会发生变化。因此,如果您升级到较新的GCC版本,由该选项控制的代码生成将改变,以反映该版本GCC发布时最常见的处理器。</p>
<p>没有-march=generic选择,因为-march表示编译器可以使用的指令集,没有适用于所有处理器的通用指令集。与此相反的是:-mtune表示代码被优化的处理器(或者,在本例中,处理器的集合)。</p>
</div></blockquote>
<p>‘intel’</p>
<blockquote>
<div><p>制作针对最新的英特尔处理器优化的代码,这个版本的GCC是Haswell和Silvermont。如果您知道您的代码将在哪个CPU上运行,那么您应该使用相应的-mtuneor-march选项而不是-mtune=intel。但是，如果您希望您的应用程序在Haswell和Silvermont上都具有更好的性能，则应该使用此选项。</p>
<p>随着市场上新的英特尔处理器的部署,这个选项的行为将发生变化。因此,如果您升级到较新版本的GCC,由该选项控制的代码生成将改变,以反映该版本GCC发布时最新的Intel处理器。</p>
<p>没有-march=intel选择,因为-march表示编译器可以使用的指令集,没有适用于所有处理器的通用指令集。与此相反的是:-mtune表示代码被优化的处理器(或者,在本例中,处理器的集合)。</p>
</div></blockquote>
</div></blockquote>
<p>-mcpu=cpu-type</p>
<blockquote>
<div><p>废弃的同义词-mtune.</p>
</div></blockquote>
<p>-mfpmath=unit</p>
<blockquote>
<div><p>为选定的单位 unit 生成浮点算法。 unit 的选择是：</p>
<p>‘387’</p>
<blockquote>
<div><p>使用标准的387浮点协处理器,大多数芯片上都有,否则会被仿真。用这个选项编译的代码几乎可以在任何地方运行。临时结果以80位精度计算,而不是以类型指定的精度计算,结果与大多数其他芯片相比略有不同。参见-ffloat-store以获得更详细的描述。</p>
<p>这是非Darwin x86-32目标的默认选择。</p>
</div></blockquote>
<p>‘sse’</p>
<blockquote>
<div><p>使用SSE指令集中存在的标量浮点指令。Pentium III及更新的芯片支持该指令集,AMD产品线中的Athlon-4、Athlon XP和Athlon MP芯片也支持该指令集。早期版本的SSE指令集只支持单精度算子,因此双精度和扩展精度算子仍然使用387来完成。后来的版本,只存在于Pentium 4和AMD x86-64芯片中,也支持双精度算术。</p>
<p>对于x86-32编译器,你必须使用-march=cpu-type,-msseor-msse2开关来启用SSE扩展并使这个选项生效。对于x86-64编译器,这些扩展是默认启用的。</p>
<p>由此产生的代码在大多数情况下应该是相当快的,并且避免了387代码的数值不稳定问题,但可能会打破一些现有的代码,这些代码期望时序为80位。</p>
<p>这是x86-64编译器、Darwin x86-32目标的默认选择,也是x86-32目标使用SSE2指令集时的默认选择。-ffast-math启用。</p>
</div></blockquote>
<p>‘sse,387’
‘sse+387’
‘both’</p>
<blockquote>
<div><p>试图同时利用两个指令集。这样可以有效地将可用的寄存器数量增加一倍,在有387和SSE独立执行单元的芯片上,执行资源也会增加一倍。谨慎使用这个选项,因为它还是试验性的,因为GCC寄存器分配器不能很好地模拟单独的功能单元,导致性能不稳定。</p>
</div></blockquote>
</div></blockquote>
<p>-masm=dialect</p>
<blockquote>
<div><p>使用选定的 dialect 输出汇编指令。还影响将哪种方言用于基本 asm （请参阅Basic Asm）和扩展 asm （请参阅Extended Asm）。支持的选项（按方言顺序）是“att’ 要么 ‘intel’。默认值为“att’。达尔文不支持“intel’.</p>
</div></blockquote>
<p>-mieee-fp
-mno-ieee-fp</p>
<blockquote>
<div><p>控制编译器是否使用IEEE浮点比较。这可以正确处理比较结果无序的情况。</p>
</div></blockquote>
<p>-m80387
-mhard-float</p>
<blockquote>
<div><p>生成包含80387条浮点指令的输出。</p>
</div></blockquote>
<p>-mno-80387
-msoft-float</p>
<blockquote>
<div><p>生成包含浮点函数库调用的输出。</p>
<p>警告：必需的库不是GCC的一部分。通常使用机器常用的C编译器的功能，但是不能直接在交叉编译中完成。您必须自行安排以提供合适的库函数以进行交叉编译。</p>
<p>在函数在80387寄存器堆栈中返回浮点结果的机器上,一些浮点运算代码可能会被发出,即使是在-msoft-float是用。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-m<var>no-fp-ret-in-387</var></span></kbd></dt>
<dd><p>不要将FPU寄存器用于函数的返回值。</p>
<p>通常的调用约定在FPU寄存器中具有返回 float 和 double 类型的值的函数，即使没有FPU也是如此。这个想法是操作系统应该模拟FPU。</p>
<p>该选项-mno-fp-ret-in-387导致在普通CPU寄存器中返回这些值。</p>
</dd>
<dt><kbd><span class="option">-m<var>no-fancy-math-387</var></span></kbd></dt>
<dd><p>某些387仿真器不支持387的 sin ， cos 和 sqrt 指令。指定此选项以避免生成那些指令。该选项在以下情况下被覆盖-march表示目标CPU总是有一个FPU,所以该指令不需要仿真。这些指令不会生成,除非您还使用了-funsafe-math-optimizationsswitch.</p>
</dd>
</dl>
<p>-malign-double
-mno-align-double</p>
<blockquote>
<div><p>控制GCC 在两字边界还是一字边界上对齐 double ， long double 和 long long 变量。在两个单词的边界上对齐 double 变量会产生在奔腾上运行速度更快的代码，但会占用更多内存。</p>
<p>在x86-64上。-malign-double默认情况下是启用的。</p>
<p>警告：如果您使用-malign-double开关,包含上述类型的结构与已发布的x86-32的应用程序二进制接口规范的排列方式不同,并且与没有该开关的编译代码中的结构不二进制兼容。</p>
</div></blockquote>
<p>-m96bit-long-double
-m128bit-long-double</p>
<blockquote>
<div><p>这些开关控制 long double 类型的大小。x86-32应用程序二进制接口将大小指定为96位，因此-m96bit-long-double是32位模式下的默认值。</p>
<p>现代体系结构（奔腾和更新的体系结构）更喜欢将 long double 对齐到8字节或16字节的边界。在符合ABI的阵列或结构中，这是不可能的。所以指定-m128bit-long-double对准 long double 到16字节边界通过填充的 long double 用另外的32位零。</p>
<p>在x86-64编译器中。-m128bit-long-double是默认选项，因为它的ABI指定 long double 精度数组在16字节边界上对齐。</p>
<p>请注意，对于 long double ，这两个选项都不能提供超过80位x87标准的任何额外精度。</p>
<p>警告：如果您覆盖目标ABI的默认值，则将更改包含 long double 变量的结构和数组的大小，并修改采用 long double 的函数的函数调用约定。因此，它们与没有该开关的编译代码不二进制兼容。</p>
</div></blockquote>
<p>-mlong-double-64
-mlong-double-80
-mlong-double-128</p>
<blockquote>
<div><p>这些开关控制 long double 类型的大小。64位的大小使 long double 类型等效于 double 类型。这是32位Bionic C库的默认设置。128位的大小使 long double 类型等效于 __float128 类型。这是64位Bionic C库的默认设置。</p>
<p>警告：如果您覆盖目标ABI的默认值，则将更改包含 long double 变量的结构和数组的大小，并修改采用 long double 的函数的函数调用约定。因此，它们与没有该开关的编译代码不二进制兼容。</p>
</div></blockquote>
<p>-malign-data=type</p>
<blockquote>
<div><p>控制GCC如何对齐变量。支持的 type 值为“compat’使用增加的对齐值，兼容使用GCC 4.8和更早的版本，’abi’使用psABI指定的对齐值，并且’cacheline’使用增加的对齐值来匹配缓存行大小。’compat’是默认值。</p>
</div></blockquote>
<p>-mlarge-data-threshold=threshold</p>
<blockquote>
<div><p>When-mcmodel=medium如果指定，则将大于 threshold 数据对象放置在大数据部分中。在链接到二进制文件的所有对象中，此值必须相同，默认值为65535。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-m<var>rtd</var></span></kbd></dt>
<dd><p>使用不同的函数调用约定，在该约定中，带有固定数量参数的函数将通过 ret num 指令返回，该指令会在返回时弹出其参数。由于无需在此处弹出参数，因此在调用方中保存了一条指令。</p>
<p>您可以使用函数属性 stdcall 指定以此调用序列调用单个函数。您也可以覆盖-mrtd通过使用功能属性 cdecl 选择选项。请参阅函数属性。</p>
<p>警告：此调用约定与Unix上通常使用的约定不兼容，因此，如果需要调用使用Unix编译器编译的库，则不能使用它。</p>
<p>同样，您必须为所有带有可变数量参数（包括 printf ）的函数提供函数原型；否则，将为调用这些函数生成错误的代码。</p>
<p>此外,如果你调用一个有太多参数的函数,会导致严重的错误代码。(通常情况下,额外的参数被无害地忽略了。)</p>
</dd>
</dl>
<p>-mregparm=num</p>
<blockquote>
<div><p>控制使用多少个寄存器传递整数参数。默认情况下，不使用任何寄存器来传递参数，并且最多可以使用3个寄存器。您可以使用功能属性 regparm 来控制特定功能的此行为。请参阅函数属性。</p>
<p>警告：如果使用此开关，并且 num 不为零，则必须使用相同的值（包括任何库）构建所有模块。这包括系统库和启动模块。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-m<var>sseregparm</var></span></kbd></dt>
<dd><p>将SSE寄存器传递约定用于float和double参数以及返回值。您可以使用功能属性 sseregparm 来控制特定功能的此行为。请参见函数属性。</p>
<p>警告：如果使用此开关，则必须使用相同的值（包括所有库）构建所有模块。这包括系统库和启动模块。</p>
</dd>
<dt><kbd><span class="option">-m<var>vect8-ret-in-mem</var></span></kbd></dt>
<dd><p>在内存中返回8字节向量，而不是MMX寄存器。这是VxWorks上的默认设置，以匹配Sun Studio编译器的ABI直到版本12。只有在需要与那些以前的编译器版本或较旧版本的GCC生成的现有代码保持兼容时，才使用此选项。</p>
</dd>
</dl>
<p>-mpc32
-mpc64
-mpc80</p>
<blockquote>
<div><p>设置80387浮点精度为32、64或80位。当-mpc32指定了浮点运算,浮点运算结果的意义值四舍五入到24位(单精度)。-mpc64将浮点运算的结果的意义四舍五入到53位(双精度),并对其进行四舍五入。-mpc80将浮点运算结果的意义值四舍五入到64位(扩展双精度),这是默认值。当使用该选项时,如果不明确设置FPU控制字,程序员将无法使用更高精度的浮点运算。</p>
<p>将浮点运算的舍入设置为小于默认的80位可以使某些程序的速度提高2％或更多。请注意，某些数学库假定默认情况下启用了扩展精度（80位）浮点运算。当使用此选项将精度设置为小于扩展精度时，此类库中的例程可能会遭受严重的精度损失，通常是通过所谓的“灾难性取消”。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-m<var>stackrealign</var></span></kbd></dt>
<dd><p>在进入时重新调整堆栈。在x86上,-mstackrealignoption生成备用的序言和结语，必要时可以重新对齐运行时堆栈。这支持将保留4字节堆栈对齐的旧代码与保留16字节堆栈对齐的现代代码混合在一起，以实现SSE兼容性。另请参阅属性 force_align_arg_pointer ，适用于各个功能。</p>
</dd>
</dl>
<p>-mpreferred-stack-boundary=num</p>
<blockquote>
<div><p>尝试使堆栈边界与2对齐，以提高到 num 字节边界。如果-mpreferred-stack-boundary未指定,默认为4(16字节或128位)。</p>
<p>警告：当为禁用了SSE扩展的x86-64体系结构生成代码时，-mpreferred-stack-boundary=3可以用来保持堆栈边界对齐到8字节边界。由于x86-64 ABI要求16字节的堆栈对齐,这与ABI不兼容,并打算在堆栈空间是重要限制的受控环境中使用。当以16字节堆栈对齐方式编译的函数(例如来自标准库的函数)被调用时,这个选项会导致错误的代码。在这种情况下,SSE指令可能会导致错误对齐的内存访问陷阱。此外,对于 16 字节对齐的对象(包括 x87 long double 和 __int128),变量参数会被错误地处理,导致错误的结果。您必须在构建所有模块时使用-mpreferred-stack-boundary=3，包括所有库。这包括系统库和启动模块。</p>
</div></blockquote>
<p>-mincoming-stack-boundary=num</p>
<blockquote>
<div><p>假定传入的堆栈与2对齐到 num 个字节的边界对齐。如果-mincoming-stack-boundary没有指定,由-mpreferred-stack-boundary是用。</p>
<p>在Pentium和Pentium Pro上， double 和 long double 值应与8字节边界对齐（请参见-malign-double）或遭受重大的运行时性能损失。在奔腾III上，如果未按16字节对齐，则流SIMD扩展（SSE）数据类型 __m128 可能无法正常工作。</p>
<p>为了确保堆栈上这个值的正确对齐,堆栈边界必须与存储在堆栈上的任何值所要求的对齐。此外,每个函数的生成都必须使其保持堆栈对齐。因此,从一个以较高的首选堆栈边界编译的函数中调用一个以较低的首选堆栈边界编译的函数,很可能会使堆栈错误对齐。建议使用回调的库始终使用默认设置。</p>
<p>这种额外的对齐方式确实会消耗额外的堆栈空间,并且通常会增加代码大小。对堆栈空间使用敏感的代码,如嵌入式系统和操作系统内核,可能希望将首选对齐方式减少为-mpreferred-stack-boundary=2.</p>
</div></blockquote>
<p>-mmmx
-msse
-msse2
-msse3
-mssse3
-msse4
-msse4a
-msse4.1
-msse4.2
-mavx
-mavx2
-mavx512f
-mavx512pf
-mavx512er
-mavx512cd
-mavx512vl
-mavx512bw
-mavx512dq
-mavx512ifma
-mavx512vbmi
-msha
-maes
-mpclmul
-mclflushopt
-mclwb
-mfsgsbase
-mptwrite
-mrdrnd
-mf16c
-mfma
-mpconfig
-mwbnoinvd
-mfma4
-mprfchw
-mrdpid
-mprefetchwt1
-mrdseed
-msgx
-mxop
-mlwp
-m3dnow
-m3dnowa
-mpopcnt
-mabm
-madx
-mbmi
-mbmi2
-mlzcnt
-mfxsr
-mxsave
-mxsaveopt
-mxsavec
-mxsaves
-mrtm
-mhle
-mtbm
-mmwaitx
-mclzero
-mpku
-mavx512vbmi2
-mavx512bf16
-mgfni
-mvaes
-mwaitpkg
-mvpclmulqdq
-mavx512bitalg
-mmovdiri
-mmovdir64b
-menqcmd
-muintr
-mtsxldtrk
-mavx512vpopcntdq
-mavx512vp2intersect
-mavx5124fmaps
-mavx512vnni
-mavxvnni
-mavx5124vnniw
-mcldemote
-mserialize
-mamx-tile
-mamx-int8
-mamx-bf16
-mhreset
-mkl
-mwidekl</p>
<blockquote>
<div><p>这些开关使MMX、SSE、SSE2、SSE3、SSSE3、SSE4、SSE4A、SSE4.1、SSE4中的指令得以使用。 2,avx,avx2,avx512f,avx512pf,avx512er,avx512cd,avx512vl,avx512bw,avx512dq,avx512ifma,avx512vbmi,sha,aes,pclmul,clflushopt,CLWB,FSGSBASE,PTWRITE,RDRND,F16C,FMA,PCONFIG,WBNOINVD,FMA4,PREFETCHW,RDPID,PREFETCHWT1,RDSEED,SGX,XOP,LWP,3DNow!,enhanced 3DNow! popcnt,abm,adx,bmi,bmi2,lzcnt,fxsr,xsave,xsaveopt,xsavec,xsaves,rtm,hle,tbm,mwaitx,clzero,pku,avx512vbmi2,gfni,vaes,waitpkg,vpclmulqdq,avx512bitalg,movdiri,movdir64b。AVX512BF16,ENQCMD,AVX512VPOPCNTDQ,AVX5124FMAPS,AVX512VNNI,AVX5124VNNIW,SERIALIZE,UINTR,HRESET,AMXTILE,AMXINT8,AMXBF16,KL,WIDEKL,AVXVNNI或CLDEMOTE扩展指令集。每条指令都有一个相应的-mno-选项来禁止使用这些指令。</p>
<p>这些扩展也可以作为内置功能使用：有关这些开关启用和禁用的功能的详细信息，请参见x86内置功能。</p>
<p>要从浮点代码中自动生成SSE/SSE2指令(与387指令相反),请参见-mfpmath=sse.</p>
<p>时,GCC压低SSEx指令。-mavx被使用。相反,当需要时,它为所有SSEx指令生成新的AVX指令或AVX等价。</p>
<p>这些选项使GCC能够在生成的代码中使用这些扩展指令,即使没有-mfpmath=sse。执行运行时CPU检测的应用程序必须使用适当的标志为每种受支持的体系结构编译单独的文件。特别是，包含CPU检测代码的文件应在没有这些选项的情况下进行编译。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-m<var>dump-tune-features</var></span></kbd></dt>
<dd><p>这个选项指示GCC转储x86性能调整特性和默认设置的名称。这些名称可以用在-mtune-ctrl=feature-list.</p>
</dd>
</dl>
<p>-mtune-ctrl=feature-list</p>
<blockquote>
<div><p>此选项用于对x86代码生成功能进行精细控制。 feature-list 是逗号分隔的 feature 名称列表。也可以看看-mdump-tune-features。指定后，如果 feature 前面没有’^’，否则将其关闭。-mtune-ctrl=feature-list是供 GCC 开发者使用的,使用它可能会导致测试没有覆盖到的代码路径,并可能导致编译器的 ICE 或运行时错误。使用它可能会导致测试没有覆盖到的代码路径,并有可能导致编译器ICE或运行时错误。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-m<var>no-default</var></span></kbd></dt>
<dd><p>这个选项指示GCC关闭所有的可调整功能。参见-mtune-ctrl=feature-listand-mdump-tune-features.</p>
</dd>
<dt><kbd><span class="option">-m<var>cld</var></span></kbd></dt>
<dd><p>该选项指示GCC 在使用字符串指令的函数的序言中发出 cld 指令。字符串指令取决于DF标志，以在自动递增或自动递减模式之间进行选择。尽管ABI指定要在函数输入时清除DF标志，但某些操作系统通过不清除其异常分派器中的DF标志来违反此规范。可以使用DF标志集来调用异常处理程序，当使用字符串指令时，这会导致错误的方向模式。默认情况下，可以通过使用以下命令配置GCC在32位x86目标上启用此选项：–enable-cld配置选项。 cld 指令的生成可以通过-mno-cld在这种情况下,编译器选项。</p>
</dd>
<dt><kbd><span class="option">-m<var>vzeroupper</var></span></kbd></dt>
<dd><p>此选项指示GCC 在控制流从该函数移出之前发出 vzeroupper 指令，以最小化AVX到SSE的转换损失并删除不必要的 zeroupper 内部函数。</p>
</dd>
<dt><kbd><span class="option">-m<var>prefer-avx128</var></span></kbd></dt>
<dd><p>这个选项指示GCC在自动矢量化器中使用128位AVX指令而不是256位AVX指令。</p>
</dd>
</dl>
<p>-mprefer-vector-width=opt</p>
<blockquote>
<div><p>该选项指示GCC 在指令中使用 opt -bit向量宽度，而不是所选平台上的默认值。</p>
<p>‘none’</p>
<blockquote>
<div><p>除所选平台定义的限制外,GCC不适用额外的限制。</p>
</div></blockquote>
<p>‘128’</p>
<blockquote>
<div><p>优先选择128位向量宽度的指令。</p>
</div></blockquote>
<p>‘256’</p>
<blockquote>
<div><p>优先选择256位向量宽度的指令。</p>
</div></blockquote>
<p>‘512’</p>
<blockquote>
<div><p>优先选择512位向量宽度的指令。</p>
</div></blockquote>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-m<var>cx16</var></span></kbd></dt>
<dd><p>此选项使GCC能够以64位代码生成 CMPXCHG16B 指令，以对16字节对齐的128位对象实施比较和交换操作。这对于超过一个机器字的数据结构的原子更新很有用。编译器使用此指令来实现__sync Builtins。但是，对于在128位整数上运行的__atomic Builtins，始终使用库调用。</p>
</dd>
<dt><kbd><span class="option">-m<var>sahf</var></span></kbd></dt>
<dd><p>该选项允许以64位代码生成 SAHF 指令。在2005年12月推出Pentium 4 G1步骤之前，支持Intel 64的早期Intel Pentium 4 CPU缺少AMD64支持的 LAHF 和 SAHF 指令。这些分别是某些状态标志的加载和存储指令。在64位模式下， SAHF 指令用于优化 fmod ， drem 和 remainder 内置函数。有关详细信息，请参见其他内置。</p>
</dd>
<dt><kbd><span class="option">-m<var>movbe</var></span></kbd></dt>
<dd><p>通过此选项，可以使用 movbe 指令来实现 __builtin_bswap32 和 __builtin_bswap64 。</p>
</dd>
<dt><kbd><span class="option">-m<var>shstk</var></span></kbd></dt>
<dd><p>The-mshstk选项启用了x86控制流执行技术(CET)的影子堆栈内置功能。</p>
</dd>
<dt><kbd><span class="option">-m<var>crc32</var></span></kbd></dt>
<dd><p>此选项启用内置函数 __builtin_ia32_crc32qi ， __builtin_ia32_crc32hi ， __builtin_ia32_crc32si 和 __builtin_ia32_crc32di 来生成 crc32 机器指令。</p>
</dd>
<dt><kbd><span class="option">-m<var>recip</var></span></kbd></dt>
<dd><p>此选项允许使用的 RCPSS 和 RSQRTSS 指令（以及它们的变体矢量 RCPPS 和 RSQRTPS ）与另外的牛顿-拉夫逊步骤增加精度而不是 DIVSS 和 SQRTSS （以及它们的变体矢量）用于单精度浮点参数。这些指令仅在以下情况下生成-funsafe-math-optimizations启用的同时-ffinite-math-onlyand-fno-trapping-math。请注意，尽管序列的吞吐量高于不可逆指令的吞吐量，但序列的精度最多可降低2 ulp（即1.0的倒数等于0.99999994）。</p>
<p>请注意，GCC 已根据 RSQRTSS （或 RSQRTPS ）实现了 1.0f/sqrtf(x)-ffast-math（或以上选项组合），并且不需要-mrecip.</p>
<p>还要注意的是GCC发射具有用于向量化单浮除法附加牛顿-拉夫逊步骤和矢量上述序列 sqrtf(x) 已经与-ffast-math（或以上选项组合），并且不需要-mrecip.</p>
</dd>
</dl>
<p>-mrecip=opt</p>
<blockquote>
<div><p>此选项控制可以使用哪些相互估计指令。 opt 是以逗号分隔的选项列表，其后可能带有’!’来反转选项：</p>
<p>‘all’</p>
<blockquote>
<div><p>启用所有估算指令。</p>
</div></blockquote>
<p>‘default’</p>
<blockquote>
<div><p>启用默认指令,相当于-mrecip.</p>
</div></blockquote>
<p>‘none’</p>
<blockquote>
<div><p>禁用所有估算指令,相当于-mno-recip.</p>
</div></blockquote>
<p>‘div’</p>
<blockquote>
<div><p>启用标量除法的近似。</p>
</div></blockquote>
<p>‘vec-div’</p>
<blockquote>
<div><p>启用向量化除法的近似值。</p>
</div></blockquote>
<p>‘sqrt’</p>
<blockquote>
<div><p>启用标量平方根的近似。</p>
</div></blockquote>
<p>‘vec-sqrt’</p>
<blockquote>
<div><p>启用向量化平方根的近似。</p>
</div></blockquote>
<p>所以,比如说:-mrecip=all,!sqrt可以实现除平方根以外的所有往复近似。</p>
</div></blockquote>
<p>-mveclibabi=type</p>
<blockquote>
<div><p>指定用于使用外部库向量化内在函数的ABI类型。支持的 type 值为“svml’用于Intel短向量数学库，和’acml’用于AMD数学核心库。要使用此选项，两者-ftree-vectorizeand-funsafe-math-optimizations必须启用,并且在链接时必须指定一个SVML或ACML ABI兼容库。</p>
<p>GCC目前发出的呼吁 vmldExp2 ， vmldLn2 ， vmldLog102 ， vmldPow2 ， vmldTanh2 ， vmldTan2 ， vmldAtan2 ， vmldAtanh2 ， vmldCbrt2 ， vmldSinh2 ， vmldSin2 ， vmldAsinh2 ， vmldAsin2 ， vmldCosh2 ， vmldCos2 ， vmldAcosh2 ， vmldAcos2 ， vmlsExp4 ， vmlsLn4 ， vmlsLog104 ， vmlsPow4 ， vmlsTanh4 ， vmlsTan4 ， vmlsAtan4 ， vmlsAtanh4 ， vmlsCbrt4 ， vmlsSinh4 ， vmlsSin4 ， vmlsAsinh4 ， vmlsAsin4 ， vmlsCosh4 ， vmlsCos4 ， vmlsAcosh4 和 vmlsAcos4 对应函数类型时-mveclibabi=svml被使用，并且 __vrd2_sin ， __vrd2_cos ， __vrd2_exp ， __vrd2_log ， __vrd2_log2 ， __vrd2_log10 ， __vrs4_sinf ， __vrs4_cosf ， __vrs4_expf ， __vrs4_logf ， __vrs4_log2f ， __vrs4_log10f 和 __vrs4_powf 用于相应函数类型时-mveclibabi=acml是用。</p>
</div></blockquote>
<p>-mabi=name</p>
<blockquote>
<div><p>为指定的调用约定生成代码。允许值为“sysv’用于在GNU / Linux和其他系统上使用的ABI，以及’ms对于Microsoft ABI。在所有其他系统上定位Microsoft Windows和SysV ABI时，默认值为使用Microsoft ABI。您可以使用功能属性 ms_abi 和 sysv_abi 来控制特定功能的此行为。请参见函数属性。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-m<var>force-indirect-call</var></span></kbd></dt>
<dd><p>强制所有对函数的调用都是间接的。这在使用英特尔处理器跟踪时非常有用,因为它会为函数调用生成更精确的时序信息。</p>
</dd>
<dt><kbd><span class="option">-m<var>manual-endbr</var></span></kbd></dt>
<dd><p>仅通过 cf_check 函数属性将ENDBR指令插入函数入口。与选项一起使用时，这很有用-fcf-protection=branch来控制ENDBR在功能入口处的插入。</p>
</dd>
<dt><kbd><span class="option">-m<var>call-ms2sysv-xlogues</var></span></kbd></dt>
<dd><p>由于64位ABI的差异,任何调用System V ABI函数的Microsoft ABI函数必须将RSI、RDI和XMM6-15视为clobbered。默认情况下,保存和恢复这些寄存器的代码是内联发射的,导致相当长的序言和尾声。使用-mcall-ms2sysv-xlogues发出序言和尾声,使用libgcc静态部分的存根来执行这些保存和恢复,从而以一些额外的指令为代价来减少函数的大小。</p>
</dd>
</dl>
<p>-mtls-dialect=type</p>
<blockquote>
<div><p>使用’生成代码以访问线程本地存储gnu’ 要么 ‘gnu2的约定。’gnu’是保守的默认值；’gnu2效率更高，但可能会增加无法在所有系统上都满足的编译和运行时要求。</p>
</div></blockquote>
<p>-mpush-args
-mno-push-args</p>
<blockquote>
<div><p>使用PUSH操作来存储输出参数。这种方法与使用SUB/MOV操作的方法相比,时间更短,速度通常同样快,并且默认启用。在某些情况下,由于改进了调度和减少了依赖性,禁用它可以提高性能。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-m<var>accumulate-outgoing-args</var></span></kbd></dt>
<dd><p>如果启用,则在函数prologue中计算出出站参数所需的最大空间。这在大多数现代CPU上速度更快,因为减少了依赖性,改进了调度,当首选堆栈边界不等于2时,减少了堆栈的使用。 缺点是代码大小明显增加。这种切换意味着-mno-push-args.</p>
</dd>
<dt><kbd><span class="option">-m<var>threads</var></span></kbd></dt>
<dd><p>在MinGW上支持线程安全异常处理。依赖于线程安全异常处理的程序必须编译并将所有的代码与线程安全异常处理链接起来。-mthreads选项。编译时。-mthreadsdefines-D_MT; 链接时，它会链接到特殊的线程帮助器库中-lmingwthrd它清理了每个线程的异常处理数据。</p>
</dd>
</dl>
<p>-mms-bitfields
-mno-ms-bitfields</p>
<blockquote>
<div><p>开启/关闭与本地Microsoft Windows编译器兼容的位域布局。</p>
<p>如果在结构上使用 packed 或使用位字段，则可能是Microsoft ABI对结构的布局不同于GCC正常进行的布局。特别是在通过GCC编译的函数和本机Microsoft编译器之间（通过函数调用或作为文件中的数据）在移动打包数据时，可能需要访问这两种格式。</p>
<p>默认情况下，对于Microsoft Windows目标启用此选项。也可以通过使用变量或类型属性在本地控制此行为。有关更多信息，请参见x86变量属性和x86类型属性。</p>
<p>微软的结构布局算法相当简单,除了位场打包。结构成员的填充和排列,以及位域是否可以跨越存储单元边界都是由这些规则决定的。</p>
<blockquote>
<div><p>结构成员按其声明的顺序依次存储:第一个成员的内存地址最低,最后一个成员的内存地址最高。
每个数据对象都有一个对齐要求。除结构，并集和数组以外的所有数据的对齐要求是对象的大小或当前的包装大小（由 aligned 属性或 pack pragma指定），以较小者为准。对于结构，联合和数组，对齐要求是其成员中最大的对齐要求。每个对象都分配有一个偏移量，以便：</p>
<p>offset % alignment_requirement == 0</p>
<p>如果积分类型大小相同,并且下一个位字段适合当前的分配单元,而不越过位字段的共同对齐要求所规定的边界,相邻的位字段就会被装入同一个1、2或4字节的分配单元。</p>
</div></blockquote>
<p>MSVC以下列方式解释零长度位字段。</p>
<blockquote>
<div><p>如果在两个正常聚合的位字段之间插入一个零长度的位字段,则位字段不聚合。</p>
<p>例如:</p>
<dl>
<dt>struct</dt><dd><dl class="simple">
<dt>{</dt><dd><p>unsigned long bf_1 : 12;
unsigned long : 0;
unsigned long bf_2 : 12;</p>
</dd>
</dl>
<p>} t1;</p>
</dd>
</dl>
<p>t1 的大小为8个字节，长度为零。如果删除了零长度位域，则 t1 的大小将为4个字节。
如果将零长度位域插入到位域 foo 之后，并且零长度位域的对齐方式大于其后的成员 bar ， bar ，则将其对齐为零长度的类型。长度位字段。</p>
<p>例如:</p>
<dl>
<dt>struct</dt><dd><dl class="simple">
<dt>{</dt><dd><p>char foo : 4;
short : 0;
char bar;</p>
</dd>
</dl>
<p>} t2;</p>
</dd>
<dt>struct</dt><dd><dl class="simple">
<dt>{</dt><dd><p>char foo : 4;
short : 0;
double bar;</p>
</dd>
</dl>
<p>} t3;</p>
</dd>
</dl>
<p>对于 t2 ， bar 放置在偏移量2处，而不是偏移量1处。因此， t2 的大小为4。对于 t3 ，零长度位域不影响 bar 的对齐，因此不影响bar的大小。结构。</p>
<dl>
<dt>考虑到这一点,必须注意以下几点:</dt><dd><p>如果零长度位域跟随正常位域，则零长度位域的类型可能会影响整个结构的对齐方式。例如， t2 的大小为4个字节，这是因为零长度的位字段跟随普通的位字段，并且类型为short。
即使零长度的位字段后面没有正常的位字段,也可能影响结构的排列。</p>
<dl>
<dt>struct</dt><dd><dl class="simple">
<dt>{</dt><dd><p>char foo : 6;
long : 0;</p>
</dd>
</dl>
<p>} t4;</p>
</dd>
</dl>
<p>在此， t4 占用4个字节。</p>
</dd>
</dl>
<p>非位字段成员后面的零长度位字段会被忽略。</p>
<dl>
<dt>struct</dt><dd><dl class="simple">
<dt>{</dt><dd><p>char foo;
long : 0;
char bar;</p>
</dd>
</dl>
<p>} t5;</p>
</dd>
</dl>
<p>在此， t5 占用2个字节。</p>
</div></blockquote>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-m<var>no-align-stringops</var></span></kbd></dt>
<dd><p>不要对齐内联字符串操作的目标。如果目标已经对齐，则此开关减小了代码大小并提高了性能，但GCC对此一无所知。</p>
</dd>
<dt><kbd><span class="option">-m<var>inline-all-stringops</var></span></kbd></dt>
<dd><p>默认情况下，仅当已知目标与至少4个字节的边界对齐时，GCC才会内联字符串操作。这样可以进行更多的内联并增加代码大小，但可以提高依赖于快速 memcpy 和 memset 的短长度代码的性能。该选项为所有指针对齐启用 strlen 的内联扩展。</p>
</dd>
<dt><kbd><span class="option">-m<var>inline-stringops-dynamically</var></span></kbd></dt>
<dd><p>对于未知大小的字符串操作,使用运行时检查,小块用内联代码,大块用库调用。</p>
</dd>
</dl>
<p>-mstringop-strategy=alg</p>
<blockquote>
<div><p>重写用于内联字符串操作的特定算法的内部决策启发式方法。 alg 的允许值为：</p>
<p>‘rep_byte’
‘rep_4byte’
‘rep_8byte’</p>
<blockquote>
<div><p>使用指定大小的i386 rep 前缀进行扩展。</p>
</div></blockquote>
<p>‘byte_loop’
‘loop’
‘unrolled_loop’</p>
<blockquote>
<div><p>展开成一个内联循环。</p>
</div></blockquote>
<p>‘libcall’</p>
<blockquote>
<div><p>总是使用库调用。</p>
</div></blockquote>
</div></blockquote>
<p>-mmemcpy-strategy=strategy</p>
<blockquote>
<div><p>覆盖内部决策启发式，以决定是否应内联 __builtin_memcpy 以及在知道复制操作的预期大小时使用哪种内联算法。 strategy 是逗号分隔的 alg ： max_size ： dest_align 三胞胎列表。 alg 在-mstringop-strategy， max_size 指定允许使用内联算法 alg 的最大字节大小。对于最后一个三元组， max_size 必须为 -1 。列表中三元组的 max_size 必须按升序指定。为最小字节大小 alg 是 0 为第一三线态和 max_size + 1 前述范围的。</p>
</div></blockquote>
<p>-mmemset-strategy=strategy</p>
<blockquote>
<div><p>该选项类似于-mmemcpy-strategy=除了要控制 __builtin_memset 扩展。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-m<var>omit-leaf-frame-pointer</var></span></kbd></dt>
<dd><p>不要将帧指针保存在用于叶函数的寄存器中。这避免了保存，设置和还原帧指针的说明，并在叶函数中提供了额外的寄存器。选项-fomit-leaf-frame-pointer删除叶子函数的帧指针,这可能会增加调试的难度。</p>
</dd>
</dl>
<p>-mtls-direct-seg-refs
-mno-tls-direct-seg-refs</p>
<blockquote>
<div><p>控制是否可以使用TLS段寄存器的偏移量（32位为 %gs ，64位为 %fs ）来访问TLS变量，或者是否必须添加线程基指针。这是否有效取决于操作系统，以及它是否将段映射为覆盖整个TLS区域。</p>
<p>对于使用GNU C库的系统,默认为开启。</p>
</div></blockquote>
<p>-msse2avx
-mno-sse2avx</p>
<blockquote>
<div><p>指定汇编器应该用VEX前缀编码SSE指令。选项-mavx默认开启。</p>
</div></blockquote>
<p>-mfentry
-mno-fentry</p>
<blockquote>
<div><p>如果剖析处于活动状态 (-pg），将配置计数器调用置于序言之前。注意：在x86架构上， ms_hook_prologue 无法使用ms_hook_prologue属性-mfentryand-pg.</p>
</div></blockquote>
<p>-mrecord-mcount
-mno-record-mcount</p>
<blockquote>
<div><p>如果剖析处于活动状态 (-pg），生成一个__mcount_loc节，其中包含指向每个性能分析调用的指针。这对于自动修补和拨出电话很有用。</p>
</div></blockquote>
<p>-mnop-mcount
-mno-nop-mcount</p>
<blockquote>
<div><p>如果剖析处于活动状态 (-pg），以NOP的形式生成对概要分析函数的调用。当以后应动态修补它们时，这很有用。这可能仅与-mrecord-mcount.</p>
</div></blockquote>
<p>-minstrument-return=type</p>
<blockquote>
<div><p>仪器函数在-pg -mfentry仪器函数中退出，并调用指定函数。这仅会检测以ret结尾的true返回，而不会检测以jump结尾的同级调用。有效类型包括： none ，不生成工具， call 以生成对__return__的调用，或 nop5 生成5字节的nop。</p>
</div></blockquote>
<p>-mrecord-return
-mno-record-return</p>
<blockquote>
<div><p>生成一个指向所有返回工具代码的__return_loc部分。</p>
</div></blockquote>
<p>-mfentry-name=name</p>
<blockquote>
<div><p>设置在-pg -mfentry函数的函数入口处调用的__fentry__符号的名称。</p>
</div></blockquote>
<p>-mfentry-section=name</p>
<blockquote>
<div><p>设置要记录-mrecord-mcount调用的部分名称(默认为__mcount_loc)。</p>
</div></blockquote>
<p>-mskip-rax-setup
-mno-skip-rax-setup</p>
<blockquote>
<div><p>在禁用SSE扩展的情况下生成x86-64架构的代码时。-mskip-rax-setup当向量寄存器中没有传递变量参数时,可以用来跳过设置RAX寄存器。</p>
<p>警告：由于使用RAX寄存器来避免在传递变量参数时将向量寄存器不必要地保存在堆栈上，因此此选项的影响是被调用方可能会浪费一些堆栈空间，行为不当或跳转到随机位置。无论RAX寄存器的值如何，GCC 4.4或更高版本都不会出现这些问题。</p>
</div></blockquote>
<p>-m8bit-idiv
-mno-8bit-idiv</p>
<blockquote>
<div><p>在某些处理器上,比如Intel Atom,8位无符号整数除法比32位/64位整数除法快得多。这个选项会产生一个运行时检查。如果除数和除数都在0到255的范围内,则使用8位无符号整数除法代替32位/64位整数除法。</p>
</div></blockquote>
<p>-mavx256-split-unaligned-load
-mavx256-split-unaligned-store</p>
<blockquote>
<div><p>分割32字节的AVX未对齐加载和存储。</p>
</div></blockquote>
<p>-mstack-protector-guard=guard
-mstack-protector-guard-reg=reg
-mstack-protector-guard-offset=offset</p>
<blockquote>
<div><p>使用canary at guard 生成堆栈保护代码。支持的位置是“global’对于全球金丝雀或’tls’表示TLS块中的每个线程的canary（默认值）。该选项仅在以下情况下有效-fstack-protectoror-fstack-protector-all是指定的。</p>
<p>对于后一种选择,选项-mstack-protector-guard-reg=regand-mstack-protector-guard-offset=offset此外，指定哪个段寄存器（ %fs 或 %gs ）用作读取金丝雀的基本寄存器，以及从该基本寄存器的偏移量开始。这些的默认设置在相关的ABI中指定。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-m<var>general-regs-only</var></span></kbd></dt>
<dd><p>生成只使用通用寄存器的代码。这可以防止编译器使用浮点、向量、掩码和绑定寄存器。</p>
</dd>
</dl>
<p>-mindirect-branch=choice</p>
<blockquote>
<div><p>转换间接调用并按 choice 跳转。默认值为“keep’，这样可以保持间接调用和跳转不变。’thunk’转换间接调用并跳转到调用并返回thunk。’thunk-inline’转换间接调用并跳转到内联调用并返回thunk。’thunk-extern’将间接调用转换为外部调用并跳转到单独的目标文件中提供的thunk。您可以使用功能属性 indirect_branch 来控制特定功能的此行为。请参阅函数属性。</p>
<p>请注意-mcmodel=large不符合-mindirect-branch=thunkand-mindirect-branch=thunk-extern因为在大代码模型中,thunk函数可能无法达到。</p>
<p>请注意-mindirect-branch=thunk-extern可与-fcf-protection=branch因为可以让外部thunk启用控制流检查。</p>
</div></blockquote>
<p>-mfunction-return=choice</p>
<blockquote>
<div><p>用 choice 转换函数返回。默认值为“keep’，使函数返回保持不变。’thunk’将函数return转换为call并返回thunk。’thunk-inline’将函数return转换为内联调用并返回thunk。’thunk-extern’将函数return转换为外部调用，并返回单独对象文件中提供的thunk。您可以使用功能属性 function_return 控制特定功能的此行为。请参见函数属性。</p>
<p>请注意-mindirect-return=thunk-extern可与-fcf-protection=branch因为可以让外部thunk启用控制流检查。</p>
<p>请注意-mcmodel=large不符合-mfunction-return=thunkand-mfunction-return=thunk-extern因为在大代码模型中,thunk函数可能无法达到。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-m<var>indirect-branch-register</var></span></kbd></dt>
<dd><p>通过寄存器强制间接调用和跳转。</p>
</dd>
</dl>
<p>这些“-m在64位环境中的x86-64处理器上，除上述功能外，还支持其他交换机。</p>
<p>-m32
-m64
-mx32
-m16
-miamcu</p>
<blockquote>
<div><p>为16位、32位或64位环境生成代码。该-m32选项将 int ， long 和指针类型设置为32位，并生成可在任何i386系统上运行的代码。</p>
<p>The-m64选项将 int 设置为32位，并将 long 和指针类型设置为64位，并为x86-64体系结构生成代码。对于达尔文而言，-m64选项也关闭了-fno-picand-mdynamic-no-picoptions.</p>
<p>The-mx32选项将 int ， long 和指针类型设置为32位，并为x86-64体系结构生成代码。</p>
<p>The-m16选项与-m32，除了它在汇编输出的开头输出 .code16gcc 汇编指令，以便二进制文件可以在16位模式下运行。</p>
<p>The-miamcu选项可以生成符合英特尔MCU psABI的代码。它需要-m32要开启的选项。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-m<var>no-red-zone</var></span></kbd></dt>
<dd><p>请勿对x86-64代码使用所谓的“红色区域”。红色区域由x86-64 ABI强制；它是堆栈指针位置之外的128字节区域，未被信号或中断处理程序修改，因此可用于临时数据而无需调整堆栈指针。旗-mno-red-zone禁用此红色区域。</p>
</dd>
</dl>
<p>-mcmodel=small</p>
<blockquote>
<div><p>生成小代码模型的代码:程序及其符号必须链接在地址空间的下2GB中。指针为64位。程序可以是静态的,也可以是动态链接的。这是默认的代码模型。</p>
</div></blockquote>
<p>-mcmodel=kernel</p>
<blockquote>
<div><p>生成内核代码模型的代码。内核运行在负2GB的地址空间中。这个模型必须用于Linux内核代码。</p>
</div></blockquote>
<p>-mcmodel=medium</p>
<blockquote>
<div><p>生成中等模型的代码:程序链接在地址空间的下2GB中。小符号也放在那里。符号的大小大于-mlarge-data-threshold被放到大数据或BSS部分,可以位于2GB以上。程序可以是静态或动态链接的。</p>
</div></blockquote>
<p>-mcmodel=large</p>
<blockquote>
<div><p>生成大型模型的代码。该模型不假设地址和部分的大小。</p>
</div></blockquote>
<p>-maddress-mode=long</p>
<blockquote>
<div><p>生成长地址模式的代码。这只支持64位和x32环境。它是64位环境的默认地址模式。</p>
</div></blockquote>
<p>-maddress-mode=short</p>
<blockquote>
<div><p>生成短地址模式的代码。这只支持32位和x32环境。这是32位和x32环境的默认地址模式。</p>
</div></blockquote>
<p>-mneeded
-mno-needed</p>
<blockquote>
<div><p>释放GNU_PROPERTY_X86_ISA_1_NEEDED GNU属性,用于指示执行二进制文件所需的微架构ISA级别。</p>
</div></blockquote>
</div>
</div>
<div class="section" id="id33">
<h2>指定子流程和传递给它们的开关<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h2>
<p>gcc 是一个驱动程序。它通过调用一系列其他程序来完成其工作，以进行编译，组装和链接。GCC解释其命令行参数，并使用这些参数推断应调用的程序以及应在命令行上放置的命令行选项。此行为由规范字符串控制。在大多数情况下，GCC可以为每个程序调用一个规范字符串，但是少数程序具有多个规范字符串来控制其行为。可以使用以下命令覆盖GCC内置的规范字符串-specs=命令行开关来指定一个规范文件。</p>
<p>规格文件是用于构造规格字符串的纯文本文件。它们由用空行分隔的一系列指令组成。指令的类型由该行上的第一个非空白字符决定，该字符可以是下列之一：</p>
<p>%command</p>
<blockquote>
<div><p>向spec文件处理器发出 command 。可以在此处显示的命令是：</p>
<p>%include &lt;file&gt;</p>
<blockquote>
<div><p>搜索 file 并将其文本插入specs文件中的当前位置。</p>
</div></blockquote>
<p>%include_noerr &lt;file&gt;</p>
<blockquote>
<div><p>就像 ‘%include’，但如果找不到包含文件，则不会生成错误消息。</p>
</div></blockquote>
<p>%rename old_name new_name</p>
<blockquote>
<div><p>将规范字符串 old_name 重命名为 new_name 。</p>
</div></blockquote>
</div></blockquote>
<p><a href="#id34"><span class="problematic" id="id35">*</span></a>[spec_name]:</p>
<blockquote>
<div><p>这告诉编译器创建，覆盖或删除命名的规范字符串。该指令之后直到下一个指令的所有行或空白行均被视为规范字符串的文本。如果结果为空字符串，则删除规范。 （或者，如果该规范不存在，那么什么也不会发生。）否则，如果该规范当前不存在，则会创建一个新的规范。如果规范确实存在，则该指令的文本将覆盖其内容，除非该文本的第一个字符为’+’字符，在这种情况下，文字会附加到规范中。</p>
</div></blockquote>
<p>[suffix]:</p>
<blockquote>
<div><p>创建一个新的“[ suffix ]规格对。该指令之后以及下一个指令之前的所有行或空白行均被视为组成指定后缀的规范字符串。当编译器遇到带有命名后缀的输入文件时，它会处理规范字符串，以弄清楚如何编译该文件。例如：</p>
<p>.ZZ:
z-compile -input %i</p>
<p>这表示名称以“。”结尾的任何输入文件.ZZ’应该传递给程序’z-compile’，应使用命令行开关调用-input并执行“%i’ 替代。（见下文。）</p>
<p>作为提供规格字符串的替代方法,后缀指令后面的文本可以是以下内容之一。</p>
<p>&#64;language</p>
<blockquote>
<div><p>这表示后缀是已知 language 的别名。这类似于使用-x命令行切换到GCC,以明确指定一种语言。例如</p>
<p>.ZZ:
&#64;c++</p>
<p>说是.ZZ文件,其实是C++源文件。</p>
</div></blockquote>
<p>#name</p>
<blockquote>
<div><p>这就会导致错误信息说。</p>
<p>name compiler not installed on this system.</p>
</div></blockquote>
<p>GCC已经有一个广泛的后缀列表。这条指令在后缀列表的末尾添加了一个条目,但由于列表是从末尾开始向后搜索的,所以使用这种技术可以有效地覆盖早期条目。</p>
</div></blockquote>
<p>GCC内置了以下规范字符串。规范文件可以覆盖这些字符串或创建自己的字符串。请注意,各个目标也可以将自己的规范字符串添加到这个列表中。</p>
<p>asm          Options to pass to the assembler
asm_final    Options to pass to the assembler post-processor
cpp          Options to pass to the C preprocessor
cc1          Options to pass to the C compiler
cc1plus      Options to pass to the C++ compiler
endfile      Object files to include at the end of the link
link         Options to pass to the linker
lib          Libraries to include on the command line to the linker
libgcc       Decides which GCC support library to pass to the linker
linker       Sets the name of the linker
predefines   Defines to be passed to the C preprocessor
signed_char  Defines to pass to CPP to say whether char is signed</p>
<blockquote>
<div><p>by default</p>
</div></blockquote>
<p>startfile    Object files to include at the start of the link</p>
<p>下面是一个规范文件的小例子。</p>
<p>%rename lib                 old_lib</p>
<p><a href="#id36"><span class="problematic" id="id37">*</span></a>lib:
–start-group -lgcc -lc -leval1 –end-group %(old_lib)</p>
<p>本示例将规范重命名为“lib’ 至 ‘old_lib’，然后覆盖先前的’lib换一个新的。新定义在包含旧定义的文本之前会添加一些额外的命令行选项。</p>
<p>规范字符串是要传递到其相应程序的命令行选项的列表。此外，规范字符串可以包含“%前缀序列，以替换变量文本或有条件地将文本插入命令行。使用这些构造，可以生成非常复杂的命令行。</p>
<p>这是所有已定义的“%’-规范字符串的序列。注意，扩展这些序列的结果不会自动产生空格。因此，您可以将它们连接在一起或在单个参数中将它们与常量文本组合在一起。</p>
<p>%%</p>
<blockquote>
<div><p>替换一个’%’插入程序名称或参数。</p>
</div></blockquote>
<p>%”</p>
<blockquote>
<div><p>代替一个空参数。</p>
</div></blockquote>
<p>%i</p>
<blockquote>
<div><p>代替正在处理的输入文件的名称。</p>
</div></blockquote>
<p>%b</p>
<blockquote>
<div><p>代替与正在处理的输入文件有关的输出的基名。这通常是直到(不包括)最后一个句号的子串,不包括目录,但是,除非%w被激活,否则它扩展到辅助输出的基名,这可能受到明确的输出名称的影响,以及控制辅助输出如何命名的各种其他选项的影响。</p>
</div></blockquote>
<p>%B</p>
<blockquote>
<div><p>这与“%b’，但包括文件后缀（最后一个句点后的文本）。如果没有 %w，它会扩展为转储输出的基本名称。</p>
</div></blockquote>
<p>%d</p>
<blockquote>
<div><p>将参数标记为包含在“%d’作为临时文件名，这样，如果GCC成功退出，该文件将被删除。与“%g’，则不会在参数中添加任何文字。</p>
</div></blockquote>
<p>%gsuffix</p>
<blockquote>
<div><p>替换后缀为 suffix 且每次编译都选择一次的文件名，并以与’%d’。为了减少遭受拒绝服务攻击的风险，现在以难以预测的方式选择文件名，即使已知先前选择的文件名也是如此。例如， ‘％gs…％go…％gs’可能会变成’ccUVUUAU.s ccXYAXZ12.o ccUVUUAU.s’。 suffix 匹配regexp’[.A-Za-z]*’或特殊字符串’%O”，就像对待“%O已被预处理。以前，“%g’只需替换为每次编译一次选择的文件名，而无需考虑任何附加后缀（因此，它像普通文本一样被对待），使得这种攻击更有可能成功。</p>
</div></blockquote>
<p>%usuffix</p>
<blockquote>
<div><p>喜欢 ‘%g”，但每次出现时都会生成一个新的临时文件名，而不是每次编译时都生成一次。</p>
</div></blockquote>
<p>%Usuffix</p>
<blockquote>
<div><p>替换用’生成的最后一个文件名%usuffix’，如果没有最后一个文件名，则生成一个新文件。在没有任何“%usuffix’，就像’%gsuffix’，除非它们不共享相同的后缀空间，所以’％gs…％Us…％gs…％Us’涉及生成两个不同的文件名，每个文件名一个%g.s’和每个’%U.s’。以前，“%U’只是替换为为先前’选择的文件名%u’，不考虑任何后缀。</p>
</div></blockquote>
<p>%jsuffix</p>
<blockquote>
<div><p>替换 HOST_BIT_BUCKET 的名称（如果有），是否可写以及-save-temps未使用; 否则，请替换临时文件的名称，就像“%u’。该临时文件不是用于进程之间的通信，而是一种垃圾处理机制。</p>
</div></blockquote>
<p>%|suffix
%msuffix</p>
<blockquote>
<div><p>喜欢 ‘%g’，除非-pipe有效。在这种情况下 ‘%|’替换单个破折号和’%m’什么也替代不了。这是指示程序从标准输入读取或写入标准输出的两种最常用的方法。如果您需要更详细的说明，可以使用“%{pipe:X}’结构：例如gcc/fortran/lang-specs.h.</p>
</div></blockquote>
<p>%.SUFFIX</p>
<blockquote>
<div><p>匹配的开关的args后缀 .SUFFIX 替换为随后输出的’%*’。 SUFFIX 由下一个空格或％终止。</p>
</div></blockquote>
<p>%w</p>
<blockquote>
<div><p>将参数标记为包含在“%w’作为此编译的指定输出文件。这会将参数放入“%o替代品。</p>
</div></blockquote>
<p>%V</p>
<blockquote>
<div><p>表示这次编译不产生输出文件。</p>
</div></blockquote>
<p>%o</p>
<blockquote>
<div><p>替换所有输出文件的名称，并在它们周围自动放置空格。您应该在“%o以及结果未定义。’%o’用于运行链接程序的规范中。名称没有可识别的后缀的输入文件根本不会编译，但是它们包含在输出文件中，因此它们被链接了。</p>
</div></blockquote>
<p>%O</p>
<blockquote>
<div><p>将后缀替换为目标文件。请注意，当它紧跟在’％g，％u或％U’，因为需要这些文件来形成完整的文件名。处理方式是“%O’就像已被替换一样，除了’％g，％u和％U’当前不支持’之后的其他 suffix 字符%O就像他们遵循的那样，例如，.o’.</p>
</div></blockquote>
<p>%I</p>
<blockquote>
<div><p>用以下任何一种替代-iprefix（由 GCC_EXEC_PREFIX 制造），-isysroot（来自 TARGET_SYSTEM_ROOT ），-isystem（由 COMPILER_PATH 和-B选项)和-imultilib必要时。</p>
</div></blockquote>
<p>%s</p>
<blockquote>
<div><p>当前参数是某个库或某种启动文件的名称。在标准目录列表中搜索该文件,并替换找到的全名。当前工作目录包含在扫描的目录列表中。</p>
</div></blockquote>
<p>%T</p>
<blockquote>
<div><p>当前参数是一个链接器脚本的名称。在当前目录列表中搜索该文件以扫描库。如果该文件被定位,则插入一个–script选项到命令行中,然后是找到的完整路径名。如果没有找到文件,则生成一个错误信息。注意:当前的工作目录不会被搜索到。</p>
</div></blockquote>
<p>%estr</p>
<blockquote>
<div><p>将 str 打印为错误消息。 str 由换行符终止。当检测到不一致的选项时，请使用此选项。</p>
</div></blockquote>
<p>%nstr</p>
<blockquote>
<div><p>打印 str 作为通知。 str 由换行符终止。</p>
</div></blockquote>
<p>%(name)</p>
<blockquote>
<div><p>此时，请替换规范字符串 name 的内容。</p>
</div></blockquote>
<p>%x{option}</p>
<blockquote>
<div><p>累积“%X’.</p>
</div></blockquote>
<p>%X</p>
<blockquote>
<div><p>输出由-Wl或“%x’spec字符串。</p>
</div></blockquote>
<p>%Y</p>
<blockquote>
<div><p>输出由-Wa.</p>
</div></blockquote>
<p>%Z</p>
<blockquote>
<div><p>输出累计的预处理器选项,由-Wp.</p>
</div></blockquote>
<p>%M</p>
<blockquote>
<div><p>Output multilib_os_dir.</p>
</div></blockquote>
<p>%R</p>
<blockquote>
<div><p>输出 target_system_root 和 target_sysroot_suffix 的连接。</p>
</div></blockquote>
<p>%a</p>
<blockquote>
<div><p>处理 asm 规范。这用于计算要传递给汇编器的开关。</p>
</div></blockquote>
<p>%A</p>
<blockquote>
<div><p>处理 asm_final 规范。如果需要这样的程序，这是一个规范字符串，用于将开关传递到汇编器后处理器。</p>
</div></blockquote>
<p>%l</p>
<blockquote>
<div><p>处理 link 规范。这是用于计算传递给链接器的命令行的规范。通常，它使用“％L％G％S％D和％E’序列。</p>
</div></blockquote>
<p>%D</p>
<blockquote>
<div><p>甩出一个-L选项,用于GCC认为可能包含启动文件的每个目录。如果目标机支持多库,那么当前的多库目录会被添加到这些路径中。</p>
</div></blockquote>
<p>%L</p>
<blockquote>
<div><p>处理 lib 规范。这是一个规范字符串，用于确定链接程序的命令行上包括哪些库。</p>
</div></blockquote>
<p>%G</p>
<blockquote>
<div><p>处理 libgcc 规范。这是一个规范字符串，用于确定链接器的命令行上包括哪个GCC支持库。</p>
</div></blockquote>
<p>%S</p>
<blockquote>
<div><p>处理 startfile 规范。这是用来确定哪些对象文件是第一个传递给链接器的规范。通常，这可能是一个名为crt0.o.</p>
</div></blockquote>
<p>%E</p>
<blockquote>
<div><p>处理最终 endfile 规范。这是一个规范字符串，用于指定最后一个传递给链接器的目标文件。</p>
</div></blockquote>
<p>%C</p>
<blockquote>
<div><p>处理 cpp 规范。这用于构造要传递给C预处理程序的参数。</p>
</div></blockquote>
<p>%1</p>
<blockquote>
<div><p>处理 cc1 规范。这用于构造要传递给实际C编译器（ cc1 ）的选项。</p>
</div></blockquote>
<p>%2</p>
<blockquote>
<div><p>处理 cc1plus 规范。这用于构造要传递给实际C ++编译器（ cc1plus ）的选项。</p>
</div></blockquote>
<p>%*</p>
<blockquote>
<div><p>替换匹配期权的变量部分。见下文。请注意,被替换的字符串中的每个逗号都会被一个空格代替。</p>
</div></blockquote>
<p>%&lt;S</p>
<blockquote>
<div><p>从命令行中删除所有出现的 -S 。注意-此命令与位置有关。’%在此字符串之前的规范字符串中的命令请参见 -S ，%’后面的规范字符串中的命令不包含。</p>
</div></blockquote>
<p>%&lt;S*</p>
<blockquote>
<div><p>如同 ‘%&lt;S’，但匹配所有以 -S 开头的开关。</p>
</div></blockquote>
<p>%&gt;S</p>
<blockquote>
<div><p>如同 ‘%&lt;S’，但在 GCC 命令行中保留 -S 。</p>
</div></blockquote>
<p>%:function(args)</p>
<blockquote>
<div><p>调用命名函数 function ，将其传递给 args 。 args 首先作为嵌套的规范字符串处理，然后以通常的方式拆分为参数向量。该函数返回一个字符串，该字符串的处理方式就好像它确实是当前规范的一部分。</p>
<p>提供以下内置的规格函数。</p>
<p>getenv</p>
<blockquote>
<div><p>该 getenv 的规范函数有两个参数：一个环境变量名和一个字符串。如果未定义环境变量，则会发出致命错误。否则，返回值是与字符串连接的环境变量的值。例如，如果 TOPDIR 定义为/path/to/top， 然后：</p>
<p>%:getenv(TOPDIR /include)</p>
<p>扩大到/path/to/top/include.</p>
</div></blockquote>
<p>if-exists</p>
<blockquote>
<div><p>在 if-exists 规范函数有一个参数，绝对路径名的文件。如果文件存在， if-exists 返回路径名。这是其用法的一个小例子：</p>
<p><a href="#id38"><span class="problematic" id="id39">*</span></a>startfile:
crt0%O%s %:if-exists(crti%O%s) crtbegin%O%s</p>
</div></blockquote>
<p>if-exists-else</p>
<blockquote>
<div><p>在 if-exists-else 规格功能类似于 if-exists 规范功能，但它有两个参数。第一个参数是文件的绝对路径名。如果文件存在， if-exists-else 返回路径名。如果不存在，则返回第二个参数。这样， if-exists-else 可以用于根据一个文件的存在来选择一个文件或另一个文件。这是其用法的一个小例子：</p>
<p><a href="#id40"><span class="problematic" id="id41">*</span></a>startfile:
crt0%O%s %:if-exists(crti%O%s) %:if-exists-else(crtbeginT%O%s crtbegin%O%s)</p>
</div></blockquote>
<p>if-exists-then-else</p>
<blockquote>
<div><p>在 if-exists-then-else 规格功能至少需要两个参数，一个可选的第三个。第一个参数是文件的绝对路径名。如果文件存在，函数返回第二个参数。如果文件不存在，则函数返回第三个参数（如果有），否则返回 NULL。这可用于根据文件的存在扩展一个文本或可选的另一个文本。这是其用法的一个小例子：</p>
<p>-l%:if-exists-then-else(%:getenv(VSB_DIR rtnet.h) rtnet net)</p>
</div></blockquote>
<p>sanitize</p>
<blockquote>
<div><p>该 sanitize 方法规范函数没有参数。如果任何地址、线程或未定义的行为清理器处于活动状态，则返回非 NULL。</p>
<p>%{%:sanitize(address):-funwind-tables}</p>
</div></blockquote>
<p>replace-outfile</p>
<blockquote>
<div><p>在 replace-outfile 规范函数有两个参数。它在outfiles数组中查找第一个参数，并将其替换为第二个参数。这是其用法的一个小例子：</p>
<p>%{fgnu-runtime:%:replace-outfile(-lobjc -lobjc-gnu)}</p>
</div></blockquote>
<p>remove-outfile</p>
<blockquote>
<div><p>在 remove-outfile 规范函数有一个参数。它在outfiles数组中查找第一个参数并将其删除。这是其用法的一个小示例：</p>
<p>%:remove-outfile(-lm)</p>
</div></blockquote>
<p>version-compare</p>
<blockquote>
<div><p>该 version-compare 规范函数采用以下形式的四个，五个参数：</p>
<p>&lt;comparison-op&gt; &lt;arg1&gt; [&lt;arg2&gt;] &lt;switch&gt; &lt;result&gt;</p>
<p>如果比较 result 为真，则返回结果，否则返回NULL。支持的 comparison-op 值是：</p>
<p>&gt;=</p>
<blockquote>
<div><p>如果 switch 是比 arg1 更高（或相同）的版本，则为真</p>
</div></blockquote>
<p>!&gt;</p>
<blockquote>
<div><p>与 &gt;= 相反</p>
</div></blockquote>
<p>&lt;</p>
<blockquote>
<div><p>如果 switch 的版本早于 arg1 ,则为真</p>
</div></blockquote>
<p>!&lt;</p>
<blockquote>
<div><p>&lt; 的对面</p>
</div></blockquote>
<p>&gt;&lt;</p>
<blockquote>
<div><p>如果 switch 是 arg1 或更高，并且早于 arg2 ，则为真</p>
</div></blockquote>
<p>&lt;&gt;</p>
<blockquote>
<div><p>如果 switch 早于 arg1 ，或者是 arg2 或更高，则为真</p>
</div></blockquote>
<p>如果根本不存在 switch ，则条件为假，除非 comparison-op 的第一个字符是 ! .</p>
<p>%:version-compare(&gt;= 10.3 mmacosx-version-min= -lmx)</p>
<p>上面的例子将添加-lmxif-mmacosx-version-min=10.3.9was passed.</p>
</div></blockquote>
<p>include</p>
<blockquote>
<div><p>在 include 规范函数表现很像 %include ，具有的优点是，它可以被嵌套在规格内，因而被条件化。它接受一个参数，即文件名，并在起始文件路径中查找它。它总是返回NULL。</p>
<p>%{static-libasan|static:%:include(libsanitizer.spec)%(link_libasan)}</p>
</div></blockquote>
<p>pass-through-libs</p>
<blockquote>
<div><p>该 pass-through-libs 规范函数可以用任何数量的参数。它发现任何-l选项和任何以.a（假定它是链接器输入库档案文件的名称），并返回一个包含所有找到的参数（每个参数都由前缀）的结果-plugin-opt=-pass-through=并以空格连接。这个列表是为了传递给LTO链接器插件。</p>
<p>%:pass-through-libs(%G %L %G)</p>
</div></blockquote>
<p>print-asm-header</p>
<blockquote>
<div><p>在 print-asm-header 功能没有参数，只是打印的一面旗帜，如：</p>
<p>Use “-Wa,OPTION” to pass “OPTION” to the assembler.</p>
<p>它用于分离编译器选项和汇编器选项。–target-helpoutput.</p>
</div></blockquote>
<p>gt</p>
<blockquote>
<div><p>该 gt 规格函数有两个或多个参数。如果倒数第二个参数大于最后一个参数，则返回 “” （空字符串），否则返回 NULL。以下示例插入 link_gomp 规范，如果最后-ftree-parallelize-loops=命令行上的选项大于1。</p>
<p>%{%:gt(%{ftree-parallelize-loops=*:%*} 1):%:include(libgomp.spec)%(link_gomp)}</p>
</div></blockquote>
<p>debug-level-gt</p>
<blockquote>
<div><p>所述 debug-level-gt 规范函数有一个参数，并返回 “” （空字符串）如果 debug_info_level 大于指定的数量更大，并且NULL否则。</p>
<p>%{%:debug-level-gt(0):%{gdwarf*:–gdwarf2}}</p>
</div></blockquote>
</div></blockquote>
<p>%{S}</p>
<blockquote>
<div><p>如果将 -S 开关分配给GCC，则将其替换。如果未指定该开关，则不会替代任何内容。请注意，指定此选项时省略了前划线，如果执行替换，它将自动插入。因此，规范字符串’%{foo}’与命令行选项匹配-foo并输出命令行选项-foo.</p>
</div></blockquote>
<p>%W{S}</p>
<blockquote>
<div><p>与％{ S } 类似，但是将其中提供的最后一个参数标记为要在失败时删除的文件。</p>
</div></blockquote>
<p><a class="reference external" href="mailto:%&#37;&#52;&#48;{S">%<span>&#64;</span>{S</a>}</p>
<blockquote>
<div><p>像 %{ S } 但将结果放入 FILE 并替换 &#64;FILE 如果已提供 &#64;file 参数。</p>
</div></blockquote>
<p>%{S*}</p>
<blockquote>
<div><p>替换所有指定给GCC的开关，这些开关的名称以 -S 开头，但也带有一个参数。这用于像-o,-D,-I等等。GCC认为-o富作为名称以“’o’。％{o <a href="#id42"><span class="problematic" id="id43">*</span></a>}替换此文本，包括空格。这样就产生了两个参数。</p>
</div></blockquote>
<p>%{S*&amp;T*}</p>
<blockquote>
<div><p>与％{ S <em>} 类似，但保留 S 和 T 选项的顺序（规范中 S 和 T 的顺序并不重要）。可以有任意数量的与号分隔的变量；对于每个通配符都是可选的。对于CPP有用为“%{D*&amp;U*&amp;A</em>}’.</p>
</div></blockquote>
<p>%{S:X}</p>
<blockquote>
<div><p>替换 X ，如果-S开关给GCC。</p>
</div></blockquote>
<p>%{!S:X}</p>
<blockquote>
<div><p>替换 X ，如果-S开关未提供给GCC。</p>
</div></blockquote>
<p>%{S*:X}</p>
<blockquote>
<div><p>如果将一个或多个名称以 -S 开头的开关指定给GCC，则用 X 代替。通常，无论出现多少这样的开关， X 只会被替换一次。然而，如果 %* 某处出现在 X ，则 X 是取代一次为每个匹配开关，用 %* 由开关匹配的部分替换 * 。</p>
<p>如果 %* 作为规范序列的最后一部分出现，则在最后一个替换结束之后添加一个空格。但是，如果序列中有更多文本，则不会生成空格。这允许将 %* 替换用作较大字符串的一部分。例如，如下所示的规范字符串：</p>
<p>%{mcu=*:–script=%*/memory.ld}</p>
<p>当匹配一个选项,如-mcu=newchipproduces:</p>
<p class="attribution">—script=newchip/memory.ld</p>
</div></blockquote>
<p>%{.S:X}</p>
<blockquote>
<div><p>替补 X ，如果处理与后缀的文件 S 。</p>
</div></blockquote>
<p>%{!.S:X}</p>
<blockquote>
<div><p>替补 X ，如果不处理与后缀的文件 S 。</p>
</div></blockquote>
<p>%{,S:X}</p>
<blockquote>
<div><p>替补 X ，如果处理语言文件 S 。</p>
</div></blockquote>
<p>%{!,S:X}</p>
<blockquote>
<div><p>替补 X ，如果不处理语言文件 S 。</p>
</div></blockquote>
<p>%{S|P:X}</p>
<blockquote>
<div><p>如果将 -S 或 -P 给GCC，则替换 X 。这可能与“!’，’.’，’,’和 * 序列，尽管它们的结合力比’|’。如果 %* 出现在 X 中，则所有替代项都必须加星号，并且仅替换第一个匹配的替代项。</p>
<p>例如,像这样的规格字符串。</p>
<p>%{.c:-foo} %{!.c:-bar} %{.c|d:-baz} %{!.c|d:-boggle}</p>
<p>从以下输入的命令行选项中输出以下命令行选项。</p>
<p>fred.c        -foo -baz
jim.d         -bar -boggle
-d fred.c     -foo -baz -boggle
-d jim.d      -bar -baz -boggle</p>
</div></blockquote>
<p>%{%:function(args):X}</p>
<blockquote>
<div><p>使用 args args 调用名为 function 的函数。如果函数返回非 NULL，则 X 被替换，如果它返回 NULL，则不会被替换。</p>
</div></blockquote>
<p>%{S:X; T:Y; :D}</p>
<blockquote>
<div><p>如果将 S 赋予GCC，则替换 X ；否则，如果将 T 赋予T，则替换 Y ；其他替代品 D 。您可以根据需要设置任意多个子句。可以与结合使用 . ， , ， ! ， | ，并根据需要添加 * 。</p>
</div></blockquote>
<p>开关匹配’中的文本 S%{S}’，’%{S:X}’或类似的构造可以使用反斜杠来忽略其后字符的特殊含义，从而允许对字符进行字面匹配，否则将对其进行特殊处理。例如， ‘%{std=iso9899:1999:X}’ 如果 X 代替X-std=iso9899:1999给出了选项。</p>
<p>有条件的文字 X 在’%{S:X}’或类似的构造可能包含其他嵌套的’%的结构或空间，甚至是换行符。如上所述，对它们进行常规处理。 X 中的尾随空白将被忽略。在这些结构中，除了之间的空白，空格也可能出现在结肠左侧的任何位置 . 或 * 和相应的单词。</p>
<p>The-O,-f,-m， 和-W开关在这些构造中得到了具体的处理。如果另一个值是-O或否定形式的-f,-m， 或者-W在命令行的后面找到switch，则忽略前面的switch值，除非{ S <a href="#id44"><span class="problematic" id="id45">*</span></a>}，其中 S 只是一个字母，它会传递所有匹配的选项。</p>
<p>人物 ‘<a href="#id46"><span class="problematic" id="id47">|</span></a>谓词文本开头的’用于表示应将命令通过管道传递给以下命令，但仅当-pipe是指定的。</p>
<p>它内置在GCC中，它的开关接受参数，而参数则不接受。（您可能会认为将其通用化以允许每个编译器的规范说出哪些开关接受参数是有用的。但这不能以一致的方式完成。GCC甚至无法在不知道哪些开关接受参数的情况下确定已指定了哪些输入文件，并且必须知道要编译哪个输入文件才能知道要运行哪个编译器。</p>
<p>GCC也隐含地知道,以-l被视为编译器输出文件,并在其他输出文件中的适当位置传递给链接器。</p>
</div>
<div class="section" id="id48">
<h2>影响GCC的环境变量<a class="headerlink" href="#id48" title="Permalink to this headline">¶</a></h2>
<p>本节介绍了影响GCC运行方式的几个环境变量。其中一些环境变量通过指定搜索各种文件时要使用的目录或前缀来工作。有些环境变量用于指定编译环境的其他方面。</p>
<p>需要注意的是,您还可以使用以下选项指定搜索地点,如-B,-Iand-L（请参阅目录选项）。这些优先于使用环境变量指定的位置，而环境变量又优先于 GCC 配置指定的位置。请参阅控制编译驱动程序海湾合作委员会 在 GNU 编译器集合 (GCC) 内部。</p>
<p>LANG
LC_CTYPE
LC_MESSAGES
LC_ALL</p>
<blockquote>
<div><p>这些环境变量控制GCC使用本地化信息的方式，该信息使GCC可以与不同的国家公约一起工作。如果已配置，GCC会检查语言环境类别 LC_CTYPE 和 LC_MESSAGES 。这些语言环境类别可以设置为安装支持的任何值。典型值为en_GB.UTF-8”表示在英国使用UTF-8编码的英语。</p>
<p>该 LC_CTYPE 环境变量指定的字符分类。GCC使用它来确定字符串中的字符边界；对于某些包含引号和转义符的多字节编码，这是必需的，否则它们会被解释为字符串结尾或转义。</p>
<p>该 LC_MESSAGES 环境变量指定的语言来诊断消息中使用。</p>
<p>如果设置了 LC_ALL 环境变量，它将覆盖 LC_CTYPE 和 LC_MESSAGES 的值；否则， LC_CTYPE 和 LC_MESSAGES 默认为 LANG 环境变量的值。如果未设置这些变量，则GCC默认为传统的C英语行为。</p>
</div></blockquote>
<p>TMPDIR</p>
<blockquote>
<div><p>如果设置了 TMPDIR ，它将指定用于临时文件的目录。GCC使用临时文件保存一个编译阶段的输出，该输出将用作下一阶段的输入：例如，预处理器的输出，这是编译器本身的输入。</p>
</div></blockquote>
<p>GCC_COMPARE_DEBUG</p>
<blockquote>
<div><p>设置 GCC_COMPARE_DEBUG 几乎等同于通过-fcompare-debug到编译器驱动程序。更多细节请参见该选项的文档。</p>
</div></blockquote>
<p>GCC_EXEC_PREFIX</p>
<blockquote>
<div><p>如果设置了 GCC_EXEC_PREFIX ，则它指定要在编译器执行的子程序名称中使用的前缀。当该前缀与子程序的名称结合使用时，不会添加任何斜杠，但是如果需要，您可以指定以斜杠结尾的前缀。</p>
<p>如果未设置 GCC_EXEC_PREFIX ，则GCC会根据调用它的路径名尝试找出要使用的适当前缀。</p>
<p>如果GCC不能用指定的前缀找到子程序,它将尝试在通常的地方寻找子程序。</p>
<p>的默认值 GCC_EXEC_PREFIX 是prefix/lib/gcc/其中 prefix 是已安装的编译器的前缀。在许多情况下， prefix 是价值 prefix ，当你跑了configurescript.</p>
<p>指定的其他前缀-B优先于这个前缀。</p>
<p>这个前缀也用于查找文件,如crt0.o用于链接的。</p>
<p>另外，在查找目录以搜索头文件时，前缀以不寻常的方式使用。对于每个名称通常以“’”开头的标准目录/usr/local/lib/gcc’（更确切地说，使用 GCC_INCLUDE_DIR 的值），GCC尝试将其替换为指定的前缀，以产生备用目录名称。因此，-Bfoo/，GCC搜索foo/bar就在它搜索标准目录之前/usr/local/lib/bar。如果标准目录以配置的 prefix 开头，则在查找头文件时， prefix 的值将替换为 GCC_EXEC_PREFIX 。</p>
</div></blockquote>
<p>COMPILER_PATH</p>
<blockquote>
<div><p>COMPILER_PATH 的值是用冒号分隔的目录列表，非常类似于 PATH 。如果无法使用 GCC_EXEC_PREFIX 找到子程序，则GCC会在搜索子程序时尝试指定的目录。</p>
</div></blockquote>
<p>LIBRARY_PATH</p>
<blockquote>
<div><p>LIBRARY_PATH 的值是用冒号分隔的目录列表，非常类似于 PATH 。当配置为本地编译器时，如果无法使用 GCC_EXEC_PREFIX 找到特殊的链接器文件，则GCC会尝试搜索指定的目录。在搜索普通库时，使用GCC链接也会使用这些目录。-l选项(但用-L先来)。)</p>
</div></blockquote>
<p>LANG</p>
<blockquote>
<div><p>此变量用于将语言环境信息传递给编译器。使用此信息的一种方法是确定在C和C ++中解析字符文字，字符串文字和注释时要使用的字符集。将编译器配置为允许多字节字符时，将识别以下 LANG 值：</p>
<p>‘C-JIS’</p>
<blockquote>
<div><p>认识JIS字符。</p>
</div></blockquote>
<p>‘C-SJIS’</p>
<blockquote>
<div><p>认识SJIS字符。</p>
</div></blockquote>
<p>‘C-EUCJP’</p>
<blockquote>
<div><p>认识EUCJP字符。</p>
</div></blockquote>
<p>如果未定义 LANG 或具有其他值，则编译器将使用默认语言环境定义的 mblen 和 mbtowc 来识别和转换多字节字符。</p>
</div></blockquote>
<p>GCC_EXTRA_DIAGNOSTIC_OUTPUT</p>
<blockquote>
<div><p>如果 GCC_EXTRA_DIAGNOSTIC_OUTPUT 设置为以下值之一，则在发出修复提示时将向 stderr 发出附加文本。-fdiagnostics-parseable-fixitsand-fno-diagnostics-parseable-fixits比这个环境变量优先。</p>
<p>‘fixits-v1’</p>
<blockquote>
<div><p>发出可解析的修复提示,相当于-fdiagnostics-parseable-fixits. 特别是，列表示为字节计数，从初始列的字节 1 开始。</p>
</div></blockquote>
<p>‘fixits-v2’</p>
<blockquote>
<div><p>作为 fixits-v1 ，但列表示为显示列，根据-fdiagnostics-column-unit=display.</p>
</div></blockquote>
</div></blockquote>
<p>一些额外的环境变量会影响预处理器的行为。</p>
<p>CPATH
C_INCLUDE_PATH
CPLUS_INCLUDE_PATH
OBJC_INCLUDE_PATH</p>
<blockquote>
<div><p>每个变量的值都是用特殊字符分隔的目录列表，类似于 PATH ，在其中查找头文件。特殊字符 PATH_SEPARATOR 取决于目标，并在GCC构建时确定。对于基于Microsoft Windows的目标，它是一个分号，对于几乎所有其他目标，它是一个冒号。</p>
<p>CPATH 指定要搜索的目录列表，就像用-I，但指定了-I选项的命令行。无论预处理的是哪种语言,都会使用这个环境变量。</p>
<p>其余的环境变量仅在预处理指定的特定语言时适用。每个环境变量都指定了一个要搜索的目录列表,就像用-isystem，但指定了-isystem命令行上的选项。</p>
<p>在所有这些变量中，一个空元素指示编译器搜索其当前工作目录。空元素可以出现在路径的开头或结尾。例如，如果 CPATH 的值为 :/special/include ，则与’ -I.-I/special/include’.</p>
</div></blockquote>
<p>DEPENDENCIES_OUTPUT</p>
<blockquote>
<div><p>如果设置了这个变量,它的值会指定如何根据编译器处理的非系统头文件来输出Make的依赖关系。系统头文件在依赖关系输出中会被忽略。</p>
<p>DEPENDENCIES_OUTPUT 的值可以只是一个文件名，在这种情况下，将Make规则写入该文件，并从源文件名中猜测目标名称。或值可以采用以下形式： filetarget’，在这种情况下，规则将使用 target 作为目标名称写入文件 file 。</p>
<p>换句话说,这个环境变量相当于将选项-MMand-MF（请参阅预处理器选项），以及一个可选的-MT转也。</p>
</div></blockquote>
<p>SUNPRO_DEPENDENCIES</p>
<blockquote>
<div><p>此变量与 DEPENDENCIES_OUTPUT 相同（请参见上文），除了不会忽略系统头文件之外，因此它意味着-M而非-MM。但是，省略了对主输入文件的依赖。请参阅预处理器选项。</p>
</div></blockquote>
<p>SOURCE_DATE_EPOCH</p>
<blockquote>
<div><p>如果设置了此变量，则其值指定一个UNIX时间戳，用于替换 __DATE__ 和 __TIME__ 宏中的当前日期和时间，以便嵌入的时间戳可重现。</p>
<p>SOURCE_DATE_EPOCH 的值必须是 UNIX 时间戳，定义为自 1970 年 1 月 1 日 00:00:00 以来的秒数（不包括闰秒），以 ASCII 表示；与GNU/Linux 和其他支持 date 命令中 %s 扩展名的系统上 date +%s 的输出相同。</p>
<p>这个值应该是一个已知的时间戳,比如源代码或软件包的最后修改时间,它应该由构建过程设置。</p>
</div></blockquote>
</div>
<div class="section" id="id49">
<h2>使用预编译头<a class="headerlink" href="#id49" title="Permalink to this headline">¶</a></h2>
<p>通常，大型项目在每个源文件中都包含许多头文件。编译器一次又一次地处理这些头文件所花费的时间几乎可以占构建项目所需的全部时间。为了使构建更快，GCC允许您预编译头文件。</p>
<p>要创建一个预编译的头文件,只需像编译其他文件一样简单地编译它,必要时使用-x选项，使驱动程序将其视为C或C ++头文件。您可能想要使用诸如 make 之类的工具，以在包含头文件的标头发生更改时保持最新状态。</p>
<p>当在编译中看到 #include 时，将搜索预编译的头文件。当它搜索包含文件时（请参阅C 预处理器中的搜索路径），编译器会在每个目录中查找包含文件之前在该目录中查找预编译头文件。搜索的名称是 #include 中指定的名称，带有 ‘.gch”。如果无法使用预编译的头文件，则将其忽略。</p>
<p>例如，如果您具有 #include “all.h” ，并且您具有all.h.gch在同一目录下all.h，则如果可能，将使用预编译的头文件，否则将使用原始头。</p>
<p>或者,你可以决定将预编译的头文件放在一个目录中,然后使用-I以确保在包含原始头的目录之前（或代替该目录）搜索目录。然后，如果要检查始终使用预编译的头文件，则可以将与原始头文件同名的文件放在该目录中，包含 #error 命令。</p>
<p>这也适用于-include。因此，使用预编译头的另一种方法（它对于没有考虑预编译头文件设计的项目很有用）是简单地获取项目使用的大多数头文件，将其包含在另一个头文件中，对该头文件进行预编译，以及-include预编译的头文件。如果头文件具有防止多次包含的保护措施，则会跳过它们，因为它们已经被包含（在预编译的头中）。</p>
<p>如果需要针对不同的语言，目标或编译器选项预编译相同的头文件，则可以改成名为like 的目录all.h.gch，然后将每个预编译的标头放在目录中，也许使用-o。在目录中调用什么文件都没有关系。考虑目录中的每个预编译头。使用在此编译有效的目录中遇到的第一个预编译标头；他们没有特定的顺序被搜索。</p>
<p>还有很多其他的可能性,只受限于你的想象力、良好的感觉和你的构建系统的限制。</p>
<p>只有当这些条件适用时,才能使用预编译的头文件。</p>
<blockquote>
<div><p>在一个特定的编译中只能使用一个预编译的头。
一旦看到第一个C标记,就不能使用预编译的头。你可以在预编译头之前有预处理器指令;你不能在另一个头里面包含一个预编译头。
预编译的头文件必须与当前编译的语言相同。你不能将C语言的预编译头文件用于C++编译。
预编译的头文件必须与当前编译使用的编译器二进制文件相同。
包含预编译头之前定义的任何宏都必须以与生成预编译头时相同的方式定义，或者必须不影响预编译头，这通常意味着它们根本不会出现在预编译头中。</p>
<p>The-Doption是在包含预编译头之前定义宏的一种方法；使用 #define 也可以做到。还有一些隐式定义宏的选项，例如-Oand-Wdeprecated; 同样的规则适用于以这种方式定义的宏。
如果使用预编译头时输出调试信息,使用-g或类似,在构建预编译的头文件时,必须输出相同的调试信息。然而,一个使用了-g可以在编译中使用,当没有输出调试信息时。
同样的-m在构建和使用预编译头文件时，通常必须使用options。有关放宽此规则的任何情况，请参见“子模型选项”。
在构建和使用预编译头时,以下每个选项必须是相同的。</p>
<p>-fexceptions</p>
<p>其他一些以-f,-p， 或者-O必须以与生成预编译头时相同的方式定义。目前，尚不清楚哪些选项可以安全更改，哪些不可以更改。最安全的选择是在生成和使用预编译的标头时使用完全相同的选项。下列是安全的：</p>
<p>-fmessage-length=  -fpreprocessed  -fsched-interblock
-fsched-spec  -fsched-spec-load  -fsched-spec-load-dangerous
-fsched-verbose=number  -fschedule-insns  -fvisibility=
-pedantic-errors</p>
<p>地址空间布局随机化(ASLR)会导致PCH文件不二进制相同。如果您依赖稳定的PCH文件内容,则在生成PCH文件时禁用ASLR。</p>
</div></blockquote>
<p>对于除最后一个之外的所有这些，如果不满足条件，编译器会自动忽略预编译头。如果您发现一个选项组合不起作用并且不会导致预编译头被忽略，请考虑提交错误报告，请参阅错误。</p>
<p>如果您在生成和使用预编译头时使用了不同的选项,那么实际的行为就是这些选项的混合行为。例如,如果您使用-g来生成预编译头,但在使用它时,你可能会或可能不会得到预编译头中例程的调试信息。</p>
<p>C实现定义的行为</p>
<blockquote>
<div><p>GNU C提供了ISO 标准C中找不到的很多语言特性（”-pedantic”会对这些扩展特性的应用打印警告信息).要在条件编译中测试这些功能的可用性，可以通过测试是否存在宏定义__GNUC__来实现。GCC下会定义这个宏。</p>
</div></blockquote>
<p>我们只关注针对C语言部分。</p>
<p>ISO C99中的某些功能不在C90中的一些功能，GCC会把些特性当作C90模式的扩展进行包含。</p>
</div>
<div class="section" id="id50">
<h2>表达式中的陈述和声明<a class="headerlink" href="#id50" title="Permalink to this headline">¶</a></h2>
<p>括号中的复合语句可能会在GNU C中作为表达式出现。这使您可以在表达式中使用循环，switch和局部变量。</p>
<blockquote>
<div><p>回想一下，复合语句是用大括号括起来的一系列语句； 在此构造中，大括号被括号括起来。 例如：</p>
</div></blockquote>
<div class="literal-block-wrapper docutils container" id="id392">
<div class="code-block-caption"><span class="caption-text">test</span><a class="headerlink" href="#id392" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="p">({</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">foo</span> <span class="p">();</span> <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>    <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>       <span class="k">else</span> <span class="n">z</span> <span class="o">=</span> <span class="o">-</span> <span class="n">y</span><span class="p">;</span>   <span class="n">z</span><span class="p">;</span> <span class="p">})</span>
</pre></div>
</td></tr></table></div>
</div>
<p>对于foo（）的绝对值是一个有效的表达式（尽管比必需的复杂一些）。</p>
<p>复合语句中的最后一件事应该是一个表达式，后跟一个分号； 该子表达式的值用作整个构造的值。 （如果最后在花括号内使用其他类型的语句，则该构造的类型为void，因此实际上没有任何值。）</p>
<p>这种应用方式在保证宏定义的安全性时尤其有用。如以下定义方式：</p>
<div class="literal-block-wrapper docutils container" id="id393">
<div class="code-block-caption"><span class="caption-text">test</span><a class="headerlink" href="#id393" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#define max(a,b) ((a) &gt; (b) ? (a) : (b))</span>
</pre></div>
</td></tr></table></div>
</div>
<p>但是此定义计算a或b两次，如果操作数有副作用，则结果会很差。 在GNU C中，如果您知道操作数的类型（此处为int），则可以通过如下定义宏来避免此问题：</p>
<div class="literal-block-wrapper docutils container" id="id394">
<div class="code-block-caption"><span class="caption-text">test</span><a class="headerlink" href="#id394" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#define maxint(a,b) \        ({int _a = (a), _b = (b); _a &gt; _b ? _a : _b; })</span>
</pre></div>
</td></tr></table></div>
</div>
<p>请注意，引入变量声明（如我们在maxint中所做的那样）可能会导致变量阴影，因此，在使用max宏的此示例中，可以产生正确的结果：</p>
</div>
<div class="section" id="id51">
<h2>本地声明的标签 （通过实验来理解）<a class="headerlink" href="#id51" title="Permalink to this headline">¶</a></h2>
<p>CC允许您在任何嵌套块范围内声明局部标签。 本地标签就像普通标签一样，但是您只能在声明它的块内引用它（使用goto语句，或通过获取其地址）。</p>
<p>本地标签声明如下所示：</p>
<p>本地标签声明必须在任何普通声明或语句之前的块的开头处声明。</p>
<p>标签声明定义标签名称，但不定义标签本身。在语句表达式的语句内使用label：来定义标签。</p>
<p>本地标签功能对于复杂的宏很有用。 如果宏包含嵌套循环，则goto可用于打破它们。 但是，不能使用范围为整个函数的普通标签：如果宏可以在一个函数中扩展多次，则该标签会在该函数中被重复定义。 本地标签可避免此问题。 例如：</p>
<p>局部标签声明还会使它们声明的标签对嵌套函数可见（如果有的话）。</p>
<p>总结：内核中使用了这个功能，基本功能可以理解，为什么必须通过__label__来声明？通常难道不是定义就成了？</p>
</div>
<div class="section" id="id52">
<h2>标签作为值<a class="headerlink" href="#id52" title="Permalink to this headline">¶</a></h2>
<p>可以利用“&amp;&amp;”运算符来获取点给钱函数中定义的一个符号的地址。类型为void <a href="#id53"><span class="problematic" id="id54">*</span></a>。这个值是一个常量，可以在有效范围内使用，如：
.. code-block:: c</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">caption</dt>
<dd class="field-odd"><p>test</p>
</dd>
<dt class="field-even">emphasize-lines</dt>
<dd class="field-even"><p>2</p>
</dd>
<dt class="field-odd">linenos</dt>
<dd class="field-odd"><p></p></dd>
</dl>
<p>void <em>ptr;/</em> … <a href="#id55"><span class="problematic" id="id56">*</span></a>/ptr = &amp;&amp;foo;</p>
</div></blockquote>
<p>在可以跳转到标签的位置使用这个值。这是通过计算得出的goto声明，goto <a href="#id57"><span class="problematic" id="id58">*</span></a>exp;例如：</p>
<div class="literal-block-wrapper docutils container" id="id395">
<div class="code-block-caption"><span class="caption-text">test</span><a class="headerlink" href="#id395" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">goto</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<p>允许使用任何类型为void <a href="#id59"><span class="problematic" id="id60">*</span></a>的表达式。使用这些常量的一种方法是初始化用作跳转表的静态数组：</p>
<div class="literal-block-wrapper docutils container" id="id396">
<div class="code-block-caption"><span class="caption-text">test</span><a class="headerlink" href="#id396" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">array</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">&amp;&amp;</span><span class="n">foo</span><span class="p">,</span><span class="o">&amp;&amp;</span><span class="n">bar</span><span class="p">,</span><span class="o">&amp;&amp;</span><span class="n">hack</span> <span class="p">};</span>
</pre></div>
</td></tr></table></div>
</div>
<p>然后，您可以选择带有索引的标签，如下所示：</p>
<p>goto <a href="#id61"><span class="problematic" id="id62">*</span></a>array[i];</p>
<p>请注意，这不会检查下标是否在边界内— C中的数组索引从不执行此操作。</p>
<p>这样的标签值数组的用途很像switch语句。 switch语句更简洁，因此，除非该问题不能很好地适合switch语句，否则使用它而不是数组。</p>
<p>标签值的另一种用法是在线程代码的解释器中。 解释器功能内的标签可以存储在线程代码中，以进行超快速调度。</p>
<p>您可能不使用此机制来跳转到其他函数中的代码。 如果这样做，则完全会发生不可预测的事情。 避免这种情况的最佳方法是仅将标签地址存储在自动变量中，并且切勿将其作为参数传递。</p>
<p>编写以上示例的另一种方法是 :</p>
<div class="literal-block-wrapper docutils container" id="id397">
<div class="code-block-caption"><span class="caption-text">test</span><a class="headerlink" href="#id397" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">array</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">&amp;&amp;</span><span class="n">foo</span> <span class="o">-</span> <span class="o">&amp;&amp;</span><span class="n">foo</span><span class="p">,</span> <span class="o">&amp;&amp;</span><span class="n">bar</span> <span class="o">-</span> <span class="o">&amp;&amp;</span><span class="n">foo</span><span class="p">,</span><span class="o">&amp;&amp;</span><span class="n">hack</span> <span class="o">-</span> <span class="o">&amp;&amp;</span><span class="n">foo</span> <span class="p">};</span><span class="k">goto</span> <span class="o">*</span><span class="p">(</span><span class="o">&amp;&amp;</span><span class="n">foo</span> <span class="o">+</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</pre></div>
</td></tr></table></div>
</div>
<p>这对于共享库中的代码更友好，因为它减少了所需的动态重定位次数，因此，使数据成为只读数据。 AVR目标不支持带有标签差异的替代方法，请对AVR程序使用第一种方法。 (AVR是什么？)</p>
<p>如果包含函数被内联或克隆，则同一标签的&amp;&amp; foo表达式可能具有不同的值。</p>
<p>如果依靠它们的程序总是相同的 ，__attribute__((__noinline__,__noclone__))用于禁止内联和克隆。如果&amp;&amp;foo在一个静态初始化的变量中，禁止内联和克隆。</p>
<p>注意：这是非常重要的功能，需要进一步理解。</p>
</div>
<div class="section" id="id63">
<h2>嵌套函数<a class="headerlink" href="#id63" title="Permalink to this headline">¶</a></h2>
<p>嵌套函数指在另外一个函数中定义的函数。GNU C中支持，GNU C++不支持。</p>
<p>嵌套函数针对其定义的块是局部的。例如，</p>
<div class="literal-block-wrapper docutils container" id="id398">
<div class="code-block-caption"><span class="caption-text">test</span><a class="headerlink" href="#id398" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">foo</span> <span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">){</span>    <span class="kt">double</span> <span class="nf">square</span> <span class="p">(</span><span class="kt">double</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">z</span> <span class="o">*</span> <span class="n">z</span><span class="p">;</span> <span class="p">}</span>      <span class="k">return</span> <span class="nf">square</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">square</span> <span class="p">(</span><span class="n">b</span><span class="p">);}</span>
</pre></div>
</td></tr></table></div>
</div>
<p>嵌套函数可以访问包含函数的所有变量，这些变量在其定义点可见。 这称为词汇作用域。 例如，这里显示了一个嵌套函数，该函数使用一个名为offset的继承变量：</p>
<div class="literal-block-wrapper docutils container" id="id399">
<div class="code-block-caption"><span class="caption-text">test</span><a class="headerlink" href="#id399" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">bar</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">){</span><span class="kt">int</span> <span class="nf">access</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">){</span> <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">offset</span><span class="p">];</span> <span class="p">}</span><span class="kt">int</span> <span class="n">i</span><span class="p">;</span><span class="cm">/* . . . */</span><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="cm">/* . . . */</span> <span class="n">access</span> <span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="cm">/* . . . */</span><span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<p>在允许变量定义的地方，允许在函数内使用嵌套函数定义； 也就是说，在任何块中，都与该块中的其他声明和语句混合在一起。</p>
<p>可以通过存储嵌套函数的地址或将该地址传递给另一个函数来从其名称范围之外调用嵌套函数：</p>
<div class="literal-block-wrapper docutils container" id="id400">
<div class="code-block-caption"><span class="caption-text">test</span><a class="headerlink" href="#id400" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">hack</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">){</span> <span class="kt">void</span> <span class="nf">store</span> <span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>       <span class="p">{</span> <span class="n">array</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span> <span class="p">}</span>       <span class="n">intermediate</span> <span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">size</span><span class="p">);}</span>
</pre></div>
</td></tr></table></div>
</div>
<p>在此，中间函数接收作为参数的存储地址。 如果存储了中间调用，则用于存储的参数将用于存储到数组中。 但是，只有在不退出包含函数（在此示例中为hack）的情况下，此技术才有效。</p>
<p>如果您尝试在包含函数退出后通过其地址调用嵌套函数，那么所有地狱都将变得松散。 如果您尝试在包含作用域级别退出后调用它，并且它引用了不再属于作用域的某些变量，那么您可能会很幸运，但是冒险是不明智的。 但是，如果嵌套函数未引用超出范围的任何内容，那么您应该是安全的。</p>
<p>GCC使用称为蹦床的技术来实现嵌套函数的地址。 在C ++的词法闭包中对此技术进行了描述（Thomas M. Breuel，USENIX C ++ Conference Proceedings，1988年10月17-21日）。</p>
<p>嵌套函数可以跳转到从包含函数继承的标签，前提是该标签在包含函数中显式声明（请参见第6.2节[局部标签]，第497页）。 这样的跳转立即返回到包含函数，退出执行了goto的嵌套函数以及任何中间函数。 这是一个例子：</p>
<div class="literal-block-wrapper docutils container" id="id401">
<div class="code-block-caption"><span class="caption-text">test</span><a class="headerlink" href="#id401" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">bar</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">){</span>      <span class="n">__label__</span> <span class="n">failure</span><span class="p">;</span>      <span class="kt">int</span> <span class="nf">access</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>      <span class="p">{</span>               <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>                       <span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>           <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">offset</span><span class="p">];</span>   <span class="p">}</span>       <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>  <span class="cm">/* . . . */</span>     <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>      <span class="cm">/* . . . */</span> <span class="n">access</span> <span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="cm">/* . . . */</span>       <span class="cm">/* . . . */</span>     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span><span class="cm">/* Control comes here from access      if it detects an error. */</span><span class="nl">failure</span><span class="p">:</span>      <span class="k">return</span> <span class="mi">-1</span><span class="p">;}</span>
</pre></div>
</td></tr></table></div>
</div>
<p><a href="#id64"><span class="problematic" id="id65">``</span></a><a href="#id66"><span class="problematic" id="id67">`</span></a></p>
<blockquote>
<div><p>嵌套函数始终没有链接。 用extern或static声明一个是错误的。 如果需要在定义嵌套函数之前先声明它，请使用auto（否则对于函数声明是没有意义的）。</p>
</div></blockquote>
<p>总结：了解过，但没有进行深入地理解。</p>
</div>
<div class="section" id="gotos">
<h2>非本地Gotos<a class="headerlink" href="#gotos" title="Permalink to this headline">¶</a></h2>
<p>GCC提供了内置函数__builtin_setjmp和__builtin_longjmp，它们与C库函数setjmp和longjmp类似，但不能互换。 内置版本供GCC的库内部使用，以对某些目标实施异常处理。 您应该在用户代码中使用在&lt;setjmp.h&gt;中声明的标准C库函数，而不要使用内置函数。</p>
<p>这些函数的内置版本使用GCC的常规机制通过函数进入和退出时的堆栈来保存和恢复寄存器。 跳转缓冲区参数buf仅保存恢复堆栈帧所需的信息，而不保存整个保存的寄存器值集。</p>
<p>一个重要的警告是，GCC安排仅保存和恢复正在编译的特定体系结构变体已知的那些寄存器。 在某些情况下，这可以使__builtin_setjmp和__builtin_longjmp效率比其库同类文件更高，但在与使用完整寄存器集的代码混合时，也可能导致不正确和神秘的行为。</p>
<p>您应将内置函数的跳转缓冲区参数buf声明为：</p>
<p>void __builtin_longjmp (intptr t * buf , int val )：内置函数，此函数将buf恢复堆栈上下文，该上下文由先前对__builtin_setjmp的调用保存。 __builtin_longjmp完成后，程序将恢复执行，就像匹配的__builtin_setjmp返回值val一样，该值必须为1。</p>
<p>由于__builtin_longjmp依赖于函数返回机制来还原堆栈上下文，因此无法从调用__builtin_setjmp的同一函数中调用它来初始化buf。 只能从调用__builtin_setjmp的函数直接（或间接）调用的函数中调用它。</p>
<p>总结：这个与jump label应该有关，对我来说也是全新的东西。</p>
</div>
<div class="section" id="id68">
<h2>构造函数调用<a class="headerlink" href="#id68" title="Permalink to this headline">¶</a></h2>
<p>使用下面描述的内置函数，可以在不知道参数的数量或类型的情况下，将参数记录为收到的函数，并使用相同的参数调用另一个函数。</p>
<p>您还可以记录该函数调用的返回值，然后在不知道函数试图返回哪种数据类型的情况下返回该值（只要调用者期望该数据类型）。</p>
<p>但是，这些内置函数可能会与某些复杂的功能或语言的其他扩展发生不良交互。 因此，不建议在非常简单的函数之外仅将其用作参数的转发器使用它们。</p>
<ul class="simple">
<li><p>void * __builtin_apply_args ()：内置函数，此内置函数返回一个指向数据的指针，该数据描述了如何使用传递给当前函数的相同参数进行调用。该函数将arg指针寄存器，结构值地址以及所有可能用于将参数传递给函数的寄存器保存到在堆栈上分配的内存块中。 然后，它返回该块的地址。 该函数将arg指针寄存器，结构值地址以及所有可能用于将参数传递给函数的寄存器保存到在堆栈上分配的内存块中。 然后，它返回该块的地址。</p></li>
<li><p>void * __builtin_apply (void (* function )(), void arguments , size t size )：内置函数。此内置函数使用由参数和大小描述的参数副本来调用函数。参数的值应为__builtin_apply_args返回的值。 参数大小指定堆栈参数数据的大小（以字节为单位）。该函数返回一个指向数据的指针，该数据描述了如何返回函数返回的任何值。 数据保存在堆栈上分配的一块内存中，计算适当的大小值并不总是那么简单。 __builtin_apply使用该值来计算应压入堆栈并从传入参数区域复制的数据量。</p></li>
<li><p>void __builtin_return (void * result )，内置函数。该内置函数返回包含函数的结果描述的值。 对于结果，您应该指定__builtin_apply返回的值。</p></li>
<li><p>__builtin_va_arg_pack ()，内置函数。此内置函数表示内联函数的所有匿名参数。 它只能在始终内联的内联函数中使用，决不能编译为单独的函数，例如使用__attribute__（（__always_inline__））或__attribute__（（__gnu_inline__））外部内联函数的函数。 它只能作为最后一个参数传递给带有可变参数的其他函数。 这对于 使用预处理器宏时，不希望为变量参数函数编写小的包装器内联。 例如：</p></li>
</ul>
<ul class="simple">
<li><p>此内置函数返回内联函数的匿名参数的数量。 它只能在始终内联的内联函数中使用，决不能编译为单独的函数，例如使用、、__attribute__（（__always_inline__））或__attribute__（（__gnu_inline__））外部内联函数的函数。 例如，以下对优化代码的打开参数进行链接或运行时检查： size_t __builtin_va_arg_pack_len ()，内置函数：</p></li>
</ul>
</div>
<div class="section" id="typeoftype">
<h2>用typeof引用Type<a class="headerlink" href="#typeoftype" title="Permalink to this headline">¶</a></h2>
<p>引用表达式类型的另一种方法是使用typeof。 使用此关键字的语法看起来像sizeof，但是该构造在语义上类似于使用typedef定义的类型名称。</p>
<p>有两种方法可以将参数写入typeof：使用表达式或类型。 这是带有表达式的示例：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">typeof</span> <span class="pre">(x[0](1))</span>
<span class="pre">`</span></code></p>
<p>假设x是一个指向函数的指针数组； 所描述的类型是函数值的类型。</p>
<p>这是一个以类型名作为参数的示例：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">typeof</span> <span class="pre">(int</span> <span class="pre">*)</span>
<span class="pre">`</span></code></p>
<p>这里描述的类型是指向int的指针的类型。</p>
<p>如果要编写的标头文件包含在ISO C程序中时必须起作用，请编写__typeof__而不是typeof。 请参阅第6.48节[备用关键字]，第673页。</p>
<p>在可以使用typedef名称的任何地方都可以使用typeof构造。 例如，您可以在声明中，强制类型转换中或在sizeof或typeof内部使用它。</p>
<p>当且仅当它是可变修饰类型的表达式或这种类型的名称时，才对typeof操作数的副作用进行评估。</p>
<p>typeof通常与语句表达式结合使用（请参见第6.1节[Statement Exprs]，第495页）。 这是将两者一起用于定义一个安全的“最大”宏的方法，该宏可在任何算术类型上运行，并且仅对每个参数进行一次赋值：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">#define</span> <span class="pre">max(a,b)</span> <span class="pre">\({</span> <span class="pre">typeof</span> <span class="pre">(a)</span> <span class="pre">_a</span> <span class="pre">=</span> <span class="pre">(a);</span> <span class="pre">\</span>&#160;&#160;&#160;&#160; <span class="pre">typeof</span> <span class="pre">(b)</span> <span class="pre">_b</span> <span class="pre">=</span> <span class="pre">(b);</span> <span class="pre">\_a</span> <span class="pre">&gt;</span> <span class="pre">_b</span> <span class="pre">?</span> <span class="pre">_a</span> <span class="pre">:</span> <span class="pre">_b;</span> <span class="pre">})</span>
<span class="pre">`</span></code></p>
<p>对局部变量使用以下划线开头的名称的原因是为了避免与替换a和b的表达式中出现的变量名称发生冲突。 最终，我们希望设计一种新的声明语法形式，使您可以声明作用域仅在其初始化程序之后才开始的变量。 这将是防止此类冲突的更可靠方法。</p>
<p>使用typeof的更多示例：</p>
<ul>
<li><p>这用x指向的类型声明y。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">typeof</span> <span class="pre">(*x)</span> <span class="pre">y;</span>
<span class="pre">`</span></code></p>
</li>
<li><p>这将y声明为此类值的数组。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">typeof</span> <span class="pre">(*x)</span> <span class="pre">y[4];</span>
<span class="pre">`</span></code></p>
</li>
<li><p>这将y声明为指向字符的指针数组：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">typeof</span> <span class="pre">(typeof</span> <span class="pre">(char</span> <span class="pre">*)[4])</span> <span class="pre">y;</span>
<span class="pre">`</span></code></p>
</li>
</ul>
<p>它等效于以下传统的C声明：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">char</span> <span class="pre">*y[4];</span>
<span class="pre">`</span></code></p>
<p>要查看使用typeof的声明的含义以及为什么它可能是一种有用的编写方法，请使用以下宏将其重写：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">#define</span> <span class="pre">pointer(T)</span> <span class="pre">typeof(T</span> <span class="pre">*)#define</span> <span class="pre">array(T,</span> <span class="pre">N)</span> <span class="pre">typeof(T</span> <span class="pre">[N])</span>
<span class="pre">`</span></code></p>
<p>现在可以用以下方式重写声明：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">array</span> <span class="pre">(pointer</span> <span class="pre">(char),</span> <span class="pre">4)</span> <span class="pre">y;</span>
<span class="pre">`</span></code></p>
<p>因此，array（pointer（char），4）是指向char的4个指针的数组的类型。</p>
<p>在GNU C中，但不是GNU C ++中，您也可以将变量的类型声明为__auto_type。在这种情况下，声明必须仅声明一个变量，其声明符必须只是一个标识符，必须对声明进行初始化，并声明类型 变量的多少由初始化程序确定； 直到初始化之后，变量名才在作用域内。 （在C ++中，您应为此目的使用C ++ 11 auto。）使用__auto_type，上面的“ maximum”宏可以写为：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">#define</span> <span class="pre">max(a,b)</span> <span class="pre">\({</span> <span class="pre">__auto_type</span> <span class="pre">_a</span> <span class="pre">=</span> <span class="pre">(a);</span> <span class="pre">\</span>&#160;&#160;&#160; <span class="pre">__auto_type</span> <span class="pre">_b</span> <span class="pre">=</span> <span class="pre">(b);</span> <span class="pre">\_a</span> <span class="pre">&gt;</span> <span class="pre">_b</span> <span class="pre">?</span> <span class="pre">_a</span> <span class="pre">:</span> <span class="pre">_b;</span> <span class="pre">})</span>
<span class="pre">`</span></code></p>
<p>使用__auto_type代替typeof有两个优点：</p>
<ul class="simple">
<li><p>宏的每个参数在宏的扩展中仅出现一次。 当对此类宏的调用嵌套在此类宏的参数中时，这可以防止宏扩展的大小呈指数增长。</p></li>
<li><p>如果宏的参数具有可变地修改的类型，则在使用__auto_type时，该参数仅求值一次，如果使用typeof，则求值两次。</p></li>
</ul>
<p>总结：这部分了解，但不精通，这次要做到精通的,需要复习一遍。</p>
</div>
<div class="section" id="id69">
<h2>省略操作数的条件<a class="headerlink" href="#id69" title="Permalink to this headline">¶</a></h2>
<p>条件表达式中的中间操作数可以省略。 然后，如果第一个操作数不为零，则其值为条件表达式的值。 因此，表达式：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">x</span> <span class="pre">?</span> <span class="pre">:</span> <span class="pre">y</span>
<span class="pre">`</span></code></p>
<p>如果x的值非零，则为x； 否则，y的值。</p>
<p>这个例子完全等同于</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">x</span> <span class="pre">?</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">y</span>
<span class="pre">`</span></code></p>
<p>在这种简单情况下，忽略中间操作数的功能不是特别有用。 当第一个操作数确实有用或可能（如果它是宏参数）可能包含副作用时，它才变得有用。 然后在中间重复操作数将产生两次副作用。忽略中间操作数将使用已经计算的值，而不会产生重新计算的不良影响。</p>
<p>总结：这个问题不大，重点在总结。</p>
</div>
<div class="section" id="id70">
<h2>命名地址空间<a class="headerlink" href="#id70" title="Permalink to this headline">¶</a></h2>
<p>作为扩展，GNU C支持ISO / IEC DTR 18037的N1275草案中定义的命名地址空间。随着技术报告草案的更改，对GCC中命名地址空间的支持也将不断发展。 任何目标的调用约定也可能会更改。 目前，只有AVR，M32C，RL78和x86目标设备支持通用地址空间以外的地址空间。 地址空间标识符可以与其他任何C类型限定符（例如const或volatile）完全一样地使用。 有关更多详细信息，请参见N1275文档。</p>
<p>总结：</p>
<div class="section" id="x86">
<h3>x86命名地址空间<a class="headerlink" href="#x86" title="Permalink to this headline">¶</a></h3>
<p>在x86目标上，可以将变量声明为相对于％fs或％gs段。</p>
<ul>
<li><p>__seg_fs\__seg_gs:</p>
<p>使用相应的段替代前缀访问该对象。 必须通过特定于操作系统的某种方法来设置相应的段基础。 这些地址空间不被认为是通用（平面）地址空间的子空间，而不是需要昂贵的系统调用来检索段基础。 这意味着需要显式强制转换才能在这些地址空间和通用地址空间之间转换指针。 在实践中，应用程序应转换为uintptr_t并应用其先前安装的段基础偏移量。</p>
<p>当支持这些地址空间时，将定义预处理器符号__SEG_FS和__SEG_GS。</p>
</li>
</ul>
<p>总结：</p>
</div>
</div>
<div class="section" id="id71">
<h2>长度为零的数组<a class="headerlink" href="#id71" title="Permalink to this headline">¶</a></h2>
<p>在GNU C中允许声明零长度数组作为扩展。 零长度数组可以用作结构的最后一个元素，该结构实际上是可变长度对象的标头 :</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">struct</span> <span class="pre">line</span> <span class="pre">{</span>&#160;&#160; <span class="pre">int</span> <span class="pre">length;</span>&#160;&#160;&#160;&#160; <span class="pre">char</span> <span class="pre">contents[0];};struct</span> <span class="pre">line</span> <span class="pre">*thisline</span> <span class="pre">=</span> <span class="pre">(struct</span> <span class="pre">line</span> <span class="pre">*)malloc</span> <span class="pre">(sizeof</span> <span class="pre">(struct</span> <span class="pre">line)</span> <span class="pre">+</span> <span class="pre">this_length);thisline-&gt;length</span> <span class="pre">=</span> <span class="pre">this_length;</span>
<span class="pre">`</span></code></p>
<p>尽管零长度数组的大小为零，但由于尾部填充，这种数组成员可能会增加封闭类型的大小。 零长度数组成员从封闭结构开始的偏移量与具有一个或多个相同类型元素的数组的偏移量相同。 零长度数组的对齐方式与其元素的对齐方式相同。</p>
<p>不建议在其他上下文中声明零长度数组，包括作为结构对象的内部成员或作为非成员对象。 在此类上下文中声明的零长度数组的访问元素是未定义的，可能会被诊断。</p>
<p>在没有零长度数组扩展名的情况下，在ISO C90中，通常将上述示例中的内容数组声明为具有单个元素。 与零长度数组不同，零长度数组仅出于以下目的而有助于封闭结构的大小： 对齐方式时，一个元素数组始终至少占用与该类型的单个对象一样多的空间。 尽管不鼓励使用单元素数组，但GCC类似于零长度数组，处理对尾随一元素数组成员的访问。</p>
<p>声明可变长度类型（如上述结构行）的首选机制是ISO C99灵活数组成员，其语法和语义略有不同：</p>
<ul class="simple">
<li><p>灵活的数组成员写为contents []，不带0。</p></li>
<li><p>灵活数组成员的类型不完整，因此可能不应用sizeof运算符。 作为零长度数组的原始实现的怪癖，sizeof的值为零。</p></li>
<li><p>灵活数组成员只能显示为结构的最后一个成员，否则该结构为非空。</p></li>
<li><p>包含柔性数组成员的结构或包含此类结构的联合（可能是递归的）可能不是结构的成员或数组的元素（但是，GCC允许将这些使用作为扩展。）</p></li>
</ul>
<p>零长度数组的非空初始化的处理方式与初始化器元素多于数组容纳的情况一样，因为会给出有关“数组中多余元素”的适当警告，并且多余元素（所有元素都包含在数组中） 这种情况）将被忽略。</p>
<p>GCC允许对灵活数组成员进行静态初始化。 这等效于定义一个包含原始结构的新结构，后跟一个足够大的数组来容纳数据。 例如。 在下面的代码中，f1的构造就像是像f2一样被声明。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">struct</span> <span class="pre">f1</span> <span class="pre">{</span>&#160;&#160;&#160;&#160; <span class="pre">int</span> <span class="pre">x;</span> <span class="pre">int</span> <span class="pre">y[];}</span> <span class="pre">f1</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">1,</span> <span class="pre">{</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4</span> <span class="pre">}</span> <span class="pre">};struct</span> <span class="pre">f2</span> <span class="pre">{</span>&#160;&#160;&#160; <span class="pre">struct</span> <span class="pre">f1</span> <span class="pre">f1;</span> <span class="pre">int</span> <span class="pre">data[3];}</span> <span class="pre">f2</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">{</span> <span class="pre">1</span> <span class="pre">},</span> <span class="pre">{</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4</span> <span class="pre">}</span> <span class="pre">};</span>
<span class="pre">`</span></code></p>
<p>此扩展的便利之处在于f1具有所需的类型，从而无需始终引用f2.f1。</p>
<p>这与常规静态数组具有对称性，因为未知大小的数组也用[]编写。</p>
<p>当然，仅当额外数据位于顶级对象的末尾时，此扩展才有意义，否则我们将在后续偏移处覆盖数据。 为了避免与深度嵌套数组的初始化造成不必要的复杂化和混乱，我们仅禁止任何非空初始化，除非该结构是顶级对象。 例如：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">struct</span> <span class="pre">foo</span> <span class="pre">{</span> <span class="pre">int</span> <span class="pre">x;</span> <span class="pre">int</span> <span class="pre">y[];</span> <span class="pre">};struct</span> <span class="pre">bar</span> <span class="pre">{</span> <span class="pre">struct</span> <span class="pre">foo</span> <span class="pre">z;</span> <span class="pre">};{struct</span> <span class="pre">foo</span> <span class="pre">a=</span> <span class="pre">{</span> <span class="pre">1,</span> <span class="pre">{2,3,4}};//validstruct</span> <span class="pre">bar</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">{1,{2,3,4}}};</span> <span class="pre">//</span> <span class="pre">Invalidstruct</span> <span class="pre">bar</span> <span class="pre">c</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">{1,{}}};</span> <span class="pre">//Valid.struct</span> <span class="pre">foo</span> <span class="pre">d[1]</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">{1,{2,3,4}}};</span> <span class="pre">//Invalid.</span>
<span class="pre">`</span></code></p>
<p>总结：了解，重点在总结,等待一遍总结。</p>
</div>
<div class="section" id="id72">
<h2>没有成员的结构<a class="headerlink" href="#id72" title="Permalink to this headline">¶</a></h2>
<p>GCC允许C结构没有成员：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">struct</span> <span class="pre">empty</span> <span class="pre">{};</span>
<span class="pre">`</span></code></p>
<p>该结构的大小为零。 在C ++中，空结构是该语言的一部分。 G ++将空结构视为具有char类型的单个成员。</p>
<p>总结：</p>
</div>
<div class="section" id="id73">
<h2>可变长度的数组<a class="headerlink" href="#id73" title="Permalink to this headline">¶</a></h2>
<p>ISO C99允许使用可变长度自动数组，并且作为扩展，GCC在C90模式和C ++中接受它们。 这些数组的声明与其他任何自动数组一样，但是其长度不是常量表达式。 存储在声明时分配，并在包含声明的块作用域退出时释放。 例如：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">FILE</span> <span class="pre">*concat_fopen</span> <span class="pre">(char</span> <span class="pre">*s1,</span> <span class="pre">char</span> <span class="pre">*s2,</span> <span class="pre">char</span> <span class="pre">*mode){</span>&#160;&#160;&#160; <span class="pre">char</span> <span class="pre">str[strlen</span> <span class="pre">(s1)</span> <span class="pre">+</span> <span class="pre">strlen</span> <span class="pre">(s2)</span> <span class="pre">+</span> <span class="pre">1];</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">strcpy</span> <span class="pre">(str,</span> <span class="pre">s1);</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">strcat</span> <span class="pre">(str,</span> <span class="pre">s2);</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">return</span> <span class="pre">fopen</span> <span class="pre">(str,</span> <span class="pre">mode);}</span>
<span class="pre">`</span></code></p>
<p>跳出或超出阵列名称范围会取消分配存储空间。 不允许跳入范围； 您会收到一条错误消息。 作为扩展，GCC接受可变长度数组作为结构或联合的成员。 例如：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">voidfoo</span> <span class="pre">(int</span> <span class="pre">n){</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">struct</span> <span class="pre">S</span> <span class="pre">{</span> <span class="pre">int</span> <span class="pre">x[n];</span> <span class="pre">};}</span>
<span class="pre">`</span></code></p>
<p>您可以使用alloca函数来获得类似于可变长度数组的效果。 alloca函数可在许多其他C实现中使用（但不是全部）。 另一方面，可变长度数组更优雅。</p>
<p>这两种方法之间还有其他差异。 用alloca分配的空间一直存在，直到包含函数返回为止。 数组名称的作用域结束时，将立即释放可变长度数组的空间，除非您也在该作用域中使用alloca。</p>
<p>您还可以将可变长度数组用作函数的参数：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">struct</span> <span class="pre">entrytester</span> <span class="pre">(int</span> <span class="pre">len,</span> <span class="pre">char</span> <span class="pre">data[len][len]){/*</span> <span class="pre">.</span> <span class="pre">.</span> <span class="pre">.</span> <span class="pre">*/}</span>
<span class="pre">`</span></code></p>
<p>分配存储空间后，数组的长度将被计算一次，并记住该数组的范围，以防您使用sizeof访问它。</p>
<p>如果要先传递数组，然后传递长度，则可以在参数列表中使用前向声明（另一个GNU扩展名）。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">struct</span> <span class="pre">entrytester</span> <span class="pre">(int</span> <span class="pre">len;</span> <span class="pre">char</span> <span class="pre">data[len][len],</span> <span class="pre">int</span> <span class="pre">len){/*</span> <span class="pre">.</span> <span class="pre">.</span> <span class="pre">.</span> <span class="pre">*/}</span>
<span class="pre">`</span></code></p>
<p>分号前的“ int len”是参数前向声明，它的作用是在解析数据声明时使len成为已知名称。</p>
<p>您可以在参数列表中编写任意数量的此类参数前向声明。它们可以用逗号或分号分隔，但最后一个必须以分号结尾，后跟“真实”参数声明。 每个前向声明必须与参数名称和数据类型中的“真实”声明匹配。 ISO C99不支持参数转发声明。</p>
<p>总结：需要回头看一遍</p>
</div>
<div class="section" id="id74">
<h2>参数可变的宏<a class="headerlink" href="#id74" title="Permalink to this headline">¶</a></h2>
<p>在1999年的ISO C标准中，可以声明宏以接受可变数量的参数，就像函数可以接受的那样。 定义宏的语法与函数的语法相似。 这是一个例子：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">#define</span> <span class="pre">debug(format,</span> <span class="pre">...)</span> <span class="pre">fprintf</span> <span class="pre">(stderr,</span> <span class="pre">format,</span> <span class="pre">__VA_ARGS__)</span>
<span class="pre">`</span></code></p>
<p>这里的“ …”是一个可变参数。 在此类宏的调用中，它表示零个或多个令牌，直到结束括号的调用结束为止，包括任何逗号。 这组标记将替换宏正文中出现的标识符__VA_ARGS__。 有关更多信息，请参见CPP手册。</p>
<p>GCC长期以来支持可变参数宏，并使用了不同的语法，使您可以像其他任何参数一样为变量参数命名。 这是一个例子：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">#define</span> <span class="pre">debug(format,</span> <span class="pre">args...)</span> <span class="pre">fprintf</span> <span class="pre">(stderr,</span> <span class="pre">format,</span> <span class="pre">args)</span>
<span class="pre">`</span></code></p>
<p>这在所有方面都等同于上面的ISO C示例，但是可以说更具可读性和描述性。</p>
<p>GNU CPP还有另外两个可变的宏扩展，并允许它们与以上两种形式的宏定义一起使用。</p>
<p>在标准C中，不允许您完全省略变量参数。 但是您可以传递一个空参数。 例如，此调用在ISO C中是无效的，因为在字符串后没有逗号：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">debug</span> <span class="pre">(&quot;A</span> <span class="pre">message&quot;)</span>
<span class="pre">`</span></code></p>
<p>GNU CPP允许您以这种方式完全省略变量参数。 在上面的示例中，编译器会抱怨，尽管由于宏的扩展在格式字符串之后仍带有多余的逗号。</p>
<p>为了帮助解决此问题，CPP专门用于与令牌粘贴运算符“ ##”一起使用的变量参数。 相反，如果你写</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">#define</span> <span class="pre">debug(format,</span> <span class="pre">...)</span> <span class="pre">fprintf</span> <span class="pre">(stderr,</span> <span class="pre">format,</span> <span class="pre">##</span> <span class="pre">__VA_ARGS__)</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><p>并且如果变量参数省略或为空，则’##’运算符使预处理器删除逗号之前的逗号。 如果确实在宏调用中提供了一些可变参数，则GNU CPP不会抱怨粘贴操作，而是将可变参数放在逗号之后。 与其他粘贴的宏参数一样，这些参数也不是宏扩展的。</p>
</div></blockquote>
<p>总结：这个需要，理解上一直有偏差。</p>
</div>
<div class="section" id="id75">
<h2>转义换行符的较宽松规则<a class="headerlink" href="#id75" title="Permalink to this headline">¶</a></h2>
<p>与C90标准所指定的相比，转义的换行符对预处理程序的处理更为宽松，C90标准要求换行符立即跟随反斜杠。 GCC的实现允许以空格，水平和垂直制表符的形式出现空格，并在反斜杠和后续换行符之间形成换页。 预处理器发出警告，但将其视为有效的转义换行符，并将这两行合并以形成一条逻辑行。 这适用于注释和标记以及标记之间。 出于放松目的，注释不被视为空格，因为它们尚未被空格代替。</p>
<p>总结：</p>
</div>
<div class="section" id="non-lvalue">
<h2>Non-Lvalue 数组可能带有下标<a class="headerlink" href="#non-lvalue" title="Permalink to this headline">¶</a></h2>
<p>在ISO C99中，不是左值的数组仍然会衰减到指针，并且可以被下标，尽管在下一个序列点之后它们可能不会被修改或使用，并且一进制’＆’运算符可能不会应用于它们。 作为扩展，GNU C允许在C90模式下对此类数组进行下标，尽管否则它们不会衰减到C99模式之外的指针。 例如，这在GNU C中有效，但在C90中无效：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">struct</span> <span class="pre">foo</span> <span class="pre">{int</span> <span class="pre">a[4];};struct</span> <span class="pre">foo</span> <span class="pre">f();bar</span> <span class="pre">(int</span> <span class="pre">index){</span>&#160; <span class="pre">return</span> <span class="pre">f().a[index];}</span>
<span class="pre">`</span></code></p>
<p>总结：</p>
</div>
<div class="section" id="id76">
<h2>无效指针和函数指针的算法<a class="headerlink" href="#id76" title="Permalink to this headline">¶</a></h2>
<p>在GNU C中，指向void的指针和指向函数的指针支持加法和减法运算。 这是通过将void或函数的大小视为1来完成的。</p>
<p>这样的结果是在void和函数类型上还允许sizeof，并返回1。</p>
<p>如果使用了这些扩展名，则选项-Wpointer-arith会发出警告。</p>
<p>总结：</p>
</div>
<div class="section" id="id77">
<h2>可变参数函数中的指针参数<a class="headerlink" href="#id77" title="Permalink to this headline">¶</a></h2>
<p>标准C要求具有可变参数列表的函数中与va_arg一起使用的指针类型必须与实际参数的指针类型兼容，或者一种类型必须是指向void的指针，而另一种必须是指向字符类型的指针。 GNU C实现了POSIX XSI扩展，该扩展另外允许使用带有指针类型的va_arg来接收任何其他指针类型的参数。</p>
<p>特别是在GNU C中，可以安全地使用“ va_arg（ap，void <a href="#id78"><span class="problematic" id="id79">*</span></a>）”来使用任何指针类型的参数。</p>
<p>总结：重要</p>
</div>
<div class="section" id="id80">
<h2>带有限定符的数组的指针按预期工作<a class="headerlink" href="#id80" title="Permalink to this headline">¶</a></h2>
<p>在GNU C中，指向带有限定符的数组的指针的工作方式类似于指向其他限定类型的指针。 例如，可以使用类型为int（*）[5]的值来初始化类型为const int（*）[5]的变量。 这些类型在ISO C中不兼容，因为const限定符正式附加到数组的元素类型，而不是数组本身。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">extern</span> <span class="pre">voidtranspose</span> <span class="pre">(int</span> <span class="pre">N,</span> <span class="pre">int</span> <span class="pre">M,</span> <span class="pre">double</span> <span class="pre">out[M][N],</span> <span class="pre">const</span> <span class="pre">double</span> <span class="pre">in[N][M]);double</span> <span class="pre">x[3][2];double</span> <span class="pre">y[2][3];...transpose(3,</span> <span class="pre">2,</span> <span class="pre">y,</span> <span class="pre">x);</span>
<span class="pre">`</span></code></p>
<p>总结：</p>
</div>
<div class="section" id="id81">
<h2>非常数初始化器<a class="headerlink" href="#id81" title="Permalink to this headline">¶</a></h2>
<p>像在标准C ++和ISO C99中一样，自动变量的聚合初始化程序的元素在GNU C中不需要是常量表达式。这是带有运行时可变元素的初始化程序的示例：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">foo</span> <span class="pre">(float</span> <span class="pre">f,</span> <span class="pre">float</span> <span class="pre">g){</span> <span class="pre">float</span> <span class="pre">beat_freqs[2]</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">f-g,</span> <span class="pre">f+g</span> <span class="pre">};</span>&#160;&#160;&#160;&#160; <span class="pre">/*</span> <span class="pre">.</span> <span class="pre">.</span> <span class="pre">.</span> <span class="pre">*/}</span>
<span class="pre">`</span></code></p>
<p>总结：</p>
</div>
<div class="section" id="id82">
<h2>复合字面量<a class="headerlink" href="#id82" title="Permalink to this headline">¶</a></h2>
<p>复合文字看起来像是用括号括起来的聚合初始化程序列表的强制转换。 它的值是强制类型转换中指定类型的对象，其中包含初始化程序中指定的元素。</p>
<p>与强制转换的结果不同，复合文字是左值。 ISO C99和更高版本支持复合文字。 作为扩展，GCC在C90模式和C ++中也支持复合文字，尽管如下所述，C ++语义有所不同。</p>
<p>通常，复合文字的指定类型是结构。 假设如下所示声明了struct foo和structure：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">struct</span> <span class="pre">foo</span> <span class="pre">{int</span> <span class="pre">a;</span> <span class="pre">char</span> <span class="pre">b[2];}</span> <span class="pre">structure;</span>
<span class="pre">`</span></code></p>
<p>这是使用复合文字构造struct foo的示例：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">structure</span> <span class="pre">=</span> <span class="pre">((struct</span> <span class="pre">foo)</span> <span class="pre">{x</span> <span class="pre">+</span> <span class="pre">y,</span> <span class="pre">’a’,</span> <span class="pre">0});</span>
<span class="pre">`</span></code></p>
<p>这等效于编写以下内容：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">{</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">struct</span> <span class="pre">foo</span> <span class="pre">temp</span> <span class="pre">=</span> <span class="pre">{x</span> <span class="pre">+</span> <span class="pre">y,</span> <span class="pre">’a’,</span> <span class="pre">0};</span>&#160;&#160;&#160;&#160;&#160; <span class="pre">structure</span> <span class="pre">=</span> <span class="pre">temp;}</span>
<span class="pre">`</span></code></p>
<p>您也可以构造一个数组，尽管这在C ++中很危险，如下所述。如果复合文字的所有元素都是（由）简单常量表达式组成的，这些常量表达式适用于静态存储持续时间的对象的初始化程序，则复合 文字可以被强制指向其第一个元素的指针，并可以在这样的初始化程序中使用，如下所示：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">char</span> <span class="pre">**foo</span> <span class="pre">=</span> <span class="pre">(char</span> <span class="pre">*[])</span> <span class="pre">{</span> <span class="pre">&quot;x&quot;,</span> <span class="pre">&quot;y&quot;,</span> <span class="pre">&quot;z&quot;</span> <span class="pre">};</span>
<span class="pre">`</span></code></p>
<p>标量类型和联合类型的复合文字也被允许。 在下面的示例中，变量i初始化为值2，该值是由复合文字创建的未命名对象递增的结果。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">int</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">++(int)</span> <span class="pre">{</span> <span class="pre">1</span> <span class="pre">};</span>
<span class="pre">`</span></code></p>
<p>作为GNU扩展，GCC允许通过复合文字初始化具有静态存储持续时间的对象（在ISO C99中是不可能的，因为初始化器不是常数）。 如果复合文字和对象的类型匹配，则如同仅使用括号括起来的列表初始化对象一样处理该对象。 复合文字的元素必须是常量。 如果要初始化的对象具有未知大小的数组类型，则该大小由复合文字的大小确定。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">static</span> <span class="pre">struct</span> <span class="pre">foo</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">(struct</span> <span class="pre">foo)</span> <span class="pre">{1,</span> <span class="pre">’a’,</span> <span class="pre">’b’};static</span> <span class="pre">int</span> <span class="pre">y[]</span> <span class="pre">=</span> <span class="pre">(int</span> <span class="pre">[])</span> <span class="pre">{1,</span> <span class="pre">2,</span> <span class="pre">3};static</span> <span class="pre">int</span> <span class="pre">z[]</span> <span class="pre">=</span> <span class="pre">(int</span> <span class="pre">[3])</span> <span class="pre">{1};</span>
<span class="pre">`</span></code></p>
<p>以上各行等效于以下内容：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">static</span> <span class="pre">struct</span> <span class="pre">foo</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">{1,</span> <span class="pre">’a’,</span> <span class="pre">’b’};static</span> <span class="pre">int</span> <span class="pre">y[]</span> <span class="pre">=</span> <span class="pre">{1,</span> <span class="pre">2,</span> <span class="pre">3};static</span> <span class="pre">int</span> <span class="pre">z[]</span> <span class="pre">=</span> <span class="pre">{1,</span> <span class="pre">0,</span> <span class="pre">0};</span>
<span class="pre">`</span></code></p>
<p>在C中，复合文字表示具有静态或自动存储持续时间的未命名对象。 在C ++中，复合文字表示一个临时对象，该对象仅在其完整表达式结束之前一直存在。 结果，可以在C ++中未定义定义良好的C代码（采用复合文字的子对象的地址），因此G ++拒绝将临时数组转换为指针。 例如，如果上面的数组复合文字示例出现在函数内部，则C ++中对foo的任何后续使用都将具有未定义的行为，因为数组的生存期在声明foo之后结束。</p>
<p>作为一种优化，G ++有时会给数组复合文字提供更长的生存期：当数组出现在函数外部或具有const限定类型时。 如果foo及其初始化程序的元素类型为char * const而不是char <a href="#id83"><span class="problematic" id="id84">*</span></a>，或者foo为全局变量，则该数组将具有静态存储持续时间。 但是，仅避免在C ++代码中使用数组复合文字可能是最安全的。</p>
<p>总结：</p>
</div>
<div class="section" id="id85">
<h2>指定的初始化程序<a class="headerlink" href="#id85" title="Permalink to this headline">¶</a></h2>
<p>标准C90要求初始化程序的元素以固定的顺序出现，与要初始化的数组或结构中的元素的顺序相同。</p>
<p>在ISO C99中，您可以按任何顺序指定元素，指定它们要应用的数组索引或结构字段名称，GNU C也允许它作为C90模式的扩展。此扩展在GNU C ++中未实现。</p>
<p>要指定数组索引，请在元素值前写“ [index] =”。 例如，</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">int</span> <span class="pre">a[6]</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">[4]</span> <span class="pre">=</span> <span class="pre">29,</span> <span class="pre">[2]</span> <span class="pre">=</span> <span class="pre">15</span> <span class="pre">};</span>
<span class="pre">`</span></code></p>
<p>相当于</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">int</span> <span class="pre">a[6]</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">15,</span> <span class="pre">0,</span> <span class="pre">29,</span> <span class="pre">0</span> <span class="pre">};</span>
<span class="pre">`</span></code></p>
<p>即使正在初始化的数组是自动的，索引值也必须是常量表达式。</p>
<p>自GCC 2.5起，此方法的一种替代语法已过时，但GCC仍接受，该语法是在元素值之前写入“ [index]”，而不能包含“ =”。</p>
<p>要将一系列元素初始化为相同的值，请写成[[first … last] = value”。这是GNU扩展名。 例如，</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">int</span> <span class="pre">widths[]</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">[0</span> <span class="pre">...</span> <span class="pre">9]</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">[10</span> <span class="pre">...</span> <span class="pre">99]</span> <span class="pre">=</span> <span class="pre">2,</span> <span class="pre">[100]</span> <span class="pre">=</span> <span class="pre">3</span> <span class="pre">};</span>
<span class="pre">`</span></code></p>
<p>如果其中的值具有副作用，则该副作用仅发生一次，而不是范围初始化程序的每个初始化字段都发生。</p>
<p>请注意，数组的长度是指定的最大值加一。</p>
<p>在结构初始化程序中，指定要在元素值之前使用“ .fieldname =”进行初始化的字段的名称。 例如，给定以下结构，</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">struct</span> <span class="pre">point</span> <span class="pre">{</span> <span class="pre">int</span> <span class="pre">x,</span> <span class="pre">y;</span> <span class="pre">};</span>
<span class="pre">`</span></code></p>
<p>以下初始化</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">struct</span> <span class="pre">point</span> <span class="pre">p</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">.y</span> <span class="pre">=</span> <span class="pre">yvalue,</span> <span class="pre">.x</span> <span class="pre">=</span> <span class="pre">xvalue</span> <span class="pre">};</span>
<span class="pre">`</span></code></p>
<p>相当于</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">struct</span> <span class="pre">point</span> <span class="pre">p</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">xvalue,</span> <span class="pre">yvalue</span> <span class="pre">};</span>
<span class="pre">`</span></code></p>
<p>自GCC 2.5起已经过时的另一种具有相同含义的语法是“ fieldname：”，如下所示：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">struct</span> <span class="pre">point</span> <span class="pre">p</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">y:</span> <span class="pre">yvalue,</span> <span class="pre">x:</span> <span class="pre">xvalue</span> <span class="pre">};</span>
<span class="pre">`</span></code></p>
<p>忽略字段的初始化与具有静态存储持续时间的对象的初始化相同。</p>
<p>“ [index]”或“ .fieldname”被称为指示符。 初始化联合时，还可以使用指定符（或过时的冒号语法）来指定应使用联合的哪个元素。 例如，</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">union</span> <span class="pre">foo</span> <span class="pre">{</span> <span class="pre">int</span> <span class="pre">i;</span> <span class="pre">double</span> <span class="pre">d;</span> <span class="pre">};union</span> <span class="pre">foo</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">.d</span> <span class="pre">=</span> <span class="pre">4</span> <span class="pre">};</span>
<span class="pre">`</span></code></p>
<p>将4转换为双精度以使用第二个元素将其存储在联合中。 相比之下，强制转换4以键入union foo则将其作为整数i存储到并集中，因为它是整数。请参阅第520页的6.31节[从Cast到Union]。</p>
<p>您可以将这种命名元素的技术与连续元素的普通C初始化结合使用。 每个没有指定符的初始化器元素将应用于数组或结构的下一个连续元素。 例如，</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">int</span> <span class="pre">a[6]</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">[1]</span> <span class="pre">=</span> <span class="pre">v1,</span> <span class="pre">v2,</span> <span class="pre">[4]</span> <span class="pre">=</span> <span class="pre">v4</span> <span class="pre">};</span>
<span class="pre">`</span></code></p>
<p>相当于</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">int</span> <span class="pre">a[6]</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">0,</span> <span class="pre">v1,</span> <span class="pre">v2,</span> <span class="pre">0,</span> <span class="pre">v4,</span> <span class="pre">0</span> <span class="pre">};</span>
<span class="pre">`</span></code></p>
<p>当索引是字符或属于枚举类型时，标记数组初始化器的元素特别有用。 例如：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">int</span> <span class="pre">whitespace[256]=</span> <span class="pre">{</span> <span class="pre">[’</span> <span class="pre">’]</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">[’\t’]</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">[’\h’]</span> <span class="pre">=</span> <span class="pre">1,[’\f’]</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">[’\n’]</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">[’\r’]</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">};</span>
<span class="pre">`</span></code></p>
<p>您还可以在“ =”之前写一系列“ .fieldname”和“ [index]”指示符，以指定要初始化的嵌套子对象； 该列表是相对于与最接近的括号对相对应的子对象获取的。 例如，使用上面的“结构点”声明：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">struct</span> <span class="pre">point</span> <span class="pre">ptarray[10]</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">[2].y</span> <span class="pre">=</span> <span class="pre">yv2,</span> <span class="pre">[2].x</span> <span class="pre">=</span> <span class="pre">xv2,</span> <span class="pre">[0].x</span> <span class="pre">=</span> <span class="pre">xv0</span> <span class="pre">};</span>
<span class="pre">`</span></code></p>
<p>如果多次初始化同一字段，或者初始化并集的重叠字段，则使用最后一次初始化的值。 当联合的字段本身是结构时，将使用最后一个初始化字段的整个结构。 如果以前的任何初始化程序都有副作用，则不确定是否发生副作用。 当前，GCC会丢弃副作用较大的初始化程序表达式并发出警告。</p>
<p>总结：差最后一遍总结。</p>
</div>
<div class="section" id="case">
<h2>case范围<a class="headerlink" href="#case" title="Permalink to this headline">¶</a></h2>
<p>您可以在单个大小写标签中指定一系列连续值，如下所示：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">case</span> <span class="pre">low</span> <span class="pre">...</span> <span class="pre">high:</span>
<span class="pre">`</span></code></p>
<p>这与适当数量的个案标签具有相同的效果，每个整数标签从低到高（包括低和高）一个。</p>
<p>此功能对于ASCII字符代码范围特别有用：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">case</span> <span class="pre">’A’</span> <span class="pre">...</span> <span class="pre">’Z’:</span>
<span class="pre">`</span></code></p>
<p>注意：在…周围写空格，否则在将其与整数值一起使用时可能会被解析为错误。 例如，编写以下代码：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">case</span> <span class="pre">1</span> <span class="pre">...</span> <span class="pre">5:</span>
<span class="pre">`</span></code></p>
<p>而不是这样：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">case</span> <span class="pre">1...5:</span>
<span class="pre">`</span></code></p>
<p>总结：需要回读一遍。</p>
</div>
<div class="section" id="id86">
<h2>转换为联合类型<a class="headerlink" href="#id86" title="Permalink to this headline">¶</a></h2>
<p>强制转换为联合类型是C扩展，在C ++中不可用。 看起来就像普通的强制类型转换一样，其约束条件是指定的类型是联合类型。 您可以使用union关键字或引用联合的typedef名称来指定类型。 强制转换为并集的结果是并集类型的临时右值，其成员的类型与初始化为操作数的值的操作数的类型匹配。 强制转换为并集的效果与复合文字相似，不同之处在于它会像标准强制转换一样产生右值。 请参见第6.28节“复合文字”，第517页。</p>
<p>可以强制转换为联合类型的表达式是那些类型至少与联合成员之一匹配的表达式。 因此，给定以下联合和变量：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">union</span> <span class="pre">foo</span> <span class="pre">{</span> <span class="pre">int</span> <span class="pre">i;</span> <span class="pre">double</span> <span class="pre">d;</span> <span class="pre">};int</span> <span class="pre">x;double</span> <span class="pre">y;union</span> <span class="pre">foo</span> <span class="pre">z;</span>
<span class="pre">`</span></code></p>
<p>x和y都可以强制转换为union foo和以下赋值类型</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">z</span> <span class="pre">=</span> <span class="pre">(union</span> <span class="pre">foo)</span> <span class="pre">x;z</span> <span class="pre">=</span> <span class="pre">(union</span> <span class="pre">foo)</span> <span class="pre">y;</span>
<span class="pre">`</span></code></p>
<p>是这些的速记等效项</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">z</span> <span class="pre">=</span> <span class="pre">(union</span> <span class="pre">foo)</span> <span class="pre">{</span> <span class="pre">.i</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">};z</span> <span class="pre">=</span> <span class="pre">(union</span> <span class="pre">foo)</span> <span class="pre">{</span> <span class="pre">.d</span> <span class="pre">=</span> <span class="pre">y</span> <span class="pre">};</span>
<span class="pre">`</span></code></p>
<p>但是，（union foo）FLT_MAX; 不是有效的类型转换，因为union没有float类型的成员。(注意，这个问题)</p>
<p>将强制转换用作联合类型变量的赋值的右侧等同于存储在具有相同类型的联合成员中</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">union</span> <span class="pre">foo</span> <span class="pre">u;/*</span> <span class="pre">.</span> <span class="pre">.</span> <span class="pre">.</span> <span class="pre">*/u</span> <span class="pre">=</span> <span class="pre">(union</span> <span class="pre">foo)</span> <span class="pre">x</span> <span class="pre">--&gt;</span> <span class="pre">u.i</span> <span class="pre">=</span> <span class="pre">xu</span> <span class="pre">=</span> <span class="pre">(union</span> <span class="pre">foo)</span> <span class="pre">y</span> <span class="pre">--&gt;</span> <span class="pre">u.d</span> <span class="pre">=</span> <span class="pre">y</span>
<span class="pre">`</span></code></p>
<p>您还可以将union强制转换用作函数参数：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">void</span> <span class="pre">hack</span> <span class="pre">(union</span> <span class="pre">foo);/*</span> <span class="pre">.</span> <span class="pre">.</span> <span class="pre">.</span> <span class="pre">*/hack</span> <span class="pre">((union</span> <span class="pre">foo)</span> <span class="pre">x);</span>
<span class="pre">`</span></code></p>
<p>总结：这个需要回头捋一遍。</p>
</div>
<div class="section" id="id87">
<h2>混合声明，标签和代码<a class="headerlink" href="#id87" title="Permalink to this headline">¶</a></h2>
<p>ISO C99和ISO C ++允许在复合语句中自由混合声明和代码。 ISO C2X允许将标签放置在声明之前和复合声明的末尾。 作为扩展，GNU C还允许在C90模式下进行所有这些操作。 例如，您可以执行以下操作：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">int</span> <span class="pre">i;/*</span> <span class="pre">.</span> <span class="pre">.</span> <span class="pre">.</span> <span class="pre">*/i++;int</span> <span class="pre">j</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">2;</span>
<span class="pre">`</span></code></p>
<p>每个标识符从声明位置到封闭块的末尾都是可见的。</p>
<p>总结：这种混合方式，需要捋清楚，回头理解我们看到的代码。</p>
</div>
<div class="section" id="id88">
<h2>声明函数的属性<a class="headerlink" href="#id88" title="Permalink to this headline">¶</a></h2>
<p>在GNU C，可以使用函数属性来指定函数特性，些属性可以帮助编译器优化调用或更仔细地检查代码的正确性。例如，可以使用属性来指定函数从不返回（noreturn），返回一个依赖于某个数值（const）的值，或具有printf样式参数（格式）的值。</p>
<p>还可以使用属性来控制要注释的函数中的内存位置，代码生成选项或调用/返回约定。 其中许多属性都是特定于目标的。 例如，许多目标都支持用于定义中断处理程序功能的属性，这些属性通常必须遵循特殊的寄存器用法和返回约定。 小节中针对每个目标描述了此类属性。 但是，大多数（如果不是全部）目标都支持大量属性。</p>
<p>函数属性由函数声明中的__attribute__关键字引入，后跟用双括号括起来的指定属性，可以在声明中指定多个属性，方法是在双括号内用逗号将它们隔开，或者紧跟在一个属性说明之后。有关属性语法和放置的确切规则后面会具体说明。 合并了同一函数的不同声明上的兼容属性规范。 与警告不兼容的属性规范与已经应用于同一函数的声明的属性不兼容。</p>
<p>某些函数属性采用一个或多个参数，这些参数通过它们在函数参数列表中的位置来引用函数的参数。 这样的属性参数称为位置参数。 除非另有说明，否则指定指针类型参数的属性的位置参数还可以指定非staticmember函数中隐式C ++ this参数以及引用指针类型的参数的相同属性。 对于普通功能，位置一指的是第一个参数 在清单上。 在C ++非静态成员函数中，位置1引用隐式this指针。 相同的限制和效果适用于与普通函数或C ++成员函数一起使用的函数属性。</p>
<p>GCC还支持变量声明的属性，标签属性，枚举器属性，声明 属性，和类型属性。</p>
<p>属性的用途和用语之间有一些重叠（请参见第6.62节[GCC接受的杂语]，第862页）。 已经发现使用__attribute__可以方便地将属性自然地附加到其对应的声明中，而#pragma用于与其他自然不构成语法一部分的编译器或构造兼容。</p>
<p>除了此处记录的属性外，GCC插件还可以提供自己的属性。</p>
<p>总结：非常重要</p>
<div class="section" id="id89">
<h3>常用函数属性<a class="headerlink" href="#id89" title="Permalink to this headline">¶</a></h3>
<p>大多数目标都支持以下属性:</p>
<p>access
access (access-mode, ref-index)
access (access-mode, ref-index, size-index)</p>
<blockquote>
<div><p>通过 access 属性可以使用它们所应用的函数或其调用者来检测无效或不安全的访问，以及对永不读取的对象的仅写访问。此类访问可通过警告（例如）来诊断-Wstringop-overflow,-Wuninitialized,-Wunused， 和别的。</p>
<p>的 access 属性指定到通过引用其自变量的属性应用一个函数根据访问被引用的对象 access-mode 。该 access-mode 参数是必需的，而且必须是四个名称之一： read_only ， read_write ， write_only ，或 none 。其余两个是位置参数。</p>
<p>必需的 ref-index 位置参数表示要访问的指针（或在C ++中为reference）类型的函数参数。同一指针参数最多可以由一个不同的 access 属性引用。</p>
<p>可选的 size-index 位置参数表示整数类型的函数参数，该函数参数指定访问的最大大小。 size是 ref-index 引用的类型的元素数，或者是指针类型为 void* 时的字节数。如果未指定 size-index 参数，则指针参数必须为null或指向一个适当对齐的空间，该空间对于至少一个引用类型的对象是适当的（这意味着过去指针不是有效参数）。访问的实际大小可以更小，但不能更大。</p>
<p>所述 read_only 存取模式指定其所适用的指针用于读取被引用的对象但不写入。除非用 size-index 表示指定访问大小的参数为零，否则必须初始化被引用的对象。该模式比 const 限定符具有更强的保证力，而const限定符在抛弃指针时不会阻止指向的对象被修改。使用 read_only 访问模式的示例是 puts 函数的参数，或者 memcpy 函数的第二个和第三个参数。</p>
<p>__attribute__ ((access (read_only, 1))) int puts (const char*);
__attribute__ ((access (read_only, 2, 3))) void* memcpy (void*, const void*, size_t);</p>
<p>该 read_write 访问模式适用于指针类型的参数，而不 const 限定符。它指定将其应用于的指针用于读取和写入引用的对象。除非用 size-index 表示指定访问大小的参数为零，否则必须初始化指针引用的对象。使用 read_write 访问模式的一个示例是 strcat 函数的第一个参数。</p>
<p>__attribute__ ((access (read_write, 1), access (read_only, 2))) char* strcat (char*, const char*);</p>
<p>只 write_only 访问模式适用于没有 const 限定符的指针类型的参数。它指定将其应用于的指针用于写入引用的对象，但不能从其读取。指针引用的对象无需初始化。使用 write_only 访问模式的一个示例是 strcpy 函数的第一个参数，或者 fgets 函数的前两个参数。</p>
<p>__attribute__ ((access (write_only, 1), access (read_only, 2))) char* strcpy (char*, const char*);
__attribute__ ((access (write_only, 1, 2), access (read_write, 3))) int fgets (char*, int, FILE*);</p>
<p>访问模式 none 指定它所应用的指针根本不用于访问引用的对象。除非指针为空，否则指向的对象必须存在并且至少具有 size-index 参数所指示的大小。对象不需要被初始化。该模式旨在用作帮助验证预期对象大小的方法，例如在调用 __builtin_object_size 的函数中。请参阅对象大小检查。</p>
</div></blockquote>
<p>alias (“target”)</p>
<blockquote>
<div><p>的 alias 属性促使声明被发射以用于另一个符号的别名，它必须用相同类型的先前声明，和用于变量，也具有相同的尺寸和对齐。声明别名与目标类型不同的别名是未定义的，可能会被诊断。例如，以下声明：</p>
<p>void __f () { /* 做一点事。<a href="#id90"><span class="problematic" id="id91">*</span></a>/; }
void f () __attribute__ ((weak, alias (“__f”)));</p>
<p>定义 ‘f’作为’的弱别名__f’。在C ++中，必须使用目标的错误名称。如果“__f不在同一翻译单元中定义。</p>
<p>这个属性需要汇编器和对象文件的支持,并不是所有目标都能使用。</p>
</div></blockquote>
<p>aligned
aligned (alignment)</p>
<blockquote>
<div><p>所述 aligned 属性指定功能的第一个指令，以字节为单位测量的最小对齐。指定时， alignment 必须是2的整数常数幂。不指定 alignment 参数就意味着目标的理想对齐方式。该 __alignof__ 操作符可以用来确定那是什么（见对齐）。当在同一转换单元中未提供功能定义时，该属性无效。</p>
<p>该属性不能用于减少先前声明的函数的限制性对齐,只能用于增加它。否则会被诊断。在这样的目标上,指定一个限制性较小的对齐方式会被默默地忽略。使用该属性会覆盖-falign-functions（请参阅优化选项）此功能的选项。</p>
<p>注意， aligned 属性的有效性可能受到系统链接器和/或目标文件格式的固有限制的限制。在某些系统上，链接器仅能够排列要对齐的功能，直到达到某个最大对齐为止。 （对于某些链接程序，所支持的最大对齐方式可能非常小。）有关更多信息，请参见链接程序文档。</p>
<p>所述 aligned 属性还可以用于变量和字段（参见变量属性。）</p>
</div></blockquote>
<p>alloc_align (position)</p>
<blockquote>
<div><p>所述 alloc_align 属性可以被应用到一个返回指针和取整数或枚举类型中的至少一个参数的函数。它指示返回的指针在 position 处由函数参数指定的边界上对齐。有意义的对齐方式是2的幂乘以1。GCC使用此信息来改进指针对齐分析。</p>
<p>表示分配的对齐方式的函数参数由一个常数整数参数指定,其编号是属性的参数。参数编号从1开始。</p>
<p>例如:</p>
<p>void* my_memalign (size_t, size_t) __attribute__ ((alloc_align (1)));</p>
<p>声明 my_memalign 返回参数1给定的最小对齐的内存。</p>
</div></blockquote>
<p>alloc_size (position)
alloc_size (position-1, position-2)</p>
<blockquote>
<div><p>所述 alloc_size 属性可以被应用于一个函数返回一个指针和取整数或枚举类型中的至少一个参数。它指示返回的指针指向内存，该内存的大小由 position-1 处的函数自变量或 position-1 与 position-2 处的自变量的乘积给出。有意义的大小是小于 PTRDIFF_MAX 的正值。 GCC使用此信息来改善 __builtin_object_size 的结果。</p>
<p>表示分配大小的函数参数由提供给属性的一个或两个整数参数指定。分配的大小是指定的单个函数参数的值或指定的两个函数参数的乘积。对于普通函数,参数编号从1开始,对于C++非静态成员函数,参数编号从2开始。</p>
<p>例如:</p>
<p>void* my_calloc (size_t, size_t) __attribute__ ((alloc_size (1, 2)));
void* my_realloc (void*, size_t) __attribute__ ((alloc_size (2)));</p>
<p>声明 my_calloc 返回由参数1和2 my_realloc 提供的大小的内存，并且my_realloc返回由参数2给定的大小的内存。</p>
</div></blockquote>
<p>always_inline</p>
<blockquote>
<div><p>一般来说,除非指定优化,否则函数不会内联。对于声明为内联的函数,该属性将内联该函数,而不受任何其他适用于内联的限制。未能内联这样的函数会被诊断为错误。请注意,如果这样的函数被间接调用,编译器可能会根据优化级别对其进行内联,也可能不会对间接调用进行内联诊断。</p>
</div></blockquote>
<p>artificial</p>
<blockquote>
<div><p>这个属性对于小的内联包装很有用,如果可能的话,这些内联包装应该在调试时作为一个单元出现。根据调试信息的格式,它要么意味着将函数标记为人为的,要么对内联体中的所有指令使用调用者位置。</p>
</div></blockquote>
<p>assume_aligned (alignment)
assume_aligned (alignment, offset)</p>
<blockquote>
<div><p>所述 assume_aligned 属性可被应用于一个返回指针的函数。它指示返回的指针在 alignment 给定的边界上对齐。如果该属性具有两个参数，则第二个参数为misalignment offset 。 alignment 有意义的值是2的幂乘以1。有意义的 offset 值大于零且小于 alignment 。</p>
<p>比如说</p>
<p>void* my_alloc1 (size_t) __attribute__((assume_aligned (16)));
void* my_alloc2 (size_t) __attribute__((assume_aligned (32, 8)));</p>
<p>声明 my_alloc1 返回16字节对齐的指针，并且 my_alloc2 返回其值取模32等于8的指针。</p>
</div></blockquote>
<p>cold</p>
<blockquote>
<div><p>函数的 cold 属性用于通知编译器该函数不太可能执行。该函数针对大小而不是速度进行了优化，并且在许多目标上将其放置在文本节的特殊子节中，因此所有冷函数都显示在一起，从而提高了程序非冷部分的代码局部性。分支预测机制将导致调用代码中冷函数的路径标记为不太可能。因此，将用于处理不太可能的情况（例如 perror )的函数标记为冷是有用的，以改善在极少数情况下确实会调用标记函数的热函数的优化。</p>
<p>当个人资料反馈可用时,通过-fprofile-use，则会自动检测到冷功能，并且会忽略此属性。</p>
</div></blockquote>
<p>const</p>
<blockquote>
<div><p>调用其返回值不受程序可观察状态的更改影响并且对这种状态没有可观察的影响（而不返回值）的函数的调用可以使自己进行优化，例如消除公共子表达式。使用 const 属性声明此类函数可以使GCC避免在重复调用具有相同参数值的函数时发出某些调用。</p>
<p>例如:</p>
<p>int square (int) __attribute__ ((const));</p>
<p>告诉GCC，后续调用具有相同参数值的 square 的函数可以由第一次调用的结果替换，而不必考虑两者之间的语句。</p>
<p>该 const 属性从阅读影响连续调用之间的返回值对象禁止功能。但是，使用该属性声明的函数可以安全地读取不更改其返回值的对象，例如非易失性常量。</p>
<p>该 const 属性规定了比同类功能的定义更严格的限制 pure 属性。诊断使用 const 和 pure 属性声明相同的功能。因为const函数不能有任何可观察到的副作用，所以使其返回 void 没有意义。诊断出声明了这样的功能。</p>
<p>注意，如果指向的数据可能在函数的连续调用之间改变，则不能将具有指针参数并检查所指向的数据的 const 声明为const。通常，由于函数无法区分可能更改的数据和不能更改的数据，因此const函数绝不能使用指针或在C ++中引用参数。同样，调用非const函数的函数通常不得为const本身。</p>
</div></blockquote>
<p>constructor
destructor
constructor (priority)
destructor (priority)</p>
<blockquote>
<div><p>的 constructor 属性导致函数被自动调用之前执行进入 main () 。同样， destructor 属性使函数在 main () 完成或调用 exit () 之后自动被调用。具有这些属性的函数对于初始化在程序执行期间隐式使用的数据很有用。</p>
<p>在某些目标上，这些属性还接受一个整数参数来指定优先级，以控制构造函数和析构函数运行的顺序。优先级编号较小的构造函数在优先级编号较大的构造函数之前运行；相反的关系适用于破坏者。因此，如果您有一个分配资源的构造函数和一个释放相同资源的析构函数，则两个函数通常具有相同的优先级。构造函数和析构函数的优先级与为命名空间范围的C ++对象指定的优先级相同（请参见C ++ Attributes）。但是，目前，具有静态存储持续时间的C ++对象的 constructor 函数和用属性构造函数修饰的函数的构造顺序未指定被调用。在混合声明中，属性 init_priority 可用于施加特定顺序。</p>
<p>在不支持该功能的目标上使用 constructor 和 destructor 属性的参数形式会被错误拒绝。</p>
</div></blockquote>
<p>copy
copy (function)</p>
<blockquote>
<div><p>该 copy 的属性应用一组与属性的 function 已被宣布为是应用该属性的函数的声明。该属性是为定义别名或函数解析器的库而设计的，这些别名或函数解析器应指定与其目标相同的属性集。的 copy 属性可以与函数，变量，或类型一起使用。但是，应用属性的符号类型（函数或变量）必须与参数所引用的符号类型匹配。该 copy 属性仅复制句法和语义属性，但不是属性，这些属性影响元件的链接或知名度，如 alias ， visibility 或 weak 。在 deprecated 和 target_clones 属性也不会被复制。请参阅“通用类型属性”。请参见通用变量属性。</p>
<p>例如， StrongAlias 宏观下方品牌使用的 alias 和 copy 属性来定义命名的别名 alloc 的功能 allocate 与属性声明 alloc_size ， malloc 的，并 nothrow 。多亏了 __typeof__ 运算符，别名与目标函数具有相同的类型。由于 copy 属性，别名也与目标共享相同的属性。</p>
<dl class="simple">
<dt>#define StrongAlias(TargetFunc, AliasDecl)  </dt><dd><dl class="simple">
<dt>extern __typeof__ (TargetFunc) AliasDecl  </dt><dd><p>__attribute__ ((alias (#TargetFunc), copy (TargetFunc)));</p>
</dd>
</dl>
</dd>
<dt>extern __attribute__ ((alloc_size (1), malloc, nothrow))</dt><dd><p>void* allocate (size_t);</p>
</dd>
</dl>
<p>StrongAlias (allocate, alloc);</p>
</div></blockquote>
<p>deprecated
deprecated (msg)</p>
<blockquote>
<div><p>如果在源文件中的任何位置使用该功能， deprecated 属性将产生警告。当识别预期在程序的将来版本中删除的功能时，此功能很有用。该警告还包括不赞成使用的函数的声明的位置，以使用户可以轻松找到有关不赞成使用该函数的原因或应采取的措施的进一步信息。请注意，警告仅针对以下用途：</p>
<p>int old_fn () __attribute__ ((deprecated));
int old_fn ();
int (<a href="#id92"><span class="problematic" id="id93">*</span></a>fn_ptr)() = old_fn;</p>
<p>在第3行而不是第2行上显示警告。如果存在，则可选的 msg 参数（必须为字符串）会显示在警告中。</p>
<p>的 deprecated 属性还可以用于变量和类型（参见变量属性，参见类型属性）。</p>
<p>附加在属性上的信息受属性的设置影响。-fmessage-lengthoption.</p>
</div></blockquote>
<p>error (“message”)
warning (“message”)</p>
<blockquote>
<div><p>如果在函数声明上使用了 error 或 warning 属性，并且没有通过消除无效代码或进行其他优化来消除了对该函数的调用，则会分别诊断出包含 message 的错误或警告。这对于编译时检查很有用，特别是与 __builtin_constant_p 和内联函数一起使用时，无法通过 extern char [(condition) ? 1 : -1]; 检查内联函数参数。1：-1]；技巧。</p>
<p>尽管可以使函数保持未定义状态，从而调用链接失败（使用 .gnu.warning* 部分中的消息定义函数），但使用这些属性时，可以更早地诊断问题，甚至可以在调用中准确定位出问题。内联函数的存在或不发出调试信息时。</p>
</div></blockquote>
<p>externally_visible</p>
<blockquote>
<div><p>这个属性,附加在全局变量或函数上,使全局变量或函数的效果无效。-fwhole-program命令行选项,所以对象在当前编译单元之外仍然可见。</p>
<p>If-fwhole-program搭配使用-flto并将 gold 用作链接器插件， externally_visible 属性自动添加到根据 gold 生成的解析文件在LTO对象外部访问的函数（由于当前的 gold 问题，该变量尚未更改）。对于其他无法生成解析文件的链接器，仍然需要显式的 externally_visible 属性。</p>
</div></blockquote>
<p>flatten</p>
<blockquote>
<div><p>通常，内联到函数是有限的。对于标有该属性的函数，如果可能，将内联该函数内的每个调用。用属性 noinline 和类似属性声明的函数不进行内联。是否考虑对函数本身进行内联取决于其大小和当前的内联参数。</p>
</div></blockquote>
<p>format (archetype, string-index, first-to-check)</p>
<blockquote>
<div><p>该 format 属性指定一个函数具有 printf 的， scanf 函数， strftime 的或 strfmon 风格的参数应该是类型检查与格式字符串。例如，声明：</p>
<p>extern int
my_printf (void <a href="#id94"><span class="problematic" id="id95">*</span></a>my_object, const char <a href="#id96"><span class="problematic" id="id97">*</span></a>my_format, …)</p>
<blockquote>
<div><p>__attribute__ ((format (printf, 2, 3)));</p>
</div></blockquote>
<p>使编译器检查对 my_printf 的调用中的参数与 printf 样式格式字符串参数 my_format 的一致性。</p>
<p>参数 archetype 决定如何解释格式字符串，并且应为 printf ， scanf ， strftime ， gnu_printf ， gnu_scanf ， gnu_strftime 或 strfmon 。（您也可以使用 __printf__ ， __scanf__ ， __strftime__ 或 __strfmon__ 。）在MinGW目标上，还存在 ms_printf ， ms_scanf 和 ms_strftime 。 archetype 值，例如 printf 指系统的C运行时库接受的格式，而以’<a href="#id404"><span class="problematic" id="id405">gnu_</span></a>’始终指GNU C库接受的格式。在Microsoft Windows目标上，前缀为’<a href="#id406"><span class="problematic" id="id407">ms_</span></a>’指的是msvcrt.dll图书馆。参数 string-index 指定哪个参数是格式字符串参数（从1开始），而 first-to-check 是要针对格式字符串检查的第一个参数的编号。对于无法检查参数的函数（例如 vprintf ），请将第三个参数指定为零。在这种情况下，编译器仅检查格式字符串的一致性。对于 strftime 格式，第三个参数必须为零。由于非静态C ++方法具有隐式 this 参数，因此在为 string-index 和 first-to-check 赋值时，此类方法的参数应从两个而不是一个计数。</p>
<p>在上面的示例中，格式字符串（ my_format ）是函数 my_print 的第二个参数，要检查的参数从第三个参数开始，因此format属性的正确参数是2和3。</p>
<p>该 format 属性可以让你找出自己的函数以格式字符串作为参数，使GCC可以检查这些功能的调用有无错误。编译器始终（除非-ffreestandingor-fno-builtin使用）在请求此类警告时使用标准库函数 printf ， fprintf ， sprintf ， scanf ， fscanf ， sscanf ， strftime ， vprintf ， vfprintf 和 vsprintf 的格式（使用此类警告时-Wformat），因此无需修改头文件stdio.h。在C99模式下，还将检查函数 snprintf ， vsnprintf ， vscanf ， vfscanf 和 vsscanf 。除了在严格符合C标准模式中，在X / Open功能 strfmon 还检查作为被 printf_unlocked 和 fprintf_unlocked 。请参阅控制C语言的选项。</p>
<p>对于Objective-C方言，可以在同一上下文中识别 NSString （或 __NSString__ ）。解析包含这些格式属性的声明以获取正确的语法，但是尚未定义此类格式字符串的检查结果，并且此版本的编译器无法执行该检查。</p>
<p>目标也可以提供其他类型的格式检查。请参阅特定于特定目标计算机的格式检查。</p>
</div></blockquote>
<p>format_arg (string-index)</p>
<blockquote>
<div><p>该 format_arg 属性指定一个函数使用一个或多个格式字符串 printf ， scanf 函数， strftime 的或 strfmon 风格的函数，并修改它（例如，把它翻译成另一种语言），这样的结果可以被传递到 printf ， scanf 函数， strftime 或 strfmon 样式函数（格式函数的其余参数与未修改的字符串相同）。可以将多个 format_arg 属性应用于同一函数，每个属性都将不同的参数指定为格式字符串。例如，声明：</p>
<p>extern char *
my_dgettext (char <a href="#id98"><span class="problematic" id="id99">*</span></a>my_domain, const char <a href="#id100"><span class="problematic" id="id101">*</span></a>my_format)</p>
<blockquote>
<div><p>__attribute__ ((format_arg (2)));</p>
</div></blockquote>
<p>使编译器检查对 printf ， scanf ， strftime 或 strfmon 类型函数的调用中的参数，这些函数的格式字符串参数是对 my_dgettext 函数的调用，以与格式字符串参数 my_format 保持一致。如果未指定 format_arg 属性，则所有编译器在对格式函数的此类调用中都可以知道format字符串参数不是常量；这将在生成警告时-Wformat-nonliteral被使用,但没有该属性就无法检查调用。</p>
<p>在对使用多个 format_arg 属性声明的函数的调用中，每个属性具有不同的参数值时，将根据属性指定的所有格式字符串检查相应的实际函数参数。此功能旨在支持GNU ngettext 系列功能。</p>
<p>参数 string-index 指定哪个参数是格式字符串参数（从1开始）。由于非静态C ++方法具有隐式 this 参数，因此此类方法的参数应从2开始计算。</p>
<p>该 format_arg 属性可以让你找出自己的函数修改格式字符串，使GCC可以检查调用 printf ， scanf 函数， strftime 的或 strfmon 类型的函数，其操作数到自己的函数之一的调用。编译器始终以这种方式处理 gettext ， dgettext 和 dcgettext ，除非在以下情况下要求严格的ISO C支持-ansi或适当的-std选项,或-ffreestandingor-fno-builtin用来。请参阅控制C语言的选项。</p>
<p>对于Objective-C方言， format-arg 属性可以引用 NSString 参考以与上面的 format 属性兼容。</p>
<p>该目标还可以允许 format-arg 属性中包含其他类型。请参阅特定于特定目标计算机的格式检查。</p>
</div></blockquote>
<p>gnu_inline</p>
<blockquote>
<div><p>此属性应与也使用 inline 关键字声明的函数一起使用。即使在C99或gnu99模式下进行编译，它也会指示GCC将功能视为在gnu90模式下定义的功能。</p>
<p>如果将函数声明为 extern ，则此函数定义仅用于内联。绝对不会将函数编译为独立函数，即使您显式获取其地址也是如此。这样的地址将成为一个外部引用，就好像您仅声明了该函数而未定义它一样。这几乎具有宏的作用。使用此方法的方法是将函数定义放入具有此属性的头文件中，并放置函数的另一个副本，而无需 extern ，在库文件中。头文件中的定义导致对函数的大多数调用被内联。如果仍然使用该功能，则它们引用库中的单个副本。请注意，函数的两个定义不必完全相同，尽管如果它们的效果不同，则您的程序可能会表现得很奇怪。</p>
<p>在C语言中，如果函数既不是 extern 也不是 static ，则该函数将编译为独立函数，并在可能的情况下内联。</p>
<p>这就是GCC传统上处理 inline 声明的函数的方式。由于ISO C99为 inline 指定了不同的语义，因此，此功能属性本身就是一种过渡措施和有用的功能。此属性在GCC 4.1.3和更高版本中可用。如果定义了预处理器宏 __GNUC_GNU_INLINE__ 或 __GNUC_STDC_INLINE__ ，则可用。请参见内联函数与宏一样快。</p>
<p>在C ++中，此属性不以任何方式依赖于 extern ，但是它仍然需要 inline 关键字来启用其特殊行为。</p>
</div></blockquote>
<p>hot</p>
<blockquote>
<div><p>函数上的 hot 属性用于通知编译器该函数是已编译程序的热点。该功能得到了更积极的优化，并且在许多目标上都将其放置在文本部分的特殊子区域中，因此所有热功能均显示在一起，从而提高了局部性。</p>
<p>当个人资料反馈可用时,通过-fprofile-use，则会自动检测到热功能，并且将忽略此属性。</p>
</div></blockquote>
<p>ifunc (“resolver”)</p>
<blockquote>
<div><p>所述 ifunc 属性用于标记一个函数作为使用STT_GNU_IFUNC符号类型扩展，ELF标准的间接功能。这允许在加载时动态确定符号值的分辨率，并为特定处理器或随后确定的其他系统特性选择例程的优化版本。要使用此属性，首先定义可用的实现功能，以及一个解析器功能，该功能返回指向所选实现功能的指针。实现函数的声明必须与要实现的函数的API相匹配。应该将解析器声明为不带参数的函数，并返回指向与实现类型相同的函数的指针。例如：</p>
<p>void <a href="#id102"><span class="problematic" id="id103">*</span></a>my_memcpy (void <a href="#id104"><span class="problematic" id="id105">*</span></a>dst, const void <a href="#id106"><span class="problematic" id="id107">*</span></a>src, size_t len)
{</p>
<blockquote>
<div><p>…
return dst;</p>
</div></blockquote>
<p>}</p>
<p>static void * (<a href="#id108"><span class="problematic" id="id109">*</span></a>resolve_memcpy (void))(void <a href="#id110"><span class="problematic" id="id111">*</span></a>, const void <a href="#id112"><span class="problematic" id="id113">*</span></a>, size_t)
{</p>
<blockquote>
<div><p>return my_memcpy; // 我们将始终选择此例程</p>
</div></blockquote>
<p>}</p>
<p>输出的头文件声明用户调用的函数将包含。</p>
<p>extern void <a href="#id114"><span class="problematic" id="id115">*</span></a>memcpy (void <a href="#id116"><span class="problematic" id="id117">*</span></a>, const void <a href="#id118"><span class="problematic" id="id119">*</span></a>, size_t);</p>
<p>允许用户将 memcpy 作为常规函数调用，而没有意识到实际的实现。最后，需要在与解析器函数相同的转换单元中定义间接函数：</p>
<dl class="simple">
<dt>void <a href="#id120"><span class="problematic" id="id121">*</span></a>memcpy (void <a href="#id122"><span class="problematic" id="id123">*</span></a>, const void <a href="#id124"><span class="problematic" id="id125">*</span></a>, size_t)</dt><dd><p>__attribute__ ((ifunc (“resolve_memcpy”)));</p>
</dd>
</dl>
<p>在C ++中， ifunc 属性采用一个字符串，该字符串是解析器函数的错误名称。应该声明一个用于类 C 的非静态成员函数的C ++解析器，以返回指向非成员函数的指针，该指针以指向 C 的指针作为第一个参数，后跟与实现函数相同的参数。G ++检查两个函数的签名并发出-Wattribute-alias警告,因为不匹配。要抑制从指向实现成员函数的指针到对应的非成员函数类型的必要转换的警告,使用-Wno-pmf-conversions选项。例如:</p>
<p>class S
{
private:</p>
<blockquote>
<div><p>int debug_impl (int);
int optimized_impl (int);</p>
<p>typedef int Func (S*, int);</p>
<p>static Func* resolver ();</p>
</div></blockquote>
<p>public:</p>
<blockquote>
<div><p>int interface (int);</p>
</div></blockquote>
<p>};</p>
<p>int S::debug_impl (int) { /* … <em>/ }
int S::optimized_impl (int) { /</em> … <a href="#id126"><span class="problematic" id="id127">*</span></a>/ }</p>
<p>S::Func* S::resolver ()
{</p>
<blockquote>
<div><dl class="simple">
<dt>int (S::<a href="#id128"><span class="problematic" id="id129">*</span></a>pimpl) (int)</dt><dd><p>= getenv (“DEBUG”) ? &amp;S::debug_impl : &amp;S::optimized_impl;</p>
</dd>
</dl>
<p>// 投射触发器 -Wno-pmf-conversions.
return reinterpret_cast&lt;Func*&gt;(pimpl);</p>
</div></blockquote>
<p>}</p>
<p>int S::interface (int) __attribute__ ((ifunc (“_ZN1S8resolverEv”)));</p>
<p>间接函数不能是弱函数。使用此功能需要Binutils 2.20.1或更高版本和GNU C库2.11.1版本。</p>
</div></blockquote>
<p>interrupt
interrupt_handler</p>
<blockquote>
<div><p>许多GCC后端都支持属性来表明一个函数是一个中断处理程序,它告诉编译器生成不同于常规函数的函数进入和退出序列。确切的语法和行为是特定于目标的,详情请参考下面的小节。</p>
</div></blockquote>
<p>leaf</p>
<blockquote>
<div><p>使用此属性对外部函数的调用必须仅通过return或通过异常处理才能返回到当前的编译单元。特别是，不允许叶子函数调用从当前编译单元传递给它的回调函数，直接调用由该单元导出的函数或将 longjmp 放入该单元中。叶子函数可能仍会从其他编译单元调用函数，因此从它们根本不包含任何函数调用的意义上来说，它们不一定是叶子。</p>
<p>该属性用于库功能以改善数据流分析。编译器提示，叶子函数无法使用或修改任何未转义当前编译单元的数据。例如， sin 函数是叶函数，而 qsort 不是。</p>
<p>请注意，叶函数可能会间接运行在当前使用静态变量的编译单元中定义的信号处理程序。同样，当执行惰性符号解析时，叶函数可能会调用间接函数，这些函数的解析器函数或实现函数在当前编译单元中定义，并使用静态变量。没有编写此类信号处理程序，解析器函数或实现函数的符合标准的方法，并且您最好的办法是删除 leaf 属性或将所有此类静态变量标记为 volatile 。最后，对于支持符号插入的基于ELF的系统，应注意当前编译单元中定义的功能不要基于定义的标准模式和定义的功能测试宏意外插入其他符号；否则会添加一个意外回调。</p>
<p>该属性对当前编译单元中定义的函数没有影响。这是为了允许将多个编译单元合并成一个单元,例如,通过使用链接时间优化。由于这个原因,该属性不允许在类型上注释间接调用。</p>
</div></blockquote>
<p>malloc
malloc (deallocator)
malloc (deallocator, ptr-index)</p>
<blockquote>
<div><p>属性 malloc 表示函数是类似 malloc 的，即函数返回的指针 P 不能在函数返回时为任何其他有效指针设置别名，而且在 P 寻址的任何存储中都不会出现指向有效对象的指针。此外，GCC 预测具有该属性的函数在大多数情况下返回非空。</p>
<p>独立地，带有一个或两个参数的属性形式将 deallocator 关联为一个合适的解除分配函数，用于从类似 malloc 的函数返回的指针。 ptr-index 表示位置参数，当指针在调用中传递给 deallocator 时，它具有解除分配的效果。</p>
<p>使用不带参数的属性旨在通过依赖其隐含的别名属性来改进优化。 malloc 和 calloc 等函数具有此属性，因为它们返回一个指向未初始化或清零的新获得的存储的指针。但是，像 realloc 这样的函数没有这个属性，因为它们可能会返回指向存储的指针，其中包含指向现有对象的指针。此外，由于假定所有此类函数仅很少返回 null，因此可以基于该假设优化调用方。</p>
<p>将函数与 deallocator 有助于检测对不匹配的分配和解除分配函数的调用，并在选项的控制下对其进行诊断，例如-Wmismatched-dealloc. 它还可以通过以下方式诊断释放未动态分配的对象的尝试-Wfree-nonheap-object. 以指示分配函数既satisifies的nonaliasing属性，并具有与之相关联的释放器，两个属性的纯形式和一个与所述 deallocator 参数必须被使用。同一个函数既可以是分配器，也可以是解除分配器。由于内联相关​​函数之一而不是另一个可能导致明显的不匹配，因此内联函数不接受这种形式的属性 malloc 。出于同样的原因，使用该属性可以防止分配和释放函数被内联扩展。</p>
<p>例如，除了声明函数返回的指针不与其他任何其他指针 fclose 别名之外，以下声明使fclose成为除 popen 之外的所有函数返回的指针的合适释放器，并使 pclose 成为从 popen 返回的指针的唯一合适释放器。必须先声明解除分配器函数，然后才能在属性中引用它们。</p>
<p>int fclose (FILE*);
int pclose (FILE*);</p>
<dl class="simple">
<dt>__attribute__ ((malloc, malloc (fclose, 1)))</dt><dd><p>FILE* fdopen (int, const char*);</p>
</dd>
<dt>__attribute__ ((malloc, malloc (fclose, 1)))</dt><dd><p>FILE* fopen (const char*, const char*);</p>
</dd>
<dt>__attribute__ ((malloc, malloc (fclose, 1)))</dt><dd><p>FILE* fmemopen(void <a href="#id130"><span class="problematic" id="id131">*</span></a>, size_t, const char <a href="#id132"><span class="problematic" id="id133">*</span></a>);</p>
</dd>
<dt>__attribute__ ((malloc, malloc (pclose, 1)))</dt><dd><p>FILE* popen (const char*, const char*);</p>
</dd>
<dt>__attribute__ ((malloc, malloc (fclose, 1)))</dt><dd><p>FILE* tmpfile (void);</p>
</dd>
</dl>
<p>所守护的警告-fanalyzer尊重用 malloc 标记的分配和释放对。特别是：</p>
<blockquote>
<div><p>分析仪将发出一个-Wanalyzer-mismatching-deallocation诊断是否存在一个执行路径,其中分配调用的结果被传递给不同的去分配器。
分析仪将发出一个-Wanalyzer-double-free诊断是否存在一个执行路径,其中一个值被多次传递给一个去分配调用。
分析器将考虑一个分配函数可能失败并返回NULL的可能性。它将发出-Wanalyzer-possible-null-dereferenceand-Wanalyzer-possible-null-argument如果执行路径中分配调用的未检查结果被取消引用或传递给需要非空参数的函数，则诊断。如果分配器始终返回非空值，请使用 __attribute__ ((returns_nonnull)) 来抑制这些警告。例如：</p>
<dl class="simple">
<dt>char <a href="#id134"><span class="problematic" id="id135">*</span></a>xstrdup (const char <a href="#id136"><span class="problematic" id="id137">*</span></a>)</dt><dd><p>__attribute__((malloc (free), returns_nonnull));</p>
</dd>
</dl>
<p>分析仪将发出一个-Wanalyzer-use-after-free诊断是否存在一个执行路径,在该路径中,由指针传递给去分配调用的内存在去分配后被使用。
分析仪将发出一个-Wanalyzer-malloc-leak诊断是否存在分配调用的结果被泄露的执行路径(没有被传递给去分配函数)。
分析仪将发出一个-Wanalyzer-free-of-non-heap如果在全局或堆栈上的变量上使用了一个去分配函数,则可诊断。</p>
</div></blockquote>
<p>分析器假定解除分配器可以优雅地处理 NULL 指针。如果不是这种情况，可以用 __attribute__((nonnull)) 标记解除分配器，以便-fanalyzer可以发射出一个-Wanalyzer-possible-null-argument诊断代码路径,其中去分配器被调用时为NULL。</p>
</div></blockquote>
<p>no_icf</p>
<blockquote>
<div><p>这个函数属性防止一个函数与另一个语义等同的函数合并。</p>
</div></blockquote>
<p>no_instrument_function</p>
<blockquote>
<div><p>如果有任何-finstrument-functions,-p， 或者-pg给出,大多数用户编译的函数在进入和退出时都会产生剖析函数调用。带有此属性的函数不会被工具化。</p>
</div></blockquote>
<p>no_profile_instrument_function</p>
<blockquote>
<div><p>函数上的 no_profile_instrument_function 属性用于通知编译器它不应处理任何基于配置文件反馈的优化代码工具。</p>
</div></blockquote>
<p>no_reorder</p>
<blockquote>
<div><p>请勿将标有 no_reorder 的函数或变量彼此重新排序，也不要在顶级汇编器语句中对可执行文件进行重新排序。程序中的实际顺序将取决于链接器命令行。标记为这样的静态变量也不会被删除。这与-fno-toplevel-reorder选项,但只适用于标记的符号。</p>
</div></blockquote>
<p>no_sanitize (“sanitize_option”)</p>
<blockquote>
<div><p>函数上的 no_sanitize 属性用于通知编译器，它不应对 sanitize_option 中提到的任何选项进行清理。可接受的值列表-fsanitize可以提供选项。</p>
<p>void __attribute__ ((no_sanitize (“alignment”, “object-size”)))
f () { /* 做一点事。<em>/; }
void __attribute__ ((no_sanitize (“alignment,object-size”)))
g () { /</em> 做一点事。<a href="#id138"><span class="problematic" id="id139">*</span></a>/; }</p>
</div></blockquote>
<p>no_sanitize_address
no_address_safety_analysis</p>
<blockquote>
<div><p>函数上的 no_sanitize_address 属性用于通知编译器，当使用-fsanitize=address选项。该 no_address_safety_analysis 是一个过时的别名 no_sanitize_address 属性，新的代码应该使用 no_sanitize_address 。</p>
</div></blockquote>
<p>no_sanitize_thread</p>
<blockquote>
<div><p>函数的 no_sanitize_thread 属性用于通知编译器，当使用.NET进行编译时，不应在函数中检测内存访问。-fsanitize=threadoption.</p>
</div></blockquote>
<p>no_sanitize_undefined</p>
<blockquote>
<div><p>函数上的 no_sanitize_undefined 属性用于通知编译器，当使用.NET进行编译时，不应检查函数中未定义的行为。-fsanitize=undefinedoption.</p>
</div></blockquote>
<p>no_split_stack</p>
<blockquote>
<div><p>If-fsplit-stack给定，函数有一个小的序言，它决定是否拆分堆栈。具有 no_split_stack 属性的函数没有该序言，因此只能在少量堆栈空间下运行。</p>
</div></blockquote>
<p>no_stack_limit</p>
<blockquote>
<div><p>该属性在本地覆盖了-fstack-limit-registerand-fstack-limit-symbol命令行选项;它的作用是在所应用的函数中禁用堆栈限制检查。</p>
</div></blockquote>
<p>noclone</p>
<blockquote>
<div><p>此函数属性可防止考虑将函数克隆—一种机制，该机制可生成函数的专门副本，并且（当前）由过程间常数传播来执行。</p>
</div></blockquote>
<p>noinline</p>
<blockquote>
<div><p>这个函数属性可以防止函数被考虑内联。如果函数没有副作用,那么除了内联之外,还有一些优化会导致函数调用被优化掉,虽然函数调用是活的。为了防止这类调用被优化掉,可以将</p>
<p>asm (“”);</p>
<p>（请参阅被扩展函数中的Extended Asm），以作为特殊的副作用。</p>
</div></blockquote>
<p>noipa</p>
<blockquote>
<div><p>禁用具有此属性的函数及其调用者之间的过程间优化，好像在优化调用者时函数的主体不可用，而在优化主体时调用者不可用。此属性暗含 noinline ， noclone 和 no_icf 属性。但是，此属性不等于其他属性的组合，因为它的目的是抑制使用过程间分析的现有和将来的优化，包括那些不具有适合单独禁用它们的属性的优化。支持此属性主要是为了测试编译器。</p>
</div></blockquote>
<p>nonnull
nonnull (arg-index, …)</p>
<blockquote>
<div><p>可以将 nonnull 属性应用于采用至少一个指针类型参数的函数。它指示引用的参数必须是非空指针。例如，声明：</p>
<p>extern void *
my_memcpy (void <a href="#id140"><span class="problematic" id="id141">*</span></a>dest, const void <a href="#id142"><span class="problematic" id="id143">*</span></a>src, size_t len)</p>
<blockquote>
<div><p>__attribute__((nonnull (1, 2)));</p>
</div></blockquote>
<p>使编译器在对 my_memcpy 的调用中检查 dest 和 src 参数是否为非null。如果编译器确定在标记为非空的参数插槽中传递了空指针，则-Wnonnull选项启用后，会发出警告。请参阅警告选项。除非被禁用-fno-delete-null-pointer-checks选项,编译器也可以基于某些函数参数不能为空的知识进行优化。此外,-fisolate-erroneous-paths-attribute可以指定option以使具有非空函数的空参数的GCC转换调用转换为陷阱。请参阅优化选项。</p>
<p>如果未将 arg-index 赋予 nonnull 属性，则所有指针参数都标记为non-null。为了说明这一点，下面的声明与前面的示例等效：</p>
<p>extern void *
my_memcpy (void <a href="#id144"><span class="problematic" id="id145">*</span></a>dest, const void <a href="#id146"><span class="problematic" id="id147">*</span></a>src, size_t len)</p>
<blockquote>
<div><p>__attribute__((nonnull));</p>
</div></blockquote>
</div></blockquote>
<p>noplt</p>
<blockquote>
<div><p>该 noplt 属性是对口选项-fno-plt。在与位置无关的代码中调用标有该属性的函数时，请勿使用PLT。</p>
<p>/* 外部定义的函数 foo. <a href="#id148"><span class="problematic" id="id149">*</span></a>/
int foo () __attribute__ ((noplt));</p>
<p>int
main (/* … <a href="#id150"><span class="problematic" id="id151">*</span></a>/)
{</p>
<blockquote>
<div><p>/* … <em>/
foo ();
/</em> … <a href="#id152"><span class="problematic" id="id153">*</span></a>/</p>
</div></blockquote>
<p>}</p>
<p>函数 foo 的 noplt 属性告诉编译器假定函数 foo 是在外部定义的，并且对 foo 的调用必须避免位置无关代码中的PLT。</p>
<p>在位置相关的代码中,少数目标也会将对那些标记为不使用PLT的函数的调用转换为使用GOT来代替。</p>
</div></blockquote>
<p>noreturn</p>
<blockquote>
<div><p>一些标准库函数（例如 abort 和 exit ）无法返回。GCC会自动知道这一点。一些程序定义了自己的永不返回的函数。你可以声明他们 noreturn 告诉编译器这个事实。例如，</p>
<p>void fatal () __attribute__ ((noreturn));</p>
<p>void
fatal (/* … <a href="#id154"><span class="problematic" id="id155">*</span></a>/)
{</p>
<blockquote>
<div><p>/* … <em>/ /</em> 打印错误信息。<em>/ /</em> … <a href="#id156"><span class="problematic" id="id157">*</span></a>/
exit (1);</p>
</div></blockquote>
<p>}</p>
<p>在 noreturn 关键字告诉编译器假定 fatal 不能返回。然后，它可以进行优化，而不必考虑如果 fatal 事件再次发生会发生什么情况。这使代码更好一些。更重要的是，它有助于避免对未初始化变量的虚假警告。</p>
<p>在 noreturn 一个：时适用的关键字不影响特殊路径 noreturn -marked功能仍然可以通过抛出异常或调用返回给调用者 longjmp 。</p>
<p>为了保留回溯，GCC绝不会将对 noreturn 函数的调用转换为尾调用。</p>
<p>不要假设在调用 noreturn 函数之前已恢复调用函数保存的寄存器。</p>
<p>对于 noreturn 函数，除了 void 以外，没有其他返回类型是没有意义的。</p>
</div></blockquote>
<p>nothrow</p>
<blockquote>
<div><p>在 nothrow 属性用来告诉编译器，一个函数不能抛出异常。例如，可以保证标准C库中的大多数函数都不会抛出异常，而带有函数指针参数的 qsort 和 bsearch 异常例外。</p>
</div></blockquote>
<p>optimize (level, …)
optimize (string, …)</p>
<blockquote>
<div><p>最 optimize 属性用于指定要使用与命令行上指定的优化选项不同的优化选项来编译功能。有效参数是常量非负整数和字符串。每个数字参数指定一个优化 level 。每个 string 参数均包含一个或多个逗号分隔的子字符串。以字母 O 开头的每个子字符串均指一个优化选项，例如-O0or-Os。其他子字符串作为 -f 前缀的后缀，共同构成优化选项的名称。请参阅优化选项。</p>
<p>‘#pragma GCC优化可以用于为多个功能设置优化选项。有关编译指示的详细信息，请参见功能特定的选项编译指示。</p>
<p>提供多个字符串作为用逗号分隔以指定多个选项的参数，等效于用逗号分隔选项后缀（’,’）放在单个字符串中。字符串中不允许有空格。</p>
<p>并非每个以属性指定的 -f 前缀开头的优化选项都必定会对函数产生影响。最 optimize 属性应仅用于调试目的。它不适用于生产代码。</p>
</div></blockquote>
<p>patchable_function_entry</p>
<blockquote>
<div><p>如果可以在运行时通过任何方式使目标文本段可写，则可以在函数条目中填充大量NOP，以提供一种通用的工具。</p>
<p>所述 patchable_function_entry 功能属性可以被用来NOP的数目改变到任何希望的值。二值语法与命令行开关的语法相同-fpatchable-function-entry=N,M，生成 N 个 NOP，其功能入口位于第 M 个NOP指令之前。如果省略，则 M 默认为0，例如，函数入口点在第一个NOP之前。</p>
<p>如果使用命令行选项全局启用了可打补丁的函数项-fpatchable-function-entry=N,M，则必须使用属性 patchable_function_entry (0) 禁用属于检测框架一部分的所有功能的检测，以防止递归。</p>
</div></blockquote>
<p>pure</p>
<blockquote>
<div><p>调用除返回值外对程序状态没有可观察的影响的函数可能有助于进行优化，例如消除公共子表达式。使用 pure 属性声明此类函数可以使GCC避免在重复调用具有相同参数值的函数时发出某些调用。</p>
<p>所述 pure 属性从修改是由比检查函数的返回值其它手段观察到的所述程序的状态禁止的功能。但是，使用 pure 属性声明的函数可以安全地读取任何非易失性对象，并以不影响其返回值或程序可观察状态的方式修改对象的值。</p>
<p>例如:</p>
<p>int hash (char <a href="#id158"><span class="problematic" id="id159">*</span></a>) __attribute__ ((pure));</p>
<p>告诉GCC后续的函数调用 hash 与相同的字符串可以通过第一呼叫的结果来代替所提供的程序通过可观察的状态 hash ，包括阵列本身的内容，在之间不改变。即使 hash 采用非常量指针参数，它也不得修改其指向的数组或程序其余部分可能依赖其值的任何其他对象。但是，调用者可以在连续调用该函数之间安全地更改数组的内容（这样做会禁用优化）。该限制还适用于C ++非静态成员函数中 this 指针引用的成员对象。</p>
<p>纯函数的一些常见示例是 strlen 或 memcmp 。有趣的非纯函数是具有无限循环的函数或取决于易失性内存或其他系统资源的函数，这些函数可能会在连续调用之间改变（例如，多线程环境中的标准C feof 函数）。</p>
<p>该 pure 属性规定了比一个函数的定义类似，但宽松的限制 const 属性： pure 允许函数读取任何非易失性存储器，即使在函数的连续调用之间变化。诊断使用 pure 和 const 属性声明相同的功能。由于纯函数不能具有任何可观察到的副作用，因此使此类函数返回 void 没有意义。诊断出声明了这样的功能。</p>
</div></blockquote>
<p>returns_nonnull</p>
<blockquote>
<div><p>该 returns_nonnull 属性指定函数的返回值应该是一个非空指针。例如，声明：</p>
<p>extern void *
mymalloc (size_t len) __attribute__((returns_nonnull));</p>
<p>让编译器在知道返回值永远不会为null的基础上优化调用者。</p>
</div></blockquote>
<p>returns_twice</p>
<blockquote>
<div><p>该 returns_twice 属性告诉编译器，函数可能会返回一个以上的时间。编译器确保在调用该函数之前所有寄存器均已失效，并发出有关该函数第二次返回后可能被破坏的变量的警告。此类功能的示例是 setjmp 和 vfork 。此类函数的类似 longjmp 的对应项（如果有）可能需要用 noreturn 属性标记。</p>
</div></blockquote>
<p>section (“section-name”)</p>
<blockquote>
<div><p>通常，编译器将其生成的代码放在 text 部分中。但是，有时您需要其他部分，或者需要某些特殊功能才能出现在特殊部分中。该 section 属性指定的函数生活在一个特定的部分。例如，声明：</p>
<p>extern void foobar (void) __attribute__ ((section (“bar”)));</p>
<p>将函数 foobar 放在 bar 部分中。</p>
<p>某些文件格式不支持任意节，因此 section 属性在所有平台上均不可用。如果需要将模块的全部内容映射到特定部分，请考虑改用链接器的功能。</p>
</div></blockquote>
<p>sentinel
sentinel (position)</p>
<blockquote>
<div><p>该函数属性指示函数调用中的参数应为显式 NULL 。该属性仅在可变参数函数上有效。默认情况下，前哨应该是函数调用的最后一个参数。如果为属性指定了可选的 position 参数，则前哨必须位于从参数列表的末尾开始倒数的 position 。</p>
<p>__attribute__ ((sentinel))
is equivalent to
__attribute__ ((sentinel(0)))</p>
<p>内置函数 execl 和 execlp 的位置自动设置为0 。内置函数 execle 的属性设置为位置1。</p>
<p>在任何情况下，任何对象指针类型都将有效 NULL 定义为零。如果您的系统使用整数类型定义 NULL 宏，则需要添加显式强制转换。在安装过程中，GCC将系统 &lt;stddef.h&gt; 标头替换为适当重新定义NULL的副本。</p>
<p>启用缺失或错误哨兵的警告,可使用-Wformat.</p>
</div></blockquote>
<p>simd
simd(“mask”)</p>
<blockquote>
<div><p>通过此属性，可以创建一个或多个函数版本，这些函数版本可以通过一次调用使用SIMD指令来处理多个参数。指定此属性可使编译器假定链接版本（在相同或另一个翻译单元中提供）可以使用这些版本。生成的版本取决于目标，并在相应的Vector ABI文档中进行了描述。对于x86_64目标，可以在此处找到此文档。</p>
<p>可选参数 mask 的值可以为 notinbranch 或 inbranch ，并指示编译器相应地生成非掩码或掩码的克隆。默认情况下，将生成所有克隆。</p>
<p>如果指定了属性，并且 #pragma omp declare simd 出现在声明中，并且-fopenmpor-fopenmp-simd开关,那么该属性将被忽略。</p>
</div></blockquote>
<p>stack_protect</p>
<blockquote>
<div><p>这个属性为函数添加了堆栈保护代码,如果flags-fstack-protector,-fstack-protector-strongor-fstack-protector-explicit被设定为。</p>
</div></blockquote>
<p>no_stack_protector</p>
<blockquote>
<div><p>这个属性可以防止函数的堆栈保护代码。</p>
</div></blockquote>
<p>target (string, …)</p>
<blockquote>
<div><p>多个目标后端实现了 target 属性，以指定要使用与命令行上指定的目标选项不同的函数来编译函数。可以提供一个或多个字符串作为参数。每个字符串由 -m 前缀的一个或多个逗号分隔的后缀组成，共同构成机器相关选项的名称。请参阅机器相关选项。</p>
<p>的 target 属性可以用于例如以具有与不同的ISA（指令集架构）比默认编译的函数。’#pragma GCC目标’可用于为多个功能指定特定于目标的选项。有关编译指示的详细信息，请参见功能特定的选项编译指示。</p>
<p>例如，在x86上，您可以使用 target(“sse4.1,arch=core2”) 属性声明一个函数，并使用 target(“sse4a,arch=amdfam10”) 属性声明另一个函数。这等效于使用-msse4.1and-march=core2选项,第二个函数为-msse4aand-march=amdfam10选项。您可以确保仅在支持为其编译特定ISA的计算机上调用函数（例如，通过在x86上使用 cpuid 来确定使用了哪些功能位和体系结构系列）。</p>
<p>int core2_func (void) __attribute__ ((__target__ (“arch=core2”)));
int sse3_func (void) __attribute__ ((__target__ (“sse3”)));</p>
<p>提供多个字符串作为用逗号分隔以指定多个选项的参数，等效于用逗号分隔选项后缀（’,’）放在单个字符串中。字符串中不允许有空格。</p>
<p>支持的选项特定于每个目标。有关详细信息，请参见x86功能属性，PowerPC功能属性，ARM功能属性，AArch64功能属性，Nios II功能属性和S / 390功能属性。</p>
</div></blockquote>
<p>symver (“<a class="reference external" href="mailto:name2&#37;&#52;&#48;nodename">name2<span>&#64;</span>nodename</a>”)</p>
<blockquote>
<div><p>在ELF目标上，此属性创建符号版本。参数的 name2 部分是外部引用符号的实际名称。的 nodename 部分应该是在建立一个共享库时提供给链接器版本脚本中指定的节点的名称。必须定义版本符号，并且必须使用默认可见性将其导出。</p>
<p>__attribute__ ((__symver__ (“<a class="reference external" href="mailto:foo&#37;&#52;&#48;VERS_1">foo<span>&#64;</span>VERS_1</a>”))) int
foo_v1 (void)
{
}</p>
<p>在汇编器输出 .symver foo_v1, <a class="reference external" href="mailto:foo&#37;&#52;&#48;VERS_1">foo<span>&#64;</span>VERS_1</a> 产生一个.symver foo_v1，foo &#64; VERS_1指令。</p>
<p>人们还可以为一个给定的符号定义多个版本(从binutils 2.35开始)。</p>
<p>__attribute__ ((__symver__ (“<a class="reference external" href="mailto:foo&#37;&#52;&#48;VERS_2">foo<span>&#64;</span>VERS_2</a>”), __symver__ (“<a class="reference external" href="mailto:foo&#37;&#52;&#48;VERS_3">foo<span>&#64;</span>VERS_3</a>”)))
int symver_foo_v1 (void)
{
}</p>
<p>这个例子创建一个符号名 symver_foo_v1 这将是版本 VERS_2 和 VERS_3 的 foo 。</p>
<p>如果你有一个旧版本的binutils,那么就需要使用符号别名。</p>
<p>__attribute__ ((__symver__ (“<a class="reference external" href="mailto:foo&#37;&#52;&#48;VERS_2">foo<span>&#64;</span>VERS_2</a>”)))
int foo_v1 (void)
{</p>
<blockquote>
<div><p>return 0;</p>
</div></blockquote>
<p>}</p>
<p>__attribute__ ((__symver__ (“<a class="reference external" href="mailto:foo&#37;&#52;&#48;VERS_3">foo<span>&#64;</span>VERS_3</a>”)))
__attribute__ ((alias (“foo_v1”)))
int symver_foo_v1 (void);</p>
<p>最后，如果参数为 “name2&#64;&#64;nodename” 则除了创建符号版本（就像使用了 “<a class="reference external" href="mailto:name2&#37;&#52;&#48;nodename">name2<span>&#64;</span>nodename</a>” ）之外，链接器还将使用该版本来解析 name2 。</p>
</div></blockquote>
<p>target_clones (options)</p>
<blockquote>
<div><p>所述 target_clones 属性用来指定一个函数被克隆到具有比命令行上指定不同的目标选项编译多个版本。支持的选项和限制与 target 属性相同。</p>
<p>例如，在x86上，您可以使用 target_clones(“sse4.1,avx”) 编译函数。GCC创建了两个函数克隆，其中一个用-msse4.1和另一个有-mavx.</p>
<p>在PowerPC上，可以使用 target_clones(“cpu=power9,default”) 编译函数。GCC将创建两个函数克隆，其中一个使用-mcpu=power9另一个带有默认选项。必须将GCC配置为使用GLIBC 2.23或更高版本，才能使用 target_clones 属性。</p>
<p>它还创建了一个解析器功能（请参见上面的 ifunc 属性），该功能可动态选择适合当前架构的克隆。仅当使用具有 target_clones 属性的函数时，才创建解析器。</p>
<p>请注意，随后从 target_clone 调用程序对没有 target_clone 的函数进行的任何后续调用都不会导致被调用函数的复制（目标克隆）。如果要强制执行此类行为，建议您使用 flatten 属性声明调用函数？</p>
</div></blockquote>
<p>unused</p>
<blockquote>
<div><p>这个属性附加在一个函数上,意味着这个函数可能是未被使用的。GCC不会对该函数产生警告。</p>
</div></blockquote>
<p>used</p>
<blockquote>
<div><p>这个属性,附加在一个函数上,意味着即使函数没有被引用,也必须为该函数发射代码。例如,当函数只在内联汇编中被引用时,这个属性就很有用。</p>
<p>当应用于一个C++类模板的成员函数时,该属性也意味着如果类本身被实例化,则该函数被实例化。</p>
</div></blockquote>
<p>retain</p>
<blockquote>
<div><p>对于支持 GNU 或 FreeBSD OSABI 的 ELF 目标，此属性将从链接器垃圾收集中保存该函数。为了支持这种行为，尚未放置在特定部分中的函数（例如通过 section 属性或 -ffunction-sections 选项）将被放置在新的、独特的部分中。</p>
<p>这个额外的功能需要Binutils 2.36版或更高版本。</p>
</div></blockquote>
<p>visibility (“visibility_type”)</p>
<blockquote>
<div><p>此属性影响其所附声明的链接。它可以应用于变量（请参阅“ 通用变量属性”）和类型（请参见“ 通用类型属性”）以及函数。</p>
<p>支持四个 visibility_type 值：默认，隐藏，受保护或内部可见性。</p>
<p>void __attribute__ ((visibility (“protected”)))
f () { /* 做一点事。<a href="#id160"><span class="problematic" id="id161">*</span></a>/; }
int i __attribute__ ((visibility (“hidden”)));</p>
<p>的可能值 visibility_type 对应于ELF加比的可见性设置。</p>
<p>default</p>
<blockquote>
<div><p>默认可见性是对象文件格式的正常情况。该值可用于可见性属性,以覆盖可能改变实体的假定可见性的其他选项。</p>
<p>在ELF上,默认可见性意味着声明对其他模块可见,在共享库中,意味着声明的实体可以被覆盖。</p>
<p>在达尔文上,默认可见性意味着声明对其他模块是可见的。</p>
<p>默认可见性对应于该语言中的“外部链接”。</p>
</div></blockquote>
<p>hidden</p>
<blockquote>
<div><p>隐藏可见性表明所声明的实体具有新的链接形式，我们称为“隐藏链接”。如果具有隐藏链接的对象的两个声明位于同一共享对象中，则它们引用同一对象。</p>
</div></blockquote>
<p>internal</p>
<blockquote>
<div><p>内部可见性就像隐藏的可见性一样，但是具有附加的处理器特定语义。除非psABI另行指定，否则GCC定义内部可见性是指永远不要从另一个模块调用函数。将此与隐藏函数进行比较，虽然隐藏函数不能被其他模块直接引用，但可以通过函数指针间接引用。通过指示无法从模块外部调用函数，GCC可以例如省略PIC寄存器的加载，因为已知调用函数已加载正确的值。</p>
</div></blockquote>
<p>protected</p>
<blockquote>
<div><p>受保护的可见性和默认可见性一样,只是它表明定义模块中的引用与该模块中的定义绑定。也就是说,声明的实体不能被另一个模块覆盖。</p>
</div></blockquote>
<p>在所有但不是所有ELF目标上都支持所有可见性（当汇编器支持“.visibility（伪操作）。到处都支持默认可见性。达尔文目标支持隐藏可见性。</p>
<p>可见性属性应仅适用于否则会有外部链接的声明。该属性应始终如一地应用,以便不以不同的属性设置来宣布同一实体。</p>
<p>在C++中,可见性属性既适用于类型,也适用于函数和对象,因为在C++中,类型具有链接性。一个类的可见性不能大于它的非静态数据成员类型和基,类成员默认为其类的可见性。另外,没有显式可见性的声明也仅限于其类型的可见性。</p>
<p>在C++中,你可以用可见性属性标记一个类的成员函数和静态成员变量。如果你知道一个特定的方法或静态成员变量应该只从一个共享对象中使用,那么这很有用;然后你可以将它标记为隐藏,而类的其他部分具有默认可见性。必须注意避免破坏 “一个定义规则”;例如,在没有将整个类标记为隐藏的情况下,将一个内联方法标记为隐藏通常是没有用的。</p>
<p>一个C++命名空间声明也可以有可见性属性。</p>
<p>namespace nspace1 __attribute__ ((visibility (“protected”)))
{ /* 做一点事。<a href="#id162"><span class="problematic" id="id163">*</span></a>/; }</p>
<p>此属性仅适用于特定的名称空间主体，不适用于同一名称空间的其他定义；等同于使用’#pragma GCC可见性在名称空间定义之前和之后（请参见可视性语法）。</p>
<p>在C++中,如果一个模板参数具有有限的可见性,这个限制会隐式地传播给模板实例化。否则,模板实例化和特殊化会默认为其模板的可见性。</p>
<p>如果模板和包围类都有显式可见性,则使用模板的可见性。</p>
</div></blockquote>
<p>warn_unused_result</p>
<blockquote>
<div><p>如果具有此属性的函数的调用者不使用其返回值，则 warn_unused_result 属性会导致发出警告。对于不检查结果是安全性问题还是总是有错误的函数（例如 realloc )，这很有用。</p>
<p>int fn () __attribute__ ((warn_unused_result));
int foo ()
{</p>
<blockquote>
<div><p>if (fn () &lt; 0) return -1;
fn ();
return 0;</p>
</div></blockquote>
<p>}</p>
<p>导致第5行的警告。</p>
</div></blockquote>
<p>weak</p>
<blockquote>
<div><p>所述 weak 属性使外部符号的声明被发射以弱符号，而不是全局的。尽管它也可以与非函数声明一起使用，但是这在定义可以在用户代码中覆盖的库函数时非常有用。覆盖符号必须与弱符号具有相同的类型。另外，如果它指定一个变量，它还必须具有与弱符号相同的大小和对齐方式。使用GNU汇编器和链接器时，ELF目标和a.out目标均支持弱符号。</p>
</div></blockquote>
<p>weakref
weakref (“target”)</p>
<blockquote>
<div><p>该 weakref 属性标记的声明视为弱引用。不带参数的情况下，应伴有命名目标符号的 alias 属性。或者，可以将 target 指定为 weakref 本身的参数，并命名别名的目标定义。该 target 必须具有相同类型的声明。另外，如果它指定一个变量，它还必须具有与声明相同的大小和对齐方式。无论采用哪种声明形式， weakref 都会将声明的符号隐式标记为 weak 。如果没有将 target 指定为 weakref 或 alias 的参数， weakref 相当于 weak （在这种情况下，声明可以 extern ）。</p>
<p>/* 鉴于声明： <a href="#id164"><span class="problematic" id="id165">*</span></a>/
extern int y (void);</p>
<p>/* 以下… <a href="#id166"><span class="problematic" id="id167">*</span></a>/
static int x (void) __attribute__ ((weakref (“y”)));</p>
<p>/* 相当于… <a href="#id168"><span class="problematic" id="id169">*</span></a>/
static int x (void) __attribute__ ((weakref, alias (“y”)));</p>
<p>/* 或者，或者，到… <a href="#id170"><span class="problematic" id="id171">*</span></a>/
static int x (void) __attribute__ ((weakref));
static int x (void) __attribute__ ((alias (“y”)));</p>
<p>弱引用是一种别名，它本身不需要为目标符号给出定义。如果仅通过弱引用来引用目标符号，则它将变为 weak 未定义符号。但是，如果直接引用，则以此类引用为准，并且需要对符号进行定义，而不必在同一翻译单元中进行定义。</p>
<p>效果等同于将对别名的所有引用移动到单独的翻译单元，将别名重命名为别名符号，声明别名为弱符号，编译两个单独的翻译单元，并执行具有可重定位输出（即 ld -r ）的链接。他们。</p>
<p>附加了 weakref 并且与命名 target 相关联的声明必须为 static 。</p>
</div></blockquote>
<p>zero_call_used_regs (“choice”)</p>
<blockquote>
<div><p>所述 zero_call_used_regs 属性使编译为零所有呼叫中使用的寄存器的子集7在函数返回。这用于通过减轻面向返回编程 (ROP) 攻击或防止信息通过寄存器泄漏来提高程序安全性。</p>
<p>为了满足用户不同的安全需求，同时控制运行时的开销， choice 参数提供了一种灵活的方式来选择要清零的调用使用寄存器的子集。 choice 的三个基本值是：</p>
<blockquote>
<div><p>‘skip’ 不会将任何调用使用的寄存器归零。
‘used’ 仅将函数中使用的调用使用的寄存器清零。“已使用”寄存器是其内容已在函数中设置或引用的寄存器。
‘all’ 将所有调用使用的寄存器归零。</p>
</div></blockquote>
<p>除了这三个基本选择之外，还可以修改 ‘used’ 要么 ‘all’ 如下：</p>
<blockquote>
<div><p>Adding ‘-gpr’ 将归零限制为通用寄存器。
Adding ‘-arg’ 将归零限制为有时可用于传递函数参数的寄存器。这包括平台调用转换定义的所有参数寄存器，无论函数是否将这些寄存器用于函数参数。</p>
</div></blockquote>
<p>这些修饰语可以单独使用,也可以一起使用。如果它们一起使用,它们必须按上述顺序出现。</p>
<p>因此， choice s的完整列表是：</p>
<p>skip</p>
<blockquote>
<div><p>不会将任何调用使用的寄存器归零。</p>
</div></blockquote>
<p>used</p>
<blockquote>
<div><p>只有在函数中使用的调用使用的寄存器被清零。</p>
</div></blockquote>
<p>used-gpr</p>
<blockquote>
<div><p>只将函数中使用的调用通用寄存器清零。</p>
</div></blockquote>
<p>used-arg</p>
<blockquote>
<div><p>只将函数中使用的调用使用的寄存器清零,并传递参数。</p>
</div></blockquote>
<p>used-gpr-arg</p>
<blockquote>
<div><p>只将函数中使用的调用通用寄存器清零,并传递参数。</p>
</div></blockquote>
<p>all</p>
<blockquote>
<div><p>将所有调用使用的寄存器清零。</p>
</div></blockquote>
<p>all-gpr</p>
<blockquote>
<div><p>将所有调用使用的通用寄存器清零。</p>
</div></blockquote>
<p>all-arg</p>
<blockquote>
<div><p>将所有传递参数的调用使用的寄存器清零。</p>
</div></blockquote>
<p>all-gpr-arg</p>
<blockquote>
<div><p>将所有调用使用的、传递参数的通用寄存器清零。</p>
</div></blockquote>
<p>在这份名单中，’used-arg’，’used-gpr-arg’，’all-arg’和’all-gpr-arg’ 主要用于 ROP 缓解。</p>
<p>该属性的默认值由-fzero-call-used-regs.</p>
</div></blockquote>
<p>Footnotes
(7)</p>
<p>“调用使用”寄存器是一个可以通过函数调用改变其内容的寄存器；因此，调用者不能假设该寄存器在从函数返回时具有与调用该函数之前相同的内容。此类寄存器也称为“调用破坏”、“调用者保存”或“易失性”。</p>
</div>
<div class="section" id="bpf">
<h3>BPF功能属性<a class="headerlink" href="#bpf" title="Permalink to this headline">¶</a></h3>
<p>这些功能属性由BPF后端支持。</p>
<p>kernel_helper</p>
<blockquote>
<div><p>使用这个属性来表示指定的函数声明是一个内核帮助器。辅助函数被作为参数传递给该属性。例子。</p>
<dl class="simple">
<dt>int bpf_probe_read (void <a href="#id172"><span class="problematic" id="id173">*</span></a>dst, int size, const void <a href="#id174"><span class="problematic" id="id175">*</span></a>unsafe_ptr)</dt><dd><p>__attribute__ ((kernel_helper (4)));</p>
</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="id176">
<h3>x86函数属性<a class="headerlink" href="#id176" title="Permalink to this headline">¶</a></h3>
<p>这些函数属性由x86后端支持。</p>
<p>cdecl</p>
<blockquote>
<div><p>在x86-32目标上， cdecl 属性使编译器假定调用函数弹出用于传递参数的堆栈空间。这对于覆盖-mrtdswitch.</p>
</div></blockquote>
<p>fastcall</p>
<blockquote>
<div><p>在x86-32目标上， fastcall 属性使编译器在寄存器ECX中传递第一个参数（如果是整数类型），在寄存器EDX中传递第二个参数（如果是整数类型）。后续和其他类型的参数在堆栈上传递。被调用函数将参数弹出堆栈。如果参数数量可变，则所有参数都将压入堆栈。</p>
</div></blockquote>
<p>thiscall</p>
<blockquote>
<div><p>在x86-32目标上， thiscall 属性使编译器在寄存器ECX中传递第一个参数（如果是整数类型）。后续和其他类型的参数在堆栈上传递。被调用函数将参数弹出堆栈。如果参数数量可变，则所有参数都将压入堆栈。所述 thiscall 属性是用于C ++非静态成员函数。作为GCC扩展，此调用约定可用于C函数和静态成员方法。</p>
</div></blockquote>
<p>ms_abi
sysv_abi</p>
<blockquote>
<div><p>在 32 位和 64 位 x86 目标上，您可以使用 ABI 属性来指示函数应使用哪种调用约定。该 ms_abi 属性告诉编译器使用Microsoft ABI，而 sysv_abi 属性告诉编译器使用System V的ELF ABI，这是在GNU / Linux和其他系统中使用。默认是在面向 Windows 时使用 Microsoft ABI。在所有其他系统上，默认值为 System V ELF ABI。</p>
<p>请注意，Microsoft Windows 64位目标的 ms_abi 属性当前需要-maccumulate-outgoing-argsoption.</p>
</div></blockquote>
<p>callee_pop_aggregate_return (number)</p>
<blockquote>
<div><p>在x86-32目标上，可以使用此属性来控制如何在内存中返回聚合。如果调用方负责将隐藏的指针与其余参数一起弹出，请指定 number 等于零。如果被叫方是负责弹出隐藏的指针，指定 number 等于一。</p>
<p>默认的x86-32 ABI假设被调用者弹出堆栈以获得隐藏的指针。然而,在x86-32 Microsoft Windows目标上,编译器假设调用者会弹出栈中的隐藏指针。</p>
</div></blockquote>
<p>ms_hook_prologue</p>
<blockquote>
<div><p>在32位和64位x86目标上，可以使用此函数属性使GCC生成Microsoft Windows XP Service Pack 2和更高版本的Win32 API函数中使用的“热补丁”函数序言。</p>
</div></blockquote>
<p>naked</p>
<blockquote>
<div><p>该属性允许编译器构造必要的函数声明，同时允许函数主体为汇编代码。指定的函数将没有编译器生成的序言/结尾序列。裸函数中只能安全地包含基本的 asm 语句（请参见Basic Asm）。虽然使用扩展 asm 或基本 asm 与C代码的混合似乎可以工作，但是不能依靠它们可靠地工作并且不受支持。</p>
</div></blockquote>
<p>regparm (number)</p>
<blockquote>
<div><p>在x86-32目标上，如果 regparm 属性在寄存器EAX，EDX和ECX中为整数类型，而不是在堆栈上，则regparm属性使编译器将第一参数传递给 number 。带有可变数量参数的函数将继续在堆栈上传递其所有参数。</p>
<p>要注意的是,在某些ELF系统中,这个属性不适合使用懒惰绑定(默认)的共享库中的全局函数。懒惰绑定会通过加载器中的解析代码发送第一次调用,这可能会假设 EAX、EDX 和 ECX 可以被 clobbered,按照标准调用惯例。Solaris 8 受此影响。使用 GNU C 库 2.1 或更高版本的系统和 FreeBSD 被认为是安全的,因为那里的加载器会保存 EAX、EDX 和 ECX。(如果需要的话,可以通过链接器或加载器禁用懒惰绑定,以避免这个问题。)</p>
</div></blockquote>
<p>sseregparm</p>
<blockquote>
<div><p>在具有SSE支持的x86-32目标上， sseregparm 属性使编译器在SSE寄存器中而不是堆栈中最多传递3个浮点参数。带有可变数量参数的函数将继续在堆栈上传递其所有浮点参数。</p>
</div></blockquote>
<p>force_align_arg_pointer</p>
<blockquote>
<div><p>在x86目标上，可以将 force_align_arg_pointer 属性应用于单个函数定义，从而生成备用的序言和结尾，以在必要时重新对齐运行时堆栈。这支持将以4字节对齐的堆栈运行的旧代码与保留16字节堆栈的现代代码混合在一起以实现SSE兼容性。</p>
</div></blockquote>
<p>stdcall</p>
<blockquote>
<div><p>在x86-32目标上， stdcall 属性使编译器假定被调用函数弹出用于传递参数的堆栈空间，除非它采用可变数量的参数。</p>
</div></blockquote>
<p>no_caller_saved_registers</p>
<blockquote>
<div><p>使用此属性指示指定的函数没有调用者保存的寄存器。也就是说，所有寄存器都被保存了被调用者。例如，此属性可用于从中断处理程序调用的函数。编译器会生成适当的函数进入和退出序列，以保存和恢复除EFLAGS寄存器外的所有已修改寄存器。由于GCC不会保留SSE，MMX或x87状态，因此GCC选项-mgeneral-regs-only应该用于编译具有 no_caller_saved_registers 属性的函数。</p>
</div></blockquote>
<p>interrupt</p>
<blockquote>
<div><p>使用此属性指示指定的函数是中断处理程序还是异常处理程序（取决于传递给该函数的参数，进一步说明）。存在此属性时，编译器会生成适合在中断处理程序中使用的函数进入和退出序列。在 IRET 指令，代替的 RET 指令，用于从中断处理程序返回。除由 IRET 指令恢复的EFLAGS寄存器外，所有寄存器均由编译器保留。由于GCC不会保留SSE，MMX或x87状态，因此GCC选项-mgeneral-regs-only应用于编译中断和异常处理程序。</p>
<p>任何无堆栈开关的可中断代码都必须用以下方法编译-mno-red-zone因为中断处理程序由于硬件设计的原因,可以也会触及红色区域。</p>
<p>中断处理程序必须声明一个强制性的指针参数。</p>
<p>struct interrupt_frame;</p>
<p>__attribute__ ((interrupt))
void
f (struct interrupt_frame <a href="#id177"><span class="problematic" id="id178">*</span></a>frame)
{
}</p>
<p>并且您必须按照处理器手册中的说明定义 struct interrupt_frame 。</p>
<p>异常处理程序与中断处理程序不同，因为系统将错误代码压入堆栈。异常处理程序的声明与中断处理程序的声明相似，但是具有不同的强制性函数签名。编译器安排在 IRET 指令之前从堆栈弹出错误代码。</p>
<p>#ifdef __x86_64__
typedef unsigned long long int uword_t;
#else
typedef unsigned int uword_t;
#endif</p>
<p>struct interrupt_frame;</p>
<p>__attribute__ ((interrupt))
void
f (struct interrupt_frame <a href="#id179"><span class="problematic" id="id180">*</span></a>frame, uword_t error_code)
{</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p>}</p>
<p>异常处理程序只能用于推送错误代码的异常,在其他情况下应该使用中断处理程序。如果使用了错误的处理程序,系统会崩溃。</p>
</div></blockquote>
<p>target (options)</p>
<blockquote>
<div><p>如“ 公共功能属性”中所述，此属性允许指定特定于目标的编译选项。</p>
<p>在x86上,允许使用以下选项:</p>
<p>‘3dnow’
‘no-3dnow’</p>
<blockquote>
<div><p>启用/禁用3DNow!指令的生成。</p>
</div></blockquote>
<p>‘3dnowa’
‘no-3dnowa’</p>
<blockquote>
<div><p>启用/禁用生成增强型3DNow!指令。</p>
</div></blockquote>
<p>‘abm’
‘no-abm’</p>
<blockquote>
<div><p>启用/禁用高级位指令的生成。</p>
</div></blockquote>
<p>‘adx’
‘no-adx’</p>
<blockquote>
<div><p>启用/禁用ADX指令的生成。</p>
</div></blockquote>
<p>‘aes’
‘no-aes’</p>
<blockquote>
<div><p>启用/禁用AES指令的生成。</p>
</div></blockquote>
<p>‘avx’
‘no-avx’</p>
<blockquote>
<div><p>启用/禁用AVX指令的生成。</p>
</div></blockquote>
<p>‘avx2’
‘no-avx2’</p>
<blockquote>
<div><p>启用/禁用AVX2指令的生成。</p>
</div></blockquote>
<p>‘avx5124fmaps’
‘no-avx5124fmaps’</p>
<blockquote>
<div><p>启用/禁用AVX5124FMAPS指令的生成。</p>
</div></blockquote>
<p>‘avx5124vnniw’
‘no-avx5124vnniw’</p>
<blockquote>
<div><p>启用/禁用AVX5124VNNIW指令的生成。</p>
</div></blockquote>
<p>‘avx512bitalg’
‘no-avx512bitalg’</p>
<blockquote>
<div><p>启用/禁用AVX512BITALG指令的生成。</p>
</div></blockquote>
<p>‘avx512bw’
‘no-avx512bw’</p>
<blockquote>
<div><p>启用/禁用AVX512BW指令的生成。</p>
</div></blockquote>
<p>‘avx512cd’
‘no-avx512cd’</p>
<blockquote>
<div><p>启用/禁用AVX512CD指令的生成。</p>
</div></blockquote>
<p>‘avx512dq’
‘no-avx512dq’</p>
<blockquote>
<div><p>启用/禁用AVX512DQ指令的生成。</p>
</div></blockquote>
<p>‘avx512er’
‘no-avx512er’</p>
<blockquote>
<div><p>启用/禁用AVX512ER指令的生成。</p>
</div></blockquote>
<p>‘avx512f’
‘no-avx512f’</p>
<blockquote>
<div><p>启用/禁用AVX512F指令的生成。</p>
</div></blockquote>
<p>‘avx512ifma’
‘no-avx512ifma’</p>
<blockquote>
<div><p>启用/禁用AVX512IFMA指令的生成。</p>
</div></blockquote>
<p>‘avx512pf’
‘no-avx512pf’</p>
<blockquote>
<div><p>启用/禁用AVX512PF指令的生成。</p>
</div></blockquote>
<p>‘avx512vbmi’
‘no-avx512vbmi’</p>
<blockquote>
<div><p>启用/禁用AVX512VBMI指令的生成。</p>
</div></blockquote>
<p>‘avx512vbmi2’
‘no-avx512vbmi2’</p>
<blockquote>
<div><p>启用/禁用AVX512VBMI2指令的生成。</p>
</div></blockquote>
<p>‘avx512vl’
‘no-avx512vl’</p>
<blockquote>
<div><p>启用/禁用AVX512VL指令的生成。</p>
</div></blockquote>
<p>‘avx512vnni’
‘no-avx512vnni’</p>
<blockquote>
<div><p>启用/禁用AVX512VNNI指令的生成。</p>
</div></blockquote>
<p>‘avx512vpopcntdq’
‘no-avx512vpopcntdq’</p>
<blockquote>
<div><p>启用/禁用AVX512VPOPCNTDQ指令的生成。</p>
</div></blockquote>
<p>‘bmi’
‘no-bmi’</p>
<blockquote>
<div><p>启用/禁用BMI指令的生成。</p>
</div></blockquote>
<p>‘bmi2’
‘no-bmi2’</p>
<blockquote>
<div><p>启用/禁用BMI2指令的生成。</p>
</div></blockquote>
<p>‘cldemote’
‘no-cldemote’</p>
<blockquote>
<div><p>开启/关闭CLDEMOTE指令的生成。</p>
</div></blockquote>
<p>‘clflushopt’
‘no-clflushopt’</p>
<blockquote>
<div><p>开启/关闭CLFLUSHOPT指令的生成。</p>
</div></blockquote>
<p>‘clwb’
‘no-clwb’</p>
<blockquote>
<div><p>启用/禁用CLWB指令的生成。</p>
</div></blockquote>
<p>‘clzero’
‘no-clzero’</p>
<blockquote>
<div><p>开启/关闭CLZERO指令的生成。</p>
</div></blockquote>
<p>‘crc32’
‘no-crc32’</p>
<blockquote>
<div><p>启用/禁用CRC32指令的生成。</p>
</div></blockquote>
<p>‘cx16’
‘no-cx16’</p>
<blockquote>
<div><p>启用/禁用CMPXCHG16B指令的生成。</p>
</div></blockquote>
<p>‘default’</p>
<blockquote>
<div><p>请参阅函数多版本化，用于指定默认函数版本。</p>
</div></blockquote>
<p>‘f16c’
‘no-f16c’</p>
<blockquote>
<div><p>启用/禁用F16C指令的生成。</p>
</div></blockquote>
<p>‘fma’
‘no-fma’</p>
<blockquote>
<div><p>启用/禁用FMA指令的生成。</p>
</div></blockquote>
<p>‘fma4’
‘no-fma4’</p>
<blockquote>
<div><p>启用/禁用FMA4指令的生成。</p>
</div></blockquote>
<p>‘fsgsbase’
‘no-fsgsbase’</p>
<blockquote>
<div><p>启用/禁用FSGSBASE指令的生成。</p>
</div></blockquote>
<p>‘fxsr’
‘no-fxsr’</p>
<blockquote>
<div><p>启用/禁用FXSR指令的生成。</p>
</div></blockquote>
<p>‘gfni’
‘no-gfni’</p>
<blockquote>
<div><p>启用/禁用GFNI指令的生成。</p>
</div></blockquote>
<p>‘hle’
‘no-hle’</p>
<blockquote>
<div><p>启用/禁用HLE指令前缀的生成。</p>
</div></blockquote>
<p>‘lwp’
‘no-lwp’</p>
<blockquote>
<div><p>开启/关闭LWP指令的生成。</p>
</div></blockquote>
<p>‘lzcnt’
‘no-lzcnt’</p>
<blockquote>
<div><p>启用/禁用LZCNT指令的生成。</p>
</div></blockquote>
<p>‘mmx’
‘no-mmx’</p>
<blockquote>
<div><p>启用/禁用MMX指令的生成。</p>
</div></blockquote>
<p>‘movbe’
‘no-movbe’</p>
<blockquote>
<div><p>启用/禁用MOVBE指令的生成。</p>
</div></blockquote>
<p>‘movdir64b’
‘no-movdir64b’</p>
<blockquote>
<div><p>启用/禁用MOVDIR64B指令的生成。</p>
</div></blockquote>
<p>‘movdiri’
‘no-movdiri’</p>
<blockquote>
<div><p>启用/禁用MOVDIRI指令的生成。</p>
</div></blockquote>
<p>‘mwaitx’
‘no-mwaitx’</p>
<blockquote>
<div><p>启用/禁用MWAITX指令的生成。</p>
</div></blockquote>
<p>‘pclmul’
‘no-pclmul’</p>
<blockquote>
<div><p>启用/禁用PCLMUL指令的生成。</p>
</div></blockquote>
<p>‘pconfig’
‘no-pconfig’</p>
<blockquote>
<div><p>开启或关闭PCONFIG指令的生成。</p>
</div></blockquote>
<p>‘pku’
‘no-pku’</p>
<blockquote>
<div><p>启用/禁用PKU指令的生成。</p>
</div></blockquote>
<p>‘popcnt’
‘no-popcnt’</p>
<blockquote>
<div><p>启用/禁用POPCNT指令的生成。</p>
</div></blockquote>
<p>‘prefetchwt1’
‘no-prefetchwt1’</p>
<blockquote>
<div><p>开启/关闭PREFETCHWT1指令的生成。</p>
</div></blockquote>
<p>‘prfchw’
‘no-prfchw’</p>
<blockquote>
<div><p>开启或关闭PREFETCHW指令的生成。</p>
</div></blockquote>
<p>‘ptwrite’
‘no-ptwrite’</p>
<blockquote>
<div><p>启用/禁用PTWRITE指令的生成。</p>
</div></blockquote>
<p>‘rdpid’
‘no-rdpid’</p>
<blockquote>
<div><p>启用/禁用RDPID指令的生成。</p>
</div></blockquote>
<p>‘rdrnd’
‘no-rdrnd’</p>
<blockquote>
<div><p>启用/禁用RDRND指令的生成。</p>
</div></blockquote>
<p>‘rdseed’
‘no-rdseed’</p>
<blockquote>
<div><p>启用/禁用RDSEED指令的生成。</p>
</div></blockquote>
<p>‘rtm’
‘no-rtm’</p>
<blockquote>
<div><p>启用/禁用RTM指令的生成。</p>
</div></blockquote>
<p>‘sahf’
‘no-sahf’</p>
<blockquote>
<div><p>启用/禁用SAHF指令的生成。</p>
</div></blockquote>
<p>‘sgx’
‘no-sgx’</p>
<blockquote>
<div><p>启用/禁用SGX指令的生成。</p>
</div></blockquote>
<p>‘sha’
‘no-sha’</p>
<blockquote>
<div><p>启用/禁用SHA指令的生成。</p>
</div></blockquote>
<p>‘shstk’
‘no-shstk’</p>
<blockquote>
<div><p>开启/关闭CET的影子栈内置功能。</p>
</div></blockquote>
<p>‘sse’
‘no-sse’</p>
<blockquote>
<div><p>启用/禁用SSE指令的生成。</p>
</div></blockquote>
<p>‘sse2’
‘no-sse2’</p>
<blockquote>
<div><p>启用/禁用SSE2指令的生成。</p>
</div></blockquote>
<p>‘sse3’
‘no-sse3’</p>
<blockquote>
<div><p>启用/禁用SSE3指令的生成。</p>
</div></blockquote>
<p>‘sse4’
‘no-sse4’</p>
<blockquote>
<div><p>启用/禁用SSE4指令的生成(包括SSE4.1和SSE4.2)。</p>
</div></blockquote>
<p>‘sse4.1’
‘no-sse4.1’</p>
<blockquote>
<div><p>开启/关闭SSE4.1指令的生成。</p>
</div></blockquote>
<p>‘sse4.2’
‘no-sse4.2’</p>
<blockquote>
<div><p>开启/关闭SSE4.2指令的生成。</p>
</div></blockquote>
<p>‘sse4a’
‘no-sse4a’</p>
<blockquote>
<div><p>启用/禁用SSE4A指令的生成。</p>
</div></blockquote>
<p>‘ssse3’
‘no-ssse3’</p>
<blockquote>
<div><p>启用/禁用SSSE3指令的生成。</p>
</div></blockquote>
<p>‘tbm’
‘no-tbm’</p>
<blockquote>
<div><p>启用/禁用TBM指令的生成。</p>
</div></blockquote>
<p>‘vaes’
‘no-vaes’</p>
<blockquote>
<div><p>开启/关闭VAES指令的生成。</p>
</div></blockquote>
<p>‘vpclmulqdq’
‘no-vpclmulqdq’</p>
<blockquote>
<div><p>启用/禁用VPCLMULQDQ指令的生成。</p>
</div></blockquote>
<p>‘waitpkg’
‘no-waitpkg’</p>
<blockquote>
<div><p>开启/关闭WAITPKG指令的生成。</p>
</div></blockquote>
<p>‘wbnoinvd’
‘no-wbnoinvd’</p>
<blockquote>
<div><p>开启/关闭WBNOINVD指令的生成。</p>
</div></blockquote>
<p>‘xop’
‘no-xop’</p>
<blockquote>
<div><p>启用/禁用XOP指令的生成。</p>
</div></blockquote>
<p>‘xsave’
‘no-xsave’</p>
<blockquote>
<div><p>启用/禁用XSAVE指令的生成。</p>
</div></blockquote>
<p>‘xsavec’
‘no-xsavec’</p>
<blockquote>
<div><p>启用/禁用XSAVEC指令的生成。</p>
</div></blockquote>
<p>‘xsaveopt’
‘no-xsaveopt’</p>
<blockquote>
<div><p>开启/关闭XSAVEOPT指令的生成。</p>
</div></blockquote>
<p>‘xsaves’
‘no-xsaves’</p>
<blockquote>
<div><p>开启/关闭XSAVES指令的生成。</p>
</div></blockquote>
<p>‘amx-tile’
‘no-amx-tile’</p>
<blockquote>
<div><p>启用/禁用AMX-TILE指令的生成。</p>
</div></blockquote>
<p>‘amx-int8’
‘no-amx-int8’</p>
<blockquote>
<div><p>启用/禁用AMX-INT8指令的生成。</p>
</div></blockquote>
<p>‘amx-bf16’
‘no-amx-bf16’</p>
<blockquote>
<div><p>启用/禁用AMX-BF16指令的生成。</p>
</div></blockquote>
<p>‘uintr’
‘no-uintr’</p>
<blockquote>
<div><p>启用/禁用UINTR指令的生成。</p>
</div></blockquote>
<p>‘hreset’
‘no-hreset’</p>
<blockquote>
<div><p>启用/禁用HRESET指令的生成。</p>
</div></blockquote>
<p>‘kl’
‘no-kl’</p>
<blockquote>
<div><p>启用/禁用KEYLOCKER指令的生成。</p>
</div></blockquote>
<p>‘widekl’
‘no-widekl’</p>
<blockquote>
<div><p>启用/禁用WIDEKL指令的生成。</p>
</div></blockquote>
<p>‘avxvnni’
‘no-avxvnni’</p>
<blockquote>
<div><p>启用/禁用AVXVNNI指令的生成。</p>
</div></blockquote>
<p>‘cld’
‘no-cld’</p>
<blockquote>
<div><p>开启/关闭在字符串移动前生成CLD的功能。</p>
</div></blockquote>
<p>‘fancy-math-387’
‘no-fancy-math-387’</p>
<blockquote>
<div><p>在387浮点单元上启用/禁用 sin ， cos 和 sqrt 指令的生成。</p>
</div></blockquote>
<p>‘ieee-fp’
‘no-ieee-fp’</p>
<blockquote>
<div><p>开启/关闭依赖于IEEE算术的浮点数的生成。</p>
</div></blockquote>
<p>‘inline-all-stringops’
‘no-inline-all-stringops’</p>
<blockquote>
<div><p>开启/关闭字符串操作的内联。</p>
</div></blockquote>
<p>‘inline-stringops-dynamically’
‘no-inline-stringops-dynamically’</p>
<blockquote>
<div><p>开启/关闭内联代码的生成,进行小的字符串操作和调用库例程进行大的操作。</p>
</div></blockquote>
<p>‘align-stringops’
‘no-align-stringops’</p>
<blockquote>
<div><p>做/不对齐内联字符串操作的目标。</p>
</div></blockquote>
<p>‘recip’
‘no-recip’</p>
<blockquote>
<div><p>启用/禁用RCPSS、RCPPS、RSQRTSS和RSQRTPS指令的生成,这些指令遵循额外的Newton-Raphson步骤,而不是做浮点除法。</p>
</div></blockquote>
<p>‘general-regs-only’</p>
<blockquote>
<div><p>生成只使用一般寄存器的代码。</p>
</div></blockquote>
<p>‘arch=ARCH’</p>
<blockquote>
<div><p>指定编译函数时要生成代码的架构。</p>
</div></blockquote>
<p>‘tune=TUNE’</p>
<blockquote>
<div><p>指定编译函数时要调整的架构。</p>
</div></blockquote>
<p>‘fpmath=FPMATH’</p>
<blockquote>
<div><p>指定要使用的浮点单位。您必须将 target(“fpmath=sse,387”) 选项指定为 target(“fpmath=sse+387”) 因为逗号会分隔不同的选项。</p>
</div></blockquote>
<p>‘prefer-vector-width=OPT’</p>
<blockquote>
<div><p>在 x86 目标上， prefer-vector-width 属性通知编译器在指令中使用 OPT 位向量宽度，而不是所选平台上的默认值。</p>
<p>有效的 OPT 值为：</p>
<p>‘none’</p>
<blockquote>
<div><p>除所选平台定义的限制外,GCC不适用额外的限制。</p>
</div></blockquote>
<p>‘128’</p>
<blockquote>
<div><p>优先选择128位向量宽度的指令。</p>
</div></blockquote>
<p>‘256’</p>
<blockquote>
<div><p>优先选择256位向量宽度的指令。</p>
</div></blockquote>
<p>‘512’</p>
<blockquote>
<div><p>优先选择512位向量宽度的指令。</p>
</div></blockquote>
<p>在x86上，内联函数不会内联具有与调用者不同的目标选项的函数，除非被调用者具有调用者的目标选项的子集。例如，用 target(“sse3”) 声明的函数可以用-target target(“sse2”) 内联函数，因为 -msse3 意味着 -msse2 。</p>
</div></blockquote>
</div></blockquote>
<p>indirect_branch(“choice”)</p>
<blockquote>
<div><p>在x86目标上， indirect_branch 属性使编译器转换间接调用并使用 choice 跳转。’keep’保持间接调用，并且跳转保持不变。’thunk’转换间接调用并跳转到调用并返回thunk。’thunk-inline’转换间接调用并跳转到内联调用并返回thunk。’thunk-extern’将间接调用转换为外部调用并跳转到单独的目标文件中提供的thunk。</p>
</div></blockquote>
<p>function_return(“choice”)</p>
<blockquote>
<div><p>在x86目标上， function_return 属性使编译器使用 choice 转换函数return 。’keep’使函数返回保持不变。’thunk’将函数return转换为call并返回thunk。’thunk-inline’将函数return转换为内联调用并返回thunk。’thunk-extern’将函数return转换为外部调用，并返回单独对象文件中提供的thunk。</p>
</div></blockquote>
<p>nocf_check</p>
<blockquote>
<div><p>函数的 nocf_check 属性用于通知编译器，当使用-fcf-protection=branch选项。编译器假定函数的地址是控制流传输的有效目标。</p>
<p>函数指针类型上的 nocf_check 属性用于通知编译器，当使用-fcf-protection=branch选项。编译器假定来自指针的函数地址是控制流传输的有效目标。通过函数名称进行的直接函数调用被认为是安全的调用，因此编译器不对直接调用进行检测。</p>
<p>所述 nocf_check 属性应用于一个对象的类型。如果将一个函数地址或一个函数指针分配给另一个指针，则该属性不会从右侧对象的类型继承。左侧对象的类型保持不变。编译器检查 nocf_check 属性是否不匹配，并在不匹配的情况下报告警告。</p>
<p>{
int foo (void) __attribute__(nocf_check);
void (<a href="#id181"><span class="problematic" id="id182">*</span></a>foo1)(void) __attribute__(nocf_check);
void (<a href="#id183"><span class="problematic" id="id184">*</span></a>foo2)(void);</p>
<p>/* foo 的地址被认为是有效的。<a href="#id185"><span class="problematic" id="id186">*</span></a>/
int
foo (void)</p>
<blockquote>
<div><p>/* 不检查此调用站点的控制流有效性。<a href="#id187"><span class="problematic" id="id188">*</span></a>/
(<a href="#id189"><span class="problematic" id="id190">*</span></a>foo1)();</p>
<p>/* 发出关于属性不匹配的警告。<a href="#id191"><span class="problematic" id="id192">*</span></a>/
foo1 = foo2;</p>
<p>/* 此调用站点仍未检查。<a href="#id193"><span class="problematic" id="id194">*</span></a>/
(<a href="#id195"><span class="problematic" id="id196">*</span></a>foo1)();</p>
<p>/* 检查此调用站点。<a href="#id197"><span class="problematic" id="id198">*</span></a>/
(<a href="#id199"><span class="problematic" id="id200">*</span></a>foo2)();</p>
<p>/* 发出关于属性不匹配的警告。<a href="#id201"><span class="problematic" id="id202">*</span></a>/
foo2 = foo1;</p>
<p>/* 这个调用站点仍然被检查。<a href="#id203"><span class="problematic" id="id204">*</span></a>/
(<a href="#id205"><span class="problematic" id="id206">*</span></a>foo2)();</p>
<p>return 0;</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>cf_check</p>
<blockquote>
<div><p>函数上的 cf_check 属性用于通知编译器在以下情况下应将ENDBR指令放置在函数条目中：-fcf-protection=branch启用。</p>
</div></blockquote>
<p>indirect_return</p>
<blockquote>
<div><p>所述 indirect_return 属性可以被应用于一个函数，以及变量或函数指针的类型通知编译器该功能可以经由间接分支返回。</p>
</div></blockquote>
<p>fentry_name(“name”)</p>
<blockquote>
<div><p>在x86目标上， fentry_name 属性将功能设置为在启用了功能检测时调用功能条目-pg -mfentry。当 name 为nop时，将生成一个5字节的nop序列。</p>
</div></blockquote>
<p>fentry_section(“name”)</p>
<blockquote>
<div><p>在x86目标上， fentry_section 属性设置该节的名称，以在启用以下命令时记录函数条目检测调用-pg -mrecord-mcount</p>
</div></blockquote>
</div>
</div>
<div class="section" id="id207">
<h2>指定变量的属性<a class="headerlink" href="#id207" title="Permalink to this headline">¶</a></h2>
<p>关键字 __attribute__ 允许您指定变量，函数参数或结构，联合以及在C ++中的类成员的特殊属性。该 __attribute__ 关键字后跟一个用双括号括起来的属性规范。当前通常为变量定义一些属性。为特定目标系统上的变量定义了其他属性。其他属性可用于函数（请参见函数属性），标签（请参见Label Attributes），枚举器（请参见Enumerator Attributes），语句（请参见Statement Attributes）和类型（请参见Type Attributes）。其他前端可能会定义更多属性（请参阅C ++语言的扩展）。</p>
<div class="section" id="id208">
<h3>通用变量属性<a class="headerlink" href="#id208" title="Permalink to this headline">¶</a></h3>
<p>大多数目标都支持以下属性:</p>
<p>alias (“target”)</p>
<blockquote>
<div><p>的 alias 变量属性促使声明被发射以用于已知为另一符号的别名的别名目标。除顶级限定符外，别名目标必须与别名具有相同的类型。例如，以下</p>
<p>int var_target;
extern int __attribute__ ((alias (“var_target”))) var_alias;</p>
<p>将 var_alias 定义为 var_target 变量的别名。</p>
<p>如果别名目标与别名不在同一个翻译单元中定义,则是一个错误。</p>
<p>请注意,在没有属性的情况下,GCC假定带有外部链接的不同声明表示不同的对象。在没有声明别名属性的翻译单元中,使用别名和别名目标来访问同一个对象是没有定义的。</p>
<p>这个属性需要汇编器和对象文件的支持,并不是所有目标都能使用。</p>
</div></blockquote>
<p>aligned
aligned (alignment)</p>
<blockquote>
<div><p>所述 aligned 属性指定以字节为单位对所述可变或结构字段一个最小对齐。指定时， alignment 必须是2的整数常数幂。不指定 alignment 参数就意味着目标的最大对齐方式，这通常（但并非总是）为8或16个字节。</p>
<p>例如,声明:</p>
<p>int x __attribute__ ((aligned (16))) = 0;</p>
<p>使编译器在16字节边界上分配全局变量 x 。在68040上，可以将它与 asm 表达式结合使用，以访问需要16字节对齐操作数的 move16 指令。</p>
<p>您还可以指定结构字段的对齐方式。例如，要创建一个双字对齐的 int 对，可以编写：</p>
<p>struct foo { int x[2] __attribute__ ((aligned (8))); };</p>
<p>这是创建带有 double 成员的并集的替代方法，后者强制使该联合是双字对齐的。</p>
<p>和前面的例子一样,你可以明确地指定你希望编译器对一个给定的变量或结构字段使用的对齐方式(以字节为单位)。或者,你也可以不使用对齐因子,只要求编译器将一个变量或字段对齐到你正在编译的目标架构的默认对齐方式。默认对齐对于所有标量类型来说是足够的,但对于支持向量操作的目标上的所有向量类型来说可能是不够的。默认对齐方式对于特定的目标ABI来说是固定的。</p>
<p>GCC还提供了特定于目标的宏 __BIGGEST_ALIGNMENT__ ，这是有史以来针对要编译的目标计算机上的任何数据类型使用的最大对齐方式。例如，您可以编写：</p>
<p>short array[3] __attribute__ ((aligned (__BIGGEST_ALIGNMENT__)));</p>
<p>编译器会自动将声明的变量或字段的对齐方式设置为 __BIGGEST_ALIGNMENT__ 。这样做通常可以使复制操作更有效率，因为在执行以这种方式对齐的变量或字段或从中进行复制时，编译器可以使用任何指令来复制最大的内存块。请注意， __BIGGEST_ALIGNMENT__ 的值可能会更改，具体取决于命令行选项。</p>
<p>当在结构或结构成员上使用时， aligned 属性只能增加对齐方式。为了减少它，还必须指定 packed 属性。当用作typedef的一部分时， aligned 属性既可以增加也可以减少对齐，并且指定 packed 属性将生成警告。</p>
<p>注意， aligned 属性对静态变量的有效性可能会受到系统链接器和/或目标文件格式的固有限制的限制。在某些系统上，链接器仅能安排将变量对齐到最大对齐程度。 （对于某些链接器，支持的最大对齐方式可能非常小。）如果链接器只能对齐最大8字节对齐方式的变量，那么在 __attribute__ 中指定 aligned(16) 仍然只能为您提供8字节对齐。有关更多信息，请参见链接器文档。</p>
<p>堆栈变量不受链接器限制的影响;GCC可以在任何目标上正确对齐它们。</p>
<p>该 aligned 属性还可以用于函数（见常用功能属性。）</p>
</div></blockquote>
<p>warn_if_not_aligned (alignment)</p>
<blockquote>
<div><p>这个属性指定了结构域的阈值,以字节为单位。如果结构字段的对齐程度低于阈值,将发出警告。例如,声明:</p>
<p>struct foo
{</p>
<blockquote>
<div><p>int i1;
int i2;
unsigned long long x __attribute__ ((warn_if_not_aligned (16)));</p>
</div></blockquote>
<p>};</p>
<p>使编译器对 struct foo 发出警告，例如’警告:’struct foo’的对齐方式8小于16。’。编译器还会发出警告，例如“警告:’struct foo’中的’x’偏移量8没有对齐到16。’，当结构字段的偏移量未对齐时：</p>
<p>struct __attribute__ ((aligned (16))) foo
{</p>
<blockquote>
<div><p>int i1;
int i2;
unsigned long long x __attribute__ ((warn_if_not_aligned (16)));</p>
</div></blockquote>
<p>};</p>
<p>可以通过以下方式禁用该警告-Wno-if-not-aligned。该 warn_if_not_aligned 属性也可用于类型（参见常见类型属性。）</p>
</div></blockquote>
<p>alloc_size (position)
alloc_size (position-1, position-2)</p>
<blockquote>
<div><p>可以将 alloc_size 变量属性应用于指向函数的指针的声明，该函数返回一个指针并采用至少一个整数类型的参数。它指示返回的指针指向一个对象，该对象的大小由 position-1 处的函数自变量或 position-1 与 position-2 处的自变量的乘积给出。有意义的大小是小于 PTRDIFF_MAX 的正值。检测到其他尺寸时将被忽略。 GCC使用此信息来改善 __builtin_object_size 的结果。</p>
<p>例如,以下声明</p>
<dl class="simple">
<dt>typedef __attribute__ ((alloc_size (1, 2))) void*</dt><dd><p>(<a href="#id209"><span class="problematic" id="id210">*</span></a>calloc_ptr) (size_t, size_t);</p>
</dd>
<dt>typedef __attribute__ ((alloc_size (1))) void*</dt><dd><p>(<a href="#id211"><span class="problematic" id="id212">*</span></a>malloc_ptr) (size_t);</p>
</dd>
</dl>
<p>指定 calloc_ptr 是一个函数的指针，该函数类似于标准C函数 calloc ，返回一个对象，其大小由参数1和2的乘积给出，并且类似地，该 malloc_ptr 类似于标准C函数 malloc ，返回一个对象其大小由函数的参数1给出。</p>
</div></blockquote>
<p>cleanup (cleanup_function)</p>
<blockquote>
<div><p>所述 cleanup 属性当变量超出范围出运行的函数。此属性只能应用于自动功能范围变量；它可能不适用于具有静态存储持续时间的参数或变量。该函数必须带有一个参数，即指向与该变量兼容的类型的指针。该函数的返回值（如果有）将被忽略。</p>
<p>If-fexceptions启用后，将在处理异常期间发生的堆栈展开期间运行 cleanup_function 。请注意， cleanup 属性不允许捕获异常，而只能执行操作。如果 cleanup_function 无法正常返回，将会发生什么仍未定义。</p>
</div></blockquote>
<p>common
nocommon</p>
<blockquote>
<div><p>该 common 属性要求GCC放置在“常用”存储的变量。所述 nocommon 属性请求对方-为它直接分配空间。</p>
<p>这些属性覆盖了由-fno-commonand-fcommon分别是标志。</p>
</div></blockquote>
<p>copy
copy (variable)</p>
<blockquote>
<div><p>该 copy 的属性应用一组与属性的 variable 已经宣布，其应用属性变量的声明。该属性是为定义别名的库而设计的，这些别名应指定与别名符号相同的属性集。的 copy 属性可以与变量，函数或类型一起使用。但是，应用属性的符号类型（变量或函数）必须与参数所引用的符号类型匹配。该 copy 属性仅复制句法和语义属性，但不是属性，这些属性影响元件的链接或知名度，如 alias ， visibility ，或 weak 。该 deprecated 属性也不会被复制。请参阅通用功能属性。请参阅“ 通用类型属性”。</p>
</div></blockquote>
<p>deprecated
deprecated (msg)</p>
<blockquote>
<div><p>该 deprecated 的警告属性的结果，如果变量在源文件中的任何地方使用。当标识预期在程序的将来版本中删除的变量时，这很有用。该警告还包括不赞成使用的变量的声明的位置，以使用户可以轻松地找到有关不赞成使用该变量的原因或应采取的行动的进一步信息。请注意，警告仅在以下情况下发生：</p>
<p>extern int old_var __attribute__ ((deprecated));
extern int old_var;
int new_fn () { return old_var; }</p>
<p>在第3行而不是第2行上显示警告。如果存在，则可选的 msg 参数（必须为字符串）会显示在警告中。</p>
<p>的 deprecated 属性也可用于功能和类型的（参见常用功能属性，见普通类型属性）。</p>
<p>附加在属性上的信息受属性的设置影响。-fmessage-lengthoption.</p>
</div></blockquote>
<p>mode (mode)</p>
<blockquote>
<div><p>此属性指定声明的数据类型-每种类型都对应于mode mode 。实际上，这使您可以根据其宽度请求整数或浮点类型。</p>
<p>请参阅GNU Compiler Collection (GCC) Internals 中的机器模式，以获取 mode 可能的关键字列表。您还可以指定 byte 或 __byte__ 的模式来指示对应于一字节整数的模式， word 或 __word__ 表示单字整数的模式，以及 pointer 或 __pointer__ 表示用于表示指针的模式。</p>
</div></blockquote>
<p>nonstring</p>
<blockquote>
<div><p>所述 nonstring 变量属性指定与类型数组的对象或成员声明 char ， signed char ，或 unsigned char ，或指针这样的类型意欲不一定包含终止存储字符阵列 NUL 。这对于检测此类数组或指针与期望以 NUL 终止的字符串的函数的使用非常有用，并且在将此类数组或指针用作有界字符串操作函数（例如 strncpy )的参数时避免发出警告。例如，如果没有该属性，GCC将为 strncpy 发出警告请致电以下，因为它可能会截断副本而不会附加终止 NUL 字符。使用该属性可以抑制警告。但是，使用属性声明数组时，将诊断对 strlen 的调用，因为当数组不包含以 NUL 终止的字符串时，该调用是不确定的。要复制，比较搜索非字符串字符数组，请使用 memcpy ， memcmp ， memchr 和其他对字节数组进行操作的函数。此外，如果指定了适当的绑定并且未对其进行诊断，则使用此类数组调用 strnlen 和 strndup 是安全的。</p>
<p>struct Data
{</p>
<blockquote>
<div><p>char name [32] __attribute__ ((nonstring));</p>
</div></blockquote>
<p>};</p>
<p>int f (struct Data <a href="#id213"><span class="problematic" id="id214">*</span></a>pd, const char <a href="#id215"><span class="problematic" id="id216">*</span></a>s)
{</p>
<blockquote>
<div><p>strncpy (pd-&gt;name, s, sizeof pd-&gt;name);
…
return strlen (pd-&gt;name);   // 不安全，收到警告</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>packed</p>
<blockquote>
<div><p>所述 packed 属性指定的结构构件应具有一个比特字段中的最小的可能取向的一个比特和一个字节否则，除非与指定的较大的值 aligned 属性。该属性不适用于非成员对象。</p>
<p>例如，在下面的结构中，成员数组 x 被打包，因此它紧跟在 a 之后，中间没有填充：</p>
<p>struct foo
{</p>
<blockquote>
<div><p>char a;
int x[2] __attribute__ ((packed));</p>
</div></blockquote>
<p>};</p>
<p>注意： GCC的4.1、4.2和4.3系列会忽略 char 类型的位字段上的 packed 属性。此问题已在GCC 4.4中修复，但更改可能导致结构布局不同。请参阅的文档-Wpacked-bitfield-compat更多信息。</p>
</div></blockquote>
<p>section (“section-name”)</p>
<blockquote>
<div><p>通常，编译器会将生成的对象放在 data 和 bss 之类的部分中。但是，有时您需要其他部分，或者需要某些特定变量才能出现在特殊部分中，例如，以映射到特殊硬件。的 section 属性指定的变量（或功能）生活在一个特定的部分。例如，此小程序使用几个特定的​​节名称：</p>
<p>struct duart a __attribute__ ((section (“DUART_A”))) = { 0 };
struct duart b __attribute__ ((section (“DUART_B”))) = { 0 };
char stack[10000] __attribute__ ((section (“STACK”))) = { 0 };
int init_data __attribute__ ((section (“INITDATA”)));</p>
<p>main()
{</p>
<blockquote>
<div><p>/* 初始化堆栈指针 <a href="#id217"><span class="problematic" id="id218">*</span></a>/
init_sp (stack + sizeof (stack));</p>
<p>/* 初始化初始化数据 <a href="#id219"><span class="problematic" id="id220">*</span></a>/
memcpy (&amp;init_data, &amp;data, &amp;edata - &amp;data);</p>
<p>/* 打开串口 <a href="#id221"><span class="problematic" id="id222">*</span></a>/
init_duart (&amp;a);
init_duart (&amp;b);</p>
</div></blockquote>
<p>}</p>
<p>使用 section 与属性全局变量而不是局部变量，在本例中，如图所示。</p>
<p>您可以将 section 属性与已初始化或未初始化的全局变量一起使用，但是链接器要求每个对象定义一次，但未初始化的变量暂定位于 common （或 bss ）部分中，并且可以与“ defined”相乘。如果未初始化的变量具有多个定义，则使用 section 属性会更改变量进入的节，并可能导致链接程序发出错误。您可以强制变量使用-fno-common标志或 nocommon 属性。</p>
<p>某些文件格式不支持任意节，因此 section 属性在所有平台上均不可用。如果需要将模块的全部内容映射到特定部分，请考虑改用链接器的功能。</p>
</div></blockquote>
<p>tls_model (“tls_model”)</p>
<blockquote>
<div><p>该 tls_model 属性设置线程本地存储模式（参见线程局部）特定的 __thread 变量，覆盖-ftls-model=每个变量的命令行开关。该 tls_model 参数应该是一个 global-dynamic ， local-dynamic ， initial-exec 或 local-exec 。</p>
<p>不是所有的目标都支持这个属性。</p>
</div></blockquote>
<p>unused</p>
<blockquote>
<div><p>这个属性,附加在一个变量上,意味着这个变量可能是未使用的。GCC不会对这个变量产生警告。</p>
</div></blockquote>
<p>used</p>
<blockquote>
<div><p>这个属性,附加在一个具有静态存储的变量上,意味着即使看起来变量没有被引用,也必须发出变量。</p>
<p>当应用于C++类模板的静态数据成员时,该属性也意味着如果类本身被实例化,则该成员被实例化。</p>
</div></blockquote>
<p>retain</p>
<blockquote>
<div><p>对于支持 GNU 或 FreeBSD OSABI 的 ELF 目标，此属性将从链接器垃圾收集中保存变量。为了支持这种行为，未放置在特定部分（例如通过 section 属性或 -fdata-sections 选项）的变量将被放置在新的、唯一的部分中。</p>
<p>这个额外的功能需要Binutils 2.36版或更高版本。</p>
</div></blockquote>
<p>vector_size (bytes)</p>
<blockquote>
<div><p>此属性指定已声明变量类型的向量大小，以字节为单位。它适用于的类型称为基本类型。的 bytes 参数必须是一个正电源的两多个基类型的大小。例如，声明：</p>
<p>int foo __attribute__ ((vector_size (16)));</p>
<p>使编译器将 foo 的模式设置为16个字节，分为 int 大小的单位。假设 int 为32位，则 foo 的类型是一个向量，该向量由四个单元（每个单元四个字节）组成，对应的 foo 模式为 V4SI 。有关处理向量变量的详细信息，请参见向量扩展。</p>
<p>这个属性只适用于积分和浮动标量,尽管数组、指针和函数返回值都允许与这个构造结合使用。</p>
<p>具有该属性的集合是无效的,即使它们与对应的标量大小相同。例如,声明:</p>
<p>struct S { int a; };
struct S  __attribute__ ((vector_size (16))) foo;</p>
<p>即使结构的大小与 int 的大小相同，也是无效的。</p>
</div></blockquote>
<p>visibility (“visibility_type”)</p>
<blockquote>
<div><p>此属性影响其所附声明的链接。该 visibility 属性描述常用功能属性。</p>
</div></blockquote>
<p>weak</p>
<blockquote>
<div><p>该 weak 属性描述常用功能属性。</p>
</div></blockquote>
<p>noinit</p>
<blockquote>
<div><p>任何具有 noinit 属性的数据都不会被 C 运行时启动代码或程序加载器初始化。不以这种方式初始化数据可以减少程序启动时间。</p>
<p>此属性特定于 ELF 目标，并依赖于链接描述文件将带有 .noinit 前缀的部分放置在正确的位置。</p>
</div></blockquote>
<p>persistent</p>
<blockquote>
<div><p>任何具有 persistent 属性的数据都不会被 C 运行时启动代码初始化，而是会被程序加载器初始化。这使变量的值成为 ‘persist’ 在处理器重置之间。</p>
<p>此属性特定于 ELF 目标，并依赖于链接描述文件将带有 .persistent 前缀的部分放置在正确的位置。具体来说，需要某种类型的非易失性、可写存储器。</p>
</div></blockquote>
<p>objc_nullability (nullability kind) (Objective-C and Objective-C++ only)</p>
<blockquote>
<div><p>此属性仅适用于指针变量。它允许使用四个可能值之一来标记指针，这些值描述了指针可能具有 nil 值的条件。在大多数情况下，该属性旨在作为属性和方法可空性的内部表示（由语言关键字指定）；不建议直接使用。</p>
<p>当可 nullability kind 为 “unspecified” 或 0 时，对于指针可能为 nil 的条件一无所知。使此状态特定可避免诊断中的误报。</p>
<p>当可 nullability kind 为 “nonnull” 或 1 时，如果指针为 nil 则指针没有意义，因此如果可以确定该值将为 nil ，编译器可以自由地发出诊断信息。</p>
<p>当可 nullability kind 为 “nullable” 或 2 时，指针可能为 nil 并带有含义。</p>
<p>当可 nullability kind 为 “resettable” 或 3 （仅在属性属性列表的上下文中使用）时，这描述了属性设置器可能采用值 nil 的情况（这可能会导致属性以某种方式重置为默认值）但是属性 getter 永远不会有效地返回 nil 。</p>
</div></blockquote>
</div>
<div class="section" id="id223">
<h3>x86 变量属性<a class="headerlink" href="#id223" title="Permalink to this headline">¶</a></h3>
<p>这些函数属性由x86后端支持。</p>
<p>cdecl</p>
<blockquote>
<div><p>在x86-32目标上， cdecl 属性使编译器假定调用函数弹出用于传递参数的堆栈空间。这对于覆盖-mrtdswitch.</p>
</div></blockquote>
<p>fastcall</p>
<blockquote>
<div><p>在x86-32目标上， fastcall 属性使编译器在寄存器ECX中传递第一个参数（如果是整数类型），在寄存器EDX中传递第二个参数（如果是整数类型）。后续和其他类型的参数在堆栈上传递。被调用函数将参数弹出堆栈。如果参数数量可变，则所有参数都将压入堆栈。</p>
</div></blockquote>
<p>thiscall</p>
<blockquote>
<div><p>在x86-32目标上， thiscall 属性使编译器在寄存器ECX中传递第一个参数（如果是整数类型）。后续和其他类型的参数在堆栈上传递。被调用函数将参数弹出堆栈。如果参数数量可变，则所有参数都将压入堆栈。所述 thiscall 属性是用于C ++非静态成员函数。作为GCC扩展，此调用约定可用于C函数和静态成员方法。</p>
</div></blockquote>
<p>ms_abi
sysv_abi</p>
<blockquote>
<div><p>在 32 位和 64 位 x86 目标上，您可以使用 ABI 属性来指示函数应使用哪种调用约定。该 ms_abi 属性告诉编译器使用Microsoft ABI，而 sysv_abi 属性告诉编译器使用System V的ELF ABI，这是在GNU / Linux和其他系统中使用。默认是在面向 Windows 时使用 Microsoft ABI。在所有其他系统上，默认值为 System V ELF ABI。</p>
<p>请注意，Microsoft Windows 64位目标的 ms_abi 属性当前需要-maccumulate-outgoing-argsoption.</p>
</div></blockquote>
<p>callee_pop_aggregate_return (number)</p>
<blockquote>
<div><p>在x86-32目标上，可以使用此属性来控制如何在内存中返回聚合。如果调用方负责将隐藏的指针与其余参数一起弹出，请指定 number 等于零。如果被叫方是负责弹出隐藏的指针，指定 number 等于一。</p>
<p>默认的x86-32 ABI假设被调用者弹出堆栈以获得隐藏的指针。然而,在x86-32 Microsoft Windows目标上,编译器假设调用者会弹出栈中的隐藏指针。</p>
</div></blockquote>
<p>ms_hook_prologue</p>
<blockquote>
<div><p>在32位和64位x86目标上，可以使用此函数属性使GCC生成Microsoft Windows XP Service Pack 2和更高版本的Win32 API函数中使用的“热补丁”函数序言。</p>
</div></blockquote>
<p>naked</p>
<blockquote>
<div><p>该属性允许编译器构造必要的函数声明，同时允许函数主体为汇编代码。指定的函数将没有编译器生成的序言/结尾序列。裸函数中只能安全地包含基本的 asm 语句（请参见Basic Asm）。虽然使用扩展 asm 或基本 asm 与C代码的混合似乎可以工作，但是不能依靠它们可靠地工作并且不受支持。</p>
</div></blockquote>
<p>regparm (number)</p>
<blockquote>
<div><p>在x86-32目标上，如果 regparm 属性在寄存器EAX，EDX和ECX中为整数类型，而不是在堆栈上，则regparm属性使编译器将第一参数传递给 number 。带有可变数量参数的函数将继续在堆栈上传递其所有参数。</p>
<p>要注意的是,在某些ELF系统中,这个属性不适合使用懒惰绑定(默认)的共享库中的全局函数。懒惰绑定会通过加载器中的解析代码发送第一次调用,这可能会假设 EAX、EDX 和 ECX 可以被 clobbered,按照标准调用惯例。Solaris 8 受此影响。使用 GNU C 库 2.1 或更高版本的系统和 FreeBSD 被认为是安全的,因为那里的加载器会保存 EAX、EDX 和 ECX。(如果需要的话,可以通过链接器或加载器禁用懒惰绑定,以避免这个问题。)</p>
</div></blockquote>
<p>sseregparm</p>
<blockquote>
<div><p>在具有SSE支持的x86-32目标上， sseregparm 属性使编译器在SSE寄存器中而不是堆栈中最多传递3个浮点参数。带有可变数量参数的函数将继续在堆栈上传递其所有浮点参数。</p>
</div></blockquote>
<p>force_align_arg_pointer</p>
<blockquote>
<div><p>在x86目标上，可以将 force_align_arg_pointer 属性应用于单个函数定义，从而生成备用的序言和结尾，以在必要时重新对齐运行时堆栈。这支持将以4字节对齐的堆栈运行的旧代码与保留16字节堆栈的现代代码混合在一起以实现SSE兼容性。</p>
</div></blockquote>
<p>stdcall</p>
<blockquote>
<div><p>在x86-32目标上， stdcall 属性使编译器假定被调用函数弹出用于传递参数的堆栈空间，除非它采用可变数量的参数。</p>
</div></blockquote>
<p>no_caller_saved_registers</p>
<blockquote>
<div><p>使用此属性指示指定的函数没有调用者保存的寄存器。也就是说，所有寄存器都被保存了被调用者。例如，此属性可用于从中断处理程序调用的函数。编译器会生成适当的函数进入和退出序列，以保存和恢复除EFLAGS寄存器外的所有已修改寄存器。由于GCC不会保留SSE，MMX或x87状态，因此GCC选项-mgeneral-regs-only应该用于编译具有 no_caller_saved_registers 属性的函数。</p>
</div></blockquote>
<p>interrupt</p>
<blockquote>
<div><p>使用此属性指示指定的函数是中断处理程序还是异常处理程序（取决于传递给该函数的参数，进一步说明）。存在此属性时，编译器会生成适合在中断处理程序中使用的函数进入和退出序列。在 IRET 指令，代替的 RET 指令，用于从中断处理程序返回。除由 IRET 指令恢复的EFLAGS寄存器外，所有寄存器均由编译器保留。由于GCC不会保留SSE，MMX或x87状态，因此GCC选项-mgeneral-regs-only应用于编译中断和异常处理程序。</p>
<p>任何无堆栈开关的可中断代码都必须用以下方法编译-mno-red-zone因为中断处理程序由于硬件设计的原因,可以也会触及红色区域。</p>
<p>中断处理程序必须声明一个强制性的指针参数。</p>
<p>struct interrupt_frame;</p>
<p>__attribute__ ((interrupt))
void
f (struct interrupt_frame <a href="#id224"><span class="problematic" id="id225">*</span></a>frame)
{
}</p>
<p>并且您必须按照处理器手册中的说明定义 struct interrupt_frame 。</p>
<p>异常处理程序与中断处理程序不同，因为系统将错误代码压入堆栈。异常处理程序的声明与中断处理程序的声明相似，但是具有不同的强制性函数签名。编译器安排在 IRET 指令之前从堆栈弹出错误代码。</p>
<p>#ifdef __x86_64__
typedef unsigned long long int uword_t;
#else
typedef unsigned int uword_t;
#endif</p>
<p>struct interrupt_frame;</p>
<p>__attribute__ ((interrupt))
void
f (struct interrupt_frame <a href="#id226"><span class="problematic" id="id227">*</span></a>frame, uword_t error_code)
{</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p>}</p>
<p>异常处理程序只能用于推送错误代码的异常,在其他情况下应该使用中断处理程序。如果使用了错误的处理程序,系统会崩溃。</p>
</div></blockquote>
<p>target (options)</p>
<blockquote>
<div><p>如“ 公共功能属性”中所述，此属性允许指定特定于目标的编译选项。</p>
<p>在x86上,允许使用以下选项:</p>
<p>‘3dnow’
‘no-3dnow’</p>
<blockquote>
<div><p>启用/禁用3DNow!指令的生成。</p>
</div></blockquote>
<p>‘3dnowa’
‘no-3dnowa’</p>
<blockquote>
<div><p>启用/禁用生成增强型3DNow!指令。</p>
</div></blockquote>
<p>‘abm’
‘no-abm’</p>
<blockquote>
<div><p>启用/禁用高级位指令的生成。</p>
</div></blockquote>
<p>‘adx’
‘no-adx’</p>
<blockquote>
<div><p>启用/禁用ADX指令的生成。</p>
</div></blockquote>
<p>‘aes’
‘no-aes’</p>
<blockquote>
<div><p>启用/禁用AES指令的生成。</p>
</div></blockquote>
<p>‘avx’
‘no-avx’</p>
<blockquote>
<div><p>启用/禁用AVX指令的生成。</p>
</div></blockquote>
<p>‘avx2’
‘no-avx2’</p>
<blockquote>
<div><p>启用/禁用AVX2指令的生成。</p>
</div></blockquote>
<p>‘avx5124fmaps’
‘no-avx5124fmaps’</p>
<blockquote>
<div><p>启用/禁用AVX5124FMAPS指令的生成。</p>
</div></blockquote>
<p>‘avx5124vnniw’
‘no-avx5124vnniw’</p>
<blockquote>
<div><p>启用/禁用AVX5124VNNIW指令的生成。</p>
</div></blockquote>
<p>‘avx512bitalg’
‘no-avx512bitalg’</p>
<blockquote>
<div><p>启用/禁用AVX512BITALG指令的生成。</p>
</div></blockquote>
<p>‘avx512bw’
‘no-avx512bw’</p>
<blockquote>
<div><p>启用/禁用AVX512BW指令的生成。</p>
</div></blockquote>
<p>‘avx512cd’
‘no-avx512cd’</p>
<blockquote>
<div><p>启用/禁用AVX512CD指令的生成。</p>
</div></blockquote>
<p>‘avx512dq’
‘no-avx512dq’</p>
<blockquote>
<div><p>启用/禁用AVX512DQ指令的生成。</p>
</div></blockquote>
<p>‘avx512er’
‘no-avx512er’</p>
<blockquote>
<div><p>启用/禁用AVX512ER指令的生成。</p>
</div></blockquote>
<p>‘avx512f’
‘no-avx512f’</p>
<blockquote>
<div><p>启用/禁用AVX512F指令的生成。</p>
</div></blockquote>
<p>‘avx512ifma’
‘no-avx512ifma’</p>
<blockquote>
<div><p>启用/禁用AVX512IFMA指令的生成。</p>
</div></blockquote>
<p>‘avx512pf’
‘no-avx512pf’</p>
<blockquote>
<div><p>启用/禁用AVX512PF指令的生成。</p>
</div></blockquote>
<p>‘avx512vbmi’
‘no-avx512vbmi’</p>
<blockquote>
<div><p>启用/禁用AVX512VBMI指令的生成。</p>
</div></blockquote>
<p>‘avx512vbmi2’
‘no-avx512vbmi2’</p>
<blockquote>
<div><p>启用/禁用AVX512VBMI2指令的生成。</p>
</div></blockquote>
<p>‘avx512vl’
‘no-avx512vl’</p>
<blockquote>
<div><p>启用/禁用AVX512VL指令的生成。</p>
</div></blockquote>
<p>‘avx512vnni’
‘no-avx512vnni’</p>
<blockquote>
<div><p>启用/禁用AVX512VNNI指令的生成。</p>
</div></blockquote>
<p>‘avx512vpopcntdq’
‘no-avx512vpopcntdq’</p>
<blockquote>
<div><p>启用/禁用AVX512VPOPCNTDQ指令的生成。</p>
</div></blockquote>
<p>‘bmi’
‘no-bmi’</p>
<blockquote>
<div><p>启用/禁用BMI指令的生成。</p>
</div></blockquote>
<p>‘bmi2’
‘no-bmi2’</p>
<blockquote>
<div><p>启用/禁用BMI2指令的生成。</p>
</div></blockquote>
<p>‘cldemote’
‘no-cldemote’</p>
<blockquote>
<div><p>开启/关闭CLDEMOTE指令的生成。</p>
</div></blockquote>
<p>‘clflushopt’
‘no-clflushopt’</p>
<blockquote>
<div><p>开启/关闭CLFLUSHOPT指令的生成。</p>
</div></blockquote>
<p>‘clwb’
‘no-clwb’</p>
<blockquote>
<div><p>启用/禁用CLWB指令的生成。</p>
</div></blockquote>
<p>‘clzero’
‘no-clzero’</p>
<blockquote>
<div><p>开启/关闭CLZERO指令的生成。</p>
</div></blockquote>
<p>‘crc32’
‘no-crc32’</p>
<blockquote>
<div><p>启用/禁用CRC32指令的生成。</p>
</div></blockquote>
<p>‘cx16’
‘no-cx16’</p>
<blockquote>
<div><p>启用/禁用CMPXCHG16B指令的生成。</p>
</div></blockquote>
<p>‘default’</p>
<blockquote>
<div><p>请参阅函数多版本化，用于指定默认函数版本。</p>
</div></blockquote>
<p>‘f16c’
‘no-f16c’</p>
<blockquote>
<div><p>启用/禁用F16C指令的生成。</p>
</div></blockquote>
<p>‘fma’
‘no-fma’</p>
<blockquote>
<div><p>启用/禁用FMA指令的生成。</p>
</div></blockquote>
<p>‘fma4’
‘no-fma4’</p>
<blockquote>
<div><p>启用/禁用FMA4指令的生成。</p>
</div></blockquote>
<p>‘fsgsbase’
‘no-fsgsbase’</p>
<blockquote>
<div><p>启用/禁用FSGSBASE指令的生成。</p>
</div></blockquote>
<p>‘fxsr’
‘no-fxsr’</p>
<blockquote>
<div><p>启用/禁用FXSR指令的生成。</p>
</div></blockquote>
<p>‘gfni’
‘no-gfni’</p>
<blockquote>
<div><p>启用/禁用GFNI指令的生成。</p>
</div></blockquote>
<p>‘hle’
‘no-hle’</p>
<blockquote>
<div><p>启用/禁用HLE指令前缀的生成。</p>
</div></blockquote>
<p>‘lwp’
‘no-lwp’</p>
<blockquote>
<div><p>开启/关闭LWP指令的生成。</p>
</div></blockquote>
<p>‘lzcnt’
‘no-lzcnt’</p>
<blockquote>
<div><p>启用/禁用LZCNT指令的生成。</p>
</div></blockquote>
<p>‘mmx’
‘no-mmx’</p>
<blockquote>
<div><p>启用/禁用MMX指令的生成。</p>
</div></blockquote>
<p>‘movbe’
‘no-movbe’</p>
<blockquote>
<div><p>启用/禁用MOVBE指令的生成。</p>
</div></blockquote>
<p>‘movdir64b’
‘no-movdir64b’</p>
<blockquote>
<div><p>启用/禁用MOVDIR64B指令的生成。</p>
</div></blockquote>
<p>‘movdiri’
‘no-movdiri’</p>
<blockquote>
<div><p>启用/禁用MOVDIRI指令的生成。</p>
</div></blockquote>
<p>‘mwaitx’
‘no-mwaitx’</p>
<blockquote>
<div><p>启用/禁用MWAITX指令的生成。</p>
</div></blockquote>
<p>‘pclmul’
‘no-pclmul’</p>
<blockquote>
<div><p>启用/禁用PCLMUL指令的生成。</p>
</div></blockquote>
<p>‘pconfig’
‘no-pconfig’</p>
<blockquote>
<div><p>开启或关闭PCONFIG指令的生成。</p>
</div></blockquote>
<p>‘pku’
‘no-pku’</p>
<blockquote>
<div><p>启用/禁用PKU指令的生成。</p>
</div></blockquote>
<p>‘popcnt’
‘no-popcnt’</p>
<blockquote>
<div><p>启用/禁用POPCNT指令的生成。</p>
</div></blockquote>
<p>‘prefetchwt1’
‘no-prefetchwt1’</p>
<blockquote>
<div><p>开启/关闭PREFETCHWT1指令的生成。</p>
</div></blockquote>
<p>‘prfchw’
‘no-prfchw’</p>
<blockquote>
<div><p>开启或关闭PREFETCHW指令的生成。</p>
</div></blockquote>
<p>‘ptwrite’
‘no-ptwrite’</p>
<blockquote>
<div><p>启用/禁用PTWRITE指令的生成。</p>
</div></blockquote>
<p>‘rdpid’
‘no-rdpid’</p>
<blockquote>
<div><p>启用/禁用RDPID指令的生成。</p>
</div></blockquote>
<p>‘rdrnd’
‘no-rdrnd’</p>
<blockquote>
<div><p>启用/禁用RDRND指令的生成。</p>
</div></blockquote>
<p>‘rdseed’
‘no-rdseed’</p>
<blockquote>
<div><p>启用/禁用RDSEED指令的生成。</p>
</div></blockquote>
<p>‘rtm’
‘no-rtm’</p>
<blockquote>
<div><p>启用/禁用RTM指令的生成。</p>
</div></blockquote>
<p>‘sahf’
‘no-sahf’</p>
<blockquote>
<div><p>启用/禁用SAHF指令的生成。</p>
</div></blockquote>
<p>‘sgx’
‘no-sgx’</p>
<blockquote>
<div><p>启用/禁用SGX指令的生成。</p>
</div></blockquote>
<p>‘sha’
‘no-sha’</p>
<blockquote>
<div><p>启用/禁用SHA指令的生成。</p>
</div></blockquote>
<p>‘shstk’
‘no-shstk’</p>
<blockquote>
<div><p>开启/关闭CET的影子栈内置功能。</p>
</div></blockquote>
<p>‘sse’
‘no-sse’</p>
<blockquote>
<div><p>启用/禁用SSE指令的生成。</p>
</div></blockquote>
<p>‘sse2’
‘no-sse2’</p>
<blockquote>
<div><p>启用/禁用SSE2指令的生成。</p>
</div></blockquote>
<p>‘sse3’
‘no-sse3’</p>
<blockquote>
<div><p>启用/禁用SSE3指令的生成。</p>
</div></blockquote>
<p>‘sse4’
‘no-sse4’</p>
<blockquote>
<div><p>启用/禁用SSE4指令的生成(包括SSE4.1和SSE4.2)。</p>
</div></blockquote>
<p>‘sse4.1’
‘no-sse4.1’</p>
<blockquote>
<div><p>开启/关闭SSE4.1指令的生成。</p>
</div></blockquote>
<p>‘sse4.2’
‘no-sse4.2’</p>
<blockquote>
<div><p>开启/关闭SSE4.2指令的生成。</p>
</div></blockquote>
<p>‘sse4a’
‘no-sse4a’</p>
<blockquote>
<div><p>启用/禁用SSE4A指令的生成。</p>
</div></blockquote>
<p>‘ssse3’
‘no-ssse3’</p>
<blockquote>
<div><p>启用/禁用SSSE3指令的生成。</p>
</div></blockquote>
<p>‘tbm’
‘no-tbm’</p>
<blockquote>
<div><p>启用/禁用TBM指令的生成。</p>
</div></blockquote>
<p>‘vaes’
‘no-vaes’</p>
<blockquote>
<div><p>开启/关闭VAES指令的生成。</p>
</div></blockquote>
<p>‘vpclmulqdq’
‘no-vpclmulqdq’</p>
<blockquote>
<div><p>启用/禁用VPCLMULQDQ指令的生成。</p>
</div></blockquote>
<p>‘waitpkg’
‘no-waitpkg’</p>
<blockquote>
<div><p>开启/关闭WAITPKG指令的生成。</p>
</div></blockquote>
<p>‘wbnoinvd’
‘no-wbnoinvd’</p>
<blockquote>
<div><p>开启/关闭WBNOINVD指令的生成。</p>
</div></blockquote>
<p>‘xop’
‘no-xop’</p>
<blockquote>
<div><p>启用/禁用XOP指令的生成。</p>
</div></blockquote>
<p>‘xsave’
‘no-xsave’</p>
<blockquote>
<div><p>启用/禁用XSAVE指令的生成。</p>
</div></blockquote>
<p>‘xsavec’
‘no-xsavec’</p>
<blockquote>
<div><p>启用/禁用XSAVEC指令的生成。</p>
</div></blockquote>
<p>‘xsaveopt’
‘no-xsaveopt’</p>
<blockquote>
<div><p>开启/关闭XSAVEOPT指令的生成。</p>
</div></blockquote>
<p>‘xsaves’
‘no-xsaves’</p>
<blockquote>
<div><p>开启/关闭XSAVES指令的生成。</p>
</div></blockquote>
<p>‘amx-tile’
‘no-amx-tile’</p>
<blockquote>
<div><p>启用/禁用AMX-TILE指令的生成。</p>
</div></blockquote>
<p>‘amx-int8’
‘no-amx-int8’</p>
<blockquote>
<div><p>启用/禁用AMX-INT8指令的生成。</p>
</div></blockquote>
<p>‘amx-bf16’
‘no-amx-bf16’</p>
<blockquote>
<div><p>启用/禁用AMX-BF16指令的生成。</p>
</div></blockquote>
<p>‘uintr’
‘no-uintr’</p>
<blockquote>
<div><p>启用/禁用UINTR指令的生成。</p>
</div></blockquote>
<p>‘hreset’
‘no-hreset’</p>
<blockquote>
<div><p>启用/禁用HRESET指令的生成。</p>
</div></blockquote>
<p>‘kl’
‘no-kl’</p>
<blockquote>
<div><p>启用/禁用KEYLOCKER指令的生成。</p>
</div></blockquote>
<p>‘widekl’
‘no-widekl’</p>
<blockquote>
<div><p>启用/禁用WIDEKL指令的生成。</p>
</div></blockquote>
<p>‘avxvnni’
‘no-avxvnni’</p>
<blockquote>
<div><p>启用/禁用AVXVNNI指令的生成。</p>
</div></blockquote>
<p>‘cld’
‘no-cld’</p>
<blockquote>
<div><p>开启/关闭在字符串移动前生成CLD的功能。</p>
</div></blockquote>
<p>‘fancy-math-387’
‘no-fancy-math-387’</p>
<blockquote>
<div><p>在387浮点单元上启用/禁用 sin ， cos 和 sqrt 指令的生成。</p>
</div></blockquote>
<p>‘ieee-fp’
‘no-ieee-fp’</p>
<blockquote>
<div><p>开启/关闭依赖于IEEE算术的浮点数的生成。</p>
</div></blockquote>
<p>‘inline-all-stringops’
‘no-inline-all-stringops’</p>
<blockquote>
<div><p>开启/关闭字符串操作的内联。</p>
</div></blockquote>
<p>‘inline-stringops-dynamically’
‘no-inline-stringops-dynamically’</p>
<blockquote>
<div><p>开启/关闭内联代码的生成,进行小的字符串操作和调用库例程进行大的操作。</p>
</div></blockquote>
<p>‘align-stringops’
‘no-align-stringops’</p>
<blockquote>
<div><p>做/不对齐内联字符串操作的目标。</p>
</div></blockquote>
<p>‘recip’
‘no-recip’</p>
<blockquote>
<div><p>启用/禁用RCPSS、RCPPS、RSQRTSS和RSQRTPS指令的生成,这些指令遵循额外的Newton-Raphson步骤,而不是做浮点除法。</p>
</div></blockquote>
<p>‘general-regs-only’</p>
<blockquote>
<div><p>生成只使用一般寄存器的代码。</p>
</div></blockquote>
<p>‘arch=ARCH’</p>
<blockquote>
<div><p>指定编译函数时要生成代码的架构。</p>
</div></blockquote>
<p>‘tune=TUNE’</p>
<blockquote>
<div><p>指定编译函数时要调整的架构。</p>
</div></blockquote>
<p>‘fpmath=FPMATH’</p>
<blockquote>
<div><p>指定要使用的浮点单位。您必须将 target(“fpmath=sse,387”) 选项指定为 target(“fpmath=sse+387”) 因为逗号会分隔不同的选项。</p>
</div></blockquote>
<p>‘prefer-vector-width=OPT’</p>
<blockquote>
<div><p>在 x86 目标上， prefer-vector-width 属性通知编译器在指令中使用 OPT 位向量宽度，而不是所选平台上的默认值。</p>
<p>有效的 OPT 值为：</p>
<p>‘none’</p>
<blockquote>
<div><p>除所选平台定义的限制外,GCC不适用额外的限制。</p>
</div></blockquote>
<p>‘128’</p>
<blockquote>
<div><p>优先选择128位向量宽度的指令。</p>
</div></blockquote>
<p>‘256’</p>
<blockquote>
<div><p>优先选择256位向量宽度的指令。</p>
</div></blockquote>
<p>‘512’</p>
<blockquote>
<div><p>优先选择512位向量宽度的指令。</p>
</div></blockquote>
<p>在x86上，内联函数不会内联具有与调用者不同的目标选项的函数，除非被调用者具有调用者的目标选项的子集。例如，用 target(“sse3”) 声明的函数可以用-target target(“sse2”) 内联函数，因为 -msse3 意味着 -msse2 。</p>
</div></blockquote>
</div></blockquote>
<p>indirect_branch(“choice”)</p>
<blockquote>
<div><p>在x86目标上， indirect_branch 属性使编译器转换间接调用并使用 choice 跳转。’keep’保持间接调用，并且跳转保持不变。’thunk’转换间接调用并跳转到调用并返回thunk。’thunk-inline’转换间接调用并跳转到内联调用并返回thunk。’thunk-extern’将间接调用转换为外部调用并跳转到单独的目标文件中提供的thunk。</p>
</div></blockquote>
<p>function_return(“choice”)</p>
<blockquote>
<div><p>在x86目标上， function_return 属性使编译器使用 choice 转换函数return 。’keep’使函数返回保持不变。’thunk’将函数return转换为call并返回thunk。’thunk-inline’将函数return转换为内联调用并返回thunk。’thunk-extern’将函数return转换为外部调用，并返回单独对象文件中提供的thunk。</p>
</div></blockquote>
<p>nocf_check</p>
<blockquote>
<div><p>函数的 nocf_check 属性用于通知编译器，当使用-fcf-protection=branch选项。编译器假定函数的地址是控制流传输的有效目标。</p>
<p>函数指针类型上的 nocf_check 属性用于通知编译器，当使用-fcf-protection=branch选项。编译器假定来自指针的函数地址是控制流传输的有效目标。通过函数名称进行的直接函数调用被认为是安全的调用，因此编译器不对直接调用进行检测。</p>
<p>所述 nocf_check 属性应用于一个对象的类型。如果将一个函数地址或一个函数指针分配给另一个指针，则该属性不会从右侧对象的类型继承。左侧对象的类型保持不变。编译器检查 nocf_check 属性是否不匹配，并在不匹配的情况下报告警告。</p>
<p>{
int foo (void) __attribute__(nocf_check);
void (<a href="#id228"><span class="problematic" id="id229">*</span></a>foo1)(void) __attribute__(nocf_check);
void (<a href="#id230"><span class="problematic" id="id231">*</span></a>foo2)(void);</p>
<p>/* foo 的地址被认为是有效的。<a href="#id232"><span class="problematic" id="id233">*</span></a>/
int
foo (void)</p>
<blockquote>
<div><p>/* 不检查此调用站点的控制流有效性。<a href="#id234"><span class="problematic" id="id235">*</span></a>/
(<a href="#id236"><span class="problematic" id="id237">*</span></a>foo1)();</p>
<p>/* 发出关于属性不匹配的警告。<a href="#id238"><span class="problematic" id="id239">*</span></a>/
foo1 = foo2;</p>
<p>/* 此调用站点仍未检查。<a href="#id240"><span class="problematic" id="id241">*</span></a>/
(<a href="#id242"><span class="problematic" id="id243">*</span></a>foo1)();</p>
<p>/* 检查此调用站点。<a href="#id244"><span class="problematic" id="id245">*</span></a>/
(<a href="#id246"><span class="problematic" id="id247">*</span></a>foo2)();</p>
<p>/* 发出关于属性不匹配的警告。<a href="#id248"><span class="problematic" id="id249">*</span></a>/
foo2 = foo1;</p>
<p>/* 这个调用站点仍然被检查。<a href="#id250"><span class="problematic" id="id251">*</span></a>/
(<a href="#id252"><span class="problematic" id="id253">*</span></a>foo2)();</p>
<p>return 0;</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>cf_check</p>
<blockquote>
<div><p>函数上的 cf_check 属性用于通知编译器在以下情况下应将ENDBR指令放置在函数条目中：-fcf-protection=branch启用。</p>
</div></blockquote>
<p>indirect_return</p>
<blockquote>
<div><p>所述 indirect_return 属性可以被应用于一个函数，以及变量或函数指针的类型通知编译器该功能可以经由间接分支返回。</p>
</div></blockquote>
<p>fentry_name(“name”)</p>
<blockquote>
<div><p>在x86目标上， fentry_name 属性将功能设置为在启用了功能检测时调用功能条目-pg -mfentry。当 name 为nop时，将生成一个5字节的nop序列。</p>
</div></blockquote>
<p>fentry_section(“name”)</p>
<blockquote>
<div><p>在x86目标上， fentry_section 属性设置该节的名称，以在启用以下命令时记录函数条目检测调用-pg -mrecord-mcount</p>
</div></blockquote>
</div>
</div>
<div class="section" id="id254">
<h2>指定类型的属性<a class="headerlink" href="#id254" title="Permalink to this headline">¶</a></h2>
<p>关键字 __attribute__ 允许您指定类型的各种特殊属性。一些类型属性仅适用于结构和联合类型，在C ++中也适用于类类型，而其他一些属性则适用于通过 typedef 声明定义的任何类型。除非另有说明，否则无论类型是琐碎的结构还是带有用户定义的构造函数，析构函数或副本分配的C ++类，相同的限制和效果都将应用于属性。</p>
<p>还为函数（请参见函数属性），标签（请参见Label Attributes），枚举器（请参见Enumerator Attributes），语句（请参见Statement Attributes）和变量（请参见Variable Attributes）定义其他属性。</p>
<p>该 __attribute__ 关键字后面括在双括号的属性规范。</p>
<p>您可以通过将它们放置在 struct ， union 或 enum 关键字之后，来在枚举，结构或联合类型声明或定义中指定类型属性。您也可以将它们放置在定义的右花括号之后，但这不是首选，因为从逻辑上说，应在右花括号处完全定义类型。</p>
<p>您还可以在 typedef 声明中包括类型属性。有关使用属性的确切语法的详细信息，请参见“ 属性语法”。</p>
<div class="section" id="id255">
<h3>通用类型属性<a class="headerlink" href="#id255" title="Permalink to this headline">¶</a></h3>
<p>大多数目标都支持以下类型属性:</p>
<p>aligned
aligned (alignment)</p>
<blockquote>
<div><p>所述 aligned 属性指定指定类型的变量的最小对齐（以字节计）。指定时， alignment 必须是2的幂。不指定 alignment 参数意味着目标的最大对齐方式，这通常是8字节或16字节，但并非总是如此。例如，声明：</p>
<p>struct __attribute__ ((aligned (8))) S { short f[3]; };
typedef int more_aligned_int __attribute__ ((aligned (8)));</p>
<p>强制编译器确保（尽可能）确保每个类型为 struct S 或 more_aligned_int 的变量都已分配并至少在8字节边界上对齐。在SPARC上，将 struct S 类型的所有变量对齐到8个字节的边界，允许编译器在将一个 struct S 类型的变量复制到另一个变量时使用 ldd 和 std （双字加载和存储）指令，从而提高了运行时效率。 。</p>
<p>注意，ISO C标准要求任何给定的 struct 或 union 类型的对齐方式至少应为所讨论的 struct 或 union 的所有成员的对齐方式的最低公倍数的完美倍数。这意味着您可以通过将 aligned 属性附加到该类型的任何一个成员 struct 有效地调整结构或 union 类型的对齐方式，但是上面示例中所示的符号是一种更明显，直观和易读的表示方式请求编译器调整整个 struct 或 union 类型的对齐方式。</p>
<p>如上例所示，您可以显式指定希望编译器用于给定 struct 或 union 类型的对齐方式（以字节为单位）。另外，您可以忽略对齐因子，而只是要求编译器将类型与要编译的目标计算机的最大有用对齐方式对齐。例如，您可以编写：</p>
<p>struct __attribute__ ((aligned)) S { short f[3]; };</p>
<p>只要在 aligned 属性规范中省略对齐因子，编译器就会自动将类型的对齐方式设置为要针对其进行编译的目标计算机上的任何数据类型使用的最大对齐方式。这样做通常可以使复制操作更有效率，因为在对具有这种类型对齐方式的变量执行复制时，编译器可以使用任何指令来复制最大的内存块。</p>
<p>在上面的示例中，如果每个 short 的大小为2个字节，则整个 struct S 类型的大小为6个字节。大于或等于8的2的最小乘方，因此编译器将整个 struct S 类型的对齐方式设置为8个字节。</p>
<p>请注意，尽管您可以要求编译器为给定类型选择省时对齐方式，然后仅声明该类型的单个独立对象，但是仅当您计划进行以下操作时，编译器才能选择省时对齐方式才是最有用的功能创建具有相关（有效对齐）类型的变量数组。如果您声明或使用有效对齐类型的变量数组，则您的程序可能还会对相关类型的指针以及编译器执行的代码进行指针算术（或下标，等同）为这些指针生成的算术运算对于高效对齐的类型通常比其他类型更有效。</p>
<p>请注意， aligned 属性的有效性可能受到链接器中固有限制的限制。在许多系统上，链接器只能安排将变量对齐到最大对齐程度。 （对于某些链接器，所支持的最大对齐方式可能非常小。）如果链接器仅能够对齐最大8字节对齐方式的变量，那么在 __attribute__ 中指定 aligned (16) 仍然只能为您提供8字节对齐。有关更多信息，请参见链接器文档。</p>
<p>当在结构或结构成员上使用时， aligned 属性只能增加对齐方式。为了减少它，还必须指定 packed 属性。当用作typedef的一部分时， aligned 属性既可以增加也可以减少对齐，并且指定 packed 属性将生成警告。</p>
</div></blockquote>
<p>warn_if_not_aligned (alignment)</p>
<blockquote>
<div><p>这个属性指定了结构域的阈值,以字节为单位。如果结构字段的对齐程度低于阈值,将发出警告。例如,声明:</p>
<dl class="simple">
<dt>typedef unsigned long long __u64</dt><dd><p>__attribute__((aligned (4), warn_if_not_aligned (8)));</p>
</dd>
</dl>
<p>struct foo
{</p>
<blockquote>
<div><p>int i1;
int i2;
__u64 x;</p>
</div></blockquote>
<p>};</p>
<p>使编译器对 struct foo 发出警告，例如’警告:’struct foo’的对齐方式4小于8。’。它用于以如下方式定义 struct foo :当 __u64 对齐4或8个字节时， struct foo 具有相同的布局，并且结构字段 x 具有相同的对齐方式。将 struct foo 对齐为8个字节：</p>
<p>struct __attribute__ ((aligned (8))) foo
{</p>
<blockquote>
<div><p>int i1;
int i2;
__u64 x;</p>
</div></blockquote>
<p>};</p>
<p>取消警告。编译器还会发出警告，例如“警告:’struct foo’中的’x’偏移量12没有对齐到8。’，当结构字段的偏移量未对齐时：</p>
<p>struct __attribute__ ((aligned (8))) foo
{</p>
<blockquote>
<div><p>int i1;
int i2;
int i3;
__u64 x;</p>
</div></blockquote>
<p>};</p>
<p>可以通过以下方式禁用该警告-Wno-if-not-aligned.</p>
</div></blockquote>
<p>alloc_size (position)
alloc_size (position-1, position-2)</p>
<blockquote>
<div><p>可以将 alloc_size 类型属性应用于返回指针并采用至少一个整数类型参数的函数类型的定义。它指示返回的指针指向一个对象，该对象的大小由 position-1 处的函数自变量或 position-1 与 position-2 处的自变量的乘积给出。有意义的大小是小于 PTRDIFF_MAX 的正值。检测到其他尺寸时将被忽略。 GCC使用此信息来改善 __builtin_object_size 的结果。</p>
<p>例如,以下声明</p>
<dl class="simple">
<dt>typedef __attribute__ ((alloc_size (1, 2))) void*</dt><dd><p>calloc_type (size_t, size_t);</p>
</dd>
<dt>typedef __attribute__ ((alloc_size (1))) void*</dt><dd><p>malloc_type (size_t);</p>
</dd>
</dl>
<p>指定 calloc_type 是函数的类型，类似于标准C函数 calloc ，返回一个对象，其大小由参数1和2的乘积给出；而 malloc_type 类似于标准C函数 malloc ，返回其大小的对象。由参数1赋予函数。</p>
</div></blockquote>
<p>copy
copy (expression)</p>
<blockquote>
<div><p>的 copy 属性适用的集合与该类型属性的 expression 已被宣布为被施加所述属性的类型的声明。该属性是为定义别名的库而设计的，这些别名应指定与别名符号相同的属性集。的 copy 属性可以与类型，变量，或功能一起使用。但是，应用属性的符号类型（变量或函数）必须与参数所引用的符号类型匹配。该 copy 属性仅复制句法和语义属性，但不是属性，这些属性影响元件的链接或知名度，如 alias ， visibility ，或 weak 。该 deprecated 属性也不会被复制。请参阅通用功能属性。请参见通用变量属性。</p>
<p>例如，假设下面的 struct A 在某个第三方库标头中定义为具有对齐要求 N ,并在由于属性 packed 而导致类型变量未如此对齐时强制发出警告。在不相关的 struct B 的定义上指定 copy 属性具有将所有相关属性从指针表达式引用的类型复制到 struct B 的作用。</p>
<p>struct __attribute__ ((aligned (N), warn_if_not_aligned (N)))
A { /* … <em>/ };
struct __attribute__ ((copy ( (struct A *)0)) B { /</em> … <a href="#id256"><span class="problematic" id="id257">*</span></a>/ };</p>
</div></blockquote>
<p>deprecated
deprecated (msg)</p>
<blockquote>
<div><p>如果在源文件中的任何位置使用了该类型， deprecated 属性将导致警告。当标识预期在程序的将来版本中删除的类型时，这很有用。如果可能的话，警告还包括不赞成使用的类型的声明的位置，以使用户可以轻松地找到有关为什么不赞成使用该类型或应该做什么的更多信息。请注意，警告仅在使用时发生，然后仅在将类型应用于未声明为不推荐使用的标识符时才发生。</p>
<p>typedef int T1 __attribute__ ((deprecated));
T1 x;
typedef T1 T2;
T2 y;
typedef T1 T3 __attribute__ ((deprecated));
T3 z __attribute__ ((deprecated));</p>
<p>会在第2行和第3行产生警告，但不会在第4行，第5行或第6行发出警告。因为没有明确弃用T2，所以不会为第4行发出警告。第5行没有警告，因为T3已被明确弃用。对于第6行也是如此。警告中将显示可选的 msg 参数，该参数必须是字符串。字符串中的控制字符将被转义序列替换，如果-fmessage-length选项设置为0(其默认值),那么任何换行字符将被忽略。</p>
<p>的 deprecated 属性还可以用于函数和变量（见功能属性，参见变量属性。）</p>
<p>附加在属性上的信息受属性的设置影响。-fmessage-lengthoption.</p>
</div></blockquote>
<p>designated_init</p>
<blockquote>
<div><p>此属性只能应用于结构类型。它指示此对象的任何初始化都必须使用指定的初始化程序，而不是位置初始化程序。此属性的目的是允许程序员指示结构的布局可能会更改，因此依赖于位置初始化将导致将来的损坏。</p>
<p>GCC默认会根据这个属性发出警告;使用-Wno-designated-init来压制他们。</p>
</div></blockquote>
<p>may_alias</p>
<blockquote>
<div><p>通过指向具有这种属性的类型的指针的访问不受基于类型的别名分析的限制,而是被认为能够别名任何其他类型的对象。在C99标准第6.5节第7段的上下文中,派生这种指针的l值表达式就像具有字符类型一样。参见-fstrict-aliasing获取更多关于别名问题的信息。这个扩展的存在是为了支持一些向量API,在这些API中,指向一个向量类型的指针可以别名指向另一个向量类型的指针。</p>
<p>请注意,具有该属性的类型的对象不具有任何特殊的语义。</p>
<p>使用实例:</p>
<p>typedef short __attribute__ ((__may_alias__)) short_a;</p>
<p>int
main (void)
{</p>
<blockquote>
<div><p>int a = 0x12345678;
short_a <a href="#id258"><span class="problematic" id="id259">*</span></a>b = (short_a <a href="#id260"><span class="problematic" id="id261">*</span></a>) &amp;a;</p>
<p>b[1] = 0;</p>
<dl class="simple">
<dt>if (a == 0x12345678)</dt><dd><p>abort();</p>
</dd>
</dl>
<p>exit(0);</p>
</div></blockquote>
<p>}</p>
<p>如果在变量声明 short_a 替换为 short ，则使用以下命令编译时上述程序将中止-fstrict-aliasing，默认情况下位于-O2或以上。</p>
</div></blockquote>
<p>mode (mode)</p>
<blockquote>
<div><p>此属性指定声明的数据类型-每种类型都对应于mode mode 。实际上，这使您可以根据其宽度请求整数或浮点类型。</p>
<p>请参阅GNU Compiler Collection (GCC) Internals 中的机器模式，以获取 mode 可能的关键字列表。您还可以指定 byte 或 __byte__ 的模式来指示对应于一字节整数的模式， word 或 __word__ 表示单字整数的模式，以及 pointer 或 __pointer__ 表示用于表示指针的模式。</p>
</div></blockquote>
<p>packed</p>
<blockquote>
<div><p>附加到 struct ， union 或C ++ class 类型定义的此属性指定放置其每个成员（零宽度位域除外）以最小化所需的内存。这等效于在每个成员上指定 packed 属性。</p>
<p>当附加到 enum 定义时， packed 属性指示应使用最小的整数类型。指定-fshort-enums命令行上的flag等效于在所有 enum 定义中指定 packed 属性。</p>
<p>在下面的示例中， struct my_packed_struct 的成员紧密打包在一起，但是其 s 成员的内部布局没有打包，为此， struct my_unpacked_struct 也需要打包。</p>
<dl>
<dt>struct my_unpacked_struct</dt><dd><dl class="simple">
<dt>{</dt><dd><p>char c;
int i;</p>
</dd>
</dl>
<p>};</p>
</dd>
<dt>struct __attribute__ ((__packed__)) my_packed_struct</dt><dd><dl class="simple">
<dt>{</dt><dd><p>char c;
int  i;
struct my_unpacked_struct s;</p>
</dd>
</dl>
<p>};</p>
</dd>
</dl>
<p>您只能在 enum ， struct ， union 或 class 的定义上指定 packed 属性，而不能在没有定义枚举类型，结构，联合或类的 typedef 上指定。</p>
</div></blockquote>
<p>scalar_storage_order (“endianness”)</p>
<blockquote>
<div><p>当附加到并 union 或 struct ，此属性设置类型的标量字段以及组成标量的数组字段的存储顺序（即字节顺序）。支持的字节序为 big-endian 和 little-endian 。该属性对本身是 union ， struct 或数组（其组成部分是 union 或 struct )的字段没有影响，这些字段可能具有与封闭类型不同的标量存储顺序。</p>
<p>这个属性只支持那些使用统一的默认标量存储顺序的目标(幸运的是,大多数目标),即那些将标量全部存储在big-endian或全部存储在little-endian的目标。</p>
<p>在目标的标量存储顺序方面,对具有反向标量存储顺序的类型实施了额外的限制。</p>
<blockquote>
<div><p>不允许使用标量存储顺序相反的 union 或 struct 的标量字段的地址，并且会产生错误。
允许采用具有标量存储顺序相反的 union 或 struct 的数组字段（其成分为标量）的地址，但会产生警告，除非-Wno-scalar-storage-order是指定的。
允许采用标量存储顺序相反的 union 或 struct 的地址。</p>
</div></blockquote>
<p>之所以存在这些限制,是因为当取标量的地址或者取带有标量成分的数组的地址时,存储顺序属性就会丢失,所以通过这个地址间接存储一般是不行的。不过第二种情况是允许的,能够从数组中或向数组进行块复制。</p>
<p>此外,不支持使用类型惩罚或别名来切换存储顺序;也就是说,一个给定的标量对象不能通过给它分配不同存储顺序的不同类型来访问。</p>
</div></blockquote>
<p>transparent_union</p>
<blockquote>
<div><p>附加到并 union 类型定义的此属性表示，具有该并集类型的任何函数参数都将导致以特殊方式处理对该函数的调用。</p>
<p>首先，与透明联合类型相对应的参数可以是联合中的任何类型。无需强制转换。另外，如果联合包含指针类型，则对应的参数可以是空指针常量或空指针表达式；如果联合包含空指针类型，则对应的参数可以是任何指针表达式。如果联合成员类型是指针，则必须 const 引用类型上的const等限定符，就像普通的指针转换一样。</p>
<p>其次,参数传递给函数时,使用的是透明联盟中第一个成员的调用惯例,而不是联盟本身的调用惯例。联合体的所有成员必须具有相同的机器表示;这对于这种参数传递的正常工作是必要的。</p>
<p>由于兼容性原因，透明联合是为具有多个接口的库函数设计的。例如，假设 wait 函数必须接受 int * 类型的值以符合POSIX，或者必须接受 union wait * 类型的值以符合4.1BSD接口。如果 wait 的参数为 void * ，则 wait 可以接受两种参数，但是也可以接受其他任何指针类型，这将使​​参数类型检查的用处不大。而是， &lt;sys/wait.h&gt; 可以如下定义接口：</p>
<dl>
<dt>typedef union __attribute__ ((__transparent_union__))</dt><dd><dl class="simple">
<dt>{</dt><dd><p>int <a href="#id262"><span class="problematic" id="id263">*</span></a>__ip;
union wait <a href="#id264"><span class="problematic" id="id265">*</span></a>__up;</p>
</dd>
</dl>
<p>} wait_status_ptr_t;</p>
</dd>
</dl>
<p>pid_t wait (wait_status_ptr_t);</p>
<p>该接口允许使用 int * 调用约定传递 int * 或 union wait * 参数。程序可以使用以下两种类型的参数调用 wait ：</p>
<p>int w1 () { int w; return wait (&amp;w); }
int w2 () { union wait w; return wait (&amp;w); }</p>
<p>使用此界面， wait 的实现可能如下所示：</p>
<p>pid_t wait (wait_status_ptr_t p)
{</p>
<blockquote>
<div><p>return waitpid (-1, p.__ip, 0);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>unused</p>
<blockquote>
<div><p>当附加到类型（包括并 union 或 struct ）时，此属性意味着该类型的变量可能未使用。即使该变量似乎无作用，GCC也不会对任何类型的变量产生警告。锁或线程类通常是这种情况，它们通常被定义然后不被引用，但是包含具有非平凡簿记功能的构造函数和析构函数。</p>
</div></blockquote>
<p>vector_size (bytes)</p>
<blockquote>
<div><p>此属性指定类型的向量大小，以字节为单位。它适用于的类型称为基本类型。的 bytes 参数必须是一个正电源的两多个基类型的大小。例如，以下声明：</p>
<p>typedef __attribute__ ((vector_size (32))) int int_vec32_t ;
typedef __attribute__ ((vector_size (32))) int* int_vec32_ptr_t;
typedef __attribute__ ((vector_size (32))) int int_vec32_arr3_t[3];</p>
<p>将 int_vec32_t 定义为由 int 大小的单元组成的32字节向量类型。如果 int 的大小为4个字节，则该类型定义一个8个单位的矢量，每个单位4个字节。 int_vec32_t 类型的变量的模式为 V8SI 。 int_vec32_ptr_t 被定义为一个指针到这样的载体类型，和 int_vec32_arr3_t 为三个这样的载体的阵列。有关处理向量类型的对象的详细信息，请参见向量扩展。</p>
<p>这个属性只适用于积分和浮动标量类型。在函数声明中,该属性适用于函数的返回类型。</p>
<p>例如,下列情况:</p>
<p>__attribute__ ((vector_size (16))) float get_flt_vec16 (void);</p>
<p>将 get_flt_vec16 声明为返回基本类型为 float 的16字节向量的函数。</p>
</div></blockquote>
<p>visibility</p>
<blockquote>
<div><p>在C ++中，属性可见性（请参见函数属性）也可以应用于类，结构，联合和枚举类型。与其他类型属性不同，该属性必须出现在初始关键字和类型名称之间；它不能出现在类型的正文之后。</p>
<p>注意,类型可见性适用于与类相关联的模糊链接实体(vtable、typeinfo节点等)。特别是,如果一个类在一个共享对象中作为异常抛出,而在另一个共享对象中被捕获,那么该类必须具有默认可见性。否则两个共享对象无法使用同一个typeinfo节点,异常处理就会中断。</p>
</div></blockquote>
<p>objc_root_class (Objective-C and Objective-C++ only)</p>
<blockquote>
<div><p>这个属性标志着一个类是一个根类,因此允许编译器忽略任何关于缺少超类的警告,并根据需要对强制性方法进行额外的检查。</p>
</div></blockquote>
<p>要指定多个属性，请在双括号内用逗号分隔它们：例如，“__attribute__（（对齐（16），包装好的））’.</p>
</div>
<div class="section" id="id266">
<h3>x86类型属性<a class="headerlink" href="#id266" title="Permalink to this headline">¶</a></h3>
<p>当前为x86配置定义了两个属性：ms_struct和gcc_struct。</p>
<ul>
<li><p>ms_struct/gcc_struct:如果在结构上使用压缩或使用位字段，则可能是Microsoft ABI打包它们的方式与GCC正常打包的方式不同。 特别是在通过GCC编译的函数和本机Microsoft编译器之间（通过函数调用或作为文件中的数据）在移动打包数据时，可能有必要访问任何一种格式。</p>
<p>ms_struct和gcc_struct属性分别对应于“ -mms-bitfields”和“ -mno-ms-bitfields”命令行选项； 有关如何影响结构布局的详细信息，请参见第3.19.59节[x86选项]，第439页。 有关变量上相应属性的信息，请参见第6.34.15节[x86变量属性]（第598页）。</p>
<p>总结：</p>
</li>
</ul>
</div>
</div>
<div class="section" id="id267">
<h2>标签属性<a class="headerlink" href="#id267" title="Permalink to this headline">¶</a></h2>
<p>GCC 允许在 C 标签上设置属性。有关使用属性的确切语法的详细信息，请参阅属性语法。其他属性可用于函数（参见函数属性）、变量（参见变量属性）、枚举器（参见枚举器属性）、语句（参见语句属性）和类型（参见类型属性）。后跟声明的标签属性属于标签而不是声明。</p>
<p>本示例使用 cold Label属性指示不太可能采用 ErrorHandling 分支，并且 ErrorHandling 标签未使用：</p>
<p>asm goto (“some asm” : : : : NoError);</p>
<p>/* 这个分支（asm 的fall-through）不太常用*/
ErrorHandling:</p>
<blockquote>
<div><p>__attribute__((cold, unused)); /* 这里需要分号 <a href="#id268"><span class="problematic" id="id269">*</span></a>/
printf(“errorn”);
return 0;</p>
</div></blockquote>
<dl class="simple">
<dt>NoError:</dt><dd><p>printf(“no errorn”);
return 1;</p>
</dd>
</dl>
<p>unused</p>
<blockquote>
<div><p>此功能适用于程序生成的代码,这些代码可能包含未使用的标签,但在编译时使用了-Wall。通常，不宜在其中使用人工编写的代码，尽管在跳转到标签的代码包含在 #ifdef 条件中的情况下，这可能会很有用。</p>
</div></blockquote>
<p>hot</p>
<blockquote>
<div><p>标签上的 hot 属性用于通知编译器，标签后的路径比未注释的路径更有可能。在无法使用 __builtin_expect 的情况下（例如，对于计算出的goto或 asm goto )，可以使用此属性。</p>
</div></blockquote>
<p>cold</p>
<blockquote>
<div><p>标签上的 cold 属性用于通知编译器该标签后面的路径不太可能被执行。在无法使用 __builtin_expect 的情况下（例如，对于计算出的goto或 asm goto )，可以使用此属性。</p>
</div></blockquote>
</div>
<div class="section" id="id270">
<h2>枚举器属性<a class="headerlink" href="#id270" title="Permalink to this headline">¶</a></h2>
<p>GCC允许在枚举数上设置属性。有关使用属性的确切语法的详细信息，请参见“ 属性语法”。其他属性可用于函数（请参阅函数属性），变量（请参见变量属性），标签（请参见Label Attributes），语句（请参见Statement Attributes）和类型（请参见Type Attributes）。</p>
<p>本示例使用 deprecated 枚举数属性来指示不推荐使用 oldval 枚举数：</p>
<dl class="simple">
<dt>enum E {</dt><dd><p>oldval __attribute__((deprecated)),
newval</p>
</dd>
</dl>
<p>};</p>
<p>int
fn (void)
{</p>
<blockquote>
<div><p>return oldval;</p>
</div></blockquote>
<p>}</p>
<p>deprecated</p>
<blockquote>
<div><p>如果在源文件中的任何位置使用了枚举数， deprecated 属性将产生警告。当确定预期在程序的将来版本中删除的枚举器时，此功能很有用。该警告还包括不赞成使用的枚举器的声明的位置，以使用户可以轻松找到有关为什么不赞成使用该枚举器或应该做什么的更多信息。请注意，警告仅在使用时出现。</p>
</div></blockquote>
</div>
<div class="section" id="id271">
<h2>语句属性<a class="headerlink" href="#id271" title="Permalink to this headline">¶</a></h2>
<p>GCC允许在null语句上设置属性。有关使用属性的确切语法的详细信息，请参见“ 属性语法”。其他属性可用于函数（请参见函数属性），变量（请参见变量属性），标签（请参见Label Attributes），枚举器（请参见Enumerator Attributes）和类型（请参见Type Attributes）。</p>
<p>本示例使用 fallthrough 语句属性来指示-Wimplicit-fallthrough不应发出警告。</p>
<dl>
<dt>switch (cond)</dt><dd><p>{
case 1:</p>
<blockquote>
<div><p>bar (1);
__attribute__((fallthrough));</p>
</div></blockquote>
<dl class="simple">
<dt>case 2:</dt><dd><p>…</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>fallthrough</p>
<blockquote>
<div><p>具有空语句的 fallthrough 属性用作fallthrough语句。它向编译器暗示一个语句落入另一个case标签或switch语句中的用户定义标签是故意的，因此-Wimplicit-fallthrough警告不得触发。跌穿属性在每个属性列表中最多只能出现一次,而且不能与其他属性混合使用。它只能用在switch语句中(否则编译器会出错),用在前面的语句之后,用在逻辑上相继出现的case标签或用户定义的标签之前。</p>
</div></blockquote>
</div>
<div class="section" id="id272">
<h2>属性语法<a class="headerlink" href="#id272" title="Permalink to this headline">¶</a></h2>
<p>本节描述了C语言可以使用 __attribute__ 的语法以及属性说明符所绑定的构造。对于C ++和Objective-C，某些细节可能有所不同。由于语法上的属性不够准确，因此此处描述的某些形式可能无法在所有情况下都成功解析。</p>
<p>C ++中的属性语义存在一些问题。例如，尽管属性可能会影响代码生成，但没有进行任何操作，因此当将属性类型与模板或重载一起使用时，可能会出现问题。同样， typeid 不能区分具有不同属性的类型。C ++中对属性的支持将来可能会仅限于声明中的属性，而不是嵌套声明符中的属性。</p>
<p>有关适用于函数的属性的语义的详细信息，请参见函数属性。有关应用于变量的属性的语义的详细信息，请参见变量属性。有关适用于结构，联合和枚举类型的属性的语义的详细信息，请参见类型属性。有关应用于标签的属性的语义的详细信息，请参见标签属性。有关应用于枚举器的属性的语义的详细信息，请参见Enumerator Attributes。有关应用于语句的属性的语义的详细信息，请参见语句属性。</p>
<p>一个属性指定符的形式是 __attribute__ ((attribute-list)) 。一个属性列表是一个可能是空的逗号分隔的序列的属性，其中每个属性是以下之一：</p>
<blockquote>
<div><p>空。空属性被忽略。
属性名称（可以是诸如 unused 的标识符，也可以是诸如 const 的保留字）。
一个属性名称,后面是一个括号内的属性参数列表。这些参数采用以下形式之一:</p>
<blockquote>
<div><p>标识符。例如， mode 属性使用此形式。
一个标识符，后跟一个逗号和一个非空逗号分隔的表达式列表。例如， format 属性使用此形式。
可能为空的逗号分隔的表达式列表。例如， format_arg 属性使用此形式，列表为单个整数常量表达式， alias 属性使用此形式，列表为单个字符串常量。</p>
</div></blockquote>
</div></blockquote>
<p>一个属性说明符列表是一个或多个属性说明符的序列，而不是由任何其他代币分离。</p>
<p>您可以选择使用’__在名称的前面和后面。这样，您就可以在头文件中使用它们，而不必担心可能存在相同名称的宏。例如，您可以使用属性名称 __noreturn__ 代替 noreturn 。</p>
<p>标签属性</p>
<p>在GNU C中，属性说明符列表可能会出现在冒号之后的标签之后，而不是 case 或 default 标签。如果属性说明符后紧跟一个分号（即，标签适用于空语句），则GNU C ++仅允许标签上的属性。如果缺少分号，则C ++标签属性是不明确的，因为声明可以使用C ++进行标记，该声明可以以属性列表开头。声明不能在C90或C99中标记，因此不会在此处引起歧义。
枚举者属性</p>
<p>在GNU C中，属性说明符列表可能作为枚举器的一部分出现。该属性位于枚举常量之后 = 之前（如果存在）。枚举器中的可选属性与枚举常量有关。如果存在，则无法将属性放在常量表达式之后。
声明属性</p>
<p>在GNU C中,属性指定器列表可以作为null语句的一部分出现。属性放在分号之前。
类型属性</p>
<p>属性说明符列表可能显示为 struct ， union 或 enum 说明符的一部分。它可以紧跟在 struct ， union 或 enum 关键字之后，或在右括号之后。前一种语法是首选。在属性说明符紧跟右括号的情况下，它们被认为与定义的结构，联合或枚举类型有关，而不与该类型说明符出现在其中的任何封闭声明有关，并且定义的类型直到属性说明符之后才是完整的。
所有其他属性</p>
<p>否则,属性指定符作为声明的一部分出现,计入未命名的参数和类型名的声明,并与该声明有关(该声明可能嵌套在另一个声明中,例如在参数声明的情况下),或与声明中的特定声明者有关。当一个属性指定符被应用于一个被声明为函数或数组的参数时,它应该应用于函数或数组,而不是隐式转换为参数的指针,但这一点还没有正确实现。</p>
<p>声明开始处的任何说明符和限定符列表都可以包含属性说明符，无论该列表在该上下文中是否可以包含存储类说明符。（但是，某些属性本质上是存储类说明符的性质，并且仅在可以使用存储类说明符的地方有意义；例如， section 。）对该语法有一个必要的限制：函数定义中的第一个旧式参数声明不能​​以属性说明符开头，因为这样的属性适用于函数，而不是通过下面描述的语法（但是还没有）在这种情况下实施）。在某些其他情况下，该语法允许属性说明符，但编译器尚不支持属性说明符。这个地方的所有属性说明符都与整个声明有关。在由于没有类型说明符而隐含 int 类型的过时用法中，此类说明符和限定符的列表可能是没有其他说明符或限定符的属性说明符列表。</p>
<p>当前，函数原型中的第一个参数必须具有某种类型说明符，而不是属性说明符。这解决了 void f(int (__attribute__((foo)) x)) 的解释中的歧义，但可能会发生变化。当前，如果函数声明符的括号仅包含属性，则将忽略这些属性，而不是产生错误或警告或暗示单个int类型的参数，但这可能会发生变化。</p>
<p>在使用一个单一的指定符和限定符列表的多个标识符的声明中,属性指定符列表可以紧接出现在一个以逗号分隔的声明符列表中的声明符(第一个声明符除外)之前。这种属性规定符只适用于它们出现在其声明符之前的标识符。例如,在</p>
<dl class="simple">
<dt>__attribute__((noreturn)) void d0 (void),</dt><dd><dl class="simple">
<dt>__attribute__((format(printf, 1, 2))) d1 (const char <a href="#id273"><span class="problematic" id="id274">*</span></a>, …),</dt><dd><p>d2 (void);</p>
</dd>
</dl>
</dd>
</dl>
<p>在 noreturn 属性适用于所有功能申报; 在 format 属性仅适用于 d1 。</p>
<p>属性说明符列表可能紧接在逗号， = 或分号之前，终止了除函数定义以外的标识符声明。这样的属性说明符适用于声明的对象或函数。如果指定了对象或函数的汇编器名称（请参见Asm Labels），则该属性必须遵循 asm 规范。</p>
<p>将来可能会允许属性指定器列表出现在函数定义中的声明符之后(在任何旧式参数声明或函数主体之前)。</p>
<p>在C99结构中，属性说明符可以与出现在参数数组声明符 [] 内的类型限定符混合，通过这种限定符将这些限定符应用于隐式转换到数组的指针。此类属性说明符适用于指针，而不适用于数组，但目前尚未实现，因此将被忽略。</p>
<p>属性说明符列表可能会出现在嵌套声明符的开头。当前，此用法有一些限制：属性正确地应用于声明符，但是对于大多数单独的属性，此暗示的语义尚未实现。当属性说明符在指针声明符的 * 后面时，它们可以与存在的任何类型限定符混合使用。下面介绍此语法的形式语义。如果您熟悉ISO C标准中声明符的正式规范，这将是最有意义的。</p>
<p>考虑一个声明 T D1 （如C99中第6.7.5节第4款所述），其中 T 包含指定类型 Type 的声明说明符（例如 int ）， D1 是包含标识符 ident 的声明符。为派生声明符的 ident 指定的类型（其类型不包含属性说明符）与ISO C标准相同。</p>
<p>如果 D1 的格式为 ( attribute-specifier-list D ) ，并且声明 T D 为 ident 指定类型“ derived-declarator-type-list Type ” ，则 T D1 指定类型为“ derived-declarator-type-list attribute-specifier-list ident 的 “ 说明符列表 Type ” 。</p>
<p>如果 D1 的形式为 * type-qualifier-and-attribute-specifier-list D ，并且声明 T D 为 ident 指定类型“ derived-declarator-type-list Type ” ，则 T D1 指定类型为“ derived-declarator-type-list - d ” 类型列表 type-qualifier-and-attribute-specifier-list 指向 ident 的 “ Type ”的指针。</p>
<p>例如:</p>
<p>void (__attribute__((noreturn)) <a href="#id275"><span class="problematic" id="id276">**</span></a><a href="#id277"><span class="problematic" id="id278">**</span></a>f) (void);</p>
<p>指定类型“指向指向返回 void 的非返回函数的指针的指针的指针”。再举一个例子</p>
<p>char <a href="#id279"><span class="problematic" id="id280">*</span></a>__attribute__((aligned(8))) <a href="#id281"><span class="problematic" id="id282">*</span></a>f;</p>
<p>指定类型“指向8字节对齐的 char 指针”。再次注意，这不适用于大多数属性。例如，“aligned’和’noreturn尚不支持上面提供的’属性。</p>
<p>为了兼容为编译器版本编写的现有代码,这些编译器没有在嵌套的声明器上实现属性,在属性的放置上允许有一些宽松。如果一个只适用于类型的属性被应用于一个声明,那么它将被视为应用于该声明的类型。如果一个只适用于声明的属性被应用于声明的类型,那么它被视为应用于该声明;而且,为了与紧接在声明的标识符之前放置属性的代码相兼容,这样一个应用于函数返回类型的属性被视为应用于函数类型,这样一个应用于数组元素类型的属性被视为应用于数组类型。如果一个只适用于函数类型的属性被应用于指针到函数类型,则被视为应用于指针目标类型;如果这样的属性被应用于不是指针到函数类型的函数返回类型,则被视为应用于函数类型。</p>
</div>
<div class="section" id="id283">
<h2>原型和旧式函数定义<a class="headerlink" href="#id283" title="Permalink to this headline">¶</a></h2>
<p>GNU C扩展了ISO C,允许一个函数原型覆盖一个后来的旧式非原型定义。请看下面的例子。</p>
<p>/* 使用原型除非编译器是老式的。<a href="#id284"><span class="problematic" id="id285">*</span></a>/
#ifdef __STDC__
#define P(x) x
#else
#define P(x) ()
#endif</p>
<p>/* 原型函数声明。<a href="#id286"><span class="problematic" id="id287">*</span></a>/
int isroot P((uid_t));</p>
<p>/* 旧式函数定义。<em>/
int
isroot (x)   /</em> ??? 损失在这里？？？<a href="#id288"><span class="problematic" id="id289">*</span></a>/</p>
<blockquote>
<div><p>uid_t x;</p>
</div></blockquote>
<dl class="simple">
<dt>{</dt><dd><p>return x == 0;</p>
</dd>
</dl>
<p>}</p>
<p>假设 uid_t 类型恰好是 short 。ISO C不允许使用此示例，因为会提升旧式非原型定义中的子字参数。因此，在此示例中，函数定义的参数实际上是一个 int ，它与 short 的原型参数类型不匹配。</p>
<p>由于ISO C的这种限制使得难以编写可移植到传统C编译器中的代码，因为程序员不知道 uid_t 类型是 short ， int 还是 long 。因此，在这种情况下，GNU C允许原型重写以后的旧式定义。更精确地讲，在GNU C中，如果函数原型参数类型与升级之前的后者类型相同，则函数原型参数类型将覆盖由较新的旧式定义所指定的参数类型。因此，在GNU C中，以上示例等效于以下示例：</p>
<p>int isroot (uid_t);</p>
<p>int
isroot (uid_t x)
{</p>
<blockquote>
<div><p>return x == 0;</p>
</div></blockquote>
<p>}</p>
<p>GNU C++不支持旧式函数定义,所以这个扩展是不相关的。</p>
</div>
<div class="section" id="id290">
<h2>标识符名称中的美元符号<a class="headerlink" href="#id290" title="Permalink to this headline">¶</a></h2>
<p>在GNU C中，通常可以在标识符名称中使用美元符号。 这是因为许多传统的C实现都允许使用此类标识符。 但是，少数目标机器不支持标识符中的美元符号，通常是因为目标汇编器不允许使用美元符号。</p>
<p>总结：</p>
</div>
<div class="section" id="esc">
<h2>常量中的字符ESC<a class="headerlink" href="#esc" title="Permalink to this headline">¶</a></h2>
<p>您可以在字符串或字符常量中使用序列“ e”代表ASCII字符ESC。</p>
<p>总结：</p>
</div>
<div class="section" id="id291">
<h2>确定函数，类型或变量的对齐方式<a class="headerlink" href="#id291" title="Permalink to this headline">¶</a></h2>
<p>关键字 __alignof__ 确定函数，对象或类型的对齐要求，或类型通常所需的最小对齐。它的语法就像 sizeof 和C11 _Alignof 一样。</p>
<p>例如，如果目标机器需要一个 double 值到8字节的边界上对齐，然后 __alignof__ (double) 为8。这是许多RISC机器真。在更传统的机器设计中， __alignof__ (double) 为4甚至2。</p>
<p>有些机器实际上从来不需要对齐；它们甚至允许在奇数地址处引用任何数据类型。对于这些机器， __alignof__ 报告通常由目标ABI要求的GCC给出数据类型的最小对齐方式。</p>
<p>如果 __alignof__ 的操作数是左值而不是类型，则它的值是其类型所需的对齐方式，同时考虑到由属性 aligned 指定的任何最小对齐方式（请参见Common Variable Attributes）。例如，在此声明之后：</p>
<p>struct foo { int x; char y; } foo1;</p>
<p>__alignof__ (foo1.y) 的值是1，即使其实际对齐方式可能是2或4，也与 __alignof__ (int) 相同。要求对齐除 void 以外的不完整类型是错误的。</p>
<p>如果 __alignof__ 表达式的操作数是一个函数，则该表达式将求值该函数的对齐方式，该对齐方式可以由属性 aligned 指定（请参见Common Function Attributes）。</p>
</div>
<div class="section" id="id292">
<h2>内联函数的速度与宏一样快<a class="headerlink" href="#id292" title="Permalink to this headline">¶</a></h2>
<p>通过声明一个函数内联，您可以指示GCC更快地调用该函数。 GCC可以做到这一点的一种方法是将该函数的代码集成到其调用者的代码中。通过消除函数调用开销，这使执行速度更快。另外，如果任何实际参数值是恒定的，则它们的已知值可能会在编译时进行简化，因此不必包括所有内联函数的代码。对代码大小的影响难以预测。根据具体情况，使用函数内联可以使目标代码更大或更小。您还可以指示GCC尝试使用选项将所有“足够简单”的功能集成到其调用方中-finline-functions.</p>
<p>GCC实现了三种不同语义的内联函数声明。一种是通过-std=gnu89or-fgnu89-inline或当所有内联声明中都包含 gnu_inline 属性时，或另一个-std=c99,-std=gnu99或使用了以后的C版本的选项(不含-fgnu89-inline），第三个用于编译C ++。</p>
<p>要声明内联函数，请在其声明中使用 inline 关键字，如下所示：</p>
<p>static inline int
inc (int <a href="#id293"><span class="problematic" id="id294">*</span></a>a)
{</p>
<blockquote>
<div><p>return (<a href="#id295"><span class="problematic" id="id296">*</span></a>a)++;</p>
</div></blockquote>
<p>}</p>
<p>如果要编写要包含在ISO C90程序中的头文件，请编写 __inline__ 而不是 inline 。请参阅备用关键字。</p>
<p>三种类型的内联的行为类似地在两个重要的情况：当 inline 关键字用于在 static 功能，如上面的例子，当一个函数被首先声明不使用 inline 的关键字，然后用所定义 inline ，如下所示：</p>
<p>extern int inc (int <a href="#id297"><span class="problematic" id="id298">*</span></a>a);
inline int
inc (int <a href="#id299"><span class="problematic" id="id300">*</span></a>a)
{</p>
<blockquote>
<div><p>return (<a href="#id301"><span class="problematic" id="id302">*</span></a>a)++;</p>
</div></blockquote>
<p>}</p>
<p>在这两种常见情况下，该程序的行为与您未使用 inline 关键字的行为相同，只是其速度不同。</p>
<p>当函数既是内联函数又是 static 函数时，如果将对函数的所有调用都集成到调用程序中，并且永远不会使用函数的地址，那么就永远不会引用函数自己的汇编代码。在这种情况下，除非指定选项，否则GCC实际上不会为该函数输出汇编代码。-fkeep-inline-functions。如果存在未集成的调用，则该函数将照常编译为汇编代码。如果程序引用其地址，则该函数也必须照常编译，因为无法内联。</p>
<p>请注意，函数定义中的某些用法可能使其不适用于内联替换。这些用法包​​括：可变函数，使用 alloca ，使用计算的goto（请参见标签为值），使用非本地goto，使用嵌套函数，使用 setjmp ，使用 __builtin_longjmp 以及使用 __builtin_return 或 __builtin_apply_args 。使用-Winline当不能替换标记为 inline 的函数时发出警告，并给出失败的原因。</p>
<p>根据ISO C ++的要求，即使未使用 inline 关键字明确声明，GCC仍将在类主体内定义的成员函数标记为内联。您可以使用-fno-default-inline; 请参阅控制C ++语言的选项。</p>
<p>如果未进行优化，则GCC不会内联任何功能，除非您指定“always_inline’函数的属性，如下所示：</p>
<p>/* 原型。 <a href="#id303"><span class="problematic" id="id304">*</span></a>/
inline void foo (const char) __attribute__((always_inline));</p>
<p>本节剩下的部分是针对GNU C90的内联。</p>
<p>当内联函数不是 static 时，则编译器必须假定可能存在其他源文件的调用；由于全局符号只能在任何程序中定义一次，因此该函数不得在其他源文件中定义，因此无法集成其中的调用。因此，非 static 内联函数总是以通常的方式自行编译。</p>
<p>如果在函数定义中同时指定 inline 和 extern ，则该定义仅用于内联。在任何情况下，即使您显式引用其地址，该函数也不会自行编译。这样的地址将成为一个外部引用，就好像您仅声明了该函数而未定义它一样。</p>
<p>inline 和 extern 这种组合几乎具有宏的作用。使用它的方法是使用这些关键字将函数定义放入头文件中，并将定义的另一个副本（缺少 inline 和 extern ）放入库文件中。头文件中的定义导致对函数的大多数调用被内联。如果仍然使用该功能，则它们引用库中的单个副本。</p>
</div>
<div class="section" id="id305">
<h2>什么时候访问易失对象？<a class="headerlink" href="#id305" title="Permalink to this headline">¶</a></h2>
<p>C语言有易失性对象的概念。这些对象通常由指针访问,用于访问硬件或线程间通信。标准鼓励编译器避免对易失性对象的访问进行优化,但对于什么是易失性访问,则让编译器在实施时加以定义。最低要求是在一个序列点上,之前对易失性对象的所有访问都已经稳定下来,并且没有后续的访问发生。因此,实现可以自由地对序列点之间发生的volatile访问进行重新排序和组合,但不能对跨序列点的访问进行排序和组合。使用volatile不允许违反两个序列点之间多次更新对象的限制。</p>
<p>对非易失性对象的访问与易失性访问相比并不排序。你不能使用易失性对象作为内存屏障来排序对非易失性内存的写入序列。比如说,你不能使用易失性对象作为内存屏障来排列对非易失性内存的写入顺序。</p>
<p>int <a href="#id306"><span class="problematic" id="id307">*</span></a>ptr = something;
volatile int vobj;
<a href="#id308"><span class="problematic" id="id309">*</span></a>ptr = something;
vobj = 1;</p>
<p>除非可以为 <a href="#id310"><span class="problematic" id="id311">*</span></a>ptr 和 vobj 加上别名，否则不能保证在更新 vobj 时对 <a href="#id312"><span class="problematic" id="id313">*</span></a>ptr 进行写操作。如果需要此保证，则必须使用更强的内存屏障，例如：</p>
<p>int <a href="#id314"><span class="problematic" id="id315">*</span></a>ptr = something;
volatile int vobj;
<a href="#id316"><span class="problematic" id="id317">*</span></a>ptr = something;
asm volatile (“” : : : “memory”);
vobj = 1;</p>
<p>当在void上下文中访问一个标量volatile对象时,就会被读取。</p>
<p>volatile int <a href="#id318"><span class="problematic" id="id319">*</span></a>src = somevalue;
<a href="#id320"><span class="problematic" id="id321">*</span></a>src;</p>
<p>这样的表达式是rvalues,GCC将其实现为对被指向的volatile对象的读取。</p>
<p>赋值也是表达式，具有右值。但是，在分配给标量volatile时，无论是否使用赋值表达式的rvalue，都不会重新读取volatile对象。如果使用分配的右值，则该值为分配给易失对象的值。例如，在以下所有情况下，都不会读取 vobj ：</p>
<p>int obj;
volatile int vobj;
vobj = something;
obj = vobj = something;
obj ? vobj = onething : vobj = anotherthing;
obj = (something, vobj = anotherthing);</p>
<p>如果需要在赋值发生后读取易失性对象,必须使用一个单独的表达式,中间有一个序列点。</p>
<p>由于位字段不是单独可寻址的,所以当写入或访问相邻位字段时,易失性位字段可能被隐式读取。比特字段的操作可能会被优化,如果相邻的比特字段跨越了存储单元的边界,那么它们只能被部分访问。由于这些原因,使用易失性位场来访问硬件是不明智的。</p>
</div>
<div class="section" id="c">
<h2>如何在C代码中使用内联汇编语言<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h2>
<p>使用asm关键字可以将汇编程序指令嵌入C代码中。 GCC提供了两种形式的内联asm语句。 基本的asm语句是没有操作数的语句（请参见第6.47.1节[基本asm]，第617页），而扩展的asm语句（请参见第6.47.2节[扩展的asm]，请参见第619页）包括一个或多个操作数。 扩展形式是在函数中混合使用C和汇编语言的首选，但是要在顶层包含汇编语言，则必须使用基本的asm。</p>
<p>您还可以使用asm关键字覆盖C符号的汇编器名称，或将C变量放置在特定的寄存器中。</p>
<p>总结：</p>
<p>### 6.47.1基本Asm —不带操作数的汇编程序指令</p>
<p>基本的asm语句具有以下语法：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">asm</span> <span class="pre">asm-qualifiers</span> <span class="pre">(</span> <span class="pre">AssemblerInstructions</span> <span class="pre">)</span>
<span class="pre">`</span></code></p>
<p>asm关键字是GNU扩展。 在编写可以使用“ -ansi”和各种“ -std”选项进行编译的代码时，请使用__asm__而不是asm（请参见第6.48节[备用关键字]，第673页）。</p>
<p>Qualifiers</p>
<ul class="simple">
<li><p>volatile:可选的volatile限定符无效。 所有基本的asm块都是隐式易失的。</p></li>
<li><p>inline:如果使用内联限定符，则出于内联目的，将asm语句的大小视为可能的最小大小（请参见第6.47.6节[asm的大小]，第672页）。</p></li>
</ul>
<p>Parameters</p>
<ul>
<li><p>AssemblerInstructions:这是一个文字字符串，用于指定汇编代码。 该字符串可以包含汇编程序可识别的任何指令，包括指令。 GCC不会自行解析汇编程序指令，也不知道它们的含义，甚至不知道它们是否是有效的汇编程序输入。</p>
<p>您可以将多个汇编程序指令放在一个asm字符串中，并用系统的汇编代码中通常使用的字符分隔。 在大多数地方都可以使用的组合是换行符，以换行符，再加上制表符（写为“ n t”）。 一些汇编程序允许使用分号作为行分隔符。 但是，请注意，某些汇编方言使用分号来开始注释。</p>
</li>
</ul>
<p>Remarks</p>
<p>使用扩展的asm（请参见第6.47.2节[扩展的asm]，第619页）通常会生成更小，更安全，更高效的代码，并且在大多数情况下，它是比基本asm更好的解决方案。 但是，在两种情况下只能使用基本的asm：</p>
<ul class="simple">
<li><p>扩展的asm语句必须在C函数内部，因此要在文件范围内（“顶级”）编写内联汇编语言，必须在C函数外部使用基本的asm。 您可以使用此技术来发出汇编指令，定义可以在文件中其他位置调用的汇编语言宏，或以汇编语言编写整个函数。函数之外的基本asm语句可能不使用任何限定符。</p></li>
<li><p>用裸属性声明的函数也需要基本的asm（请参见第6.33节[函数属性]，第521页）。</p></li>
</ul>
<p>从基本asm中安全地访问C数据和调用函数比看起来要复杂得多。 要访问C数据，最好使用扩展的asm。</p>
<p>不要期望汇编后的一系列asm语句保持完美连续。 如果某些指令需要在输出中保持连续，请将它们放在单个多指令asm语句中。 请注意，GCC的优化程序可以相对于其他代码（包括跨跳转）移动asm语句。</p>
<p>asm语句可能不会执行跳转到其他asm语句的操作。 GCC不了解这些跳跃，因此在决定如何优化时无法考虑它们。 仅在扩展的asm中支持从asm到C标签的跳转。</p>
<p>在某些情况下，GCC可能会在优化时复制（或删除重复的）汇编代码。 如果您的汇编代码定义了符号或标签，则可能导致在编译期间出现意外的重复符号错误。</p>
<p>警告：C标准没有为asm指定语义，这使其成为编译器之间不兼容的潜在来源。 这些不兼容性可能不会产生编译器警告/错误。</p>
<p>GCC不会解析基本的asm的AssemblerInstructions，这意味着无法与编译器进行通信。 GCC在asm中没有可见的符号，可能会将其作为未引用的符号丢弃。 它还不知道汇编代码的副作用，例如对内存或寄存器的修改。 与某些编译器不同，GCC假定不会更改通用寄存器。 此假设可能会在将来的版本中更改。</p>
<p>为了避免将来对语义的更改以及编译器之间的兼容性问题而带来的麻烦，请考虑使用扩展的asm替换基本的asm。 有关如何执行此转换的信息，请参见如何从基本的asm转换为扩展的asm。</p>
<p>编译器将基本汇编语言中的汇编程序指令逐字复制到汇编语言输出文件中，而无需处理方言或扩展汇编语言中可用的任何“％”运算符。 这会导致基本的asm字符串和扩展的asm模板之间的细微差别。 例如，要引用寄存器，您可以在基本asm中使用“％eax”，在扩展asm中使用“ %% eax”。</p>
<p>在支持多种汇编方言的x86之类的目标上，所有基本的asm块都使用“ -masm”命令行选项指定的汇编方言（请参见第3.19.59节[x86选项]，第439页）。 基本asm没有提供为不同的方言提供不同的汇编程序字符串的机制。</p>
<p>对于具有非空汇编程序字符串的基本汇编，GCC假定汇编程序块不会更改任何通用寄存器，但可以读取或写入任何全局可访问变量。</p>
<p>这是i386的基本asm示例：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">/*</span> <span class="pre">Note</span> <span class="pre">that</span> <span class="pre">this</span> <span class="pre">code</span> <span class="pre">will</span> <span class="pre">not</span> <span class="pre">compile</span> <span class="pre">with</span> <span class="pre">-masm=intel</span> <span class="pre">*/#define</span> <span class="pre">DebugBreak()</span> <span class="pre">asm(&quot;int</span> <span class="pre">$3&quot;)</span>
<span class="pre">`</span></code></p>
<p>总结：</p>
<p>### 6.47.2 扩展的Asm-具有C表达式操作数的汇编程序指令</p>
<p>使用扩展的asm，您可以从汇编器读取和写入C变量，并执行从汇编器代码到C标签的跳转。 扩展的asm语法使用冒号（’：’）来分隔汇编模板后的操作数参数：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">asm</span> <span class="pre">asm-qualifiers</span> <span class="pre">(</span> <span class="pre">AssemblerTemplate</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">OutputOperands</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">[</span> <span class="pre">:</span> <span class="pre">InputOperands</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">[</span> <span class="pre">:</span> <span class="pre">Clobbers</span> <span class="pre">]</span> <span class="pre">])asm</span> <span class="pre">asm-qualifiers</span> <span class="pre">(</span> <span class="pre">AssemblerTemplate</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">OutputOperands</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">InputOperands</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">Clobbers</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">GotoLabels)</span>
<span class="pre">`</span></code></p>
<p>在最后一种形式中，asm限定符包含goto（在第一种形式中则不是）。</p>
<p>asm关键字是GNU扩展。 在编写可以使用“ -ansi”和各种“ -std”选项进行编译的代码时，请使用__asm__而不是asm（请参见第6.48节[备用关键字]，第673页）。</p>
<p>Qualifiers</p>
<ul class="simple">
<li><p>volatile:扩展asm语句的典型用法是操纵输入值以产生输出值。 但是，您的asm语句也可能会产生副作用。 如果是这样，您可能需要使用volatile限定符来禁用某些优化。 参见[Volatile]，第621页。</p></li>
<li><p>inline:如果使用内联限定符，则出于内联目的，将asm语句的大小视为可能的最小尺寸（请参见第6.47.6节[asm的大小]，第672页）。</p></li>
<li><p>goto:该限定符通知编译器，asm语句可能会跳转到GotoLabels中列出的标签之一。 参见[GotoLabels]，第633页。</p></li>
</ul>
<p>Parameters</p>
<ul>
<li><p>AssemblerTemplate:这是一个文字字符串，它是汇编代码的模板。 它是固定文本和令牌的组合，这些令牌引用了输入，输出和goto参数。 参见[AssemblerTemplate]，第622页。</p></li>
<li><p>OutputOperands:由AssemblerTemplate中的指令修改的C变量的逗号分隔列表。 允许使用空列表。 参见[OutputOperands]，第624页。</p></li>
<li><p>InputOperands:由AssemblerTemplate中的指令读取的C表达式的逗号分隔列表。 允许使用空列表。 参见[InputOperands]，第628页。</p></li>
<li><p>Clobbers:由逗号分隔的寄存器列表或由AssemblerTemplate更改的其他值（列表中的输出除外）。允许使用空列表。 请参阅第630页的[Clobbers和暂存寄存器]。</p></li>
<li><p>GotoLabels:当您使用asm的goto形式时，此部分包含AssemblerTemplate中的代码可能跳转到的所有C标签的列表。 参见[GotoLabels]，第633页。</p>
<p>asm语句可能不会跳转到其他asm语句，而只会跳转到列出的GotoLabels。 GCC的优化程序不了解其他跳转； 因此，在决定如何优化时，他们无法考虑它们。</p>
</li>
</ul>
<p>输入+输出+跳转操作数的总数限制为30。</p>
<p>Remarks</p>
<p>使用asm语句可以将汇编指令直接包含在C代码中，这可以帮助您最大程度地提高对时间敏感的代码的性能或访问C程序不易使用的汇编指令。</p>
<p>请注意，扩展的asm语句必须在函数内部。 只有基本汇编可能是外部功能（请参见第6.47.1节[基本汇编]，第617页）。 用裸属性声明的函数也需要基本的asm（请参见第6.33节[函数属性]，第521页）。</p>
<p>尽管asm的用法是多种多样的，但将asm语句视为将输入参数转换为输出参数的一系列低级指令可能会有所帮助。 因此，一个使用asm的i386的简单示例（如果不是特别有用）可能看起来像这样：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">int</span> <span class="pre">src</span> <span class="pre">=</span> <span class="pre">1;int</span> <span class="pre">dst;asm</span> <span class="pre">(&quot;mov</span> <span class="pre">%1,</span> <span class="pre">%0\n\t&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">&quot;add</span> <span class="pre">$1,</span> <span class="pre">%0&quot;</span>&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;=r&quot;</span> <span class="pre">(dst)</span>&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;r&quot;</span> <span class="pre">(src));printf(&quot;%d\n&quot;,</span> <span class="pre">dst);</span>
<span class="pre">`</span></code></p>
<p>此代码将src复制到dst，并将1加到dst。</p>
<p>总结：</p>
<p>#### 6.47.2.1 Volatile</p>
<p>如果GCC的优化程序确定不需要输出变量，则有时会丢弃asm语句。 同样，如果优化器认为代码将始终返回相同的结果（即，其输入值在两次调用之间均未更改），则可以将代码移出循环。 使用易失性限定词将禁用这些优化。 没有输出操作数的asm语句和asm goto语句是隐式易失的。</p>
<p>此i386代码演示了一种不使用（或不需要）volatile限定符的情况。 如果它正在执行断言检查，则此代码使用asm来执行验证。否则，任何代码都不会引用dwRes。 结果，优化器可以放弃asm语句，从而消除了对整个DoCheck例程的需求。 通过在不需要时取消易失性限定符，可以使优化器生成尽可能高效的代码。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">void</span> <span class="pre">DoCheck(uint32_t</span> <span class="pre">dwSomeValue){</span>&#160;&#160;&#160;&#160; <span class="pre">uint32_t</span> <span class="pre">dwRes;</span> <span class="pre">//</span> <span class="pre">Assumes</span> <span class="pre">dwSomeValue</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">zero.</span>&#160;&#160;&#160;&#160; <span class="pre">asm</span> <span class="pre">(&quot;bsfl</span> <span class="pre">%1,%0&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;=r&quot;</span> <span class="pre">(dwRes)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;r&quot;</span> <span class="pre">(dwSomeValue)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;cc&quot;);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">assert(dwRes</span> <span class="pre">&gt;</span> <span class="pre">3);}</span>
<span class="pre">`</span></code></p>
<p>下一个示例显示了这样一种情况：优化器可以识别出输入（dwSomeValue）在函数执行期间永不改变，因此可以将asm移出循环以产生更有效的代码。 同样，使用易失性限定词会禁用这种类型的优化。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">void</span> <span class="pre">do_print(uint32_t</span> <span class="pre">dwSomeValue){</span>&#160;&#160;&#160; <span class="pre">uint32_t</span> <span class="pre">dwRes;</span> <span class="pre">for</span> <span class="pre">(uint32_t</span> <span class="pre">x=0;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">5;</span> <span class="pre">x++)</span>&#160; <span class="pre">{</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">//</span> <span class="pre">Assumes</span> <span class="pre">dwSomeValue</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">zero.</span>&#160;&#160;&#160;&#160; <span class="pre">asm</span> <span class="pre">(&quot;bsfl</span> <span class="pre">%1,%0&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;=r&quot;</span> <span class="pre">(dwRes)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;r&quot;</span> <span class="pre">(dwSomeValue)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;cc&quot;);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">printf(&quot;%u:</span> <span class="pre">%u</span> <span class="pre">%u\n&quot;,</span> <span class="pre">x,</span> <span class="pre">dwSomeValue,</span> <span class="pre">dwRes);</span>&#160; <span class="pre">}}</span>
<span class="pre">`</span></code></p>
<p>下面的示例演示了需要使用volatile限定符的情况。 它使用x86 rdtsc指令，该指令读取计算机的时间戳记计数器。 如果没有volatile限定符，优化器可能会假设asm块将始终返回相同的值，因此可以优化掉第二个调用。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">uint64_t</span> <span class="pre">msr;asm</span> <span class="pre">volatile</span> <span class="pre">(</span> <span class="pre">&quot;rdtsc\n\t&quot;</span> <span class="pre">&quot;shl</span> <span class="pre">$32,</span> <span class="pre">%%rdx\n\t&quot;</span>&#160;&#160;&#160; <span class="pre">&quot;or</span> <span class="pre">%%rdx,</span> <span class="pre">%0&quot;</span>&#160; <span class="pre">:</span> <span class="pre">&quot;=a&quot;</span> <span class="pre">(msr)</span>&#160;&#160;&#160; <span class="pre">:</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;rdx&quot;);printf(&quot;msr:</span> <span class="pre">%llx\n&quot;,</span> <span class="pre">msr);asm</span> <span class="pre">volatile</span> <span class="pre">(</span> <span class="pre">&quot;rdtsc\n\t&quot;</span>&#160; <span class="pre">&quot;shl</span> <span class="pre">$32,</span> <span class="pre">%%rdx\n\t&quot;</span>&#160;&#160;&#160; <span class="pre">&quot;or</span> <span class="pre">%%rdx,</span> <span class="pre">%0&quot;</span>&#160; <span class="pre">:</span> <span class="pre">&quot;=a&quot;</span> <span class="pre">(msr)</span>&#160;&#160;&#160; <span class="pre">:</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;rdx&quot;);printf(&quot;msr:</span> <span class="pre">%llx\n&quot;,</span> <span class="pre">msr);</span>
<span class="pre">`</span></code></p>
<p>GCC的优化程序不会像前面的示例中那样将这些代码视为非易失性代码。它们不会将其移出循环，也不会在先前调用的结果仍然有效的前提下将其省略。</p>
<p>请注意，编译器甚至可以相对于其他代码移动易失性asm指令，包括跨跳转指令。 例如，在许多目标上，都有一个系统寄存器来控制浮点运算的舍入模式。 如下面的PowerPC示例中那样，使用易失的asm语句设置它不能可靠地工作。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">asm</span> <span class="pre">volatile(&quot;mtfsf</span> <span class="pre">255,</span> <span class="pre">%0&quot;</span> <span class="pre">:</span> <span class="pre">:</span> <span class="pre">&quot;f&quot;</span> <span class="pre">(fpenv));sum</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y;</span>
<span class="pre">`</span></code></p>
<p>编译器可以将附加项移回volatile asm语句之前。 为了使其按预期工作，请通过在后续代码中引用一个变量，将人工依赖项添加到asm中，例如：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">asm</span> <span class="pre">volatile</span> <span class="pre">(&quot;mtfsf</span> <span class="pre">255,%1&quot;</span> <span class="pre">:</span> <span class="pre">&quot;=X&quot;</span> <span class="pre">(sum)</span> <span class="pre">:</span> <span class="pre">&quot;f&quot;</span> <span class="pre">(fpenv));sum</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y;</span>
<span class="pre">`</span></code></p>
<p>在某些情况下，GCC可能会在优化时复制（或删除重复的）汇编代码。 如果您的asm代码定义了符号或标签，则可能在编译期间导致意外的重复符号错误。 使用“％=”（请参阅[AssemblerTemplate]， 第622页）可能有助于解决此问题。</p>
<p>总结：</p>
<p>#### 6.47.2.2 汇编模板</p>
<p>汇编器模板是包含汇编器指令的文字字符串。 编译器替换引用输入，输出和goto标签的模板中的标记，然后将结果字符串输出到汇编器。 该字符串可以包含汇编程序可识别的任何指令，包括指令。 GCC不会自行解析汇编程序指令，也不知道它们的含义，甚至不知道它们是否为有效的汇编程序输入。 但是，它确实对语句进行计数（请参见第6.47.6节“汇编程序的大小”，第672页）。</p>
<p>您可以将多个汇编程序指令放在一个asm字符串中，并用系统的汇编代码中通常使用的字符分隔。 在大多数情况下都可以使用的组合是：换行符以换行，再加上制表符以移至说明字段（写为“ n t”）。 一些汇编程序允许使用分号作为行分隔符。 但是，请注意，某些汇编方言使用分号来开始注释。</p>
<p>即使在使用volatile限定符时，也不要期望asm语句序列在编译后会保持完美连续。 如果某些指令需要在输出中保持连续，请将它们放在单个多指令asm语句中。</p>
<p>在不使用输入/输出操作数的情况下（例如通过直接从汇编模板使用全局符号）从C程序访问数据可能无法按预期方式工作。 同样，直接从汇编器模板调用函数需要对目标汇编器和ABI有详细的了解。</p>
<p>由于GCC不会解析汇编程序模板，因此它看不到它引用的任何符号。 除非这些符号也被列为输入，输出或goto操作数，否则这可能导致GCC丢弃那些未引用的符号。</p>
<p>Special format strings</p>
<p>除了输入，输出和goto操作数所描述的标记外，这些标记在汇编器模板中还具有特殊含义：</p>
<ul class="simple">
<li><p>‘%%’:将单个“％”输出到汇编代码中。</p></li>
<li><p>‘%=’:输出整个编译过程中asm语句的每个实例唯一的数字。 当创建本地标签并在生成多个汇编指令的单个模板中多次引用它们时，此选项很有用。</p></li>
<li><p>‘%{’/‘%|’/‘%}’:将“ {”，“ <a href="#id322"><span class="problematic" id="id323">|</span></a>”和“}”字符分别输出到汇编代码中。 不转义时，这些字符具有特殊的含义，以指示多种汇编方言，如下所述。</p></li>
</ul>
<p>#### asm模板中的多个汇编方言</p>
<p>在诸如x86的目标上，GCC支持多种汇编方言。 “ -masm”选项控制GCC将哪一种方言用作内联汇编程序的默认语言。 “ -masm”选项的特定于目标的文档包含受支持的方言列表，以及未指定选项的默认方言。 理解这些信息可能很重要，因为使用一种方言进行编译时可以正常工作的汇编代码如果使用另一种方言进行编译可能会失败。 请参阅第3.19.59节[x86选项]，第439页。</p>
<p>如果您的代码需要支持多种汇编方言（例如，如果您正在编写需要支持多种编译选项的公共头文件），请使用以下形式的构造：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">{</span> <span class="pre">dialect0</span> <span class="pre">|</span> <span class="pre">dialect1</span> <span class="pre">|</span> <span class="pre">dialect2...</span> <span class="pre">}</span>
<span class="pre">`</span></code></p>
<p>当使用方言＃0编译代码时，此构造输出方言0；对于方言＃1，使用方言1编译，以此类推。如果花括号中的替代项少于编译器支持的方言数量，则该结构不输出任何内容。</p>
<p>例如，如果x86编译器支持两种方言（“ att”，“ intel”），则将是如下所示的汇编模板：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">&quot;bt{l</span> <span class="pre">%[Offset],%[Base]</span> <span class="pre">|</span> <span class="pre">%[Base],%[Offset]};</span> <span class="pre">jc</span> <span class="pre">%l2&quot;</span>
<span class="pre">`</span></code></p>
<p>等价于以下之一 :</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">&quot;btl</span> <span class="pre">%[Offset],%[Base]</span> <span class="pre">;</span> <span class="pre">jc</span> <span class="pre">%l2&quot;</span>&#160;&#160; <span class="pre">/*</span> <span class="pre">att</span> <span class="pre">dialect</span> <span class="pre">*/&quot;bt</span> <span class="pre">%[Base],%[Offset];</span> <span class="pre">jc</span> <span class="pre">%l2&quot;</span>&#160;&#160; <span class="pre">/*</span> <span class="pre">intel</span> <span class="pre">dialect</span> <span class="pre">*/</span>
<span class="pre">`</span></code></p>
<p>使用相同的编译器，此代码：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">&quot;xchg{l}\t{\%\%}ebx,</span> <span class="pre">%1&quot;</span>
<span class="pre">`</span></code></p>
<p>对应于</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">&quot;xchgl\t%%ebx,</span> <span class="pre">%1&quot;</span>&#160; <span class="pre">/*</span> <span class="pre">att</span> <span class="pre">dialect</span> <span class="pre">*/&quot;xchg\tebx,</span> <span class="pre">%1&quot;</span>&#160; <span class="pre">/*</span> <span class="pre">intel</span> <span class="pre">dialect</span> <span class="pre">*/</span>
<span class="pre">`</span></code></p>
<p>不支持嵌套方言替代方案。</p>
<p>总结：</p>
<p>### 6.47.2.3 输出操作数</p>
<p>一个asm语句具有零个或多个输出操作数，这些输出操作数指示由汇编代码修改的C变量的名称。</p>
<p>在此i386示例中，old（在模板字符串中称为％0）和* Base（作为％1）是输出，而Offset（％2）是输入：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">bool</span> <span class="pre">old;__asm__</span> <span class="pre">(&quot;btsl</span> <span class="pre">%2,%1\n\t&quot;</span> <span class="pre">//</span> <span class="pre">Turn</span> <span class="pre">on</span> <span class="pre">zero-based</span> <span class="pre">bit</span> <span class="pre">#Offset</span> <span class="pre">in</span> <span class="pre">Base.</span>&#160;&#160; <span class="pre">&quot;sbb</span> <span class="pre">%0,%0&quot;</span>&#160;&#160;&#160;&#160; <span class="pre">//</span> <span class="pre">Use</span> <span class="pre">the</span> <span class="pre">CF</span> <span class="pre">to</span> <span class="pre">calculate</span> <span class="pre">old.</span> <span class="pre">:</span> <span class="pre">&quot;=r&quot;</span> <span class="pre">(old),</span> <span class="pre">&quot;+rm&quot;</span> <span class="pre">(*Base)</span>&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;Ir&quot;</span> <span class="pre">(Offset)</span> <span class="pre">:</span> <span class="pre">&quot;cc&quot;);return</span> <span class="pre">old;</span>
<span class="pre">`</span></code></p>
<p>操作数之间用逗号分隔。 每个操作数都具有以下格式：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">[</span> <span class="pre">[asmSymbolicName]</span> <span class="pre">]</span> <span class="pre">constraint</span> <span class="pre">(cvariablename)</span>
<span class="pre">`</span></code></p>
<ul>
<li><p>asmSymbolicName:指定操作数的符号名称。 将名称括在方括号中即可引用汇编程序模板中的名称（即“％[Value]”）。 名称的范围是包含定义的asm语句。 任何有效的C变量名称都是可接受的，包括周围代码中已定义的名称。 同一asm语句中的两个操作数都不能使用相同的符号名。 不使用asmSymbolicName时，请在汇编器模板的操作数列表中使用操作数（从零开始）的位置。 例如，如果有三个输出操作数，则在模板中使用“％0”来引用第一个，第二个是“％1”，第三个是“％2”。</p></li>
<li><p>constraint:一个字符串常量，它指定对操作数的放置的限制； 有关详细信息，请参见第6.47.3节“约束”（第638页）。</p>
<p>输出限制必须以“ =”（覆盖现有值的变量）或“ +”（读取和写入时）开头。</p>
<p>当使用’=’时，除非将操作数绑定到输入，否则不要假定该位置包含输入到asm时的现有值； 请参阅[输入操作数]，第628页。</p>
<p>在前缀之后，必须有一个或多个其他约束（请参阅 第6.47.3节[约束]，第638页）描述了该值所在的位置。</p>
<p>常见的限制条件包括“ r”代表寄存器，“ m”代表内存。 当您列出多个可能的位置（例如，“ = rm”）时，编译器将根据当前上下文选择最有效的位置。 如果您列出了asm语句允许的尽可能多的替代项，则可以允许优化器产生最佳的代码。 如果必须使用特定的寄存器，但是您的机器约束不能提供足够的控制来选择所需的特定寄存器，则可以使用局部寄存器变量来提供解决方案（请参见第671.5.2节[局部寄存器变量]）。</p>
</li>
<li><p>cvariablename:指定一个C lvalue表达式来保存输出，通常是一个变量名。括号是语法的必需部分。</p></li>
</ul>
<p>当编译器选择用于表示输出操作数的寄存器时，它不使用任何破坏寄存器（请参见[Clobbers和Scratch寄存器]，第630页）。</p>
<p>输出操作数表达式必须为左值。 编译器无法检查操作数是否具有对于正在执行的指令合理的数据类型。 对于不能直接寻址的输出表达式（例如，位字段），约束必须允许寄存器。 在这种情况下，GCC将寄存器用作asm的输出，然后将该寄存器存储到输出中。</p>
<p>使用“ +”约束修饰符的操作数将作为两个操作数（即，作为输入和输出）计入每个asm语句的最大30个操作数。</p>
<p>在所有不得与输入重叠的输出操作数上使用“＆”约束修饰符（请参见第6.47.3.3节[修饰符]，第641页）。 否则，假设汇编代码在产生输出之前会消耗其输入，则GCC可以将输出操作数与无关的输入操作数分配在同一寄存器中。 如果汇编代码实际上由多个指令组成，则此假设可能是错误的。</p>
<p>如果一个输出参数（a）允许寄存器约束，而另一个输出参数（b）允许存储器约束，则可能发生相同的问题。 GCC生成的用于访问b中的内存地址的代码可以包含可能由a共享的寄存器，并且GCC认为这些寄存器是asm的输入。 如上所述，GCC假定在写入任何输出之前就消耗了这些输入寄存器。 如果在使用b之前将asm语句写入a，则此假设可能会导致错误的行为。 将“＆”修饰符与a上的寄存器约束结合使用，可以确保修改a不会影响b引用的地址。 否则，如果在使用b之前修改了a，则b的位置是不确定的。</p>
<p>asm支持对操作数进行操作数修饰符（例如，“％k2”而不是简单的“％2”）。通常，这些限定符取决于硬件。 可在[x86Operandmodifiers]（第634页）中找到x86支持的修饰符列表。</p>
<p>如果asm后面的C代码不使用任何输出操作数，则对asm语句使用volatile，以防止优化程序不必要地丢弃asm语句（请参见[Volatile]，第621页）。</p>
<p>此代码不使用可选的asmSymbolicName。 因此，它将第一个输出操作数引用为％0（如果有第二个，则为％1，依此类推）。 第一个输入操作数的数量比最后一个输出操作数的数量大一个。 在此i386示例中， 使Mask引用为％1：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">uint32_t</span> <span class="pre">Mask</span> <span class="pre">=</span> <span class="pre">1234;uint32_t</span> <span class="pre">Index;asm</span> <span class="pre">(&quot;bsfl</span> <span class="pre">%1,</span> <span class="pre">%0&quot;</span>&#160; <span class="pre">:</span> <span class="pre">&quot;=r&quot;</span> <span class="pre">(Index)</span>&#160; <span class="pre">:</span> <span class="pre">&quot;r&quot;</span> <span class="pre">(Mask)</span>&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;cc&quot;);</span>
<span class="pre">`</span></code></p>
<p>该代码将覆盖变量Index（’=’），并将值存储在寄存器（’r’）中。 使用通用的“ r”约束代替特定寄存器的约束，可使编译器选择要使用的寄存器，从而可以提高代码效率。 如果汇编指令需要特定的寄存器，则可能无法实现。</p>
<p>以下i386示例使用asmSymbolicName语法。 它产生的结果与上面的代码相同，但是有些人可能认为它更具可读性或可维护性，因为在添加或删除操作数时不需要对索引号进行重新排序。 名称aIndex和aMask仅在此示例中用于强调哪些名称在何处使用。 重用名称Index和Mask是可以接受的。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">uint32_t</span> <span class="pre">Mask</span> <span class="pre">=</span> <span class="pre">1234;uint32_t</span> <span class="pre">Index;asm</span> <span class="pre">(&quot;bsfl</span> <span class="pre">%[aMask],</span> <span class="pre">%[aIndex]&quot;</span>&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">[aIndex]</span> <span class="pre">&quot;=r&quot;</span> <span class="pre">(Index)</span> <span class="pre">:</span> <span class="pre">[aMask]</span> <span class="pre">&quot;r&quot;</span> <span class="pre">(Mask)</span>&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;cc&quot;);</span>
<span class="pre">`</span></code></p>
<p>这是输出操作数的更多示例。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">uint32_t</span> <span class="pre">c</span> <span class="pre">=</span> <span class="pre">1;uint32_t</span> <span class="pre">d;uint32_t</span> <span class="pre">*e</span> <span class="pre">=</span> <span class="pre">&amp;c;asm</span> <span class="pre">(&quot;mov</span> <span class="pre">%[e],</span> <span class="pre">%[d]&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">[d]</span> <span class="pre">&quot;=rm&quot;</span> <span class="pre">(d)</span> <span class="pre">:</span> <span class="pre">[e]</span> <span class="pre">&quot;rm&quot;</span> <span class="pre">(*e));</span>
<span class="pre">`</span></code></p>
<p>此处，d可以在寄存器中，也可以在存储器中。 由于编译器可能已经在寄存器中拥有e指向的uint32_t位置的当前值，因此可以通过指定两个约束使它为d选择最佳位置。</p>
<p>总结：</p>
<p>#### 6.47.2.4 标志输出操作数</p>
<p>一些目标有一个特殊的寄存器，用于保存操作或比较结果的“标志”。 通常，该寄存器的内容不会被asm修改，或者将asm语句视为破坏内容。</p>
<p>在某些目标上，存在一种特殊形式的输出操作数，通过这种形式，标志寄存器中的条件可以是asm的输出。 支持的条件集是特定于目标的，但是一般规则是输出变量必须是标量整数，并且值是布尔值。 如果受支持，则目标定义预处理器符号__GCC_ASM_FLAG_OUTPUTS__。</p>
<p>由于标志输出操作数的特殊性质，约束可能不包括替代项。</p>
<p>目标通常只有一个标志寄存器，因此是许多指令的隐含操作数。 在这种情况下，不应在汇编模板中通过％0等引用操作数，因为汇编语言中没有相应的文本。</p>
<ul class="simple">
<li><p>x86 family:x86系列的标志输出约束形式为“ = &#64; cccond”，其中cond是ISA手册中为jcc或setcc定义的标准条件之一。
- a :“above” or unsigned greater than
- ae: “above or equal” or unsigned greater than or equal
- b: “below” or unsigned less than
- be: “below or equal” or unsigned less than or equal
- c: carry flag set
- e:
- z: “equal” or zero flag set
- g: signed greater than
- ge: signed greater than or equal
- l: signed less than
- le: signed less than or equal
- o: overflow flag set
- p: parity flag set
- s: sign flag set
- na:
- nae:
- nb:
- nbe:
- nc:
- ne:
- ng:
- nge:
- nl:
- nle:
- no:
- np:
- ns:
- nz: “not” flag, or inverted versions of those above</p></li>
</ul>
<p>总结：</p>
<p>#### 6.47.2.5输入操作数</p>
<p>输入操作数使C变量和表达式中的值可用于汇编代码。</p>
<p>操作数之间用逗号分隔。 每个操作数都具有以下格式：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">[</span> <span class="pre">[asmSymbolicName]</span> <span class="pre">]</span> <span class="pre">constraint</span> <span class="pre">(cexpression)</span>
<span class="pre">`</span></code></p>
<ul>
<li><p>asmSymbolicName:指定操作数的符号名称。 将名称括在方括号中即可引用汇编程序模板中的名称（即“％[Value]”）。 名称的范围是包含定义的asm语句。 任何有效的C变量名称都是可接受的，包括周围代码中已定义的名称。 同一asm语句中的两个操作数都不能使用相同的符号名。</p>
<p>不使用asmSymbolicName时，请在汇编器模板的操作数列表中使用操作数（从零开始）的位置。 例如，如果有两个输出操作数和三个输入，则在模板中使用“％2”来引用第一个输入操作数，第二个为“％3”，第三个为“％4”。</p>
</li>
<li><p>constraint:一个字符串常量，它指定对操作数的放置的限制； 有关详细信息，请参见第6.47.3节“约束”（第638页）。</p>
<p>输入约束字符串不能以“ =”或“ +”开头。 当您列出多个可能的位置（例如“ irm”）时，编译器会根据当前上下文选择效率最高的位置。 如果必须使用特定的寄存器，但是您的机器约束不能提供足够的控制来选择所需的特定寄存器，则可以使用局部寄存器变量来提供解决方案（请参见第671.5.2节[局部寄存器变量]）。</p>
<p>输入约束也可以是数字（例如，“ 0”）。 这表明在输出约束列表的（从零开始）索引处，指定的输入必须与输出约束位于同一位置。 当对输出操作数使用asmSymbolicName语法时，可以使用这些名称（用括号[[]]括起来）代替数字。</p>
</li>
<li><p>cexpression:这是C变量或表达式，将其作为输入传递给asm语句。 括号是语法的必需部分。</p></li>
</ul>
<p>当编译器选择用于表示输入操作数的寄存器时，它不使用任何破坏寄存器（请参见[Clobbers和Scratch寄存器]，第630页）。</p>
<p>如果没有输出操作数，但是有输入操作数，则将两个连续的冒号放在输出操作数将要到达的位置：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">__asm__</span> <span class="pre">(&quot;some</span> <span class="pre">instructions&quot;</span>&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">/*</span> <span class="pre">No</span> <span class="pre">outputs.</span> <span class="pre">*/</span>&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;r&quot;</span> <span class="pre">(Offset</span> <span class="pre">/</span> <span class="pre">8));</span>
<span class="pre">`</span></code></p>
<p>警告：请勿修改仅输入操作数的内容（绑定到输出的输入除外）。 编译器假定从asm语句退出时，这些操作数包含的值与执行该语句之前的值相同。 无法使用Clobber通知编译器这些输入中的值正在更改。 一种常见的解决方法是将变化的输入变量与永远不会使用的输出变量联系起来。 但是请注意，如果asm语句后的代码不使用任何输出操作数，则GCC优化器可能会不必要地丢弃asm语句（请参见[Volatile]，第621页）。</p>
<p>asm支持对操作数进行操作数修饰符（例如，“％k2”而不是简单的“％2”）。 通常，这些限定符取决于硬件。 可在[x86Operandmodifiers]（第634页）中找到x86支持的修饰符列表。</p>
<p>在使用虚拟组合指令的示例中，输入操作数1的约束“ 0”表示它必须与输出操作数0占据相同的位置。只有输入操作数可以在约束中使用数字，并且它们每个都必须引用输出操作数。 约束中只有数字（或符号汇编程序名称）可以保证一个操作数与另一个操作数位于同一位置。 仅foo是两个操作数的值这一事实不足以保证它们在生成的汇编代码中位于同一位置。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">asm</span> <span class="pre">(&quot;combine</span> <span class="pre">%2,</span> <span class="pre">%0&quot;</span>&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;=r&quot;</span> <span class="pre">(foo)</span>&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;0&quot;</span> <span class="pre">(foo),</span> <span class="pre">&quot;g&quot;</span> <span class="pre">(bar));</span>
<span class="pre">`</span></code></p>
<p>这是一个使用符号名称的示例。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">asm</span> <span class="pre">(&quot;cmoveq</span> <span class="pre">%1,</span> <span class="pre">%2,</span> <span class="pre">%[result]&quot;</span> <span class="pre">:</span> <span class="pre">[result]</span> <span class="pre">&quot;=r&quot;(result)</span> <span class="pre">:</span> <span class="pre">&quot;r&quot;</span> <span class="pre">(test),</span> <span class="pre">&quot;r&quot;</span> <span class="pre">(new),</span> <span class="pre">&quot;[result]&quot;</span> <span class="pre">(old));</span>
<span class="pre">`</span></code></p>
<p>总结：</p>
<p>#### 6.47.2.6 Clobbers and Scratch Registers</p>
<p>尽管编译器知道对输出操作数中列出的条目的更改，但内联汇编代码可能不仅对输出进行了修改。 例如，计算可能需要其他寄存器，或者处理器可能会由于特定汇编程序指令的副作用而覆盖寄存器。 为了将这些更改通知编译器，请在Clobber列表中列出它们。 垃圾清单项目可以是寄存器名称，也可以是特殊的垃圾清单（下面列出）。 每个clobber列表项都是一个字符串常量，用双引号引起来并分隔 用逗号分隔。</p>
<p>垃圾描述可能不会与输入或输出操作数重叠。 例如，当您将一个寄存器描述在寄存器列表中时，可能没有一个操作数用一个成员来描述一个寄存器类。 声明要存在于特定寄存器中的变量（请参见 第6.47.5节[显式寄存器变量]（第670页），并且用作asm输入或输出操作数，在Clobber描述中必须没有提及。 特别是，如果没有将输入操作数也指定为输出操作数，就无法指定对其进行修改。</p>
<p>当编译器选择使用哪个寄存器表示输入和输出操作数时，它不使用任何破坏寄存器。 结果，在汇编代码中任何可用的寄存器都可以使用。</p>
<p>另一个限制是，Clobber列表不应包含堆栈指针寄存器。 这是因为编译器要求在asm语句之后，堆栈指针的值必须与进入该语句时的堆栈指针的值相同。 但是，以前版本的GCC并未强制执行此规则，并允许堆栈指针以不明确的语义出现在列表中。 不建议使用此行为，并且在将来的GCC版本中列出堆栈指针可能会成为错误。</p>
<p>这是VAX的一个实际示例，显示了破坏性寄存器的使用：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">asm</span> <span class="pre">volatile</span> <span class="pre">(&quot;movc3</span> <span class="pre">%0,</span> <span class="pre">%1,</span> <span class="pre">%2&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:/*</span> <span class="pre">No</span> <span class="pre">outputs.</span> <span class="pre">*/</span>&#160;&#160;&#160;&#160;&#160; <span class="pre">:g&quot;</span> <span class="pre">(from),</span> <span class="pre">&quot;g&quot;</span> <span class="pre">(to),</span> <span class="pre">&quot;g&quot;</span> <span class="pre">(count)</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:&quot;r0&quot;,</span> <span class="pre">&quot;r1&quot;,</span> <span class="pre">&quot;r2&quot;,</span> <span class="pre">&quot;r3&quot;,</span> <span class="pre">&quot;r4&quot;,</span> <span class="pre">&quot;r5&quot;,</span> <span class="pre">&quot;memory&quot;);</span>
<span class="pre">`</span></code></p>
<p>此外，还有两个特殊的争吵参数：</p>
<ul class="simple">
<li><p>“cc”:“ cc”漏洞表明汇编代码修改了标志寄存器。在某些计算机上，GCC将条件代码表示为特定的硬件寄存器；在某些情况下，GCC将条件代码表示为特定的硬件寄存器。 “ cc”用于命名该寄存器。 在其他机器上，条件代码的处理有所不同，并且指定“ cc”无效。 但这是有效的，无论目标是什么。</p></li>
<li><p>“memory”:“内存”缓冲区告诉编译器，汇编代码对输入和输出操作数中未列出的项目执行内存读取或写入操作（例如，访问由输入参数之一指向的内存）。 为了确保内存中包含正确的值，GCC可能需要在执行asm之前将特定的寄存器值刷新到内存中。 此外，编译器不假定在asm之后从内存中读取的任何值在该asm之后保持不变。 它会根据需要重新加载它们。 使用“内存”缓冲区有效地构成了编译器的读/写内存屏障。请注意，此缓冲区不会阻止处理器通过asm语句进行推测性读取。 为避免这种情况，您需要特定于处理器的篱笆指令。</p></li>
</ul>
<p>将寄存器刷新到内存会影响性能，并且可能是时间敏感代码的问题。 您可以向GCC提供更好的信息来避免这种情况，如以下示例所示。 至少，别名规则使GCC知道不需要刷新哪些内存。</p>
<p>这是一个虚拟的平方和指令，它使用两个指针指向内存中的浮点值，并产生一个浮点寄存器输出。 请注意，x和y都在asm参数中出现两次，一次是指定要访问的内存，一次是指定asm使用的基址寄存器。 通常，您这样做不会浪费寄存器，因为GCC可以将相同的寄存器用于这两个目的。 但是，在此asm中为x使用％1和％3都是愚蠢的，并期望它们是相同的。 实际上，％3可能不是寄存器。 它可能是对x指向的对象的符号内存引用。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">asm</span> <span class="pre">(&quot;sumsq</span> <span class="pre">%0,</span> <span class="pre">%1,</span> <span class="pre">%2&quot;</span> <span class="pre">:</span> <span class="pre">&quot;+f&quot;</span> <span class="pre">(result)</span> <span class="pre">:</span> <span class="pre">&quot;r&quot;</span> <span class="pre">(x),</span> <span class="pre">&quot;r&quot;</span> <span class="pre">(y),</span> <span class="pre">&quot;m&quot;</span> <span class="pre">(*x),</span> <span class="pre">&quot;m&quot;</span> <span class="pre">(*y));</span>
<span class="pre">`</span></code></p>
<p>这是一个虚拟的* z ++ = * x ++ * * y ++指令。 请注意，必须将x，y和z指针寄存器指定为输入/输出，因为asm会对其进行修改。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">asm</span> <span class="pre">(&quot;vecmul</span> <span class="pre">%0,</span> <span class="pre">%1,</span> <span class="pre">%2&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;+r&quot;</span> <span class="pre">(z),</span> <span class="pre">&quot;+r&quot;</span> <span class="pre">(x),</span> <span class="pre">&quot;+r&quot;</span> <span class="pre">(y),</span> <span class="pre">&quot;=m&quot;</span> <span class="pre">(*z)</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;m&quot;</span> <span class="pre">(*x),</span> <span class="pre">&quot;m&quot;</span> <span class="pre">(*y));</span>
<span class="pre">`</span></code></p>
<p>一个x86示例，其中字符串内存参数的长度未知。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">asm(&quot;repne</span> <span class="pre">scasb&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;=c&quot;</span> <span class="pre">(count),</span> <span class="pre">&quot;+D&quot;</span> <span class="pre">(p)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;m&quot;</span> <span class="pre">(*(const</span> <span class="pre">char</span> <span class="pre">(*)[])</span> <span class="pre">p),</span> <span class="pre">&quot;0&quot;</span> <span class="pre">(-1),</span> <span class="pre">&quot;a&quot;</span> <span class="pre">(0));</span>
<span class="pre">`</span></code></p>
<p>如果您知道上述内容只会读取一个十字节的数组，则可以改用如下的内存输入：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">&quot;m&quot;</span> <span class="pre">(*(const</span> <span class="pre">char</span> <span class="pre">(*)[10])</span> <span class="pre">p).</span>
<span class="pre">`</span></code></p>
<p>这是一个以汇编形式实现的PowerPC矢量比例的示例，其中包含矢量和条件代码修饰符，以及一些经asm不变的初始化偏移寄存器。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">voiddscal</span> <span class="pre">(size_t</span> <span class="pre">n,</span> <span class="pre">double</span> <span class="pre">*x,</span> <span class="pre">double</span> <span class="pre">alpha){asm</span> <span class="pre">(&quot;/*</span> <span class="pre">lots</span> <span class="pre">of</span> <span class="pre">asm</span> <span class="pre">here</span> <span class="pre">*/&quot;</span>&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;+m&quot;</span> <span class="pre">(*(double</span> <span class="pre">(*)[n])</span> <span class="pre">x),</span> <span class="pre">&quot;+&amp;r&quot;</span> <span class="pre">(n),</span> <span class="pre">&quot;+b&quot;</span> <span class="pre">(x)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;d&quot;</span> <span class="pre">(alpha),</span> <span class="pre">&quot;b&quot;</span> <span class="pre">(32),</span> <span class="pre">&quot;b&quot;</span> <span class="pre">(48),</span> <span class="pre">&quot;b&quot;</span> <span class="pre">(64),</span>&#160;&#160;&#160;&#160;&#160; <span class="pre">&quot;b&quot;</span> <span class="pre">(80),</span> <span class="pre">&quot;b&quot;</span> <span class="pre">(96),</span> <span class="pre">&quot;b&quot;</span> <span class="pre">(112)</span> <span class="pre">:</span> <span class="pre">&quot;cr0&quot;,</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">&quot;vs32&quot;,&quot;vs33&quot;,&quot;vs34&quot;,&quot;vs35&quot;,&quot;vs36&quot;,&quot;vs37&quot;,&quot;vs38&quot;,&quot;vs39&quot;,</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">&quot;vs40&quot;,&quot;vs41&quot;,&quot;vs42&quot;,&quot;vs43&quot;,&quot;vs44&quot;,&quot;vs45&quot;,&quot;vs46&quot;,&quot;vs47&quot;);}</span>
<span class="pre">`</span></code></p>
<p>与其通过clobbers分配固定寄存器来为asm语句提供暂存器，还可以定义变量并将其设置为早期生成器输出，如下面的示例中的a2和a3所示。这为编译器寄存器分配器提供了更大的自由度。您还可以定义一个变量并将其输出绑定到输入，就像a0和a1分别绑定到ap和lda一样。当然，对于绑定输出，由于它们是同一寄存器，所以在修改输出寄存器后，您的asm不能使用输入值。更重要的是，如果您在输出中省略了早期代码，那么如果GCC可以证明它们在输入asm时具有相同的值，则GCC可能会将相同的寄存器分配给另一个输入。这就是为什么a1具有早期优势的原因。可以想象，它的并列输入lda具有值16，并且没有早期消息共享与％11相同的寄存器。另一方面，ap不能与任何其他输入相同，因此不需要a0上的早期提示。在这种情况下也是不希望的。 a0上的早期中断会导致GCC为“ m”（<em>（const double（</em>）[]）ap）输入分配一个单独的寄存器。请注意，将输入绑定到输出是设置初始化的方式由asm语句修改的临时寄存器。 GCC认为未绑定到输出的输入是不变的，例如，下面的“ b”（16）将％11设置为16，如果碰巧需要值16，则GCC可以在以下代码中使用该寄存器。如果在使用暂存器之前已消耗了可能共享同一寄存器的所有输入，则甚至可以将普通的asm输出用于暂存器。除了GCC对asm参数数量的限制之外，被asm语句破坏的VSX寄存器可能已经使用了此技术。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">static</span> <span class="pre">voiddgemv_kernel_4x4</span> <span class="pre">(long</span> <span class="pre">n,</span> <span class="pre">const</span> <span class="pre">double</span> <span class="pre">*ap,</span> <span class="pre">long</span> <span class="pre">lda,const</span> <span class="pre">double</span> <span class="pre">*x,</span> <span class="pre">double</span> <span class="pre">*y,</span> <span class="pre">double</span> <span class="pre">alpha){double</span> <span class="pre">*a0;double</span> <span class="pre">*a1;double</span> <span class="pre">*a2;double</span> <span class="pre">*a3;__asm__(/*</span> <span class="pre">lots</span> <span class="pre">of</span> <span class="pre">asm</span> <span class="pre">here</span> <span class="pre">*/&quot;#n=%1</span> <span class="pre">ap=%8=%12</span> <span class="pre">lda=%13</span> <span class="pre">x=%7=%10</span> <span class="pre">y=%0=%2</span> <span class="pre">alpha=%9</span> <span class="pre">o16=%11\n&quot;&quot;#a0=%3</span> <span class="pre">a1=%4</span> <span class="pre">a2=%5</span> <span class="pre">a3=%6&quot;:</span>&#160;&#160;&#160; <span class="pre">&quot;+m&quot;</span> <span class="pre">(*(double</span> <span class="pre">(*)[n])</span> <span class="pre">y),</span>&#160;&#160;&#160;&#160;&#160; <span class="pre">&quot;+&amp;r&quot;</span> <span class="pre">(n),</span> <span class="pre">//</span> <span class="pre">1</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">&quot;+b&quot;</span> <span class="pre">(y),</span> <span class="pre">//</span> <span class="pre">2</span>&#160; <span class="pre">&quot;=b&quot;</span> <span class="pre">(a0),</span> <span class="pre">//</span> <span class="pre">3</span> <span class="pre">&quot;=&amp;b&quot;</span> <span class="pre">(a1),</span> <span class="pre">//</span> <span class="pre">4</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">&quot;=&amp;b&quot;</span> <span class="pre">(a2),</span> <span class="pre">//</span> <span class="pre">5</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">&quot;=&amp;b&quot;</span> <span class="pre">(a3)</span> <span class="pre">//</span> <span class="pre">6:</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">&quot;m&quot;</span> <span class="pre">(*(const</span> <span class="pre">double</span> <span class="pre">(*)[n])</span> <span class="pre">x),</span> <span class="pre">&quot;m&quot;</span> <span class="pre">(*(const</span> <span class="pre">double</span> <span class="pre">(*)[])</span> <span class="pre">ap),</span> <span class="pre">&quot;d&quot;</span> <span class="pre">(alpha),</span> <span class="pre">//</span> <span class="pre">9</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">&quot;r&quot;</span> <span class="pre">(x),//10&quot;b&quot;</span> <span class="pre">(16),//11&quot;3&quot;</span> <span class="pre">(ap),//12&quot;4&quot;</span> <span class="pre">(lda)</span> <span class="pre">//</span> <span class="pre">13:</span>&#160; <span class="pre">&quot;cr0&quot;,</span>&#160; <span class="pre">&quot;vs32&quot;,&quot;vs33&quot;,&quot;vs34&quot;,&quot;vs35&quot;,&quot;vs36&quot;,&quot;vs37&quot;,</span>&#160;&#160;&#160;&#160;&#160; <span class="pre">&quot;vs40&quot;,&quot;vs41&quot;,&quot;vs42&quot;,&quot;vs43&quot;,&quot;vs44&quot;,&quot;vs45&quot;,&quot;vs46&quot;,&quot;vs47&quot;</span>&#160;&#160; <span class="pre">);}</span>
<span class="pre">`</span></code></p>
<p>#### 6.47.2.7 goto标签</p>
<p>asm goto允许汇编代码跳转到一个或多个C标签。 asm goto语句中的GotoLabels部分包含用逗号分隔的所有C标签列表，汇编代码可能会跳转到这些列表。 GCC假定asm的执行一直执行到下一条语句（如果不是这种情况，请考虑在asm语句之后使用__builtin_unreachable内部函数）。 使用热标签和冷标签属性可以改善asm goto的优化（请参见第607页的6.36节[标签属性]）。</p>
<p>如果汇编代码确实进行了任何修改，请使用“内存”缓冲程序强制优化器将所有寄存器值刷新到内存中，并在asm语句之后根据需要重新加载它们。</p>
<p>还要注意，asm goto语句始终被隐式认为是易失的。</p>
<p>仅在某些可能的控制流路径上在asm goto中设置输出操作数时要小心。 如果您没有在给定路径上设置输出，并且从不在此路径上使用它，那就可以了。 否则，您应该使用“ +”约束修饰符，这意味着操作数是输入和输出一个。 使用此修饰符，您将在asm goto的所有可能路径上获得正确的值。</p>
<p>要在汇编器模板中引用标签，请在标签前添加“％l”（小写字母“ L”），后跟其在GotoLabels中的（从零开始）位置以及输入操作数的数量。 例如，如果asm具有三个输入并引用了两个标签，则将第一个标签称为“％l3”，将第二个标签称为“％l4”）。</p>
<p>另外，您也可以使用括号内的实际C标签名称来引用标签。例如，要引用名为进位的标签，可以使用“％l [carry]”。 使用此方法时，标签仍必须在GotoLabels部分中列出。</p>
<p>这是用于i386的asm goto的示例：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">asm</span> <span class="pre">goto</span> <span class="pre">(</span>&#160;&#160;&#160;&#160;&#160; <span class="pre">&quot;btl</span> <span class="pre">%1,</span> <span class="pre">%0\n\t&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">&quot;jc</span> <span class="pre">%l2&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">/*</span> <span class="pre">No</span> <span class="pre">outputs.</span> <span class="pre">*/</span>&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;r&quot;</span> <span class="pre">(p1),</span> <span class="pre">&quot;r&quot;</span> <span class="pre">(p2)</span>&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;cc&quot;</span>&#160; <span class="pre">:</span> <span class="pre">carry);return</span> <span class="pre">0;carry:return</span> <span class="pre">1;</span>
<span class="pre">`</span></code></p>
<p>以下示例显示了使用内存破坏者的asm goto。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">int</span> <span class="pre">frob(int</span> <span class="pre">x){</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">int</span> <span class="pre">y;</span>&#160; <span class="pre">asm</span> <span class="pre">goto</span> <span class="pre">(&quot;frob</span> <span class="pre">%%r5,</span> <span class="pre">%1;</span> <span class="pre">jc</span> <span class="pre">%l[error];</span> <span class="pre">mov</span> <span class="pre">(%2),</span> <span class="pre">%%r5&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">/*</span> <span class="pre">No</span> <span class="pre">outputs.</span> <span class="pre">*/</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;r&quot;(x),</span> <span class="pre">&quot;r&quot;(&amp;y)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;r5&quot;,</span> <span class="pre">&quot;memory&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">error);</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">return</span> <span class="pre">y;error:</span> <span class="pre">return</span> <span class="pre">-1;}</span>
<span class="pre">`</span></code></p>
<p>以下示例显示了使用输出的asm goto。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">int</span> <span class="pre">foo(int</span> <span class="pre">count){</span>&#160; <span class="pre">asm</span> <span class="pre">goto</span> <span class="pre">(&quot;dec</span> <span class="pre">%0;</span> <span class="pre">jb</span> <span class="pre">%l[stop]&quot;</span>&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;+r&quot;</span> <span class="pre">(count)</span>&#160; <span class="pre">:</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">stop);</span>&#160; <span class="pre">return</span> <span class="pre">count;stop:</span>&#160; <span class="pre">return</span> <span class="pre">0;}</span>
<span class="pre">`</span></code></p>
<p>以下人工示例显示了一个asm goto，它仅在asm goto内部的一条路径上设置输出。 约束修饰符=而不是+的使用将是错误的，因为从asm goto的所有路径上都使用factor。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">int</span> <span class="pre">foo(int</span> <span class="pre">inp){</span>&#160;&#160; <span class="pre">int</span> <span class="pre">factor</span> <span class="pre">=</span> <span class="pre">0;</span>&#160;&#160; <span class="pre">asm</span> <span class="pre">goto</span> <span class="pre">(&quot;cmp</span> <span class="pre">%1,</span> <span class="pre">10;</span> <span class="pre">jb</span> <span class="pre">%l[lab];</span> <span class="pre">mov</span> <span class="pre">2,</span> <span class="pre">%0&quot;</span>&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;+r&quot;</span> <span class="pre">(factor)</span> <span class="pre">:</span> <span class="pre">&quot;r&quot;</span> <span class="pre">(inp)</span>&#160;&#160;&#160;&#160; <span class="pre">:</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">lab);</span>&#160;&#160; <span class="pre">lab:</span>&#160; <span class="pre">return</span> <span class="pre">inp</span> <span class="pre">*</span> <span class="pre">factor;</span> <span class="pre">/*</span> <span class="pre">return</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">inp</span> <span class="pre">or</span> <span class="pre">0</span> <span class="pre">if</span> <span class="pre">inp</span> <span class="pre">&lt;</span> <span class="pre">10</span> <span class="pre">*/}</span>
<span class="pre">`</span></code></p>
<p>总结：</p>
<p>#### 6.47.2.8 x86操作数修饰符</p>
<p>扩展的asm语句的汇编器模板中对输入，输出和goto操作数的引用可以使用修饰符来影响在输出到汇编器的代码中格式化操作数的方式。 例如，以下代码对x86使用“ h”和“ b”修饰符：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">uint16_t</span> <span class="pre">num;asm</span> <span class="pre">volatile</span> <span class="pre">(&quot;xchg</span> <span class="pre">%h0,</span> <span class="pre">%b0&quot;</span> <span class="pre">:</span> <span class="pre">&quot;+a&quot;</span> <span class="pre">(num)</span> <span class="pre">);</span>
<span class="pre">`</span></code></p>
<p>这些修饰符生成以下汇编代码：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">xchg</span> <span class="pre">%ah,</span> <span class="pre">%al</span>
<span class="pre">`</span></code></p>
<p>本讨论的其余部分出于说明目的使用以下代码。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">int</span> <span class="pre">main(){</span>&#160;&#160;&#160;&#160; <span class="pre">int</span> <span class="pre">iInt</span> <span class="pre">=</span> <span class="pre">1;</span>&#160;&#160; <span class="pre">top:</span>&#160;&#160;&#160; <span class="pre">asm</span> <span class="pre">volatile</span> <span class="pre">goto</span> <span class="pre">(&quot;some</span> <span class="pre">assembler</span> <span class="pre">instructions</span> <span class="pre">here&quot;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">/*</span> <span class="pre">No</span> <span class="pre">outputs.</span> <span class="pre">*/</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">&quot;q&quot;</span> <span class="pre">(iInt),</span> <span class="pre">&quot;X&quot;</span> <span class="pre">(sizeof(unsigned</span> <span class="pre">char)</span> <span class="pre">+</span> <span class="pre">1),</span> <span class="pre">&quot;i&quot;</span> <span class="pre">(42)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">/*</span> <span class="pre">No</span> <span class="pre">clobbers.</span> <span class="pre">*/</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">:</span> <span class="pre">top);}</span>
<span class="pre">`</span></code></p>
<p>没有修饰符，这就是汇编器的“ att”和“ intel”方言的操作数输出：</p>
<p>![](/assets/images/linux_img/gcc/gcc_p651.png)</p>
<p>下表显示了受支持的修饰符及其效果的列表。</p>
<p>![](/assets/images/linux_img/gcc/gcc_p651_1.png)</p>
<p>![](/assets/images/linux_img/gcc/gcc_652.png)</p>
<p>![](/assets/images/linux_img/gcc/gcc_652_1.png)</p>
<p>总结：</p>
<p>#### 6.47.2.9 x86浮点汇编操作数</p>
<p>在x86目标上，关于在asm的操作数中使用类似堆栈的寄存器的规则有很多。 这些规则仅适用于类似于堆栈的寄存器的操作数：</p>
<ol class="arabic">
<li><p>除非被约束为与输出操作数匹配，否则必须显式破坏由asm隐式弹出的输入寄存器。 给定一组在asm中消失的输入寄存器，有必要知道asm隐式弹出了哪些输入寄存器，以及GCC显式弹出了哪些输入寄存器。</p>
<p>除非被约束为与输出操作数匹配，否则必须显式破坏由asm隐式弹出的输入寄存器。</p>
</li>
<li><p>对于由asm隐式弹出的任何输入寄存器，有必要知道如何调整堆栈以补偿弹出。 如果有任何未弹出的输入比隐式弹出的寄存器更靠近reg-stack的顶部，则不可能知道堆栈是什么样子—尚不清楚其余堆栈如何“向上滑动”。</p>
<p>所有隐式弹出的输入寄存器必须比未隐式弹出的任何输入都更靠近寄存器堆栈的顶部。</p>
<p>如果输入在asm中死亡，则编译器可能会将输入寄存器用于输出重载。 考虑以下示例：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">asm</span> <span class="pre">(&quot;foo&quot;</span> <span class="pre">:</span> <span class="pre">&quot;=t&quot;</span> <span class="pre">(a)</span> <span class="pre">:</span> <span class="pre">&quot;f&quot;</span> <span class="pre">(b));</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><p>这段代码说，输入b不会被asm弹出，并且asm将结果推送到reg堆栈上，即，堆栈比asm更深。 但是，重载可能会认为它可以将相同的寄存器用于输入和输出。</p>
</div></blockquote>
<p>为了防止这种情况的发生，如果任何输入操作数使用“ f”约束，则所有输出寄存器约束都必须使用“＆” Early-Clobber修饰符。</p>
<p>上面的示例正确编写为：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">asm</span> <span class="pre">(&quot;foo&quot;</span> <span class="pre">:</span> <span class="pre">&quot;=&amp;t&quot;</span> <span class="pre">(a)</span> <span class="pre">:</span> <span class="pre">&quot;f&quot;</span> <span class="pre">(b));</span>
<span class="pre">`</span></code></p>
</li>
<li><p>一些操作数需要放在堆栈中的特定位置。 所有输出操作数都属于此类别-GCC没有其他方法可以知道输出出现在哪个寄存器中，除非您在约束中指出。 输出操作数必须专门指出在asm之后输出出现在哪个寄存器中。 不允许使用“ = f”：操作数约束必须选择具有单个寄存器的类。</p></li>
<li><p>输出操作数可能不会“插入”现有的堆栈寄存器之间。 由于没有387操作码使用读/写操作数，因此所有输出操作数在asm之前都是无效的，并由asm推送。 除了reg-stack的顶部之外，将其推入其他任何位置都没有任何意义。</p>
<p>输出操作数必须从reg-stack的顶部开始：输出操作数可能不会“跳过”寄存器。</p>
</li>
<li><p>一些asm语句可能需要额外的堆栈空间来进行内部计算。 这可以通过破坏与输入和输出无关的堆栈寄存器来保证。</p></li>
</ol>
<p>这个asm接受一个输入，该输入在内部弹出，并产生两个输出。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">asm</span> <span class="pre">(&quot;fsincos&quot;</span> <span class="pre">:</span> <span class="pre">&quot;=t&quot;</span> <span class="pre">(cos),</span> <span class="pre">&quot;=u&quot;</span> <span class="pre">(sin)</span> <span class="pre">:</span> <span class="pre">&quot;0&quot;</span> <span class="pre">(inp));</span>
<span class="pre">`</span></code></p>
<p>该asm接受两个输入，这些输入由fyl2xp1操作码弹出，并将它们替换为一个输出。 要使编译器知道fyl2xp1会同时弹出两个输入，st（1）缓冲区是必不可少的</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">asm</span> <span class="pre">(&quot;fyl2xp1&quot;</span> <span class="pre">:</span> <span class="pre">&quot;=t&quot;</span> <span class="pre">(result)</span> <span class="pre">:</span> <span class="pre">&quot;0&quot;</span> <span class="pre">(x),</span> <span class="pre">&quot;u&quot;</span> <span class="pre">(y)</span> <span class="pre">:</span> <span class="pre">&quot;st(1)&quot;);</span>
<span class="pre">`</span></code></p>
<p>### 6.47.3 asm操作数的约束</p>
<p>以下是有关可与asm操作数一起使用的约束字母的特定详细信息。 约束可以说明操作数是否可以在寄存器中，以及哪种类型的寄存器；该操作数是否可以是内存引用，以及哪种地址？ 操作数是否可以是立即数常量，以及它可以具有哪些可能的值。 约束也可能需要两个操作数来匹配。 除非使用“ &lt;”或“&gt;”约束，否则内联汇编操作数中不允许出现副作用，因为不能保证副作用会在可更新寻址寄存器的指令中恰好发生一次。</p>
<p>总结：</p>
<p>#### 6.47.3.1 简单约束</p>
<p>最简单的约束是充满字母的字符串，每个字母都描述一种允许的操作数。 以下是允许的字母：</p>
<ul>
<li><p>whitespace:空格字符将被忽略，并且可以插入除第一个字符之外的任何位置。 这样，即使操作数具有不同数量的约束和修饰符，也可以在机器说明中直观地对齐每个操作数。</p></li>
<li><p>‘m’:允许使用内存操作数，该内存通常具有机器支持的任何类型的地址。 注意，用于常规内存约束的字母可以由后端使用TARGET_MEM_CONSTRAINT宏重新定义。</p></li>
<li><p>‘o’:允许使用内存操作数，但前提是该地址是可偏移的。 这意味着可以将一个小整数（实际上，由操作数的机器模式确定的操作数的字节宽度）添加到该地址，并且结果也是有效的内存地址。 例如，一个常量地址是可偏移的。 一个地址是一个寄存器和一个常数的总和（只要稍大一点的常数也在机器支持的地址偏移范围内）； 但是自动递增或自动递减地址不可偏移。 更复杂的间接/索引地址可能可以偏移，也可能无法偏移，具体取决于机器支持的其他寻址模式。 请注意，在可以与另一个操作数匹配的输出操作数中，约束字母“ o”仅在同时带有“ &lt;”（如果目标机器具有减量寻址）和“&gt;”（如果目标机器具有预增量）时才有效。 寻址）。</p></li>
<li><p>‘V’:不可偏移的内存操作数。 换句话说，符合“ m”约束但不符合“ o”约束的所有内容。</p></li>
<li><p>‘&lt;’:允许使用具有自动减量寻址（前减量或后减量）的内存操作数。 在内联汇编中，仅当在可以处理副作用的指令中仅对操作数使用一次时，才允许使用此约束。完全不使用内联汇编模式中约束字符串中带有“ &lt;”的操作数或在多个指令中使用该操作数是无效的，因为将不会执行副作用，也不会执行一次以上的副作用。 此外，在某些目标上，约束字符串中带有“ &lt;”的操作数必须随附特殊的指令后缀，例如PowerPC上的％U0指令后缀或IA-64上的％P0。</p></li>
<li><p>‘&gt;’:允许使用具有自动递增寻址（预递增或后递增）的内存操作数。 内联汇编中的限制与对&lt;&lt;的限制相同。</p></li>
<li><p>‘r’:允许使用寄存器操作数，只要它在通用寄存器中即可。</p></li>
<li><p>‘i’:允许使用立即数整数（具有恒定值的一个）。 这包括符号常量，其值仅在汇编时或更晚才知道。</p></li>
<li><p>‘n’:允许使用具有已知数值的立即整数操作数。 许多系统不能支持小于一字宽的操作数的汇编时常数。 这些操作数的约束应使用“ n”而不是“ i”。</p></li>
<li><p>‘I’, ‘J’, ‘K’, … ‘P’:“ I”到“ P”范围内的其他字母可以以与机器有关的方式定义，以允许具有指定范围内显式整数值的立即整数操作数。 例如，在68000上，“ I”被定义为代表值1到8的范围。这是移位指令中允许作为移位计数的范围。</p></li>
<li><p>‘E’:仅当目标浮点格式与主机（在其上运行编译器）的浮点格式相同时，才允许使用立即浮点操作数（表达式代码const_double）。</p></li>
<li><p>‘F’:允许使用立即数浮动操作数const_vector。</p></li>
<li><p>‘G’, ‘H’:可以以与机器相关的方式定义“ G”和“ H”，以允许在特定值范围内的立即浮动操作数。</p></li>
<li><p>‘s’:允许使用其值不是显式整数的立即数整数操作数。 如果insn允许使用在编译时未知的值的常量操作数，则它肯定必须允许任何已知的值。 那么，为什么要使用“ s”而不是“ i”呢？ 有时，它允许生成更好的代码。 例如，在68000的全字指令中，可以使用立即数操作数。 但是，如果立即数在-128到127之间，则将值加载到寄存器中并使用该寄存器会产生更好的代码。 这是因为可以通过“ moveq”指令将数据加载到寄存器中。 我们通过定义字母“ K”来表示“ −128到127范围之外的任何整数”，然后在操作数约束中指定“ Ks”来安排这种情况的发生。</p></li>
<li><p>‘g’:允许使用寄存器，内存或立即数整数操作数，但非通用寄存器的寄存器除外。</p></li>
<li><p>‘X’:允许任何操作数。</p></li>
<li><p>‘0’, ‘1’, ‘2’, … ‘9’:允许与指定操作数编号匹配的操作数。 如果在同一替代方案中将数字和字母一起使用，则该数字应排在最后。</p>
<p>此数字允许多于一个数字。 如果连续遇到多个数字，则将它们解释为单个十进制整数。 模棱两可的可能性很小，因为迄今为止，从未希望将“ 10”解释为与操作数1或操作数0匹配。如果需要，可以使用多个替代方法。</p>
<p>这称为匹配约束，其真正含义是汇编器只有一个操作数，它可以填补asm所区分的两个角色。 例如，一条add指令使用两个输入操作数和一个输出操作数，但是在大多数CISC机器上，一条add指令实际上只有两个操作数，其中一个是输入-输出操作数：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">addl</span> <span class="pre">#35,r12</span>
<span class="pre">`</span></code></p>
<p>在这些情况下使用匹配约束。 更准确地说，两个匹配的操作数必须包括一个仅输入操作数和一个仅输出操作数。 此外，该数字必须小于在约束中使用该数字的操作数的数字。</p>
</li>
<li><p>‘p’:允许的操作数是有效的内存地址。 这用于“加载地址”和“推送地址”指令。</p>
<p>约束中的“ p”必须与address_operand一起作为match_operand中的谓词。 该谓词将match_operand中指定的模式解释为地址将对其有效的内存引用的模式。</p>
</li>
<li><p>other-letters:可以以机器相关的方式定义其他字母，以代表特定类别的寄存器或其他任意操作数类型。 在68000/68020中定义了“ d”，“ a”和“ f”以代表数据，地址和浮点寄存器。</p></li>
</ul>
<p>总结：</p>
<p>#### 6.47.3.2多个替代约束</p>
<p>有时，一条指令具有多个可能的操作数替代集。 例如，在68000上，逻辑或指令可以将寄存器或立即数组合到内存中，也可以将任何类型的操作数组合到寄存器中。 但是它不能将一个存储位置合并到另一个存储位置。</p>
<p>这些约束表示为多种选择。 每个操作数可以通过一系列字母来描述。 操作数的总体约束由第一个备选方案中该操作数的字母，逗号， 此操作数从第二个备选方案（逗号）开始，直到最后一个备选方案。 一条指令的所有操作数必须具有相同数量的替代项。</p>
<p>因此，第68000个逻辑运算符的第一个替代项可以写为“ + m”（输出）：“ ir”（输入）。 第二个可以是“ + r”（输出）：“ irm”（输入）。 但是，不能在一条指令中使用两个存储单元的事实阻止了仅使用“ + rm”（输出）：“ irm”（输入）的事实。 使用多选项，可以将其写为“ + m，r”（输出）：“ ir，irm”（输入）。 这描述了所有可用的替代方法 编译器，允许它为当前条件选择最有效的编译器。</p>
<p>模板内无法确定选择了哪个替代方案。 但是，您可以使用诸如__builtin_constant_p之类的内置函数包装asm语句，以实现所需的结果。</p>
<p>总结：</p>
<p>#### 6.47.3.3约束修饰符</p>
<p>这是约束修饰符。</p>
<ul>
<li><p>‘=’:表示此操作数由该指令写入：先前的值将被丢弃，并由新数据替换。</p></li>
<li><p>‘+’:表示该操作数由指令读取和写入。 当编译器修正操作数以满足约束条件时，它需要知道哪些操作数由指令读取，哪些操作数由指令写入。 ‘=’标识只写的操作数； “ +”表示可读写的操作数； 假定所有其他操作数都只能读取。 如果在约束中指定“ =”或“ +”，则将其放在约束字符串的第一个字符中。</p></li>
<li><p>‘&amp;’:表示（在特定替代方案中）此操作数是早期指令操作数，它是在使用输入操作数完成指令之前写入的。因此，此操作数可能不位于指令读取的寄存器中或作为任何内存的一部分 地址。</p>
<p>“＆”仅适用于其编写方式。 在具有多种选择的约束中，有时一个选择需要使用“＆”，而其他则不需要。 例如，参见68000的“ movdf” insn。</p>
<p>如果指令读取的操作数仅在输入早期结果之前就用作输入，则可以将其与早期的Clobber操作数绑定。添加这种形式的替代项通常会使GCC在只有某些读取的操作数可以生成更好的代码的情况下 受到早期用户的影响。 例如，请参见ARM的“ mulsi3” insn。</p>
<p>此外，如果EarlyClobber操作数也是读/写操作数，则仅在使用该操作数后才写入该操作数。</p>
<p>“＆”不会消除写“ =”或“ +”的必要。 由于总是写早期用户操作数，因此只读早期用户操作数是错误的，并且会被编译器拒绝。</p>
</li>
<li><p>‘%’:声明该操作数与后续操作数的可交换指令。 这意味着如果这是使所有操作数都符合约束的最便宜方法，则编译器可以互换两个操作数。 “％”适用于所有替代项，并且必须作为约束中的第一个字符出现。 只有只读操作数可以使用“％”。</p>
<p>GCC只能在一个asm中处理一对可交换对。 如果使用更多，编译器可能会失败。 请注意，如果两个选择严格相同，则无需使用修饰符。 这样只会浪费时间在重新加载过程中。</p>
</li>
</ul>
<p>总结：</p>
<p>#### 6.47.3.4 特定机器的约束</p>
<p>只要有可能，就应该在asm参数中使用通用约束字母，因为它们将更容易地将含义传达给阅读您的代码的人。 失败的话，使用通常在体系结构中具有非常相似含义的约束字母。 最常用的约束是“ m”和“ r”（分别用于存储器和通用寄存器；请参见第6.47.3.1节“简单约束”，第638页）和“ I”，通常用字母表示最常见的立即数。 -恒定格式。</p>
<p>每种体系结构都定义了其他约束。 这些约束由编译器本身用于指令生成以及asm语句。 因此，某些约束对于asm并不是特别有用。 这是某些特定机器上可用的一些与机器有关的约束的摘要。 它既包括对asm有用的约束，也包括对asm无用的约束。 表格标题中针对每种体系结构提及的编译器源文件是该体系结构约束含义的权威参考。</p>
<p>### x86 family—‘config/i386/constraints.md’</p>
<ul class="simple">
<li><p>R:  Legacy register—the eight integer registers available on all i386 processors (a, b, c, d, si, di, bp, sp).</p></li>
<li></li>
</ul>
<p>(待总结。。。)</p>
<p>总结：</p>
<p>### 6.47.4控制在汇编代码中使用的名称</p>
<p>您可以通过在声明器之后编写asm（或__asm__）关键字来指定C函数或变量的汇编代码中要使用的名称。 您可以自行确定选择的汇编器名称不会与任何其他汇编器符号或引用寄存器冲突。</p>
<p>##### 数据的汇编程序名称：</p>
<p>此示例显示如何为数据指定汇编程序名称：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">int</span> <span class="pre">foo</span> <span class="pre">asm</span> <span class="pre">(&quot;myfoo&quot;)</span> <span class="pre">=</span> <span class="pre">2;</span>
<span class="pre">`</span></code></p>
<p>这指定在汇编代码中用于变量foo的名称应为“ myfoo”，而不是通常的“ _foo”。</p>
<p>在下划线通常以C变量名开头的系统上，此功能使您可以定义链接程序的名称，这些名称不以下划线开头。</p>
<p>GCC不支持将此功能与非静态局部变量一起使用，因为此类变量没有汇编程序名称。 如果您试图将变量放入特定的寄存器中，请参见第6.47.5节“显式寄存器变量”，第670页。</p>
<p>#### 函数的汇编程序名称：</p>
<p>要为函数指定汇编程序名称，请在函数定义之前编写一个声明，然后将asm放在其中，如下所示：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">int</span> <span class="pre">func</span> <span class="pre">(int</span> <span class="pre">x,</span> <span class="pre">int</span> <span class="pre">y)</span> <span class="pre">asm</span> <span class="pre">(&quot;MYFUNC&quot;);int</span> <span class="pre">func</span> <span class="pre">(int</span> <span class="pre">x,</span> <span class="pre">int</span> <span class="pre">y){/*</span> <span class="pre">.</span> <span class="pre">.</span> <span class="pre">.</span> <span class="pre">*/</span>
<span class="pre">`</span></code></p>
<p>这指定在汇编代码中用于函数func的名称应为MYFUNC。</p>
<p>总结：</p>
<p>### 6.47.5指定寄存器中的变量</p>
<p>GNU C允许您将特定的硬件寄存器与C变量关联。 在几乎所有情况下，允许编译器分配寄存器都会产生最佳代码。 但是，在某些特殊情况下，需要对变量存储进行更精确的控制。</p>
<p>全局变量和局部变量都可以与寄存器关联。 如下所述，执行此关联的结果在两者之间是非常不同的。</p>
<p>总结：</p>
<p>#### 6.47.5.1定义全局寄存器变量</p>
<p>您可以定义一个全局寄存器变量，并将其与指定的寄存器关联，如下所示：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">register</span> <span class="pre">int</span> <span class="pre">*foo</span> <span class="pre">asm</span> <span class="pre">(&quot;r12&quot;);</span>
<span class="pre">`</span></code></p>
<p>r12是应使用的寄存器的名称。 请注意，这与用于定义本地寄存器变量的语法相同，但是对于全局变量，声明显示在函数外部。 register关键字是必需的，不能与static组合。 寄存器名称必须是目标平台的有效寄存器名称。</p>
<p>不要使用类型限定符，例如const和volatile，因为结果可能与预期相反。 特别是，使用易失性限定符不会完全阻止编译器优化对寄存器的访问。</p>
<p>寄存器是大多数系统上的稀缺资源，并且允许编译器管理其使用通常会获得最佳代码。 但是，在特殊情况下，可以在全球范围内保留一些资源。 例如，这在诸如程序语言解释器之类的程序中很有用，该程序具有几个经常访问的全局变量。</p>
<p>定义全局寄存器变量后，对于当前编译单元：</p>
<ul class="simple">
<li><p>如果该寄存器是保存调用的寄存器，则调用ABI会受到影响：在分配变量后，该寄存器将不会按函数结尾序列恢复。 因此，功能不能安全地返回到采用标准ABI的呼叫者。</p></li>
<li><p>相反，如果该寄存器是调用密集型寄存器，则对使用标准ABI的函数进行的调用可能会丢失该变量的内容。 即使原始程序中没有明显的调用，编译器也可能创建此类调用，例如，当使用libgcc函数来弥补不可用的指令时。</p></li>
<li><p>可以照常优化对变量的访问，并且只要不影响变量的可观察值，寄存器就可以分配和在任何计算中使用。</p></li>
<li><p>如果在内联汇编中引用了变量，则必须通过约束向编译器提供访问类型（请参见第6.47.3节“约束”，第638页）。 不支持来自基本asms的访问。</p></li>
</ul>
<p>请注意，这些要点仅适用于使用该定义编译的代码。 仅链接到其中的代码（例如，来自库的代码）的行为不会受到影响。</p>
<p>如果要重新编译实际上不使用全局寄存器变量的源文件，以使它们不将指定的寄存器用于任何其他目的，则实际上不需要将全局寄存器声明添加到其源代码中。 只需指定编译器选项“ -ffixed-reg”（请参阅第250页的3.17 [Code Gen选项]，）即可保留寄存器。</p>
<p>#### 声明变量</p>
<p>全局寄存器变量不能具有初始值，因为可执行文件无法为寄存器提供初始内容。</p>
<p>选择寄存器时，请选择通常通过计算机上的函数调用保存和恢复的寄存器。 这样可以确保不知道此保留的代码（例如库例程）在返回之前将其还原。</p>
<p>在具有寄存器窗口的机器上，请确保选择不受函数调用机制影响的全局寄存器。</p>
<p>#### 使用变量</p>
<p>当调用不知道保留的例程时，请谨慎使用这些例程，如果它们被调用回使用它们的代码。 例如，如果您调用系统库版本的qsort，它可能会在执行过程中破坏您的寄存器，但是（如果您选择了适当的寄存器）它将在返回之前恢复它们。 但是，在调用qsort的比较函数之前，它不会还原它们。 结果，除非重新构建qsort函数本身，否则全局值将无法可靠地用于比较函数。</p>
<p>同样，从信号处理程序或多个控制线程访问全局寄存器变量也不安全。 除非您为手头的任务专门重新编译它们，否则系统库例程可能会暂时将寄存器用于其他用途。 此外，由于寄存器不是专门为变量保留的，因此从异步信号的处理程序访问该寄存器可能会观察到寄存器中不相关的临时值。</p>
<p>在大多数计算机上，longjmp将其在setjmp时的值恢复到每个全局寄存器变量。 但是，在某些计算机上，longjmp不会更改全局寄存器变量的值。 为了便于移植，调用setjmp的函数应进行其他安排以保存全局寄存器变量的值，并将其恢复为longjmp。 这样，不管longjmp做什么，都会发生相同的事情。</p>
<p>总结：</p>
<p>#### 6.47.5.2为局部变量指定寄存器</p>
<p>您可以定义一个本地寄存器变量，并将其与指定的寄存器关联，如下所示：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">register</span> <span class="pre">int</span> <span class="pre">*foo</span> <span class="pre">asm</span> <span class="pre">(&quot;r12&quot;);</span>
<span class="pre">`</span></code></p>
<p>r12是应使用的寄存器的名称。 请注意，这与用于定义全局寄存器变量的语法相同，但是对于局部变量，声明出现在函数内。 register关键字是必需的，不能与static组合。 寄存器名称必须是目标平台的有效寄存器名称。</p>
<p>不要使用类型限定符，例如const和volatile，因为结果可能与预期相反。 特别是，当使用const限定符时，编译器可能会在asm语句中将变量替换为其初始值设定项，这可能导致相应的操作数出现在不同的寄存器中。</p>
<p>与全局寄存器变量一样，建议您选择一个通常由计算机上的函数调用保存和还原的寄存器，这样对库例程的调用将不会破坏它。</p>
<p>此功能唯一受支持的用途是在调用扩展asm时为输入和输出操作数指定寄存器（请参见第6.47.2节[扩展asm]，第619页）。 如果特定机器的约束条件不能提供足够的控制来选择所需的寄存器，则可能有必要。 要将操作数强制进入寄存器，请创建一个局部变量，并在变量声明后指定寄存器名称。 然后将局部变量用于asm操作数，并指定与寄存器匹配的任何约束字母：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">register</span> <span class="pre">int</span> <span class="pre">*p1</span> <span class="pre">asm</span> <span class="pre">(&quot;r0&quot;)</span> <span class="pre">=</span> <span class="pre">...;register</span> <span class="pre">int</span> <span class="pre">*p2</span> <span class="pre">asm</span> <span class="pre">(&quot;r1&quot;)</span> <span class="pre">=</span> <span class="pre">...;register</span> <span class="pre">int</span> <span class="pre">*result</span> <span class="pre">asm</span> <span class="pre">(&quot;r0&quot;);asm</span> <span class="pre">(&quot;sysint&quot;</span> <span class="pre">:</span> <span class="pre">&quot;=r&quot;</span> <span class="pre">(result)</span> <span class="pre">:</span> <span class="pre">&quot;0&quot;</span> <span class="pre">(p1),</span> <span class="pre">&quot;r&quot;</span> <span class="pre">(p2));</span>
<span class="pre">`</span></code></p>
<p>警告：在上面的示例中，请注意，后续代码可以调用寄存器（例如r0），包括对其他变量进行算术运算符的函数调用和库调用（例如p2的初始化）。 在这种情况下，请为寄存器分配之间的表达式使用临时变量：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">int</span> <span class="pre">t1</span> <span class="pre">=</span> <span class="pre">...;register</span> <span class="pre">int</span> <span class="pre">*p1</span> <span class="pre">asm(&quot;r0&quot;)</span> <span class="pre">=</span> <span class="pre">...;register</span> <span class="pre">int</span> <span class="pre">*p2</span> <span class="pre">asm(&quot;r1&quot;)</span> <span class="pre">=</span> <span class="pre">t1;register</span> <span class="pre">int</span> <span class="pre">*result</span> <span class="pre">asm</span> <span class="pre">(&quot;r0&quot;);asm</span> <span class="pre">(&quot;sysint&quot;</span> <span class="pre">:</span> <span class="pre">&quot;=r&quot;</span> <span class="pre">(result)</span> <span class="pre">:</span> <span class="pre">&quot;0&quot;</span> <span class="pre">(p1),</span> <span class="pre">&quot;r&quot;</span> <span class="pre">(p2));</span>
<span class="pre">`</span></code></p>
<p>定义寄存器变量不会保留寄存器。 除了调用扩展asm时，不能保证指定寄存器的内容。 因此，明确不支持以下用途。 如果它们似乎起作用，那只是偶然的，并且可能由于（似乎）周围代码中不相关的更改，甚至在gcc未来版本的优化中的微小更改而无法按预期停止工作：</p>
<ul class="simple">
<li><p>将参数传递到基本asm或从中传递参数</p></li>
<li><p>在不使用输入或输出操作数的情况下，将参数传递给扩展asm或从扩展asm传递参数。</p></li>
<li><p>使用非标准调用约定将参数传递到以汇编程序（或其他语言）编写的例程中，或从中传递参数。</p></li>
</ul>
<p>一些开发人员使用本地寄存器变量来尝试改善gcc的寄存器分配，尤其是在大型函数中。 在这种情况下，寄存器名称本质上是对寄存器分配器的提示。 尽管在某些情况下这可以生成更好的代码，但改进取决于分配器/优化器的异想天开。 由于不能保证您的改进不会丢失，因此不建议使用Local Register Variables。</p>
<p>在MIPS平台上，具有略微不同特征的局部寄存器变量也有相关用途（请参见GNU编译器集合（GCC）内部的“定义MIPS目标的协处理器特性”部分）。</p>
<p>总结：</p>
<p>### 6.47.6 asm的大小</p>
<p>一些目标要求GCC跟踪使用的每条指令的大小，以便生成正确的代码。 由于asm语句生成的代码的最终长度仅由汇编程序知道，因此GCC必须估算其大小。 它通过对asm模式中的指令数进行计数并将其乘以该处理器支持的最长指令的长度来做到这一点。 （在计算指令数时，它假定汇编程序支持出现换行符或任何语句分隔符的情况（通常为“;”）表示指令的结束。）</p>
<p>通常，GCC的估算值足以确保生成正确的代码，但是如果您使用伪指令或扩展为多个实际指令的汇编宏，或者使用汇编指令将其扩展为更多空间，则可能使编译器感到困惑。 目标文件比单个指令所需的文件多。 如果发生这种情况，则汇编器可能会生成诊断消息，指出标签无法到达。</p>
<p>此大小也用于内联决策。 如果您使用asm inline而不是asm，则出于内联目的，将asm的大小作为最小大小，而忽略了GCC认为有多少条指令。</p>
<p>总结：</p>
</div>
<div class="section" id="id324">
<h2>备用关键字<a class="headerlink" href="#id324" title="Permalink to this headline">¶</a></h2>
<p>“ -ansi”和各种“ -std”选项会禁用某些关键字。 当您要使用GNU C扩展名或应由所有程序（包括ISO C程序）使用的通用头文件时，这会引起麻烦。 关键字asm，typeof和inline在使用“ -ansi”或“ -std”编译的程序中不可用（尽管inline可以在使用“ -std = c99”或更高版本的编译程序中使用）。 仅当’-std = gnu99’（最终将是默认值）或’-std = c99’（或等效的’-std = iso9899：1999’）或更高版本的选项时，ISO C99关键字限制才可用 使用标准版本。</p>
<p>解决这些问题的方法是在每个问题关键字的开头和结尾都加上“ __”。 例如，使用__asm__代替asm，并使用__inline__代替inline。</p>
<p>其他C编译器将不接受这些替代关键字。 如果要使用其他编译器进行编译，则可以将备用关键字定义为宏，以将它们替换为常规关键字。 看起来像这样：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">#ifndef</span> <span class="pre">__GNUC__#define</span> <span class="pre">__asm__</span> <span class="pre">asm#endif</span>
<span class="pre">`</span></code></p>
<p>“ -pedantic”和其他选项会引起许多GNU C扩展的警告。 您可以通过在表达式之前写__extension__来防止在一个表达式中出现此类警告。__extension__除此之外没有任何作用。</p>
<blockquote>
<div><p>总结：</p>
</div></blockquote>
</div>
<div class="section" id="id325">
<h2>不完整的枚举类型<a class="headerlink" href="#id325" title="Permalink to this headline">¶</a></h2>
<p>您可以定义枚举标签，而无需指定其可能的值。 这将导致不完整的类型，就像您在不描述元素的情况下编写struct foo时所得到的那样。</p>
<p>稍后的声明确实指定了可能的值，从而完成了该类型。</p>
<p>当类型不完整时，您不能使用该类型分配变量或存储。 但是，您可以使用指向该类型的指针。</p>
<p>这个扩展可能不是很有用，但是它使枚举的处理与处理struct和union的方式更加一致。</p>
<p>GNU C ++不支持此扩展。</p>
<p>总结：</p>
</div>
<div class="section" id="id326">
<h2>函数名称为字符串<a class="headerlink" href="#id326" title="Permalink to this headline">¶</a></h2>
<p>GCC提供了三个魔术常量，它们将当前函数的名称保存为字符串。在C ++ 11和更高版本的模式中，这三个常量都被视为常量表达式，并且可以在constexpr上下文中使用。 这些常量中的第一个是__func__，它是C99标准的一部分：</p>
<p>标识符__func__由翻译器隐式声明，就像在紧随每个函数定义的大括号之后进行声明一样</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">static</span> <span class="pre">const</span> <span class="pre">char</span> <span class="pre">__func__[]</span> <span class="pre">=</span> <span class="pre">&quot;function-name&quot;;</span>
<span class="pre">`</span></code></p>
<p>出现，其中function-name是词法包围函数的名称。 此名称是函数的未经修饰的名称。 作为扩展，在文件（或在C ++中，命名空间范围）中，__func__求值为空字符串。</p>
<p>__FUNCTION__是__func__的另一个名称，旨在与旧版本的GCC向后兼容。</p>
<p>在C中，__ PRETTY_FUNCTION__是__func__的另一个名称，除了在文件范围（或在C ++中，名称空间范围）中，它的计算结果为字符串“顶级”。 另外，在C ++中，__ PRETTY_FUNCTION__包含函数的签名及其裸名。 例如，该程序：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">extern</span> <span class="pre">&quot;C&quot;</span> <span class="pre">int</span> <span class="pre">printf</span> <span class="pre">(const</span> <span class="pre">char</span> <span class="pre">*,</span> <span class="pre">...);class</span> <span class="pre">a</span> <span class="pre">{</span>&#160;&#160;&#160;&#160; <span class="pre">public:</span> <span class="pre">void</span> <span class="pre">sub</span> <span class="pre">(int</span> <span class="pre">i)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">{</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">printf</span> <span class="pre">(&quot;__FUNCTION__</span> <span class="pre">=</span> <span class="pre">%s\n&quot;,</span> <span class="pre">__FUNCTION__);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">printf</span> <span class="pre">(&quot;__PRETTY_FUNCTION__</span> <span class="pre">=</span> <span class="pre">%s\n&quot;,</span> <span class="pre">__PRETTY_FUNCTION__);</span>&#160;&#160;&#160;&#160; <span class="pre">}};intmain</span> <span class="pre">(void){</span>&#160;&#160;&#160;&#160;&#160; <span class="pre">a</span> <span class="pre">ax;</span>&#160;&#160; <span class="pre">ax.sub</span> <span class="pre">(0);</span>&#160;&#160;&#160;&#160; <span class="pre">return</span> <span class="pre">0;}</span>
<span class="pre">`</span></code></p>
<p>给出以下输出：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">__FUNCTION__</span> <span class="pre">=</span> <span class="pre">sub__PRETTY_FUNCTION__</span> <span class="pre">=</span> <span class="pre">void</span> <span class="pre">a::sub(int)</span>
<span class="pre">`</span></code></p>
<p>这些标识符是变量，不是预处理器宏，并且不能用于初始化char数组或与字符串文字串联。</p>
<p>总结：</p>
</div>
<div class="section" id="id327">
<h2>获取函数的返回地址或帧地址<a class="headerlink" href="#id327" title="Permalink to this headline">¶</a></h2>
<p>这些函数可用于获取有关函数调用者的信息。</p>
<ul>
<li><p>void * __builtin_return_address (unsigned int level )   [Built-in Function]:此函数返回当前函数或其调用者之一的返回地址。level参数是要向上扫描调用堆栈的帧数。 值为0产生当前函数的返回地址，值为1产生当前函数的调用者的返回地址，依此类推。 内联预期行为时 是该函数返回返回到的函数的地址。 要变通解决此问题，请使用noinline函数属性。</p>
<p>level参数必须是一个常量整数。</p>
<p>在某些机器上，可能无法确定除当前函数以外的任何函数的返回地址。 在这种情况下，或者到达栈顶时，此函数返回一个未指定的值。 另外__ builtin_frame_address可用于确定是否已到达栈顶。</p>
<p>可能需要对返回值进行其他后期处理，请参见__builtin_extract_return_addr。</p>
<p>返回地址在内存中存储的表示形式可能与__builtin_return_address返回的地址不同。 例如，在AArch64上，存储的地址可能会用返回地址签名进行修饰，而__builtin_return_address返回的地址则不会。</p>
<p>使用非零参数调用此函数可能会产生不可预知的后果，包括使调用程序崩溃。 结果，当“ -Wframe-address”选项生效时，将诊断出认为不安全的呼叫。 此类调用仅应在调试情况下进行。</p>
<p>在代码地址可表示为void <a href="#id328"><span class="problematic" id="id329">*</span></a>的目标上，</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">void</span> <span class="pre">*addr</span> <span class="pre">=</span> <span class="pre">__builtin_extract_return_addr</span> <span class="pre">(__builtin_return_address</span> <span class="pre">(0));</span>
<span class="pre">`</span></code></p>
<p>给出当前函数将返回的代码地址。 例如，这样的地址可以与dladdr或其他与代码地址一起使用的接口一起使用。</p>
</li>
<li><p>void * __builtin_extract_return_addr (void * addr )  [Built-in Function]:__builtin_return_address返回的地址可能必须通过此函数提供，才能获得实际的编码地址。 例如，在31位S / 390平台上，最高位必须被屏蔽掉，或者在SPARC平台上，必须添加偏移量才能执行真正的下一条指令。 如果不需要修正，则此函数仅通过addr传递。</p></li>
<li><p>void * __builtin_frob_return_addr (void * addr ) [Built-in Function]:此函数的作用与__builtin_extract_return_addr相反。</p></li>
<li><p>void * __builtin_frame_address (unsigned int level ) [Built-in Function]:该函数类似于__builtin_return_address，但是它返回函数框架的地址，而不是函数的返回地址。 值为0调用__builtin_ frame_address会产生当前函数的帧地址，值为1会产生当前函数的调用者的帧地址，依此类推。</p>
<p>框架是堆栈上保存局部变量和已保存寄存器的区域。 帧地址通常是该函数压入堆栈的第一个字的地址。 但是，确切的定义取决于处理器和调用约定。 如果处理器具有专用的帧指针寄存器，而函数具有帧，则__builtin_frame_address返回帧指针寄存器的值。</p>
<p>在某些机器上，可能无法确定除当前功能以外的任何功能的帧地址。 在这种情况下，或者到达栈顶时，如果启动代码正确初始化了第一个帧指针，则此函数返回0。</p>
<p>使用非零参数调用此函数可能会产生不可预知的后果，包括使调用程序崩溃。 结果，当“ -Wframe-address”选项生效时，将诊断出认为不安全的呼叫。 此类调用仅应在调试情况下进行。</p>
<p>总结：这又涉及内嵌函数，非常重点的地方。</p>
</li>
</ul>
</div>
<div class="section" id="id330">
<h2>通过内置函数使用矢量指令<a class="headerlink" href="#id330" title="Permalink to this headline">¶</a></h2>
<p>（没有整理)</p>
<p>总结：</p>
</div>
<div class="section" id="offsetof">
<h2>支持offsetof<a class="headerlink" href="#offsetof" title="Permalink to this headline">¶</a></h2>
<p>GCC为C和C ++实现了语法扩展，以实现offsetof宏。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">primary:</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">&quot;__builtin_offsetof&quot;</span> <span class="pre">&quot;(&quot;</span> <span class="pre">typename</span> <span class="pre">&quot;,&quot;</span> <span class="pre">offsetof_member_designator</span> <span class="pre">&quot;)&quot;offsetof_member_designator:</span> <span class="pre">identifier</span>&#160;&#160;&#160;&#160;&#160; <span class="pre">|</span> <span class="pre">offsetof_member_designator</span> <span class="pre">&quot;.&quot;</span> <span class="pre">identifier</span>&#160;&#160;&#160;&#160; <span class="pre">|</span> <span class="pre">offsetof_member_designator</span> <span class="pre">&quot;[&quot;</span> <span class="pre">expr</span> <span class="pre">&quot;]&quot;</span>
<span class="pre">`</span></code></p>
<p>此扩展足以使</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">#define</span> <span class="pre">offsetof(type,</span> <span class="pre">member)</span> <span class="pre">__builtin_offsetof</span> <span class="pre">(type,</span> <span class="pre">member)</span>
<span class="pre">`</span></code></p>
<p>是offsetof宏的合适定义。 在C ++中，类型可能是依赖的。 无论哪种情况，成员都可以由单个标识符组成，也可以由一系列成员访问和数组引用组成。</p>
<p>总结：</p>
</div>
<div class="section" id="sync">
<h2>用于原子内存访问的旧版__sync内置函数<a class="headerlink" href="#sync" title="Permalink to this headline">¶</a></h2>
<p>以下内置功能旨在与特定于Intel Itanium处理器的应用程序二进制接口，第7.4节中描述的功能兼容。 因此，它们不使用一般的GCC惯例，因为它们不使用“ __builtin_”前缀，而且由于重载而可以处理多种类型。</p>
<p>英特尔文档中给出的定义仅允许使用int，long，long long或它们的无符号对应类型。 除了C类型_Bool或C ++类型bool之外，GCC允许大小为1、2、4或8个字节的任何标量类型。 对指针参数的操作就像操作数是uintptr_t类型一样执行。 也就是说，它们不会按指针指向的类型的大小进行缩放。</p>
<p>这些功能是通过__atomic内置函数实现的（请参见第6.55节[atomic内置函数]，第681页）。 不应将它们用于应使用__atomic内置函数的新代码。</p>
<p>并非所有目标处理器都支持所有操作。 如果无法在目标处理器上执行特定操作，则会生成警告并生成对外部函数的调用。 外部函数的名称与内置版本的名称相同，并带有一个附加的后缀“ _n”，其中n是数据类型的大小。</p>
<p>在大多数情况下，这些内置功能被视为完全障碍。 也就是说，没有内存操作数在操作中向前或向后移动。 此外，必要时还会发出指令，以防止处理器在整个操作过程中推测负载 并在手术后从排队商店。</p>
<p>英特尔文档中将所有例程描述为“受内存屏障保护的变量的可选列表”。 目前尚不清楚这是什么意思； 这可能意味着仅列出的变量受到保护，或者可能意味着要保护的其他变量的列表。 该列表会被GCC忽略，它将视为空列表。 GCC将一个空列表解释为意味着应保护所有全局可访问变量。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">type</span> <span class="pre">__sync_fetch_and_add</span> <span class="pre">(type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">value,</span> <span class="pre">...)type</span> <span class="pre">__sync_fetch_and_sub</span> <span class="pre">(type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">value,</span> <span class="pre">...)type</span> <span class="pre">__sync_fetch_and_or</span> <span class="pre">(type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">value,</span> <span class="pre">...)type</span> <span class="pre">__sync_fetch_and_and</span> <span class="pre">(type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">value,</span> <span class="pre">...)type</span> <span class="pre">__sync_fetch_and_xor</span> <span class="pre">(type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">value,</span> <span class="pre">...)type</span> <span class="pre">__sync_fetch_and_nand</span> <span class="pre">(type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">value,</span> <span class="pre">...)</span>
<span class="pre">`</span></code></p></li>
</ul>
<p>这些内置函数执行名称建议的操作，并返回以前在内存中的值。 即，对整数操作数的操作具有以下语义。 对指针参数的操作就像操作数是uintptr_t类型一样执行。 也就是说，它们不会按指针指向的类型的大小进行缩放。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">{</span> <span class="pre">tmp</span> <span class="pre">=</span> <span class="pre">*ptr;</span> <span class="pre">*ptr</span> <span class="pre">op=</span> <span class="pre">value;</span> <span class="pre">return</span> <span class="pre">tmp;</span> <span class="pre">}{</span> <span class="pre">tmp</span> <span class="pre">=</span> <span class="pre">*ptr;</span> <span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">~(tmp</span> <span class="pre">&amp;</span> <span class="pre">value);</span> <span class="pre">return</span> <span class="pre">tmp;</span> <span class="pre">}//</span> <span class="pre">nand</span>
<span class="pre">`</span></code></p>
<p>第一个参数指向的对象必须是整数或指针类型，不能是布尔类型。</p>
<p>注意：GCC 4.4和更高版本将__sync_fetch_and_nand实现为* ptr =〜（tmp＆value）而不是* ptr =〜tmp＆value。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">type</span> <span class="pre">__sync_add_and_fetch</span> <span class="pre">(type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">value,</span> <span class="pre">...)type</span> <span class="pre">__sync_sub_and_fetch</span> <span class="pre">(type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">value,</span> <span class="pre">...)type</span> <span class="pre">__sync_or_and_fetch</span> <span class="pre">(type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">value,</span> <span class="pre">...)type</span> <span class="pre">__sync_and_and_fetch</span> <span class="pre">(type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">value,</span> <span class="pre">...)type</span> <span class="pre">__sync_xor_and_fetch</span> <span class="pre">(type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">value,</span> <span class="pre">...)type</span> <span class="pre">__sync_nand_and_fetch</span> <span class="pre">(type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">value,</span> <span class="pre">...)</span>
<span class="pre">`</span></code></p></li>
</ul>
<p>这些内置函数执行名称建议的操作，并返回新值。 即，对整数操作数的操作具有以下语义。 对指针操作数的操作就像操作数的类型为uintptr_t一样进行。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">{</span> <span class="pre">*ptr</span> <span class="pre">op=</span> <span class="pre">value;</span> <span class="pre">return</span> <span class="pre">*ptr;</span> <span class="pre">}{</span> <span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">~(*ptr</span> <span class="pre">&amp;</span> <span class="pre">value);</span> <span class="pre">return</span> <span class="pre">*ptr;</span> <span class="pre">}</span> <span class="pre">//</span> <span class="pre">nand</span>
<span class="pre">`</span></code></p>
<p>对参数的约束与对相应的__sync_op_和_fetch内置函数的约束相同。</p>
<p>注意：GCC 4.4和更高版本将__sync_nand_and_fetch实现为* ptr =〜（* ptr＆value）而不是* ptr =〜* ptr＆value。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">bool</span> <span class="pre">__sync_bool_compare_and_swap</span> <span class="pre">(type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">oldval,</span> <span class="pre">type</span> <span class="pre">newval,</span> <span class="pre">...)type</span> <span class="pre">__sync_val_compare_and_swap</span> <span class="pre">(type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">oldval,</span> <span class="pre">type</span> <span class="pre">newval,</span> <span class="pre">...)</span>
<span class="pre">`</span></code></p></li>
</ul>
<p>这些内置函数执行原子比较和交换。 也就是说，如果* ptr的当前值为oldval，则将newval写入* ptr。</p>
<p>如果比较成功并且写入了newval，则“ bool”版本将返回true。 “ val”版本返回* ptr的内容，然后再执行操作。</p>
<ul>
<li><p>__sync_synchronize (…):此内置功能发出了完整的内存屏障。</p></li>
<li><p>type __sync_lock_test_and_set (type <em>ptr, type value, …):如Intel所述，此内置功能不是传统的测试设置操作，而是原子交换操作。 它将值写入</em> ptr，并返回* ptr的先前内容。许多目标仅对这种锁的支持最少，并且不支持完整的交换操作。 在这种情况下，目标可以支持简化的功能，在此功能中，要存储的唯一有效值是立即数1。实际存储在* ptr中的确切值由实现定义。 此内置功能不是完全障碍，而是获取障碍。 这意味着操作后的引用无法移至（或推测为）操作前，但先前的存储器存储可能尚未全局可见，并且先前的存储器负载可能尚未得到满足。__</p></li>
<li><p>__void __sync_lock_release (type <em>ptr, …):此内置函数释放由__sync_lock_test_and_ set获取的锁。 通常，这意味着将常数0写入</em> ptr。</p>
<p>此内置功能不是完全障碍，而是释放障碍。 这意味着所有先前的存储器存储都是全局可见的，并且已满足所有先前的存储器负载，但是不会阻止后续的存储器读取被推测为在屏障之前。</p>
</li>
</ul>
<p>总结：</p>
</div>
<div class="section" id="id331">
<h2>内存模型感知原子操作的内置函数<a class="headerlink" href="#id331" title="Permalink to this headline">¶</a></h2>
<p>以下内置函数大致符合C ++ 11内存模型的要求。 它们都以“ __atomic”为前缀进行标识，并且大多数都已重载，因此它们可以使用多种类型。</p>
<p>这些功能旨在替代旧版“ __sync”内置函数。 主要区别在于请求的存储顺序是功能的参数。 新代码应始终使用“ __atomic”内置插件，而不是“ __sync”内置插件。</p>
<p>请注意，“ __ atomic”内置函数假定程序将符合C ++ 11内存模型。 特别是，他们假定程序没有数据争用。 有关详细要求，请参见C ++ 11标准。</p>
<p>“ __atomic”内置函数可与长度为1、2、4或8个字节的任何整数标量或指针类型一起使用。 如果体系结构支持’__int128’（请参见6.9节[int128]，第505页），则也允许使用16个字节的整数类型。</p>
<p>四个非算术函数（加载，存储，交换和比较交换）也都具有通用版本。 此通用版本适用于任何数据类型。 如果特定的数据类型大小使它成为可能，它将使用无锁内置函数。 否则，将在运行时解决外部呼叫。 此外部调用的格式相同，但添加了一个“ size_t”参数作为第一个参数，该参数指示了所指向对象的大小。 所有对象的大小必须相同。</p>
<p>可以指定6种不同的存储顺序。 这些映射到具有相同名称的C ++ 11内存顺序，有关详细定义，请参见C ++ 11标准或原子同步上的GCC Wiki。 各个目标也可能支持在特定体系结构上使用的其他内存顺序。 有关这些的详细信息，请参阅目标文档。</p>
<p>原子操作既可以约束代码运动，又可以映射到硬件指令，以实现线程之间的同步（例如，围栏）。 发生这种情况的程度由存储顺序控制，这些顺序在此处以强度的大约升序排列。 每个存储顺序的描述仅是为了粗略地说明其效果，而不是一个说明。 有关精确语义的信息，请参见C ++ 11内存模型。</p>
<ul class="simple">
<li><p>__ATOMIC_RELAXED:暗示没有线程间排序约束。</p></li>
<li><p>__ATOMIC_CONSUME:由于C ++ 11的memory_order_consume语义不足，因此目前使用更强的__ATOMIC_ACQUIRE内存顺序来实现此功能。</p></li>
<li><p>__ATOMIC_ACQUIRE:从释放（或更强）语义存储库到此获取负载，创建线程间事件发生之前约束。 可以防止在操作之前将代码吊起。</p></li>
<li><p>__ATOMIC_RELEASE:创建线程间事件发生前约束，以获取（或更强的）从此发行版存储读取的语义负载。 可以防止代码下沉到操作之后。</p></li>
<li><p>__ATOMIC_ACQ_REL:组合__ATOMIC_ACQUIRE和__ATOMIC_RELEASE的效果。</p></li>
<li><p>__ATOMIC_SEQ_CST:与所有其他__ATOMIC_SEQ_CST操作一起强制执行总排序。</p></li>
</ul>
<p>请注意，在C ++ 11内存模型中，篱笆（例如，“ __ atomic_thread_fence”）与其他特定于特定内存位置（例如，原子负载）的原子操作结合在一起生效； 特定内存位置上的操作不一定会以相同的方式影响其他操作。</p>
<p>鼓励目标体系结构为每个原子内置函数提供其自己的模式。 如果未提供目标，则使用原始的“ __sync”原子内置函数的非内存模型集，以及围绕它的任何必需的同步防护，以实现正确的行为。 在这种情况下，执行与内置功能受到相同的限制。</p>
<p>如果没有提供无锁指令序列的模式或机制，则使用在运行时要解析的具有相同参数的外部例程进行调用。</p>
<p>在为这些内置函数实现模式时，只要该模式实现限制性最强的__ATOMIC_SEQ_CST存储器顺序，就可以忽略该内存顺序参数。 其他任何一个内存命令都可以使用此内存命令正确执行，但是它们的执行效率可能不如宽松要求的更合适的实现方式有效。</p>
<p>请注意，C ++ 11标准允许在运行时而不是在编译时确定内存顺序参数。 这些内置函数将任何运行时值映射到__ATOMIC_SEQ_CST，而不是调用运行时库调用或内联switch语句。 目前，这是符合标准，安全且最简单的方法。</p>
<p>内存顺序参数是一个有符号的int，但是仅低16位保留用于内存顺序。 有符号的int的其余部分保留给目标使用，并且应为0。使用预定义的原子值可确保正确使用。</p>
<ul>
<li><p>type __atomic_load_n ( type <em>ptr, int memorder) [Built-in Function]:此内置函数实现了原子加载操作。 它返回</em> ptr的内容。 有效的内存顺序变量是__ATOMIC_RELAXED，__ATOMIC_SEQ_CST，__ATOMIC_ACQUIRE和__ATOMIC_CONSUME。</p></li>
<li><p>void __atomic_load ( type <em>ptr, type *ret, int memorder) [Built-in Function]:这是原子负载的通用版本。 它在</em> ret中返回* ptr的内容。</p></li>
<li><p>void __atomic_store_n ( type <em>ptr, type val, int memorder) [Built-in Function]:此内置函数实现了原子存储操作。 它将val写入</em> ptr。</p>
<p>有效的内存顺序变量是__ATOMIC_RELAXED，__ATOMIC_SEQ_CST和__ATOMIC_RELEASE。</p>
</li>
<li><p>void __atomic_store ( type <em>ptr, type *val, int memorder) [Built-in Function]:这是原子存储的通用版本。 它将</em> val的值存储到* ptr中。</p></li>
<li><p>type __atomic_exchange_n ( type <em>ptr, type val, int  memorder)  [Built-in Function]:此内置函数实现了原子交换操作。 它将val写入</em> ptr，并返回* ptr的先前内容。 有效的内存顺序变量是__ATOMIC_RELAXED，__ATOMIC_SEQ_CST，__ATOMIC_ACQUIRE，__ATOMIC_RELEASE和__ATOMIC_ACQ_REL。</p></li>
<li><p>void __atomic_exchange ( type <em>ptr, type *val, type *ret, int memorder)[Built-in Function]:这是原子交换的通用版本。 它将</em> val的内容存储到* ptr中。 * ptr的原始值将复制到* ret。</p></li>
<li><p>bool __atomic_compare_exchange_n ( type <em>ptr, type *expected, type desired, bool weak, int success memorder, int
failure memorder)  [Built-in Function]:此内置函数实现了原子比较和交换操作。 这会将</em> ptr的内容与* expected的内容进行比较。 如果相等，则该操作是将所需内容写入* ptr的读-修改-写操作。 如果它们不相等，则该操作为读操作，并且* ptr的当前内容被写入* expected。 “弱”对于弱比较交换是正确的，它可能会虚假地失败；而对于“强变化”，它永远不会虚假地失败，这是错误的。 许多目标仅提供强大的变化，而忽略该参数。 如有疑问，请使用较大的变化。</p>
<p>如果需要将其写入* ptr，则返回true，并且根据成功内存顺序指定的内存顺序来影响内存。 在这里可以使用什么存储顺序没有限制。</p>
<p>否则，将根据失败的内存顺序返回false并影响内存。此内存顺序不能为__ATOMIC_RELEASE或__ATOMIC_ACQ_REL。 它也不能比成功内存顺序所指定的顺序更强。</p>
</li>
<li><p>bool __atomic_compare_exchange ( type <a href="#id332"><span class="problematic" id="id333">*</span></a>ptr, type <a href="#id334"><span class="problematic" id="id335">*</span></a>expected, type <a href="#id336"><span class="problematic" id="id337">*</span></a>desired, bool weak, int success memorder, int
failure memorder) [Built-in Function]:此内置函数实现__atomic_compare_exchange的通用版本。 该函数实际上与__atomic_compare_exchange_n相同，只是所需的值也是一个指针。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">type</span> <span class="pre">__atomic_add_fetch</span> <span class="pre">(</span> <span class="pre">type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">val,</span> <span class="pre">int</span> <span class="pre">memorder)</span> <span class="pre">[Built-in</span> <span class="pre">Function]type</span> <span class="pre">__atomic_sub_fetch</span> <span class="pre">(</span> <span class="pre">type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">val,</span> <span class="pre">int</span> <span class="pre">memorder)</span> <span class="pre">[Built-in</span> <span class="pre">Function]type</span> <span class="pre">__atomic_and_fetch</span> <span class="pre">(</span> <span class="pre">type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">val,</span> <span class="pre">int</span> <span class="pre">memorder)</span> <span class="pre">[Built-in</span> <span class="pre">Function]type</span> <span class="pre">__atomic_xor_fetch</span> <span class="pre">(</span> <span class="pre">type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">val,</span> <span class="pre">int</span> <span class="pre">memorder)</span> <span class="pre">[Built-in</span> <span class="pre">Function]type</span> <span class="pre">__atomic_or_fetch</span> <span class="pre">(</span> <span class="pre">type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">val,</span> <span class="pre">int</span> <span class="pre">memorder)</span> <span class="pre">[Built-in</span> <span class="pre">Function]type</span> <span class="pre">__atomic_nand_fetch</span> <span class="pre">(</span> <span class="pre">type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">val,</span> <span class="pre">int</span> <span class="pre">memorder)</span> <span class="pre">[Built-in</span> <span class="pre">Function]</span>
<span class="pre">`</span></code></p>
<p>这些内置函数执行名称建议的操作，并返回操作结果。 对指针参数的操作就像操作数是uintptr_t类型一样执行。 也就是说，它们不会按指针指向的类型的大小进行缩放。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">{</span> <span class="pre">*ptr</span> <span class="pre">op=</span> <span class="pre">val;</span> <span class="pre">return</span> <span class="pre">*ptr;</span> <span class="pre">}{</span> <span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">~(*ptr</span> <span class="pre">&amp;</span> <span class="pre">val);</span> <span class="pre">return</span> <span class="pre">*ptr;</span> <span class="pre">}</span> <span class="pre">//</span> <span class="pre">nand</span>
<span class="pre">`</span></code></p>
<p>第一个参数指向的对象必须是整数或指针类型。 它不能是布尔类型。 所有内存顺序均有效。</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">type</span> <span class="pre">__atomic_fetch_add</span> <span class="pre">(</span> <span class="pre">type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">val,</span> <span class="pre">int</span> <span class="pre">memorder)</span> <span class="pre">[Built-in</span> <span class="pre">Function]type</span> <span class="pre">__atomic_fetch_sub</span> <span class="pre">(</span> <span class="pre">type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">val,</span> <span class="pre">int</span> <span class="pre">memorder)</span> <span class="pre">[Built-in</span> <span class="pre">Function]type</span> <span class="pre">__atomic_fetch_and</span> <span class="pre">(</span> <span class="pre">type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">val,</span> <span class="pre">int</span> <span class="pre">memorder)</span> <span class="pre">[Built-in</span> <span class="pre">Function]type</span> <span class="pre">__atomic_fetch_xor</span> <span class="pre">(</span> <span class="pre">type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">val,</span> <span class="pre">int</span> <span class="pre">memorder)</span> <span class="pre">[Built-in</span> <span class="pre">Function]type</span> <span class="pre">__atomic_fetch_or</span> <span class="pre">(</span> <span class="pre">type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">val,</span> <span class="pre">int</span> <span class="pre">memorder)</span> <span class="pre">[Built-in</span> <span class="pre">Function]type</span> <span class="pre">__atomic_fetch_nand</span> <span class="pre">(</span> <span class="pre">type</span> <span class="pre">*ptr,</span> <span class="pre">type</span> <span class="pre">val,</span> <span class="pre">int</span> <span class="pre">memorder)</span> <span class="pre">[Built-in</span> <span class="pre">Function]</span>
<span class="pre">`</span></code></p>
<p>这些内置函数执行名称建议的操作，并返回以前在* ptr中的值。 对指针参数的操作就像操作数是uintptr_t类型一样执行。 也就是说，它们不会按指针指向的类型的大小进行缩放。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">{</span> <span class="pre">tmp</span> <span class="pre">=</span> <span class="pre">*ptr;</span> <span class="pre">*ptr</span> <span class="pre">op=</span> <span class="pre">val;</span> <span class="pre">return</span> <span class="pre">tmp;</span> <span class="pre">}{</span> <span class="pre">tmp</span> <span class="pre">=</span> <span class="pre">*ptr;</span> <span class="pre">*ptr</span> <span class="pre">=</span> <span class="pre">~(*ptr</span> <span class="pre">&amp;</span> <span class="pre">val);</span> <span class="pre">return</span> <span class="pre">tmp;</span> <span class="pre">}</span> <span class="pre">//</span> <span class="pre">nand</span>
<span class="pre">`</span></code></p>
<p>对参数的约束与对相应的__atomic_op_fetch内置函数的约束相同。 所有内存顺序均有效。</p>
</li>
<li><p>bool __atomic_test_and_set (void <em>ptr, int memorder) [Built-in Function]:此内置函数对</em> ptr处的字节执行原子测试和设置操作。该字节被设置为某些实现定义的非零“设置”值，并且仅当以前的内容被“设置”时，返回值才为true。 ”。 它仅应用于bool或char类型的操作数。 对于其他类型，只能设置部分值。 所有内存顺序均有效。</p></li>
<li><p>void __atomic_clear (bool <em>ptr, int memorder) [Built-in Function]:此内置函数在</em> ptr上执行原子清除操作。 运算后，* ptr包含0。它仅应用于bool或char类型的操作数，并应与__atomic_test_and_set结合使用。 对于其他类型，可能仅部分清除。 如果类型不是布尔型，则首选使用__atomic_store。 有效的内存顺序变量是__ATOMIC_RELAXED，__ATOMIC_SEQ_CST和__ATOMIC_RELEASE。</p></li>
<li><p>void __atomic_thread_fence (int memorder) [Built-in Function]:此内置函数根据指定的内存顺序充当线程之间的同步防护。 所有内存顺序均有效。</p></li>
<li><p>void __atomic_signal_fence (int memorder) [Built-in Function]:此内置函数充当线程和基于同一线程的信号处理程序之间的同步防护。 所有内存顺序均有效。</p></li>
<li><p>bool __atomic_always_lock_free (size t size, void <a href="#id338"><span class="problematic" id="id339">*</span></a>ptr) [Built-in Function]:如果大小字节的对象始终为目标体系结构生成无锁原子指令，则此内置函数将返回true。 size必须解析为编译时常量，并且结果也解析为编译时常量。 ptr是指向对象的可选指针，可用于确定对齐方式。 值0表示应使用典型的对齐方式。 编译器也可以忽略此参数。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">if</span> <span class="pre">(__atomic_always_lock_free</span> <span class="pre">(sizeof</span> <span class="pre">(long</span> <span class="pre">long),</span> <span class="pre">0))</span>
<span class="pre">`</span></code></p>
</li>
<li><p>bool __atomic_is_lock_free (size t size, void <a href="#id340"><span class="problematic" id="id341">*</span></a>ptr) [Built-in Function]: 如果大小字节的对象始终为目标体系结构生成无锁原子指令，则此内置函数将返回true。 如果未知内置函数是无锁的，则调用名为__atomic_is_lock_free的运行时例程。</p>
<p>ptr是指向对象的可选指针，可用于确定对齐方式。 值0表示应使用典型的对齐方式。 编译器也可以忽略此参数。</p>
<p>总结：</p>
</li>
</ul>
</div>
<div class="section" id="id342">
<h2>内置函数，可通过溢出检查执行算术运算<a class="headerlink" href="#id342" title="Permalink to this headline">¶</a></h2>
<p>以下内置函数允许执行简单的算术运算以及检查运算是否溢出。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">bool</span> <span class="pre">__builtin_add_overflow</span> <span class="pre">(</span> <span class="pre">type1</span> <span class="pre">a,</span> <span class="pre">type2</span> <span class="pre">b,</span> <span class="pre">type3</span> <span class="pre">*res)</span>&#160; <span class="pre">[Built-in</span> <span class="pre">Function]bool</span> <span class="pre">__builtin_sadd_overflow</span> <span class="pre">(int</span> <span class="pre">a,</span> <span class="pre">int</span> <span class="pre">b,</span> <span class="pre">int</span> <span class="pre">*res)</span>&#160; <span class="pre">[Built-in</span> <span class="pre">Function]bool</span> <span class="pre">__builtin_saddl_overflow</span> <span class="pre">(long</span> <span class="pre">int</span> <span class="pre">a,</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">b,</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">*res)</span> <span class="pre">[Built-in</span> <span class="pre">Function]bool</span> <span class="pre">__builtin_saddll_overflow</span> <span class="pre">(long</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">a,</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">b,</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">*res)</span> <span class="pre">[Built-in</span> <span class="pre">Function]bool</span> <span class="pre">__builtin_uadd_overflow</span> <span class="pre">(unsigned</span> <span class="pre">int</span> <span class="pre">a,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">b,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*res)</span> <span class="pre">[Built-in</span> <span class="pre">Function]bool</span> <span class="pre">__builtin_uaddl_overflow</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">a,unsigned</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">b,</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">*res)</span> <span class="pre">[Built-in</span> <span class="pre">Function]bool</span> <span class="pre">__builtin_uaddll_overflow</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">a,unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">b,</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">*res)</span> <span class="pre">[Built-in</span> <span class="pre">Function]</span>
<span class="pre">`</span></code></p>
<p>这些内置函数将前两个操作数提升为无限精度带符号类型，并对这些提升的操作数执行加法运算。 然后将结果强制转换为第三个指针参数指向的类型并存储在那里。 如果存储的结果等于无限精度的结果，则内置函数返回false，否则返回true。 由于加法运算以无穷大的符号精度执行，因此这些内置函数对所有参数值具有完全定义的行为。</p>
<blockquote>
<div><p>第一个内置函数允许为操作数使用任意整数类型，并且结果类型必须是指向除枚举或布尔类型之外的某些整数类型的指针，其余的内置函数具有显式整数类型。</p>
<p>编译器将在可能的情况下尝试使用硬件指令来实现这些内置功能，例如加法后的条件跳转，进位条件跳转等。</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">bool</span> <span class="pre">__builtin_sub_overflow</span> <span class="pre">(</span> <span class="pre">type1</span> <span class="pre">a,</span> <span class="pre">type2</span> <span class="pre">b,</span> <span class="pre">type3</span> <span class="pre">*res)</span> <span class="pre">[Built-in</span> <span class="pre">Function]bool</span> <span class="pre">__builtin_ssub_overflow</span> <span class="pre">(int</span> <span class="pre">a,</span> <span class="pre">int</span> <span class="pre">b,</span> <span class="pre">int</span> <span class="pre">*res)</span> <span class="pre">[Built-in</span> <span class="pre">Function]bool</span> <span class="pre">__builtin_ssubl_overflow</span> <span class="pre">(long</span> <span class="pre">int</span> <span class="pre">a,</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">b,</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">*res)</span> <span class="pre">[Built-in</span> <span class="pre">Function]bool</span> <span class="pre">__builtin_ssubll_overflow</span> <span class="pre">(long</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">a,</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">b,</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">*res)</span> <span class="pre">[Built-in</span> <span class="pre">Function]bool</span> <span class="pre">__builtin_usub_overflow</span> <span class="pre">(unsigned</span> <span class="pre">int</span> <span class="pre">a,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">b,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*res)</span> <span class="pre">[Built-in</span> <span class="pre">Function]bool</span> <span class="pre">__builtin_usubl_overflow</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">a,unsigned</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">b,</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">*res)</span> <span class="pre">[Built-in</span> <span class="pre">Function]bool</span> <span class="pre">__builtin_usubll_overflow</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">a,unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">b,</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">*res)</span> <span class="pre">[Built-in</span> <span class="pre">Function]</span>
<span class="pre">`</span></code></p>
<p>这些内置函数类似于上面的添加溢出检查内置函数，不同之处在于它们执行减法运算，从第一个参数中减去第二个参数，而不是加法。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">bool</span> <span class="pre">__builtin_mul_overflow</span> <span class="pre">(</span> <span class="pre">type1</span> <span class="pre">a,</span> <span class="pre">type2</span> <span class="pre">b,</span> <span class="pre">type3</span> <span class="pre">*res)</span> <span class="pre">[Built-in</span> <span class="pre">Function]bool</span> <span class="pre">__builtin_smul_overflow</span> <span class="pre">(int</span> <span class="pre">a,</span> <span class="pre">int</span> <span class="pre">b,</span> <span class="pre">int</span> <span class="pre">*res)</span> <span class="pre">[Built-in</span> <span class="pre">Function]bool</span> <span class="pre">__builtin_smull_overflow</span> <span class="pre">(long</span> <span class="pre">int</span> <span class="pre">a,</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">b,</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">*res)</span> <span class="pre">[Built-in</span> <span class="pre">Function]bool</span> <span class="pre">__builtin_smulll_overflow</span> <span class="pre">(long</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">a,</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">b,</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">*res)</span> <span class="pre">[Built-in</span> <span class="pre">Function]bool</span> <span class="pre">__builtin_umul_overflow</span> <span class="pre">(unsigned</span> <span class="pre">int</span> <span class="pre">a,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">b,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*res)</span> <span class="pre">[Built-in</span> <span class="pre">Function]bool</span> <span class="pre">__builtin_umull_overflow</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">a,unsigned</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">b,</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">*res)</span> <span class="pre">[Built-in</span> <span class="pre">Function]bool</span> <span class="pre">__builtin_umulll_overflow</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">a,unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">b,</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">int</span> <span class="pre">*res)</span> <span class="pre">[Built-in</span> <span class="pre">Function]</span>
<span class="pre">`</span></code></p>
<p>这些内置函数与上面的添加溢出检查内置函数相似，不同之处在于它们执行乘法而不是加法。</p>
<p>以下内置函数允许检查简单的算术运算是否会溢出。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">bool</span> <span class="pre">__builtin_add_overflow_p</span> <span class="pre">(</span> <span class="pre">type1</span> <span class="pre">a,</span> <span class="pre">type2</span> <span class="pre">b,</span> <span class="pre">type3</span> <span class="pre">c)</span> <span class="pre">[Built-in</span> <span class="pre">Function]bool</span> <span class="pre">__builtin_sub_overflow_p</span> <span class="pre">(</span> <span class="pre">type1</span> <span class="pre">a,</span> <span class="pre">type2</span> <span class="pre">b,</span> <span class="pre">type3</span> <span class="pre">c)</span> <span class="pre">[Built-in</span> <span class="pre">Function]bool</span> <span class="pre">__builtin_mul_overflow_p</span> <span class="pre">(</span> <span class="pre">type1</span> <span class="pre">a,</span> <span class="pre">type2</span> <span class="pre">b,</span> <span class="pre">type3</span> <span class="pre">c)</span> <span class="pre">[Built-in</span> <span class="pre">Function]</span>
<span class="pre">`</span></code></p>
<p>这些内置函数类似于__builtin_add_overflow，__builtin_sub_overflow或__builtin_mul_overflow，不同之处在于它们不将算术运算的结果存储在任何地方，并且最后一个参数不是指针，而是某些具有枚举或布尔类型以外的整数类型的表达式 。</p>
<p>内置函数将前两个操作数提升为无限精度带符号类型，并对这些提升的操作数执行加法运算。 然后将结果转换为第三个参数的类型。 如果强制转换结果等于无限精度结果，则内置函数返回false，否则返回true。 将忽略第三个参数的值，仅评估第三个参数中的副作用，并且不对最后一个参数执行积分参数提升。 如果第三个参数是位字段，则用于结果强制转换的类型具有给定位字段的精度和正负号，而不是基础类型的精度和正负号。</p>
<p>例如，以下宏可用于在编译时便携式检查是否将两个常数整数相加是否溢出，并且仅在已知安全且不触发“ -Woverflow”警告的情况下执行相加操作 。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">#define</span> <span class="pre">INT_ADD_OVERFLOW_P(a,</span> <span class="pre">b)</span> <span class="pre">\</span>&#160;&#160;&#160; <span class="pre">__builtin_add_overflow_p</span> <span class="pre">(a,</span> <span class="pre">b,</span> <span class="pre">(__typeof__</span> <span class="pre">((a)</span> <span class="pre">+</span> <span class="pre">(b)))</span> <span class="pre">0)</span>
<span class="pre">enum</span> <span class="pre">{</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">A</span> <span class="pre">=</span> <span class="pre">INT_MAX,</span> <span class="pre">B</span> <span class="pre">=</span> <span class="pre">3,</span>&#160;&#160;&#160;&#160; <span class="pre">C</span> <span class="pre">=</span> <span class="pre">INT_ADD_OVERFLOW_P</span> <span class="pre">(A,</span> <span class="pre">B)</span> <span class="pre">?</span> <span class="pre">0</span> <span class="pre">:</span> <span class="pre">A</span> <span class="pre">+</span> <span class="pre">B,</span>&#160;&#160;&#160;&#160;&#160; <span class="pre">D</span> <span class="pre">=</span> <span class="pre">__builtin_add_overflow_p</span> <span class="pre">(1,</span> <span class="pre">SCHAR_MAX,</span> <span class="pre">(signed</span> <span class="pre">char)</span> <span class="pre">0)};</span>
<span class="pre">`</span></code></p>
<p>编译器将在可能的情况下尝试使用硬件指令来实现这些内置功能，例如加法后的条件跳转，进位条件跳转等。</p>
<p>总结：</p>
</li>
</ul>
</div>
<div class="section" id="id343">
<h2>x86特定于事务性内存的内存模型扩展<a class="headerlink" href="#id343" title="Permalink to this headline">¶</a></h2>
<p>x86体系结构支持附加的内存排序标志，以标记用于硬件锁定清除的关键部分。 除了原子内在函数的现有存储顺序之外，还必须指定这些参数。</p>
<ul class="simple">
<li><p>__ATOMIC_HLE_ACQUIRE:在锁定变量上启动锁定省略。 内存顺序必须为__ATOMIC_ACQUIRE或更强。</p></li>
<li><p>__ATOMIC_HLE_RELEASE:在锁变量上结束锁省略。 内存顺序必须为__ATOMIC_RELEASE或更高。</p></li>
</ul>
<p>当锁获取失败时，需要良好的性能才能快速中止事务。 可以使用_mm_pause来完成。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">#include</span> <span class="pre">&lt;immintrin.h&gt;</span> <span class="pre">//</span> <span class="pre">For</span> <span class="pre">_mm_pauseint</span> <span class="pre">lockvar;/*</span> <span class="pre">Acquire</span> <span class="pre">lock</span> <span class="pre">with</span> <span class="pre">lock</span> <span class="pre">elision</span> <span class="pre">*/while</span> <span class="pre">(__atomic_exchange_n(&amp;lockvar,</span> <span class="pre">1,</span> <span class="pre">__ATOMIC_ACQUIRE|__ATOMIC_HLE_ACQUIRE))_mm_pause();</span> <span class="pre">/*</span> <span class="pre">Abort</span> <span class="pre">failed</span> <span class="pre">transaction</span> <span class="pre">*/.../*</span> <span class="pre">Free</span> <span class="pre">lock</span> <span class="pre">with</span> <span class="pre">lock</span> <span class="pre">elision</span> <span class="pre">*/__atomic_store_n(&amp;lockvar,</span> <span class="pre">0,</span> <span class="pre">__ATOMIC_RELEASE|__ATOMIC_HLE_RELEASE);</span>
<span class="pre">`</span></code></p>
<p>总结：</p>
</div>
<div class="section" id="id344">
<h2>对象大小检查内置函数<a class="headerlink" href="#id344" title="Permalink to this headline">¶</a></h2>
<p>GCC实施了有限的缓冲区溢出保护机制，可以通过确定要写入数据的对象的大小并在大小不足时阻止写入来防止某些缓冲区溢出攻击。 下文所述的内置函数在一起使用和启用优化时会产生最佳结果。例如，要检测跨函数边界的对象大小或通过非平凡的控制流跟踪指针分配，它们依赖于通过’ -O2’。 但是，在一定程度上，它们也可以在不进行优化的情况下使用。</p>
<ul>
<li><p>size_t __builtin_object_size (const void * ptr , int type ) [Built-in Function]:是一个内置结构，该结构从ptr到对象ptr指针所指向的末尾返回恒定数量的字节（如果在编译时已知）。 为了确定动态分配的对象的大小，该函数依赖于分配函数，这些分配函数被调用来获取要使用alloc_size属性声明的存储（请参见第6.33.1节[公共函数属性]，第522页）。__builtin_object_size永远不会评估其参数是否有副作用。 如果其中有任何副作用，则对于类型0或1返回（size_t）-1，对于类型2或3返回（size_t）0。如果ptr可以指向多个对象，并且在编译时都知道它们 ，返回的数字是类型＆2为0时这些对象中剩余字节数的最大值，如果非零则为最小值。 如果无法确定编译时ptr指向的对象，则__builtin_object_size对于类型0或1应该返回（size_t）-1，对于类型2或3应该返回（size_t）0。</p></li>
<li><p>type是一个介于0到3之间的整数常量。如果最低有效位清零，则对象是完整变量，如果已设置，则将最接近的周围子对象视为指针指向的对象。 第二位确定是否计算剩余字节的最大值或最小值。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">struct</span> <span class="pre">V</span> <span class="pre">{</span> <span class="pre">char</span> <span class="pre">buf1[10];</span> <span class="pre">int</span> <span class="pre">b;</span> <span class="pre">char</span> <span class="pre">buf2[10];</span> <span class="pre">}</span> <span class="pre">var;char</span> <span class="pre">*p</span> <span class="pre">=</span> <span class="pre">&amp;var.buf1[1],</span> <span class="pre">*q</span> <span class="pre">=</span> <span class="pre">&amp;var.b;/*</span> <span class="pre">Here</span> <span class="pre">the</span> <span class="pre">object</span> <span class="pre">p</span> <span class="pre">points</span> <span class="pre">to</span> <span class="pre">is</span> <span class="pre">var.</span> <span class="pre">*/assert</span> <span class="pre">(__builtin_object_size</span> <span class="pre">(p,</span> <span class="pre">0)</span> <span class="pre">==</span> <span class="pre">sizeof</span> <span class="pre">(var)</span> <span class="pre">-</span> <span class="pre">1);/*</span> <span class="pre">The</span> <span class="pre">subobject</span> <span class="pre">p</span> <span class="pre">points</span> <span class="pre">to</span> <span class="pre">is</span> <span class="pre">var.buf1.</span> <span class="pre">*/assert</span> <span class="pre">(__builtin_object_size</span> <span class="pre">(p,</span> <span class="pre">1)</span> <span class="pre">==</span> <span class="pre">sizeof</span> <span class="pre">(var.buf1)</span> <span class="pre">-</span> <span class="pre">1);/*</span> <span class="pre">The</span> <span class="pre">object</span> <span class="pre">q</span> <span class="pre">points</span> <span class="pre">to</span> <span class="pre">is</span> <span class="pre">var.</span> <span class="pre">*/assert</span> <span class="pre">(__builtin_object_size</span> <span class="pre">(q,</span> <span class="pre">0)</span>&#160;&#160;&#160;&#160;&#160; <span class="pre">==</span> <span class="pre">(char</span> <span class="pre">*)</span> <span class="pre">(&amp;var</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">-</span> <span class="pre">(char</span> <span class="pre">*)</span> <span class="pre">&amp;var.b);/*</span> <span class="pre">The</span> <span class="pre">subobject</span> <span class="pre">q</span> <span class="pre">points</span> <span class="pre">to</span> <span class="pre">is</span> <span class="pre">var.b.</span> <span class="pre">*/assert</span> <span class="pre">(__builtin_object_size</span> <span class="pre">(q,</span> <span class="pre">1)</span> <span class="pre">==</span> <span class="pre">sizeof</span> <span class="pre">(var.b));</span>
<span class="pre">`</span></code></p>
<p>为许多常见的字符串操作函数添加了内置函数，例如，为memcpy提供了__builtin___memcpy_chk内置函数。 此内置函数有一个附加的last参数，该参数是dest参数指向的对象中剩余的字节数，如果大小未知，则为（size_t）-1。</p>
<blockquote>
<div><p>如果最后一个参数为（size_t）-1或在编译时得知目标对象不会溢出，则将内置函数优化为诸如memcpy之类的常规字符串函数。 如果编译器可以在编译时确定该对象将始终被溢出，则会发出警告。</p>
</div></blockquote>
<p>预期用途可以是例如 :</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">#undef</span> <span class="pre">memcpy#define</span> <span class="pre">bos0(dest)</span> <span class="pre">__builtin_object_size</span> <span class="pre">(dest,</span> <span class="pre">0)#define</span> <span class="pre">memcpy(dest,</span> <span class="pre">src,</span> <span class="pre">n)</span> <span class="pre">\__builtin___memcpy_chk</span> <span class="pre">(dest,</span> <span class="pre">src,</span> <span class="pre">n,</span> <span class="pre">bos0</span> <span class="pre">(dest))char</span> <span class="pre">*volatile</span> <span class="pre">p;char</span> <span class="pre">buf[10];/*</span> <span class="pre">It</span> <span class="pre">is</span> <span class="pre">unknown</span> <span class="pre">what</span> <span class="pre">object</span> <span class="pre">p</span> <span class="pre">points</span> <span class="pre">to,</span> <span class="pre">so</span> <span class="pre">this</span> <span class="pre">is</span> <span class="pre">optimizedinto</span> <span class="pre">plain</span> <span class="pre">memcpy</span> <span class="pre">-</span> <span class="pre">no</span> <span class="pre">checking</span> <span class="pre">is</span> <span class="pre">possible.</span> <span class="pre">*/memcpy</span> <span class="pre">(p,</span> <span class="pre">&quot;abcde&quot;,</span> <span class="pre">n);/*</span> <span class="pre">Destination</span> <span class="pre">is</span> <span class="pre">known</span> <span class="pre">and</span> <span class="pre">length</span> <span class="pre">too.</span> <span class="pre">It</span> <span class="pre">is</span> <span class="pre">known</span> <span class="pre">at</span> <span class="pre">compiletime</span> <span class="pre">there</span> <span class="pre">will</span> <span class="pre">be</span> <span class="pre">no</span> <span class="pre">overflow.</span> <span class="pre">*/memcpy</span> <span class="pre">(&amp;buf[5],</span> <span class="pre">&quot;abcde&quot;,</span> <span class="pre">5);/*</span> <span class="pre">Destination</span> <span class="pre">is</span> <span class="pre">known,</span> <span class="pre">but</span> <span class="pre">the</span> <span class="pre">length</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">known</span> <span class="pre">at</span> <span class="pre">compile</span> <span class="pre">time.This</span> <span class="pre">will</span> <span class="pre">result</span> <span class="pre">in</span> <span class="pre">__memcpy_chk</span> <span class="pre">call</span> <span class="pre">that</span> <span class="pre">can</span> <span class="pre">check</span> <span class="pre">for</span> <span class="pre">overflowat</span> <span class="pre">run</span> <span class="pre">time.</span> <span class="pre">*/memcpy</span> <span class="pre">(&amp;buf[5],</span> <span class="pre">&quot;abcde&quot;,</span> <span class="pre">n);/*</span> <span class="pre">Destination</span> <span class="pre">is</span> <span class="pre">known</span> <span class="pre">and</span> <span class="pre">it</span> <span class="pre">is</span> <span class="pre">known</span> <span class="pre">at</span> <span class="pre">compile</span> <span class="pre">time</span> <span class="pre">there</span> <span class="pre">willbe</span> <span class="pre">overflow.</span> <span class="pre">There</span> <span class="pre">will</span> <span class="pre">be</span> <span class="pre">a</span> <span class="pre">warning</span> <span class="pre">and</span> <span class="pre">__memcpy_chk</span> <span class="pre">call</span> <span class="pre">thatwill</span> <span class="pre">abort</span> <span class="pre">the</span> <span class="pre">program</span> <span class="pre">at</span> <span class="pre">run</span> <span class="pre">time.</span> <span class="pre">*/memcpy</span> <span class="pre">(&amp;buf[6],</span> <span class="pre">&quot;abcde&quot;,</span> <span class="pre">5);</span>
<span class="pre">`</span></code></p>
</li>
</ul>
<p>为memcpy，mempcpy，memmove，memset，strcpy，stpcpy，strncpy，strcat和strncat提供了此类内置函数。</p>
<p>还检查内置函数是否格式化了输出函数。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">int</span> <span class="pre">__builtin___sprintf_chk</span> <span class="pre">(char</span> <span class="pre">*s,</span> <span class="pre">int</span> <span class="pre">flag,</span> <span class="pre">size_t</span> <span class="pre">os,</span> <span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt,</span> <span class="pre">...);int</span> <span class="pre">__builtin___snprintf_chk</span> <span class="pre">(char</span> <span class="pre">*s,</span> <span class="pre">size_t</span> <span class="pre">maxlen,</span> <span class="pre">int</span> <span class="pre">flag,</span> <span class="pre">size_t</span> <span class="pre">os,const</span> <span class="pre">char</span> <span class="pre">*fmt,</span> <span class="pre">...);int</span> <span class="pre">__builtin___vsprintf_chk</span> <span class="pre">(char</span> <span class="pre">*s,</span> <span class="pre">int</span> <span class="pre">flag,</span> <span class="pre">size_t</span> <span class="pre">os,</span> <span class="pre">const</span> <span class="pre">char</span> <span class="pre">*fmt,va_list</span> <span class="pre">ap);int</span> <span class="pre">__builtin___vsnprintf_chk</span> <span class="pre">(char</span> <span class="pre">*s,</span> <span class="pre">size_t</span> <span class="pre">maxlen,</span> <span class="pre">int</span> <span class="pre">flag,</span> <span class="pre">size_t</span> <span class="pre">os,const</span> <span class="pre">char</span> <span class="pre">*fmt,</span> <span class="pre">va_list</span> <span class="pre">ap);</span>
<span class="pre">`</span></code></p>
<p>添加的标志参数未更改地传递给__sprintf_chk等函数，并且可以包含特定于实现的标志，这些标志涉及检查函数可能采取的其他安全措施，例如以不同方式处理％n。</p>
<p>os参数是s指向的对象大小，就像其他内置函数一样。 但是，行为上有细微的差别，如果os为（size_t）-1，则仅当flag为0时，才会将内置函数优化为非检查函数，否则，将os参数设置为（ size_t）-1。</p>
<p>除此之外，还检查内置函数__builtin___printf_chk，__builtin___vprintf_chk，__builtin___fprintf_chk和__builtin___vfprintf_chk，它们仅在格式字符串fmt之前有一个附加参数flag 如果编译器能够将其优化为fputc等函数，则可以，否则，将调用checking函数并将flag参数传递给该函数。</p>
<p>总结：</p>
</div>
<div class="section" id="id345">
<h2>GCC提供的其他内置函数<a class="headerlink" href="#id345" title="Permalink to this headline">¶</a></h2>
<p>除了上述功能外，GCC还提供了许多内置函数。其中一些函数供内部使用，用于处理异常或变长参数列表，此处未作记录，因为它们可能会不时更改。 我们不建议您一般使用这些功能。</p>
<p>提供其余功能是出于优化目的。</p>
<p>除了具有库等效项（例如下面讨论的标准C库函数）或扩展为库调用的内置插件外，GCC内置函数始终始终内联扩展，因此没有相应的入口点，因此它们的地址不能为 获得。 尝试在函数调用以外的表达式中使用它们会导致编译时错误。</p>
<p>GCC在标准C库中包含许多功能的内置版本。 这些函数有两种形式：一种以__builtin_前缀开头，另一种则不带前缀。 两种形式都具有相同的类型（包括原型），相同的地址（使用它们的地址时），以及与C库函数相同的含义，即使您指定了’-fno-builtin’选项，请参见第3.4节[C语言选项] ]，第43页）。 其中许多功能仅在某些情况下进行了优化。 如果在特定情况下未对它们进行优化，则会发出对库函数的调用。</p>
<p>在严格的ISO C模式之外（’-ansi’，’-std = c90’，’-std = c99’或’-std = c11’），函数_exit，alloca，bcmp，bzero，dcgettext，dgettext，dremf，dreml ，drem，exp10f，exp10l，exp10，ffsll，ffsl，ffs，fprintf_unlocked，fputs_unlocked，gammaf，gammal，gamma，gammaf_r，gammal_r，gamma_r，gettext，index，isascii，j0f，j0l，j0，j1，j1f， ，jnl，jn，lgammaf_r，lgammal_r，lgamma_r，mempcpy，pow10f，pow10l，pow10，printf_unlocked，rindex，roundeven，roundevenf，roundevenl，scalbf，scalbl，scalb，signbit，signbitf，signbitl，signbitd32，signbitd32， ，有意义，sincosf，sincosl，sincos，stpcpy，stpncpy，strcasecmp，strdup，strfmon，strncasecmp，strndup，strnlen，toascii，y0f，y0l，y0，y1f，y1l，y1，ynf，ynl和yn -l 在功能上。 所有这些功能都有相应的前缀为__builtin_的版本，即使在严格的C90模式下也可以使用。</p>
<p>ISO C99功能_Exit，acoshf，acoshl，acosh，asinhf，asinhl，asinh，atanhf，atanhl，atanh，cabsf，cabsl，cabs，cacosf，cacoshf，cacoshl，cacosh，cacosl，cacosf，cargf，cargl，carg，casin casinhf，casinhl，casinh，casinl，casin，catanf，catanhf，catanhl，catanh，catanl，catan，cbrtf，cbrtl，cbrt，ccosf，ccoshf，ccoshl，ccosh，ccosl，ccosl，cexpf，cexpl，cexp，cexp，cexp cimag，clogf，clogl，clog，conjf，conjl，conj，copysignf，copysignl，copysign，cpowf，cpowl，cpow，cprojf，cprojl，cproj，crealf，creall，creal，csinf，csinhf，csinhl，csinh， csqrtf，csqrtl，csqrt，ctanf，ctanhf，ctanhl，ctanh，ctanl，ctan，erfcf，erfcl，erfc，erff，erfl，erfcf，exp2f，exp2l，exp2，expm1f，expm1l，expm1，fdimf， fmal，fmaxf，fmaxl，fmax，fma，fminf，fminl，fmin，hypotf，hypotl，hypot，logbf，ilogbl，ilogb，imaxabs，isblank，iswblank，lgammaf，lgammal，lgamma，llabs，llrintf，llrintl，llrint， llroundl，llround，log1pf，log1pl，log1p，log2f，log2l，log2，logbf，logbl，logb，lrintf，lrintl，lrint，lroundf，lroundl，lround，neighborintf，neighborintl，neighborintint，nextafterf，nextafterl，nextafter，nexttowardf，nexttol nexttoward，remainderf，remainderl，remain，remquof，remquol，remquo，rintf，rintl，rint，roundf，roundl，round，scalblnf，scalblnl，scalbln，scalbnf，scalbnl，scalbn，snprintf，tgammaf，tgammal，tgammat，tgammal，tgammat trunc，vfscanf，vscanf，vsnprintf和vsscanf被作为内置函数处理，但在严格的ISO C90模式（“ -ansi”或“ -std = c90”）下除外。</p>
<p>ISO C99的内置版本还具有以下功能：acosf，acosl，asinf，asinl，atan2f，atan2l，atanf，atanl，ceilf，ceill，cosf，coshf，coshl，cosl，expf，expl，fabsf，fabsl，floorf， floorl，fmodf，fmodl，frexpf，frexpl，ldexpf，ldexpl，log10f，log10l，logf，logl，modfl，modf，powf，powl，sinf，sinhf，sinhl，sinl，sqrtf，sqrtl，tanf，tanhf，tanhl和tanl 可以以任何方式识别，因为ISO C90保留这些名称是为了ISO C99放置它们的目的。 所有这些功能都有对应的版本，其前缀为__builtin_。</p>
<p>对于受支持的类型_Floatn和_Floatn，还具有内置函数__builtin_fabsfn，__builtin_fabsfnx，__builtin_copysignfn和__builtin_copysignfnx，它们对应于TS 18661-3函数fabsfn，fabsfnx，copysignfn和copysignfnx。</p>
<p>还有GNU扩展功能clog10，clog10f和clog10l，这些名称由ISO C99保留以供将来使用。 所有这些函数的版本均带有__builtin_前缀。</p>
<blockquote>
<div><p>ISO C94函数iswalnum，iswalpha，iswcntrl，iswdigit，iswgraph，iswlower，iswprint，iswpunct，iswspace，iswupper，iswxdigit，towlower和towupper均作为内置函数处理，但在严格的ISO C90模式下（“ -ansi”或“- std = c90’）。</p>
</div></blockquote>
<p>ISO C90功能中止，abs，acos，asin，atan2，atan，calloc，ceil，cosh，cos，exit，exp，fabs，floor，fprintf，fputs，free，frexp，fscanf，isalnum，isalpha，iscntrl， isdigit，isgraph，islower，isprint，ispunct，isspace，isupper，isxdigit，tolower，toupper，实验室，ldexp，log10，log，malloc，memchr，memcmp，memcpy，memset，modf，pow，print，printf，putchar，puts，realloc， scanf，sinh，sin，snprintf，sprintf，sqrt，sscanf，strcat，strchr，strcmp，strcpy，strcspn，strlen，strncat，strncmp，strncpy，strpbrk，strrchr，strspn，strncpn，strstrmp，tanh，tan，vfprintf，vprintf和vsprintf是 除非指定了“ -fno-builtin”（或为单个功能指定了“ -fno-builtin-function”），否则所有公认的内置函数。 所有这些功能都有对应的版本，其前缀为__builtin_。</p>
<p>GCC提供了ISO C99浮点比较宏的内置版本，可避免引发无序操作数的异常。 它们具有与标准宏相同的名称（isgreater,isgreaterequal，isless，islessequal，islessgreater和isunordered），并带有__builtin_前缀。 我们希望库实现者能够简单地#define每个标准宏为其内置等效项。 GCC以相同的方式提供fpclassify，isfinite，isinf_sign，isnormal和signbit内置插件（以__builtin_为前缀）。 带有和不带有__builtin_前缀的isinf和isnan内置函数都会出现。</p>
<ul>
<li><p>void <a href="#id346"><span class="problematic" id="id347">*</span></a>__builtin_alloca (size t size)  [Built-in Function]:__builtin_alloca函数必须在块范围内调用。 该函数在调用函数的堆栈上分配较大的对象大小字节。 对象在由__BIGGEST_ALIGNMENT__宏确定的目标的默认堆栈对齐边界上对齐。 __builtin_alloca函数返回一个指向已分配对象的第一个字节的指针。 分配的对象的生存期刚好在调用函数返回其调用者之前结束。 即使在嵌套块中调用__builtin_alloca时也是如此。</p>
<p>例如，以下函数在堆栈上分配八个n个字节的对象，并在数组a的连续元素中存储指向每个对象的指针。 然后，它将数组传递给函数g，该函数可以安全地使用每个数组元素所指向的存储。</p>
</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">void</span> <span class="pre">f</span> <span class="pre">(unsigned</span> <span class="pre">n){</span>&#160;&#160;&#160; <span class="pre">void</span> <span class="pre">*a</span> <span class="pre">[8];</span>&#160;&#160;&#160; <span class="pre">for</span> <span class="pre">(int</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">0;</span> <span class="pre">i</span> <span class="pre">!=</span> <span class="pre">8;</span> <span class="pre">++i)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">a</span> <span class="pre">[i]</span> <span class="pre">=</span> <span class="pre">__builtin_alloca</span> <span class="pre">(n);</span>&#160;&#160; <span class="pre">g</span> <span class="pre">(a,</span> <span class="pre">n);//</span> <span class="pre">safe}</span>
<span class="pre">`</span></code></p>
<p>由于__builtin_alloca函数不会验证其参数，因此调用方有责任确保该参数不会导致其超出堆栈大小限制。 提供__builtin_alloca函数可以在堆栈上分配字节数组，并可以在运行时计算其上限。 由于C99可变长度数组在可移植，更方便和更安全的界面下提供了类似的功能，因此建议在GCC将其作为扩展的C99和C ++程序中使用它们。 有关详细信息，请参见第6.20节“变量长度”，第514页。</p>
<ul class="simple">
<li><p>void <a href="#id348"><span class="problematic" id="id349">*</span></a>__builtin_alloca_with_align (size t size, size t alignment)  [Built-in Function] :__builtin_alloca_with_align函数必须在块作用域内调用。 该函数在调用函数的堆栈上分配较大的对象大小字节。</p></li>
</ul>
<p>分配的对象在参数对齐方式指定的边界上对齐，参数对齐方式以位（而非字节）为单位。 size参数必须为正，且不能超过堆栈大小限制。 对齐参数必须是一个恒定的整数表达式，其求值为2的幂，大于或等于CHAR_BIT并且小于一些未指定的最大值。 使用其他值的调用将被拒绝，并显示一个指示有效范围的错误。 该函数返回一个指向所分配对象的第一个字节的指针。 分配的对象的生存期在调用该函数的块的末尾结束。 所分配的存储至少要在调用函数返回其调用者之前释放，但是可以在调用该函数的块的末尾释放。</p>
<p>例如，在以下函数中，对g的调用是不安全的，因为当overalign不为零时，由__builtin_alloca_with_align分配的空间可能已在其被调用的if语句的末尾释放。</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">void</span> <span class="pre">f</span> <span class="pre">(unsigned</span> <span class="pre">n,</span> <span class="pre">bool</span> <span class="pre">overalign){</span>&#160;&#160;&#160; <span class="pre">void</span> <span class="pre">*p;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">if</span> <span class="pre">(overalign)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">p</span> <span class="pre">=</span> <span class="pre">__builtin_alloca_with_align</span> <span class="pre">(n,</span> <span class="pre">64</span> <span class="pre">/*</span> <span class="pre">bits</span> <span class="pre">*/);</span>&#160;&#160;&#160;&#160; <span class="pre">else</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">p</span> <span class="pre">=</span> <span class="pre">__builtin_alloc</span> <span class="pre">(n);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">g</span> <span class="pre">(p,</span> <span class="pre">n);</span> <span class="pre">//</span> <span class="pre">unsafe}</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><p>由于__builtin_alloca_with_align函数不会验证其size参数，因此调用方有责任确保该参数不会导致其超出堆栈大小限制。 提供了__builtin_alloca_with_align函数，以便可以在堆栈上分配字节数超出上限的数组，并在运行时计算出上限。 由于C99可变长数组在可移植，更方便和更安全的界面下提供了相同的功能，因此建议在GCC将其作为扩展的C99和C ++程序中使用它们。 有关详细信息，请参见第6.20节“变量长度”，第514页。</p>
</div></blockquote>
<ul>
<li><p>void <a href="#id350"><span class="problematic" id="id351">*</span></a>__builtin_alloca_with_align_and_max (size t size,size t alignment, size t max size)  [Built-in Function]:与__builtin_alloca_with_align相似，但是采用一个额外的参数来指定大小上限，以防在编译时无法计算其值，以供’-fstack-usage’，’-Wstack-usage’和’-Walloca-larger-than’使用 。 max size必须是一个常数整数表达式，它对代码生成没有影响，也没有尝试检查其与size的兼容性。</p></li>
<li><p>bool __builtin_has_attribute ( type-or-expression , attribute ) [Built-in Function]:如果已经使用第二个参数所引用的属性声明了type-or-expression参数所引用的符号或类型，则__builtin_has_attribute函数将得出等于true的整数常量表达式。对于不引用符号的类型或表达式自变量，由于属性不适用于内置表达式，因此内置函数会考虑自变量的类型。这两个参数均未评估。 type-or-expression自变量与typeof自变量具有相同的限制（请参见第6.7节[Typeof]，第503页）。属性参数是一个属性名称，可以选择在其后跟随用括号括起来的逗号分隔的参数列表。可以识别两种形式的属性名称（带或不带双下划线和下划线）。有关详细信息，请参见第6.39节[属性语法]，第609页。如果没有为需要一个或多个参数的属性指定属性参数，则无论是否使用属性声明了类型或表达式，该函数均会返回true。</p></li>
<li><p>为期望某些属性的参数提供的参数经过验证，并与提供的数字匹配。 如果所有提供的参数都匹配，则该函数返回true。 例如，对以下函数的第一次调用的结果为true，因为x是用aligned属性声明的，而第二次调用的结果是false，因为x被声明为aligned（8）而不是aligned（4）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">__attribute__</span> <span class="pre">((aligned</span> <span class="pre">(8)))</span> <span class="pre">int</span> <span class="pre">x;_Static_assert</span> <span class="pre">(__builtin_has_attribute</span> <span class="pre">(x,</span> <span class="pre">aligned),</span> <span class="pre">&quot;aligned&quot;);_Static_assert</span> <span class="pre">(!__builtin_has_attribute</span> <span class="pre">(x,</span> <span class="pre">aligned</span> <span class="pre">(4)),</span> <span class="pre">&quot;aligned</span> <span class="pre">(4)&quot;);</span>
<span class="pre">`</span></code></p>
<p>由于限制，即使type-or-expression参数引用的类型或变量声明为1，__builtin_has_attribute函数对于mode属性也返回false。 标签也不支持该功能，C中还没有枚举器支持该功能。</p>
<p>请注意，与适用于#if预处理指令的__has_attribute预处理程序运算符不同，__builtin_has_attribute是一种内在函数，在这种情况下无法识别。</p>
<p>type __builtin_speculation_safe_value ( type val, type failval)  [Built-in Function]:此内置函数可用于帮助缓解不安全的投机执行。 type可以是任何整数类型或任何指针类型。</p>
<ul class="simple">
<li><p>如果CPU没有以推测方式执行代码，则返回val。</p></li>
<li><p>如果CPU正在执行推测性执行，则：
- 该函数可能导致执行暂停，直到知道不再通过推测方式执行代码为止（在这种情况下，可以如上所述返回val）； 或者
- 当已知推测执行已错误地预测了条件分支操作时，该函数可以使用依赖于目标的推测跟踪状态来使failval返回。</p></li>
</ul>
<p>第二个参数failval是可选的，如果省略则默认为零。</p>
<p>GCC为已更新为支持此内置目标的目标定义了预处理器宏__HAVE_BUILTIN_SPECULATION_SAFE_VALUE。</p>
<p>可以在似乎可以安全使用变量的情况下使用内置函数，但是由于推测性执行，CPU可能会暂时忽略边界检查。</p>
<p>例如，考虑以下功能：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">int</span> <span class="pre">array[500];int</span> <span class="pre">f</span> <span class="pre">(unsigned</span> <span class="pre">untrusted_index){</span>&#160;&#160;&#160;&#160;&#160; <span class="pre">if</span> <span class="pre">(untrusted_index</span> <span class="pre">&lt;</span> <span class="pre">500)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">return</span> <span class="pre">array[untrusted_index];</span>&#160; <span class="pre">return</span> <span class="pre">0;}</span>
<span class="pre">`</span></code></p>
<p>如果使用untrusted_index小于500的限制重复调用该函数，则分支预测器将获悉将执行返回存储在数组中的值的代码块。 如果随后使用超出范围的值调用该函数，它将仍然尝试首先执行该代码块，直到CPU确定 预测不正确（此时，CPU将取消所有不正确的操作）。 但是，根据函数结果的使用方式，可能会在高速缓存中留下一些痕迹，这些痕迹可以揭示出存储在越界位置的内容。 通过将代码更改为以下内容，可以使用内置功能以这种方式提供一些保护，以防止数据泄漏：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">int</span> <span class="pre">array[500];int</span> <span class="pre">f</span> <span class="pre">(unsigned</span> <span class="pre">untrusted_index){</span>&#160;&#160;&#160;&#160;&#160; <span class="pre">if</span> <span class="pre">(untrusted_index</span> <span class="pre">&lt;</span> <span class="pre">500)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">return</span> <span class="pre">array[__builtin_speculation_safe_value</span> <span class="pre">(untrusted_index)];</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">return</span> <span class="pre">0;}</span>
<span class="pre">`</span></code></p>
<p>内置函数将导致执行停止，直到条件分支已完全解决，或者它可以允许推测执行继续进行，但如果超出限制，则使用0而不是untrusted_value。</p>
<p>如果在推测执行不正确时访问任何内存位置可能不安全，则可以将代码重写为</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">int</span> <span class="pre">array[500];int</span> <span class="pre">f</span> <span class="pre">(unsigned</span> <span class="pre">untrusted_index){</span>&#160;&#160;&#160;&#160;&#160; <span class="pre">if</span> <span class="pre">(untrusted_index</span> <span class="pre">&lt;</span> <span class="pre">500)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">return</span> <span class="pre">*__builtin_speculation_safe_value</span> <span class="pre">(&amp;array[untrusted_index],</span> <span class="pre">NULL);</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">return</span> <span class="pre">0;}</span>
<span class="pre">`</span></code></p>
</li>
</ul>
<p>这将导致将NULL指针用于不安全的情况。</p>
<ul>
<li><p>int __builtin_types_compatible_p ( type1 , type2 ) [Built-in Function]:您可以使用内置函数__builtin_types_compatible_p来确定两种类型是否相同。如果类型1和类型2的非限定版本（它们是类型，而不是表达式）兼容，则此内置函数返回1，否则返回0。 此内置函数的结果可用于整数常量表达式。 此内置函数会忽略顶级限定符（例如const，volatile）。 例如，int等同于const int。</p>
<p>类型int []和int [5]是兼容的。 另一方面，int和char <a href="#id352"><span class="problematic" id="id353">*</span></a>不兼容，即使它们的类型大小在特定体系结构上相同。 同样，在确定相似性时要考虑指针间接的数量。 因此，short <a href="#id354"><span class="problematic" id="id355">*</span></a>与short <a href="#id356"><span class="problematic" id="id357">**</span></a>不相似。 此外，如果两个类型定义的类型的基础类型兼容，则认为它们是兼容的。</p>
<p>一个枚举类型不被认为与另一个枚举类型兼容，即使它们都与同一个整数类型兼容； 这就是C标准指定的内容。 例如，枚举{foo，bar}与枚举{hot，dog}不相似。</p>
<p>您通常在代码中使用此函数，其执行会根据参数的类型而有所不同。 例如：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">#define</span> <span class="pre">foo(x)</span> <span class="pre">\({</span> <span class="pre">\typeof</span> <span class="pre">(x)</span> <span class="pre">tmp</span> <span class="pre">=</span> <span class="pre">(x);</span> <span class="pre">\if</span> <span class="pre">(__builtin_types_compatible_p</span> <span class="pre">(typeof</span> <span class="pre">(x),</span> <span class="pre">long</span> <span class="pre">double))</span> <span class="pre">\</span>&#160;&#160;&#160;&#160;&#160; <span class="pre">tmp</span> <span class="pre">=</span> <span class="pre">foo_long_double</span> <span class="pre">(tmp);</span> <span class="pre">\else</span> <span class="pre">if</span> <span class="pre">(__builtin_types_compatible_p</span> <span class="pre">(typeof</span> <span class="pre">(x),</span> <span class="pre">double))</span> <span class="pre">\</span>&#160;&#160;&#160;&#160; <span class="pre">tmp</span> <span class="pre">=</span> <span class="pre">foo_double</span> <span class="pre">(tmp);</span> <span class="pre">\else</span> <span class="pre">if</span> <span class="pre">(__builtin_types_compatible_p</span> <span class="pre">(typeof</span> <span class="pre">(x),</span> <span class="pre">float))</span> <span class="pre">\</span>&#160;&#160; <span class="pre">tmp</span> <span class="pre">=</span> <span class="pre">foo_float</span> <span class="pre">(tmp);</span> <span class="pre">\else</span> <span class="pre">\</span>&#160; <span class="pre">abort</span> <span class="pre">();</span> <span class="pre">\tmp;</span> <span class="pre">\})</span>
<span class="pre">`</span></code></p>
<p>注意：此构造仅适用于C。</p>
<ul>
<li><p>type __builtin_call_with_static_chain ( call_exp ,pointer_exp )     [Built-in Function]</p>
<p>调用exp表达式必须是函数调用，并且指针exp表达式必须是指针。 指针exp传递到目标的静态链位置中的函数调用。 内建的结果是函数调用的结果。</p>
<p>注意：此内置函数仅适用于C。此内置函数可用于从C调用Go闭包。</p>
</li>
<li><p>type __builtin_choose_expr ( const_exp , exp1 , exp2 ) [Built-in Function]:您可以使用内置函数__builtin_choose_expr来根据常量表达式的值来评估代码。 如果作为整数常量表达式的const exp非零，则此内置函数将返回exp1。 否则返回exp2。</p>
<p>此内置功能类似于“？ ：”是C语言中的运算符，只是返回的表达式的类型不受升级规则的影响。 此外，内置函数不会评估未选择的表达式。 例如，如果const exp评估为true，则即使有副作用，exp2也不会评估。</p>
<p>如果所选参数是左值，则此内置函数可以返回左值。 如果返回exp1，则返回类型与exp1的类型相同。同样，如果返回exp2，则其返回类型与exp2相同。例如：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">#define</span> <span class="pre">foo(x)__builtin_choose_expr</span> <span class="pre">(</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">\</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">__builtin_types_compatible_p</span> <span class="pre">(typeof</span> <span class="pre">(x),</span> <span class="pre">double),</span>&#160;&#160;&#160;&#160;&#160; <span class="pre">\</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">foo_double</span> <span class="pre">(x),</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">\</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">__builtin_choose_expr</span> <span class="pre">(</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">\</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">__builtin_types_compatible_p</span> <span class="pre">(typeof</span> <span class="pre">(x),</span> <span class="pre">float),</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">\</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">foo_float</span> <span class="pre">(x),</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">\/*</span> <span class="pre">The</span> <span class="pre">void</span> <span class="pre">expression</span> <span class="pre">results</span> <span class="pre">in</span> <span class="pre">a</span> <span class="pre">compile-time</span> <span class="pre">error</span> <span class="pre">\</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">when</span> <span class="pre">assigning</span> <span class="pre">the</span> <span class="pre">result</span> <span class="pre">to</span> <span class="pre">something.</span> <span class="pre">*/(void)0))</span>
<span class="pre">`</span></code></p>
<p>注意：此构造仅适用于C。此外，未使用的表达式（exp1或exp2取决于const exp的值）可能仍会生成语法错误。在以后的版本中可能会更改。</p>
<p>type __builtin_tgmath ( functions , arguments ) [Built-in Function]:内置函数__builtin_tgmath仅可用于C和Objective-C，它调用根据&lt;tgmath.h&gt;宏规则确定的函数。 它旨在用于该标头的实现中，以便从该标头扩展宏只能将其每个参数扩展一次，以避免调用时出现问题 此类宏嵌套在其他对此类宏的调用的参数中； 此外，与使用其他GNU C语言功能的实现相比，它可以更好地诊断对&lt;tgmath.h&gt;宏的无效调用。 例如，pow类型通用宏可以定义为：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">#define</span> <span class="pre">pow(a,</span> <span class="pre">b)</span> <span class="pre">__builtin_tgmath</span> <span class="pre">(powf,</span> <span class="pre">pow,</span> <span class="pre">powl,</span> <span class="pre">\</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">cpowf,</span> <span class="pre">cpow,</span> <span class="pre">cpowl,</span> <span class="pre">a,</span> <span class="pre">b)</span>
<span class="pre">`</span></code></p>
<p>__builtin_tgmath的参数至少是两个指向函数的指针，其后是指向类型通用宏的参数（它将作为参数传递给所选函数）。 所有指向函数的指针都必须是原型函数的指针，它们都不能具有可变参数，并且它们都必须具有相同数量的参数。 第一个函数的参数数量确定将__builtin_tgmath的参数解释为函数指针，以及将多少作为调用函数的参数。</p>
<p>指定函数的类型必须全部不同，但彼此之间的关联方式与可以由&lt;tgmath.h&gt;中的宏选择的一组函数相同。 这意味着这些函数由浮点类型t进行参数化，每个浮点类型都不同。 函数返回类型可能都相同 类型，或者对于每个函数，它们可以是t，或者对于每个函数，它们可以是与t对应的实类型（如果某些类型t是复杂的）。 同样，对于每个参数位置，该位置中参数的类型可能始终是相同类型，或者对于每个功能可能是t（这种情况必须适用于至少一个参数位置），或者可能是与 每个功能的t。</p>
<p>&lt;tgmath.h&gt;宏的标准规则用于从参数的参数类型中查找通用类型u，参数的类型在函数之间有所不同；为此，将复杂的整数类型（GNU扩展）视为_Complex double（ 或_Complex _Float64（如果所有函数返回类型都是相同的_Floatn或_Floatnx类型）。 如果函数的返回类型不同，或者都是相同的整数类型，则调用的函数就是t为u的函数，如果没有这样的函数，则错误。 如果函数返回类型都是相同的浮点类型，则将类型通用宏视为TS 18661中的一种，该宏将结果四舍五入为较窄的类型； 如果存在一个t为u的函数，则将其调用，否则，将调用t至少具有u的范围和精度的第一个函数（如果有），并且如果没有这样的函数，则为错误 。</p>
<ul>
<li><p>type __builtin_complex ( real , imag ) [Built-in Function]:提供了内置函数__builtin_complex，用于实现ISO C11宏CMPLXF，CMPLX和CMPLXL。 real和imag必须具有相同的类型，一个实数二进制浮点类型，并且结果具有相应的复杂类型，其中real和imag为实数和虚数部分。 与“ real + I * imag”不同，即使涉及无限大，NaN和负零，它也可以工作。</p></li>
<li><p>int __builtin_constant_p ( exp ) [Built-in Function]:您可以使用内置函数__builtin_constant_p来确定在编译时某个值是否已知为常量，因此GCC可以对涉及该值的表达式执行常量折叠。 函数的参数是要测试的值。 如果该参数已知为编译时常量，则该函数返回整数1；如果未知该参数为编译时常量，则返回0。 返回0并不表示该值不是常数，而只是GCC无法证明其为带有-O选项指定值的常数。 通常，在内存是关键资源的嵌入式应用程序中使用此功能。 如果您有一些复杂的计算，则可能需要对它进行折叠（如果它包含常量），但是如果不包含常量，则需要调用该函数。 例如：</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">#define</span> <span class="pre">Scale_Value(X)</span> <span class="pre">\(__builtin_constant_p</span> <span class="pre">(X)</span> <span class="pre">\</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">?</span> <span class="pre">((X)</span> <span class="pre">*</span> <span class="pre">SCALE</span> <span class="pre">+</span> <span class="pre">OFFSET)</span> <span class="pre">:</span> <span class="pre">Scale</span> <span class="pre">(X))</span>
<span class="pre">`</span></code></p>
<p>您可以在宏或内联函数中使用此内置函数。 但是，如果在内联函数中使用它并将该函数的参数作为内置参数传递，则当您使用字符串常量或复合文字调用内联函数时，GCC永远不会返回1（请参见第6.28节“复合文字”）。 ]，第517页），并且当您将常量数值传递给内联函数时，除非您指定“ -O”选项，否则不会返回1。</p>
<p>您还可以在初始化程序中使用__builtin_constant_p来获取静态数据。 例如，你可以写 :</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">static</span> <span class="pre">const</span> <span class="pre">int</span> <span class="pre">table[]</span> <span class="pre">=</span> <span class="pre">{</span>&#160;&#160;&#160;&#160;&#160; <span class="pre">__builtin_constant_p</span> <span class="pre">(EXPRESSION)</span> <span class="pre">?</span> <span class="pre">(EXPRESSION)</span> <span class="pre">:</span> <span class="pre">-1,</span>&#160; <span class="pre">/*</span> <span class="pre">.</span> <span class="pre">.</span> <span class="pre">.</span> <span class="pre">*/};</span>
<span class="pre">`</span></code></p>
<p>即使EXPRESSION不是常数表达式，这也是可接受的初始值设定项，包括__builtin_constant_p返回1的情况，因为EXPRESSION可以折叠为常数，但EXPRESSION包含静态初始值设定项中不允许的操作数（例如0 &amp;&amp; foo（））。 在这种情况下，GCC在评估内置组件时必须更加保守，因为它没有机会执行优化。</p>
</li>
<li><p>bool __builtin_is_constant_evaluated (void) [Built-in Function]: __builtin_is_constant_evaluated函数仅在C ++中可用。 内置供std :: is_constant_evaluated C ++函数的实现使用。 程序应利用后者的功能，而不是直接调用内置函数。</p>
<p>内置的主要用例是确定是否在constexpr上下文中调用constexpr函数。 当且仅当函数调用出现在按照C ++标准定义的表达式或转换的求值中，且该求值明显地是常量求值时，对函数的调用才会求值为值为true的核心常量表达式。 显然，常量评估的上下文包括常量表达式， constexpr if语句，约束表达式和可在常量表达式中使用的变量的初始化程序的条件。 有关更多详细信息，请参考C ++标准的最新版本。</p>
<p>void __builtin_clear_padding ( ptr ) [Built-in Function]:</p>
<p>type __builtin_bit_cast ( type , arg )  [Built-in Function]:</p>
<p>long __builtin_expect (long exp , long c ) [Built-in Function]:</p>
<p>long __builtin_expect_with_probability(long exp, long c, double probability)  [Built-in Function]:</p>
<p>void __builtin_trap (void) [Built-in Function]:</p>
<p>void __builtin_unreachable (void) [Built-in Function]:</p>
<p>void * __builtin_assume_aligned (const void * exp , size t align , …) [Built-in Function]:</p>
<p>int __builtin_LINE ()  [Built-in Function]:</p>
<p>const char * __builtin_FUNCTION ()  [Built-in Function]:</p>
<p>const char * __builtin_FILE ()  [Built-in Function]:</p>
<p>void __builtin___clear_cache (void * begin , void * end ) [Built-in Function]:</p>
<p>void __builtin_prefetch (const void * addr , …) [Built-in Function]:</p>
<p>__builtin_object_size(const void * ptr,int type)  [Built-in Functionsize t]</p>
<p>double __builtin_huge_val (void) [Built-in Function]</p>
<p>float __builtin_huge_valf (void) [Built-in Function]</p>
<p>long double __builtin_huge_vall (void) [Built-in Function]</p>
<p>_Floatn __builtin_huge_valfn (void) [Built-in Function]</p>
<p>_Floatnx __builtin_huge_valfnx (void) [Built-in Function]</p>
<p>int __builtin_fpclassify (int, int, int, int, int, …) [Built-in Function]</p>
<p>double __builtin_inf (void) [Built-in Function]</p>
<p>_Decimal32 __builtin_infd32 (void) [Built-in Function]</p>
<p>_Decimal64 __builtin_infd64 (void) [Built-in Function]</p>
<p>_Decimal128 __builtin_infd128 (void) [Built-in Function]</p>
<p>float __builtin_inff (void) [Built-in Function]</p>
<p>long double __builtin_infl (void) [Built-in Function]</p>
<p>_Floatn __builtin_inffn (void) [Built-in Function]</p>
<p>_Floatn __builtin_inffnx (void) [Built-in Function]</p>
<p>int __builtin_isinf_sign (…) [Built-in Function]</p>
<p>double __builtin_nan (const char <a href="#id358"><span class="problematic" id="id359">*</span></a>str) [Built-in Function]</p>
<p>（没有完成）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>总结：</p>
</div>
<div class="section" id="id360">
<h2>特定于目标机器的内置函数<a class="headerlink" href="#id360" title="Permalink to this headline">¶</a></h2>
<p>在某些目标机器上，GCC支持许多特定于这些机器的内置函数，通常这些函数会生成对特定机器指令的调用，但允许编译器调度这些调用。</p>
<div class="section" id="id361">
<h3>BPF内置功能<a class="headerlink" href="#id361" title="Permalink to this headline">¶</a></h3>
<p>以下内置功能可用于eBPF目标。</p>
<ul class="simple">
<li><p>unsigned long long __builtin bpf_load_byte (unsigned long long offset )  [Built-in Function]</p></li>
<li><p>unsigned long long __builtin bpf_load_half (unsigned long long offset )  [Built-in Function]</p></li>
<li><p>unsigned long long __builtin bpf_load_word(unsigned long long offset )  [Built-in Function]</p></li>
</ul>
<p>总结：</p>
</div>
<div class="section" id="id362">
<h3>x86内置函数<a class="headerlink" href="#id362" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="id363">
<h3>x86事务性内存固有<a class="headerlink" href="#id363" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="id364">
<h3>x86控制流保护本质<a class="headerlink" href="#id364" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="id365">
<h2>特定于特定目标计算机的格式检查<a class="headerlink" href="#id365" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id366">
<h2>接受的用语说明<a class="headerlink" href="#id366" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id367">
<h2>未命名的结构和联合字段<a class="headerlink" href="#id367" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id368">
<h2>线程本地存储<a class="headerlink" href="#id368" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="b">
<h2>使用“ 0b”前缀的二进制常量<a class="headerlink" href="#b" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="c-linux">
<h2>C 扩展部分在linux 内核中的应用<a class="headerlink" href="#c-linux" title="Permalink to this headline">¶</a></h2>
<p>二进制兼容性</p>
<p>gcov</p>
<p>gcov是一个测试覆盖程序。 与GCC配合使用，可以分析您的程序，以帮助创建更高效，更快速的代码，并发现未经测试的程序部分。 您可以将gcov用作性能分析工具，以帮助您发现优化工作将最有效地影响代码的位置。 您还可以将gcov与其他性能分析工具gprof一起使用，以评估代码的哪些部分使用了最多的计算时间。</p>
<p>分析工具可帮助您分析代码的性能。 使用诸如gcov或gprof之类的探查器，您可以找到一些基本的性能统计信息，例如：</p>
<ul class="simple">
<li><p>每行代码执行的频率</p></li>
<li><p>实际执行哪些代码行</p></li>
<li><p>每个代码段使用多少计算时间</p></li>
</ul>
<p>一旦了解了有关代码在编译时如何工作的这些知识，就可以查看每个模块，以了解应优化的模块。 gcov可帮助您确定在哪里进行优化。</p>
<p>软件开发人员还与测试套件一起使用覆盖率测试，以确保软件对于发行版而言确实足够好。 测试人员可以验证程序是否按预期工作； Coverage程序会进行测试，以查看测试对象行使了多少程序。 然后，开发人员可以确定需要将哪些类型的测试用例添加到测试套件中，以创建更好的测试和更好的最终产品。</p>
<p>如果您打算使用gcov，则应在不进行优化的情况下编译代码，因为通过将一些代码行合并到一个函数中，优化可能不会为您提供所需的信息，而这些信息可能需要查找使用代码的“热点”。 大量的计算机时间。 同样，由于gcov会按行（以最低分辨率）累积统计信息，因此它最适合于在每行仅放置一条语句的编程风格。 如果使用扩展到循环或其他控制结构的复杂宏，则统计信息的用处较小-它们仅在出现宏调用的行上报告。 如果复杂宏的行为类似于函数，则可以用内联函数替换它们以解决此问题。</p>
<p>gcov创建一个名为“ sourcefile.gcov”的日志文件，该文件指示源文件“ sourcefile.c”的每一行执行了多少次。 您可以将这些日志文件与gprof一起使用，以帮助微调程序的性能。 gprof提供了您可以使用的计时信息以及从gcov获得的信息。</p>
<p>gcov仅适用于使用GCC编译的代码。 它与任何其他配置文件或测试覆盖率机制不兼容。</p>
<div class="section" id="gcov">
<h3>10.2调用gcov<a class="headerlink" href="#gcov" title="Permalink to this headline">¶</a></h3>
<p>gcov [options] files</p>
<p>gcov 接受以下选项：</p>
<p>-a
–all-blocks</p>
<blockquote>
<div><p>为每个基本块写入单独的执行次数。通常gcov只输出一行中主要块的执行次数。有了这个选项,你可以确定一行中的块是否没有被执行。</p>
</div></blockquote>
<p>-b
–branch-probabilities</p>
<blockquote>
<div><p>将分支频率写入输出文件,并将分支摘要信息写入标准输出。这个选项可以让你看到程序中每个分支的频率。无条件的分支将不会被显示,除非是在-u给出了选项。</p>
</div></blockquote>
<p>-c
–branch-counts</p>
<blockquote>
<div><p>将分支频率写成所取的分支数,而不是所取分支的百分比。</p>
</div></blockquote>
<p>-d
–display-progress</p>
<blockquote>
<div><p>在标准输出上显示进度。</p>
</div></blockquote>
<p>-f
–function-summaries</p>
<blockquote>
<div><p>除了文件级摘要外,还输出每个函数的摘要。</p>
</div></blockquote>
<p>-h
–help</p>
<blockquote>
<div><p>显示有关使用 gcov 的帮助（在标准输出上），然后退出而不进行任何进一步处理。</p>
</div></blockquote>
<p>-j
–json-format</p>
<blockquote>
<div><p>以易于解析的JSON中间格式输出gcov文件,生成时不需要源代码。JSON文件是用gzip压缩算法压缩的,文件的内容有.gcov.json.gzextension.</p>
<p>JSON的结构如下。</p>
<dl class="simple">
<dt>{</dt><dd><p>“current_working_directory”: current_working_directory,
“data_file”: data_file,
“format_version”: format_version,
“gcc_version”: gcc_version
“files”: [file]</p>
</dd>
</dl>
<p>}</p>
<p>根元素的字段具有以下语义。</p>
<blockquote>
<div><p>current_working_directory ：编译编译单元的工作目录
data_file ：数据文件的名称（GCDA）
format_version ：格式的语义版本
gcc_version ：GCC编译器的版本</p>
</div></blockquote>
<p>每个 file 具有以下形式：</p>
<dl class="simple">
<dt>{</dt><dd><p>“file”: file_name,
“functions”: [function],
“lines”: [line]</p>
</dd>
</dl>
<p>}</p>
<p>file 元素的字段具有以下语义：</p>
<blockquote>
<div><p>file_name ：源文件的名称</p>
</div></blockquote>
<p>每个 function 具有以下形式：</p>
<dl class="simple">
<dt>{</dt><dd><p>“blocks”: blocks,
“blocks_executed”: blocks_executed,
“demangled_name”: “demangled_name,
“end_column”: end_column,
“end_line”: end_line,
“execution_count”: execution_count,
“name”: name,
“start_column”: start_column
“start_line”: start_line</p>
</dd>
</dl>
<p>}</p>
<p>function 元素的字段具有以下语义：</p>
<blockquote>
<div><p>blocks ：函数中的块数
blocks_executed ：函数已执行的块数
demangled_name ：函数的已取消名称
end_column ：函数结束的源文件中的列
end_line ：源文件中函数结束的行
execution_count ：函数的执行次数
name ：函数名称
start_column ：函数开始的源文件中的列
start_line ：函数开始的源文件中的行</p>
</div></blockquote>
<p>请注意，行号和列号从1开始编号。在当前实现中， start_line 和 start_column 不包括任何模板参数和前导返回类型，但是将来可能会修复。</p>
<p>每 line 具有以下形式：</p>
<dl class="simple">
<dt>{</dt><dd><p>“branches”: [branch],
“count”: count,
“line_number”: line_number,
“unexecuted_block”: unexecuted_block
“function_name”: function_name,</p>
</dd>
</dl>
<p>}</p>
<p>仅在使用 -b 选项时才存在分支。 line 元素的字段具有以下语义：</p>
<blockquote>
<div><p>count ：该行的执行次数
line_number ：行号
unexecuted_block ：标记该行是否包含未执行的块（不是该行上的所有语句都已执行）
function_name ：此 line 所属的函数的名称（因为不能设置带有内联语句的行）</p>
</div></blockquote>
<p>每个 branch 具有以下形式：</p>
<dl class="simple">
<dt>{</dt><dd><p>“count”: count,
“fallthrough”: fallthrough,
“throw”: throw</p>
</dd>
</dl>
<p>}</p>
<p>branch 元素的字段具有以下语义：</p>
<blockquote>
<div><p>count ：分支的执行次数
fallthrough ：当分支是直通分支时为true
throw ：当分支是特殊分支时为true</p>
</div></blockquote>
</div></blockquote>
<p>-H
–human-readable</p>
<blockquote>
<div><p>以人类可读的格式(如24.6k)写入计数。</p>
</div></blockquote>
<p>-k
–use-colors</p>
<blockquote>
<div><p>使用颜色表示覆盖率为零的代码行。我们对非特殊的行使用红色,对特殊的行使用青色。同样的颜色用于基本块与-aoption.</p>
</div></blockquote>
<p>-l
–long-file-names</p>
<blockquote>
<div><p>为包含的源文件创建长文件名。例如,如果头文件是x.h包含代码,并被包含在文件a.c，然后在文件上运行 gcova.c将产生一个名为a.c##x.h.gcov而不是x.h.gcov。如果这可以是有用的x.h包含在多个源文件中，您想查看各个贡献。如果您使用“-p’选项，包含文件名和包含文件名都将是完整的路径名。</p>
</div></blockquote>
<p>-m
–demangled-names</p>
<blockquote>
<div><p>在输出中显示已解密的函数名。默认情况下是显示杂乱的函数名。</p>
</div></blockquote>
<p>-n
–no-output</p>
<blockquote>
<div><p>不要创建 gcov 输出文件。</p>
</div></blockquote>
<p>-o directory|file
–object-directory directory
–object-file file</p>
<blockquote>
<div><p>指定包含gcov数据文件的目录或对象路径名。对象路径名。.gcno， 和.gcda的数据文件,如果指定了一个目录,则数据文件在该目录中,并以输入文件名命名,不含扩展名。如果指定了一个目录,数据文件就在该目录中,并以输入的文件名命名,不加扩展名。如果在此指定了一个文件,则数据文件以该文件的名字命名,不含扩展名。</p>
</div></blockquote>
<p>-p
–preserve-paths</p>
<blockquote>
<div><p>保留完整的路径信息在生成的.gcov文件。如果没有此选项，则仅使用文件名组件。使用此选项时，将使用所有目录，并带有“/将字符翻译为#’个字符，.目录中的组件被删除和不可删除..组件重命名为“^’。如果源文件位于几个不同的目录中，这将很有用。</p>
</div></blockquote>
<p>-q
–use-hotness-colors</p>
<blockquote>
<div><p>发出类似敷衍的彩色输出,用于热线。在输出文件的开头打印色标的图例。</p>
</div></blockquote>
<p>-r
–relative-only</p>
<blockquote>
<div><p>只输出带有相对路径名的源文件信息(在源文件前缀删除后)。绝对路径通常是系统头文件,对其中的任何内联函数的覆盖通常是不感兴趣的。</p>
</div></blockquote>
<p>-s directory
–source-prefix directory</p>
<blockquote>
<div><p>生成输出覆盖文件时要删除的源文件名的前缀。当在单独的目录中构建,并且在确定输出文件名时不需要源目录的路径名时,该选项非常有用。需要注意的是,这个前缀检测是在确定源文件是否为绝对文件之前应用的。</p>
</div></blockquote>
<p>-t
–stdout</p>
<blockquote>
<div><p>输出到标准输出而不是输出文件。</p>
</div></blockquote>
<p>-u
–unconditional-branches</p>
<blockquote>
<div><p>当给出分支概率时,包括无条件分支的概率。无条件分支通常不感兴趣。</p>
</div></blockquote>
<p>-v
–version</p>
<blockquote>
<div><p>显示 gcov 版本号（在标准输出上），然后不做任何进一步处理就退出。</p>
</div></blockquote>
<p>-w
–verbose</p>
<blockquote>
<div><p>打印与基本块和弧相关的详细信息。</p>
</div></blockquote>
<p>-x
–hash-filenames</p>
<blockquote>
<div><p>使用 –preserve-paths 时，gcov使用源文件的完整路径名来创建输出文件名。这会导致文件名过长，从而导致文件系统限制溢出。此选项创建表单的名称source-file##md5.gcov，其中 source-file 组件是文件名的最后一部分，而 md5 组件是根据完整改写的名称计算出来的，否则该名称会被使用。在具有文件系统限制的系统上，该选项是 –preserve-paths 的替代。</p>
</div></blockquote>
<p>gcov 应该在当前目录下运行，与调用编译器时的目录相同。否则它将无法找到源文件。 gcov 产生名为mangledname.gcov在当前目录下。这些内容包含了它们所对应的源文件的覆盖信息。一个.gcov将为每个包含代码的源（或头）文件生成文件，将其编译以生成数据文件。输出文件名的 mangledname 部分通常只是源文件名，但如果使用’-l’ 要么 ‘-p’选项。有关详细信息，请参阅这些选项。</p>
<p>如果您使用多个输入文件调用 gcov ，则将每个输入文件的贡献求和。通常，您将使用与可执行文件的最终链接相同的文件列表来调用它。</p>
<p>The.gcov文件包含“:分隔字段以及程序源代码。格式是</p>
<p>execution_count:line_number:source line text</p>
<p>当命令行选项请求时，其他的块信息可能会在每行之后。该 execution_count 是’-‘用于不包含代码的行。未执行的行标记为“#####’ 要么 ‘=====’，取决于它们分别是非异常路径还是仅异常路径（例如C ++异常处理程序）可访问的。鉴于 ‘-a’选项，未执行的块被标记为’$$$$$’ 要么 ‘%%%%%’，取决于基本块是否可以通过非异常或异常路径到达。语句为0的已执行基本块以’ execution_count 结尾*字符，并用洋红色和-k选项。Ada不支持此功能。</p>
<p>请注意，GCC可以完全删除不需要的功能主体-例如，如果它们在任何地方都内联。此类功能标有“-”，这可能会造成混淆。使用-fkeep-inline-functionsand-fkeep-static-functions保留这些功能并允许gcov正确显示其 execution_count 的选项。</p>
<p>开头的某些信息行的 line_number 为零。这些前导行的形式为</p>
<p>-:0:<a class="reference external" href="tag:value">tag:value</a></p>
<p>随着 gcov 开发的进展，这些序言行的顺序和数量将会增加-不要依赖于它们保持不变。使用 tag 找到特定的前导行。</p>
<p>附加块信息的形式是</p>
<p>tag information</p>
<p>该 information 是人类可读的，但也设计得足够简单以用于机器解析。</p>
<p>当打印百分比时，仅当值分别恰好为 0％和100％时才打印0％和100％。取而代之的是将通常四舍五入为0％或100％的其他值打印为最接近的非边界值。</p>
<p>使用 gcov 时，必须首先使用特殊的GCC选项“–coverage’。这告诉编译器生成gcov所需的其他信息（基本上是程序的流程图），并且在目标文件中还包含其他代码，用于生成gcov所需的其他概要信息。这些其他文件放置在目标文件所在的目录中。</p>
<p>运行该程序将导致生成配置文件输出。对于每个用-fprofile-arcs，伴随.gcda文件将被放置在对象文件目录中。</p>
<p>现在，使用程序的源文件名作为参数运行 gcov ，将产生代码清单以及每行的执行频率。例如，如果您的程序被调用tmp.cpp，这是使用基本 gcov 工具时看到的内容：</p>
<p>$ g++ –coverage tmp.cpp -c
$ g++ –coverage tmp.o
$ a.out
$ gcov tmp.cpp -m
File ‘tmp.cpp’
Lines executed:92.86% of 14
Creating ‘tmp.cpp.gcov’</p>
<p>该文件tmp.cpp.gcov包含 gcov 的输出。这是一个示例：</p>
<dl>
<dt>-:    0:Source:tmp.cpp</dt><dd><blockquote>
<div><p>-:    0:Working directory:/home/gcc/testcase
-:    0:Graph:tmp.gcno
-:    0:Data:tmp.gcda
-:    0:Runs:1
-:    0:Programs:1
-:    1:#include &lt;stdio.h&gt;
-:    2:
-:    3:template&lt;class T&gt;
-:    4:class Foo
-:    5:{
-:    6:  public:</p>
</div></blockquote>
<p>1*:    7:  Foo(): b (1000) {}</p>
</dd>
</dl>
<div class="section" id="void-inc-b">
<h4>2*:    8:  void inc () { b++; }<a class="headerlink" href="#void-inc-b" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt>Foo&lt;char&gt;::inc():</dt><dd><p>#####:    8:  void inc () { b++; }</p>
</dd>
</dl>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>-:   11:  int b;
-:   12:};
-:   13:
-:   14:template class Foo&lt;int&gt;;
-:   15:template class Foo&lt;char&gt;;
-:   16:
-:   17:int
1:   18:main (void)
-:   19:{
-:   20:  int i, total;
1:   21:  Foo&lt;int&gt; counter;
-:   22:
1:   23:  counter.inc();
1:   24:  counter.inc();
1:   25:  total = 0;
-:   26:</p>
</div></blockquote>
<p>11:   27:  for (i = 0; i &lt; 10; i++)
10:   28:    total += i;</p>
<blockquote>
<div><p>-:   29:</p>
</div></blockquote>
<dl class="simple">
<dt>1*:   30:  int v = total &gt; 100 ? 1<span class="classifier">2;</span></dt><dd><p>-:   31:
1:   32:  if (total != 45)</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>#####:   33:    printf (“Failuren”);</dt><dd><p>-:   34:  else
1:   35:    printf (“Successn”);
1:   36:  return 0;
-:   37:}</p>
</dd>
</dl>
</div></blockquote>
<p>请注意,第7行在报告中多次出现。第一次出现显示了该行的总执行次数,接下来的两次属于类Foo构造函数的实例。你也可以看到,第30行包含了一些未执行的基本块,因此执行次数有星号符号。</p>
<p>当您使用-a选项,你将得到单个块的数量,输出结果是这样的。</p>
<dl>
<dt>-:    0:Source:tmp.cpp</dt><dd><blockquote>
<div><p>-:    0:Working directory:/home/gcc/testcase
-:    0:Graph:tmp.gcno
-:    0:Data:tmp.gcda
-:    0:Runs:1
-:    0:Programs:1
-:    1:#include &lt;stdio.h&gt;
-:    2:
-:    3:template&lt;class T&gt;
-:    4:class Foo
-:    5:{
-:    6:  public:</p>
</div></blockquote>
<p>1*:    7:  Foo(): b (1000) {}</p>
</dd>
</dl>
</div>
<div class="section" id="id369">
<h4>2*:    8:  void inc () { b++; }<a class="headerlink" href="#id369" title="Permalink to this headline">¶</a></h4>
<dl class="simple">
<dt>Foo&lt;char&gt;::inc():</dt><dd><p>#####:    8:  void inc () { b++; }</p>
</dd>
</dl>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>-:   11:  int b;
-:   12:};
-:   13:
-:   14:template class Foo&lt;int&gt;;
-:   15:template class Foo&lt;char&gt;;
-:   16:
-:   17:int
1:   18:main (void)
-:   19:{
-:   20:  int i, total;
1:   21:  Foo&lt;int&gt; counter;
1:   21-block  0
-:   22:
1:   23:  counter.inc();
1:   23-block  0
1:   24:  counter.inc();
1:   24-block  0
1:   25:  total = 0;
-:   26:</p>
</div></blockquote>
<dl class="simple">
<dt>11:   27:  for (i = 0; i &lt; 10; i++)</dt><dd><p>1:   27-block  0</p>
</dd>
</dl>
<p>11:   27-block  1
10:   28:    total += i;
10:   28-block  0</p>
<blockquote>
<div><p>-:   29:</p>
</div></blockquote>
<dl class="simple">
<dt>1*:   30:  int v = total &gt; 100 ? 1<span class="classifier">2;</span></dt><dd><p>1:   30-block  0</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>%%%%%:   30-block  1</dt><dd><p>1:   30-block  2
-:   31:
1:   32:  if (total != 45)
1:   32-block  0</p>
</dd>
</dl>
<p>#####: 33: printf (“失败n”);
%%%%%:   33-block  0</p>
<blockquote>
<div><p>-:   34:  else
1:   35:    printf (“Successn”);
1:   35-block  0
1:   36:  return 0;
1:   36-block  0
-:   37:}</p>
</div></blockquote>
</div></blockquote>
<p>在此模式下，每个基本块仅显示在一行（块的最后一行）上。多行块只会增加最后一行的执行计数，其他行不会显示为包含代码，除非先前的块在这些行上结束。显示了一行的总执行计数，随后的行显示了在该行结束的各个块的执行计数。在每个块之后，将显示该块的分支和调用计数，如果-b给出了选项。</p>
<p>由于GCC工具调用的方式,可以在没有单独块的行后显示调用计数。如你所见,第33行包含了一个没有被执行的基本块。</p>
<p>当您使用-b选项,你的输出是这样的。</p>
<dl>
<dt>-:    0:Source:tmp.cpp</dt><dd><blockquote>
<div><p>-:    0:Working directory:/home/gcc/testcase
-:    0:Graph:tmp.gcno
-:    0:Data:tmp.gcda
-:    0:Runs:1
-:    0:Programs:1
-:    1:#include &lt;stdio.h&gt;
-:    2:
-:    3:template&lt;class T&gt;
-:    4:class Foo
-:    5:{
-:    6:  public:</p>
</div></blockquote>
<p>1*:    7:  Foo(): b (1000) {}</p>
</dd>
</dl>
<blockquote>
<div><p>#####:    7:  Foo(): b (1000) {}</p>
</div></blockquote>
<blockquote>
<div><p>1:    7:  Foo(): b (1000) {}</p>
</div></blockquote>
</div>
<div class="section" id="id370">
<h4>2*:    8:  void inc () { b++; }<a class="headerlink" href="#id370" title="Permalink to this headline">¶</a></h4>
<p>Foo&lt;char&gt;::inc():
function Foo&lt;char&gt;::inc() called 0 returned 0% blocks executed 0%</p>
<blockquote>
<div><p>#####:    8:  void inc () { b++; }</p>
</div></blockquote>
<blockquote>
<div><p>2:    8:  void inc () { b++; }</p>
</div></blockquote>
<blockquote>
<div><p>-:   11:  int b;
-:   12:};
-:   13:
-:   14:template class Foo&lt;int&gt;;
-:   15:template class Foo&lt;char&gt;;
-:   16:
-:   17:int</p>
</div></blockquote>
<dl class="simple">
<dt>function main called 1 returned 100% blocks executed 81%</dt><dd><p>1:   18:main (void)
-:   19:{
-:   20:  int i, total;
1:   21:  Foo&lt;int&gt; counter;</p>
</dd>
</dl>
<p>call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)</p>
<blockquote>
<div><p>-:   22:
1:   23:  counter.inc();</p>
</div></blockquote>
<p>call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)</p>
<blockquote>
<div><p>1:   24:  counter.inc();</p>
</div></blockquote>
<p>call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)</p>
<blockquote>
<div><blockquote>
<div><p>1:   25:  total = 0;
-:   26:</p>
</div></blockquote>
<p>11:   27:  for (i = 0; i &lt; 10; i++)</p>
</div></blockquote>
<p>branch  0 taken 91% (fallthrough)
branch  1 taken 9%</p>
<blockquote>
<div><dl class="simple">
<dt>10:   28:    total += i;</dt><dd><p>-:   29:</p>
</dd>
</dl>
<p>1*:   30:  int v = total &gt; 100 ? 1 : 2;</p>
</div></blockquote>
<p>branch  0 taken 0% (fallthrough)
branch  1 taken 100%</p>
<blockquote>
<div><p>-:   31:
1:   32:  if (total != 45)</p>
</div></blockquote>
<p>branch  0 taken 0% (fallthrough)
branch  1 taken 100%</p>
<blockquote>
<div><p>#####:   33:    printf (“Failuren”);</p>
</div></blockquote>
<p>call    0 never executed
branch  1 never executed
branch  2 never executed</p>
<blockquote>
<div><p>-:   34:  else
1:   35:    printf (“Successn”);</p>
</div></blockquote>
<p>call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)</p>
<blockquote>
<div><p>1:   36:  return 0;
-:   37:}</p>
</div></blockquote>
<p>对于每个函数，将打印一行以显示该函数被调用了多少次，返回了多少次以及执行了多少百分比的功能块。</p>
<p>对于每个基本块,在基本块的最后一行之后打印一行,描述结束基本块的分支或调用。如果有多个基本块在一条源线上结束,那么可以为该线列出多个分支和调用。在这种情况下,分支和调用都被赋予一个编号。没有简单的方法可以将这些分支和调用映射回源构造。但一般来说,编号最低的分支或调用将对应于源行上最左边的构造。</p>
<p>对于分支，如果执行了至少一次，则将打印一个百分比，该百分比指示分支被执行的次数除以分支被执行的次数。否则，将显示消息“从不执行”。</p>
<p>对于一个呼叫，如果它至少执行了一次，则将打印一个百分比，该百分比表示该呼叫返回的次数除以该呼叫执行的次数。通常为100％，但对于调用 exit 或 longjmp 的函数而言可能会更少，因此可能不会在每次调用它们时都返回。</p>
<p>执行次数是累计的。如果示例程序再次执行时没有删除.gcda文件,源文件中每行的执行次数将被添加到之前的运行结果中。这在几个方面都有潜在的用处。例如,它可以用来积累一些程序运行的数据,作为测试验证套件的一部分,或者提供大量程序运行的更精确的长期信息。</p>
<p>的数据。.gcda文件会在程序退出前立即保存。对于每个用-fprofile-arcs，分析代码首先尝试读取现有的.gcda文件; 如果文件与可执行文件不匹配（基本块计数不同），它将忽略文件的内容。然后，它添加新的执行计数，最后将数据写入文件。</p>
</div>
</div>
<div class="section" id="gcovgcc">
<h3>将gcov与GCC优化配合使用<a class="headerlink" href="#gcovgcc" title="Permalink to this headline">¶</a></h3>
<p>如果您打算使用 gcov 来帮助优化代码，则必须首先使用特殊的GCC选项“–coverage’。除此之外，您还可以使用其他任何GCC选项；但是，如果您想证明程序中的每一行都已执行，则不应同时进行优化编译。在某些机器上，优化器可以通过将一些简单的代码行与其他代码行结合来消除它们。例如，如下代码：</p>
<dl class="simple">
<dt>if (a != b)</dt><dd><p>c = 1;</p>
</dd>
<dt>else</dt><dd><p>c = 0;</p>
</dd>
</dl>
<p>在某些机器上可以被编译成一条指令。在这种情况下， gcov 无法为每行计算单独的执行计数，因为每行没有单独的代码。因此，如果您使用优化编译程序，则 gcov 输出如下所示：</p>
<p>100:   12:if (a != b)
100:   13:  c = 1;
100:   14:else
100:   15:  c = 0;</p>
<p>输出显示,这段代码通过优化组合,执行了100次。从某种意义上说,这个结果是正确的,因为只有一条指令代表这四行代码。但是,输出并没有说明结果是0的次数和结果是1的次数。</p>
<p>可内联函数会产生意想不到的行数。可内联函数的源代码会显示行数,但显示的行数取决于函数内联的位置,或者根本没有内联。</p>
<p>如果函数没有内联,编译器必须在任何需要它的对象文件中,发出一个函数的外行副本。如果fileA.oandfileB.o都包含一个特定的可内联函数的行外体,它们也都包含该函数的覆盖率计数。当fileA.oandfileB.o连接在一起,在许多系统中,链接器会在所有对该函数的调用中选择其中一个出线体,并删除或忽略另一个。不幸的是,它不会删除未使用的函数体的覆盖计数器。因此,当检测到该函数时,除了一次使用外,所有的函数都会显示零计数。</p>
<p>如果函数在多个地方内联,每个地方的块结构可能不一样。例如,在某些情况下,一个条件现在可能在编译时可以计算。因为内联函数的所有使用的覆盖范围将显示为相同的源行,所以行数本身可能看起来不一致。</p>
<p>长时间运行的应用程序可以使用 __gcov_reset 和 __gcov_dump 工具将概要文件收集限制为感兴趣的程序区域。调用 __gcov_reset(void) 将清除所有配置文件计数器为零，而调用 __gcov_dump(void) 将导致在该点收集的配置文件信息被转储到.gcda输出文件。检测的应用程序使用优先级为99的静态析构函数来调用 __gcov_dump 函数。因此，在所有用户定义的静态析构函数以及向 atexit 注册的处理程序之后，将执行 __gcov_dump 。如果可执行文件通过dlopen功能加载动态共享对象，-Wl,–dynamic-list-data需要转储所有配置文件数据。</p>
<p>概要分析运行时库报告与概要文件处理和概要文件保存相关的各种错误。错误会打印到标准错误输出或’GCOV_ERROR_FILE’文件（如果使用环境变量）。为了在发生错误后立即终止，请设置’GCOV_EXIT_AT_ERROR’环境变量。这可以帮助用户查找配置文件冲突，从而导致配置文件产生误导。</p>
</div>
<div class="section" id="id371">
<h3>10.4 gcov数据文件的简要说明<a class="headerlink" href="#id371" title="Permalink to this headline">¶</a></h3>
<p>gcov 使用两个文件进行概要分析。这些文件的名称从原始目标文件派生而来，方法是将文件后缀替换为.gcno， 或者.gcda。这些文件包含以独立于平台的格式存储的coverage和配置文件数据。的.gcno文件被放置在与对象文件相同的目录中。默认情况下,.gcda文件也存储在与对象文件相同的目录中,但GCC的-fprofile-dir选项可以用来存储.gcda文件在一个单独的目录中。</p>
<p>The.gcno当用GCC编译源文件时,会产生注释文件。-ftest-coverage选项,它包含了重建基本块图和为块分配源线号的信息。它包含了重建基本块图和为块分配源线号的信息。</p>
<p>The.gcda当一个程序包含用GCC构建的对象文件时,就会生成count数据文件。-fprofile-arcs选项被执行。一个单独的.gcda文件是为每个用这个选项编译的对象文件创建的。它包含了圆弧转换计数、数值轮廓计数和一些摘要信息。</p>
<p>不建议直接访问coverage文件。消费者应使用 gcov 工具通过以下方式提供的中间格式–json-formatoption.</p>
</div>
<div class="section" id="id372">
<h3>10.5数据文件重定位以支持交叉分析<a class="headerlink" href="#id372" title="Permalink to this headline">¶</a></h3>
<p>运行该程序将导致生成配置文件输出。对于每个用-fprofile-arcs，伴随.gcda文件将被放置在对象文件目录中。这就隐含着要求在与程序建立时相同的系统上运行程序,或者在目标系统上拥有相同的绝对目录结构。程序将尝试创建所需的目录结构,如果它还不存在的话。</p>
<p>为了支持交叉剖析,编制了一个程序,其中包括-fprofile-arcs可以根据两个环境变量来重新定位数据文件。</p>
<blockquote>
<div><p>GCOV_PREFIX包含了要添加到对象文件中绝对路径的前缀。前缀可以是绝对的,也可以是相对的。默认情况下是没有前缀。
GCOV_PREFIX_STRIP 表示要从硬线绝对路径上剥离多少个初始目录名。默认值为0。</p>
<p>注意：如果在未定义GCOV_PREFIX的情况下设置了GCOV_PREFIX_STRIP，则将从硬连线的绝对路径中创建相对路径。</p>
</div></blockquote>
<p>例如,如果对象文件/user/build/foo.o建有-fprofile-arcs，最终的可执行文件将尝试创建数据文件/user/build/foo.gcda在目标系统上运行时。如果相应的目录不存在并且无法创建它，它将失败。例如，可以通过将环境设置为“GCOV_PREFIX=/target/run’和’GCOV_PREFIX_STRIP=1’。这样的设置将命名数据文件/target/run/build/foo.gcda.</p>
<p>您必须将数据文件移动到预期的目录树中,以便将它们用于配置文件定向优化(-fprofile-use），或使用 gcov 工具。</p>
</div>
</div>
<div class="section" id="gcov-tool">
<h2>gcov-tool<a class="headerlink" href="#gcov-tool" title="Permalink to this headline">¶</a></h2>
<p>gcov-tool 是可以与GCC结合使用的工具，可以离线操作或处理gcda配置文件。</p>
<div class="section" id="id373">
<h3>gcov-tool简介<a class="headerlink" href="#id373" title="Permalink to this headline">¶</a></h3>
<p>gcov-tool 是一个离线工具，用于处理gcc的gcda配置文件。</p>
<p>当前的gcov-tool支持以下功能。</p>
<blockquote>
<div><p>合并两组带权重的型材。
读取一组配置文件并重写配置文件内容。可以对计数值进行缩放或标准化。</p>
</div></blockquote>
<p>该工具的使用案例有:</p>
<blockquote>
<div><p>收集不同输入集的剖面图,并使用此工具将其合并。可以指定权重,以考虑每个输入的相对重要性。
删除gcda文件的子集后重写配置文件,同时保持摘要和直方图的一致性。
它也可以用来调试或libgcov代码,因为该工具共享大部分代码作为运行时库。</p>
</div></blockquote>
<p>请注意,对于合并操作,离线生成的配置文件可能包含与在线合并配置文件略有不同的值。以下是典型的差异列表。</p>
<blockquote>
<div><p>直方图差异：合并计数器后，此离线工具重新计算直方图。因此，所得的直方图是精确的。在线合并不具备此功能-直方图是从两个直方图合并而成的，其结果是一个近似值。
摘要校验和的区别：摘要校验和使用CRC32操作。该值取决于gcov-info对象的链接列表顺序。gcov-tool中的此顺序与在线合并中的顺序不同。预期会有不同的摘要校验和。这并不重要，因为编译器不会在任何地方使用此校验和。
值配置文件计数器值的差异：值配置文件的某些计数器值与运行时有关，例如堆地址。看到这些计数器有些不同是正常的。</p>
</div></blockquote>
</div>
<div class="section" id="id374">
<h3>调用 gcov-tool<a class="headerlink" href="#id374" title="Permalink to this headline">¶</a></h3>
<p>gcov-tool [global-options] SUB_COMMAND [sub_command-options] profile_dir</p>
<p>gcov-tool 接受以下选项：</p>
<p>-h
–help</p>
<blockquote>
<div><p>显示有关使用 gcov-tool 的帮助（在标准输出上），然后不做任何进一步处理就退出。</p>
</div></blockquote>
<p>-v
–version</p>
<blockquote>
<div><p>显示 gcov-tool 版本号（在标准输出上），然后不做任何进一步处理就退出。</p>
</div></blockquote>
<p>merge</p>
<blockquote>
<div><p>合并两个配置文件目录。</p>
<p>-o directory
–output directory</p>
<blockquote>
<div><p>设置输出配置文件目录。默认输出目录名称为 merged_profile 。</p>
</div></blockquote>
<p>-v
–verbose</p>
<blockquote>
<div><p>设置啰嗦模式。</p>
</div></blockquote>
<p>-w w1,w2
–weight w1,w2</p>
<blockquote>
<div><p>分别设置 directory1 和 directory2 的合并权重。两者的默认权重均为1。</p>
</div></blockquote>
</div></blockquote>
<p>rewrite</p>
<blockquote>
<div><p>读取指定的配置文件目录并重写到新的目录。</p>
<p>-n long_long_value
–normalize &lt;long_long_value&gt;</p>
<blockquote>
<div><p>规范化配置文件。指定的值是新配置文件中的最大计数器值。</p>
</div></blockquote>
<p>-o directory
–output directory</p>
<blockquote>
<div><p>设置输出配置文件目录。默认输出名称为 rewrite_profile 。</p>
</div></blockquote>
<p>-s float_or_simple-frac_value
–scale float_or_simple-frac_value</p>
<blockquote>
<div><p>缩放轮廓计数器。指定的值可以是浮点值,或简单的分数值形式,如1、2、2/3和5/3。</p>
</div></blockquote>
<p>-v
–verbose</p>
<blockquote>
<div><p>设置啰嗦模式。</p>
</div></blockquote>
</div></blockquote>
<p>overlap</p>
<blockquote>
<div><p>计算两个指定剖面目录之间的重叠得分。重叠得分是根据弧形轮廓计算的。它被定义为所有弧形计数器i的最小值(p1_counter[i]/p1_sum_all,p2_counter[i]/p2_sum_all)之和,其中p1_counter[i]和p2_counter[i]是两个匹配的计数器,p1_sum_all和p2_sum_all分别是剖面1和剖面2的计数器值之和。</p>
<p>-f
–function</p>
<blockquote>
<div><p>打印功能级别重叠得分。</p>
</div></blockquote>
<p>-F
–fullname</p>
<blockquote>
<div><p>打印完整的gcda文件名。</p>
</div></blockquote>
<p>-h
–hotonly</p>
<blockquote>
<div><p>只打印热对象/功能的信息。</p>
</div></blockquote>
<p>-o
–object</p>
<blockquote>
<div><p>打印对象级重叠得分。</p>
</div></blockquote>
<p>-t float
–hot_threshold &lt;float&gt;</p>
<blockquote>
<div><p>设置热计数器值的阈值。</p>
</div></blockquote>
<p>-v
–verbose</p>
<blockquote>
<div><p>设置啰嗦模式。</p>
</div></blockquote>
</div></blockquote>
</div>
</div>
<div class="section" id="gcov-dump">
<h2>gcov-dump<a class="headerlink" href="#gcov-dump" title="Permalink to this headline">¶</a></h2>
<p>gcov-dump 是可以与GCC结合使用的工具，可以离线转储gcda和gcno配置文件的内容。</p>
<div class="section" id="id375">
<h3>调用<a class="headerlink" href="#id375" title="Permalink to this headline">¶</a></h3>
<p>Usage: gcov-dump [OPTION] … gcovfiles</p>
<p>gcov-dump 接受以下选项：</p>
<p>-h
–help</p>
<blockquote>
<div><p>显示有关使用 gcov-dump 的帮助（在标准输出上），然后不做任何进一步处理就退出。</p>
</div></blockquote>
<p>-l
–long</p>
<blockquote>
<div><p>转储记录的内容。</p>
</div></blockquote>
<p>-p
–positions</p>
<blockquote>
<div><p>倾倒记录的位置。</p>
</div></blockquote>
<p>-r
–raw</p>
<blockquote>
<div><p>打印原始格式的内容记录。</p>
</div></blockquote>
<p>-v
–version</p>
<blockquote>
<div><p>显示 gcov-dump 版本号（在标准输出上），然后不做任何进一步处理就退出。</p>
</div></blockquote>
</div>
</div>
<div class="section" id="lto-dump">
<h2>lto-dump<a class="headerlink" href="#lto-dump" title="Permalink to this headline">¶</a></h2>
<p>lto-dump 是可以与GCC结合使用以转储链接时间优化目标文件的工具。</p>
<div class="section" id="id376">
<h3>调用方法<a class="headerlink" href="#id376" title="Permalink to this headline">¶</a></h3>
<p>Usage: lto-dump [OPTION] … objfiles</p>
<p>lto-dump 接受以下选项：</p>
<dl class="option-list">
<dt><kbd><span class="option">-l<var>ist</var></span></kbd></dt>
<dd><p>转储函数和变量的细节列表。</p>
</dd>
<dt><kbd><span class="option">-d<var>emangle</var></span></kbd></dt>
<dd><p>甩掉脱芒的输出。</p>
</dd>
<dt><kbd><span class="option">-d<var>efined-only</var></span></kbd></dt>
<dd><p>只转储定义的符号。</p>
</dd>
<dt><kbd><span class="option">-p<var>rint-value</var></span></kbd></dt>
<dd><p>转储变量的初始值。</p>
</dd>
<dt><kbd><span class="option">-n<var>ame-sort</var></span></kbd></dt>
<dd><p>按字母顺序对符号进行排序。</p>
</dd>
<dt><kbd><span class="option">-s<var>ize-sort</var></span></kbd></dt>
<dd><p>根据大小对符号进行排序。</p>
</dd>
<dt><kbd><span class="option">-r<var>everse-sort</var></span></kbd></dt>
<dd><p>按相反的顺序倾倒符号。</p>
</dd>
<dt><kbd><span class="option">-n<var>o-sort</var></span></kbd></dt>
<dd><p>按出现的顺序倾倒符号。</p>
</dd>
</dl>
<p>-symbol=</p>
<blockquote>
<div><p>甩出特定符号的细节。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-o<var>bjects</var></span></kbd></dt>
<dd><p>转储LTO对象的详细信息。</p>
</dd>
<dt><kbd><span class="option">-t<var>ype-stats</var></span></kbd></dt>
<dd><p>对树型进行统计。</p>
</dd>
<dt><kbd><span class="option">-t<var>ree-stats</var></span></kbd></dt>
<dd><p>倾力统计的树木。</p>
</dd>
<dt><kbd><span class="option">-g<var>imple-stats</var></span></kbd></dt>
<dd><p>倾力统计gimple语句。</p>
</dd>
</dl>
<p>-dump-level=</p>
<blockquote>
<div><p>用于决定身体的优化程度。</p>
</div></blockquote>
<p>-dump-body=</p>
<blockquote>
<div><p>甩开具体的篾片体。</p>
</div></blockquote>
<dl class="option-list">
<dt><kbd><span class="option">-h<var>elp</var></span></kbd></dt>
<dd><p>显示转储工具帮助。</p>
</dd>
</dl>
<p>linux 内核编程中GCC的高级应用</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="comp_ld.html" class="btn btn-neutral float-left" title="ld 在linux中的应用" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="comp_elf.html" class="btn btn-neutral float-right" title="ELF基础" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Rachel.Sun.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>