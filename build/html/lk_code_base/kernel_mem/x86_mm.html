<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>x86架构级内存管理总结 &mdash; Rachel&#39;s E-book 1.0 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> Rachel's E-book
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../os_base/index.html">linux 操作系统概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lk_devel/index.html">linux 内核开发基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../x86_kernel_base.html">linux X86内核基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lk_code/index.html">linux 内核基础代码分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pm.html">电源管理框架</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cpu.html">cpu管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver.html">设备驱动</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ps.html">进程管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mem.html">内存管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fs.html">文件系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sec.html">linux 内核安全</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../yocto_kernel.html">yocto uboot与内核模块、内核开发总结</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../uboot.html">uboot理解</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dot.html">dot画图</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf_helper.html">BPF-HELPERS</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Rachel's E-book</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>x86架构级内存管理总结</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/lk_code_base/kernel_mem/x86_mm.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="x86">
<h1>x86架构级内存管理总结<a class="headerlink" href="#x86" title="Permalink to this headline">¶</a></h1>
<div class="literal-block-wrapper docutils container" id="id301">
<div class="code-block-caption"><span class="caption-text">struct_task –&gt; mm</span><a class="headerlink" href="#id301" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="id1">
<h1>缺页中断：看硬件映射<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="literal-block-wrapper docutils container" id="id302">
<div class="code-block-caption"><span class="caption-text">struct_task –&gt; mm</span><a class="headerlink" href="#id302" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp"># 硬件（X86架构）</span>
</pre></div>
</td></tr></table></div>
</div>
<p>异常类型：Fault</p>
<p>####描述：</p>
<p>CR0寄存器设置PG标志，处理器通过页转化机制将一个线性地址转换为一个物理地址时探测到以下条件之一：</p>
<ol class="arabic simple">
<li><p>地址转换需要的页目录或页表入口项的P(present)标志为空，表示包含内容的页表或页不在物理内存中。</p></li>
<li><p>程序没有足够的特权访问指定的页面（也就是说，运行在应用模式的程序试图访问超级模式的页）。如果设置了CR4的SMAP标志，运行在超级模式的程序试图访问用户模式地址的数据也可以触发缺页中断。如果设置了CR4中的PKE或PKS标志，访问包含保护密钥的线性地址时，保护密钥权限寄存器可能产生缺页中断。（理解上需要进一步确认）</p></li>
<li><p>运行在用户模式的代码试图向一个只读页面里写数据。如果使能了CR0的WP标志，运行在超级用户模式的程序试图向一个只读页面写数据时也会触发缺页中断。</p></li>
<li><p>从禁止了可执行位的页面中取指令。如果设置了CR4的SMEP位，运行在超级模式下的代码试图从用户地址空家获取指令时也会触发页错误。</p></li>
<li><p>页结构入口的保留位设置为1时。（就是写了保留位）</p></li>
<li><p>对不是shadow-stack页的页进行shadow-stack访问。</p></li>
<li><p>enclave访问，违反访问控制要求时，此时异常称为SGX-induced page fault.处理器使用后面描述的错误码来从传统的页错误中区分SGX产生的页错误。</p></li>
</ol>
<p>异常处理程序可以通过重启程序或任务从页不在内存中恢复回来，保持程序的连续性。它还可以在权限冲突后重新启动程序或任务，但是造成特权侵犯的问题可能是无法纠正的。</p>
<p>#### 异常错误码</p>
<p>处理器向page-fault处理程序提供两项信息来诊断异常并从中恢复：</p>
<ol class="arabic">
<li><p>##### 堆栈上的错误代码</p>
<p>page-fault的错误码的格式与其他异常的错误码格式不同。处理器按照如下规则设置错误码：</p>
<ol class="arabic simple">
<li><p>bit 0: P flag:如果用于地址转换的页结构项的P标志为0则线性地址不进行转换，</p></li>
<li><p>bit 1: W/R:如果导致页面错误异常的访问是写入，则此标志为1；否则为0。此标志描述访问导致page-fault 异常的访问不是分页指定的访问权限。</p></li>
<li><p>bit 2:U/S:  如果用户模式访问导致了page-fault异常，则此标志为1；如果是超级模式访问导致，则此标志为0。此标志描述导致page-fault异常的访问不是分页指定的访问权限。</p></li>
<li><p>bit 3:RSVD:  如果因为因为在用于转换该地址的分页结构项中设置了保留位导致线性地址没有转换，则此标志为1。</p></li>
<li><p>bit 4:I/D:如果导致页面错误异常的访问是指令获取，则此标志为1。此标志描述导致页面错误异常的访问不是分页指定的访问权限。</p></li>
<li><p>bit 5:PK:对具有保护密钥数据的线性地址的数据访问导致的错误，保护密钥权限寄存器不允许访问该地址，则此标志为1。</p></li>
<li><p>bit 1:SS:因为对shadow-stck访问（包括enclave模式中的shadow-stack访问）导致的page-fault异常设置次标志为1。此标志描述由于访问权限冲突导致page-fault异常。</p></li>
<li><p>bit 15:SGX:如果异常与分页无关，而是由违反SGX特定的访问控制要求而导致的，则此标志为1。因为只有在没有普通page-fault的情况下才可能发生这种冲突，所以仅当P标志（位0）为1并且RSVD标志（位3）和PK标志（位5）都为0时才设置该标志。</p></li>
</ol>
</li>
<li><p>##### CR2寄存器的内容</p>
<p>处理器将生成异常的32位线性地址加载到CR2寄存器。page-fault处理程序可以使用此地址定位相应的页目录和页表条目。在执行页page-fault处理程序期间，可能会发生另一个page-fault错误；处理程序应在发生第二个page-fault之前保存CR2寄存器的内容。如果page-fault是由页面级别保护冲突引起的，则在发生错误时设置页面目录项中的访问标志。IA-32处理器关于相应页表条目中的访问标志的行为是特定于model的，而不是体系结构定义的。</p>
</li>
</ol>
<p>#### 保存的指令指针</p>
<p>CS和EIP寄存器保存的内容通常指向生成异常的指令。如果在任务切换期间发生page-fault异常，CS和EIP寄存器可能会指向新任务的第一条指令（如“程序状态更改”部分所述）。</p>
<p>####  程序状态更改</p>
<p>page-fault异常通常不会导致程序状态更改，因为导致生成异常的指令不会被执行。在page-fault异常处理程序纠正了冲突（例如，将页面加载到内存中）之后，程序或任务能恢复执行。</p>
<p>当在任务切换期间产生page-fault异常时，程序状态可能会更改，如下所示。在任务切换期间，在以下任何操作期间都可能发生page-fault异常：</p>
<ol class="arabic simple">
<li><p>当将任务的状态写入该任务的TSS时。</p></li>
<li><p>在读取GDT以定位新任务的TSS描述符时。</p></li>
<li><p>读取新任务的TSS。</p></li>
<li><p>从新任务中读取与段选择器关联的段描述符时。</p></li>
<li><p>在读取新任务的LDT时，验证存储在新TSS中的段寄存器。</p></li>
</ol>
<p>在最后两种情况下，异常发生在新任务的上下文中。指令指针指向新任务的第一条指令，而不是导致任务切换的指令（或在中断的情况下执行的最后一条指令）。如果操作系统的设计允许在任务切换期间发生page-fault异常，则应通过任务门调用page-fault处理程序。(注意任务门间是否互斥？很重要的问题)</p>
<p>如果在任务切换期间发生page-fautl，则处理器将在生成异常之前从新的TSS（不执行任何其他限制，是否存在或类型检查）中加载所有状态信息。因此，page-fault处理程序不应假定使用CS，SS，DS，ES，FS和GS寄存器中的段选择子时不会引起其他异常。（可结合Interrupt 10进行理解）</p>
<p>其他异常处理信息</p>
<p>应格外小心，以确保在显式堆栈切换期间发生的异常不会导致处理器使用无效的堆栈指针（SS：ESP）。 为16位IA-32处理器编写的软件通常使用一对指令更改新堆栈，例如：</p>
<p><code class="docutils literal notranslate"><span class="pre">`ruby</span>
<span class="pre">MOV</span> <span class="pre">SS,</span> <span class="pre">AX</span>
<span class="pre">MOV</span> <span class="pre">SP,</span> <span class="pre">StackTop</span>
<span class="pre">`</span></code></p>
<p>在32位IA-32处理器上执行此代码时，在SS寄存器加载了段选择子之后，ESP寄存器加载段选择子之前可能会出现page-fault，通用保护错误（#GP）或对齐检查错误（#AC）。  此时，堆栈指针的两个部分（SS和ESP）是不一致。 新的堆栈段正在与旧的堆栈指针一起使用。</p>
<p>如果异常处理程序切换到定义良好的堆栈（即该处理程序是任务或特权更高的处理过程），则处理器不会使用不一致的堆栈指针。 但是，如果在相同的特权级别并从同一任务调用异常处理程序，则处理器将尝试使用不一致的堆栈指针。</p>
<p>在faulting任务中处理页面错误，常规保护或对齐检查异常的系统（带有陷阱门或中断门）中，以与异常处理程序相同的特权级别执行的软件应使用LSS指令而不是一对MOV指令初始化新堆栈。 当异常处理程序以特权级别0（正常情况）运行时，问题仅限于以特权级别0运行的过程或任务，通常是特权级别0的过程或任务。通常是操作系统内核。（待确认，这一段，脑袋不太清楚）</p>
<p># linux 内核代码分析</p>
<p>kernel:v5.10.13</p>
<p>#### 异常程序基本代码架构：</p>
<p><a href="#id2"><span class="problematic" id="id3">``</span></a><a href="#id4"><span class="problematic" id="id5">`</span></a>ruby
arch/x86/include/asm/trapnr.h:
#define X86_TRAP_PF     14  /*  Page Fault <a href="#id6"><span class="problematic" id="id7">*</span></a>/</p>
<p>arch/x86/kernel/idt.c</p>
<p>/* Interrupt gate ：中断门*/
struct idt_bits {</p>
<blockquote>
<div><dl class="simple">
<dt>u16 ist<span class="classifier">3,</span></dt><dd><p>zero:5,
type:5,
dpl:2,
p:1;</p>
</dd>
</dl>
<p>} __attribute__((packed));</p>
</div></blockquote>
<dl class="simple">
<dt>struct idt_data { /* 中断门格式 <a href="#id8"><span class="problematic" id="id9">*</span></a>/</dt><dd><p>unsigned int vector; /* 向量号：#PF –&gt; 14*/
unsigned int segment; /* 代码段 <em>/
struct idt_bits bits; /</em> 权限相关设置 <em>/
const void *addr; /</em> 处理程序地址 <a href="#id10"><span class="problematic" id="id11">*</span></a>/</p>
</dd>
</dl>
<p>};</p>
<p>#define  G(_vector,_addr,_ist,_type,_dpl,_segment) /* 初始化struct idt_data结构 <a href="#id12"><span class="problematic" id="id13">*</span></a>/</p>
<blockquote>
<div><dl class="simple">
<dt>{       </dt><dd><p>.vector = _vector, .bits.ist = _ist, .bits.type = _type, .bits.dpl = _dpl, .bits.p = 1,    .addr = _addr, .segment = _segment,   </p>
</dd>
</dl>
</div></blockquote>
<p>}
#define DEFAULT_STACK 0
enum {</p>
<blockquote>
<div><p>GATE_INTERRUPT =0xE,
GATE_TRAP = 0xF,
GATE_CALL = 0xC,
GATE_TASK = 0x5,</p>
</div></blockquote>
<p>};
#define DPL0    0x0  /* 注意: linux 只使用了这两种优先级 <a href="#id14"><span class="problematic" id="id15">*</span></a>/
#define DPL3    0x3</p>
<p>#define GDT_ENTRY_KERNEL_CS     12
#define GDT_ENTRY_KERNEL_DS     13</p>
<p>#define __KERNEL_CS     (GDT_ENTRY_KERNEL_CS * 8)
#define __KERNEL_DS     (GDT_ENTRY_KERNEL_DS * 8)
#define __USER_DS       (GDT_ENTRY_DEFAULT_USER_DS * 8 + 3)
#define __USER_CS       (GDT_ENTRY_DEFAULT_USER_CS * 8 + 3)
#define __ESPFIX_SS     (GDT_ENTRY_ESPFIX_SS * 8)</p>
<dl class="simple">
<dt>#define INTG(_vector,_addr)</dt><dd><p>G(_vector,_addr,DEFAULT_STACK,GATE_INTERRUPT,DPL0,__KERNEL_CS)</p>
</dd>
</dl>
<p>INTG(X86_TRAP_PF,asm_exc_page_fault);/* 中断异常表入口 <a href="#id16"><span class="problematic" id="id17">*</span></a>/</p>
<p><a href="#id18"><span class="problematic" id="id19">``</span></a>`
#### 定义 asm_exc_page_fault</p>
<p><a href="#id20"><span class="problematic" id="id21">``</span></a><a href="#id22"><span class="problematic" id="id23">`</span></a>ruby
arch/x86/include/asm/idtentry.h /* 定义如下 <a href="#id24"><span class="problematic" id="id25">*</span></a>/</p>
<dl class="simple">
<dt>#define DECLARE_IDTENTRY_ERRORCODE(vector,func) </dt><dd><p>idtentry vector asm_##func func has_error_code=1</p>
</dd>
<dt>#define DECLARE_IDTENTRY_RAW_ERRORCODE(vector,func)     </dt><dd><p>DECLARE_IDTENTRY_ERRORCODE(vector,func)</p>
</dd>
</dl>
<p>DECLARE_IDTENTRY_RAW_ERRORCODE(X86_TRAP_PF,exc_page_fault)
展开后定义为:
idtentry X86_TRAP_PF asm_exc_page_fault  exc_page_fault has_error_code=1
<a href="#id26"><span class="problematic" id="id27">``</span></a><a href="#id28"><span class="problematic" id="id29">`</span></a></p>
<p><a href="#id30"><span class="problematic" id="id31">``</span></a><a href="#id32"><span class="problematic" id="id33">`</span></a>ruby
arch/x86/entry/entry_64.S
/* 函数定义</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>idtentry - Macro to generate entry stubs for simple IDT entries</dt><dd><p>&#64;vector: Vector number
&#64;asmsym: ASM symbol for the entry point
&#64;cfunc:  C function to be called
&#64;has_error_code: Hardware pushed error code on stack
The macro emits code to set up the kernel context for straight forward and simple IDT entries.No IST stack,no paranoid entry checks.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p><a href="#id34"><span class="problematic" id="id35">*</span></a>/</p>
<p>.macro idtentry vector asmsym cfunc has_error_code:req
SYM_CODE_START(asmsym)</p>
<blockquote>
<div><p>UNWIND_HINT_IRET_REGS offset=has_error_code * 8
ASM_CLAC
.if has_error_code == 0 /* 针对没有错误码的中断/异常 <a href="#id36"><span class="problematic" id="id37">*</span></a>/</p>
<blockquote>
<div><p>pushq $-1</p>
</div></blockquote>
<p>.endif
.if vector == X86_TRAP_BP /* 断点:用于调试 <a href="#id38"><span class="problematic" id="id39">*</span></a>/</p>
<blockquote>
<div><p>testb $3,CS-ORIG_RAX(%rsp)
jnz .Lfrom_usermode_no_gap_&#64; /* 用户空间 <a href="#id40"><span class="problematic" id="id41">*</span></a>/
.rept 6
pushq 5 * 8(%rsp)
.endr
UNWIND_HINT_IRET_REGS offset=8</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>.Lfrom_usermode_no_gap_&#64;:</dt><dd><p>.endif
idtentry_body cfunc has_error_code /* 主题 <a href="#id42"><span class="problematic" id="id43">*</span></a>/</p>
</dd>
</dl>
<p>_ASM_NOKPROBE(asmsym)
SYM_CODE_END(asmsym)
.endm</p>
<p>/* 函数主题定义
idtentry_body: Macro to emit code calling the C function</p>
<blockquote>
<div><p>&#64;cfunc:C function to the called
&#64;has_error_code:       Hardware pushed error code on stack</p>
</div></blockquote>
<p><a href="#id44"><span class="problematic" id="id45">*</span></a>/
.macro idtentry_body cfunc has_error_code:req</p>
<blockquote>
<div><blockquote>
<div><p>call error_entry /* Save all registers in pt_regs,and switch GS if needed <a href="#id46"><span class="problematic" id="id47">*</span></a>/
UNWIND_HINT_REGS
movq %rsp,%rdi
.if has_error_code == 1</p>
<blockquote>
<div><p>movq ORIG_RAX(%rsp),%rsi
movq $-1,ORIG_RAX(%rsp)</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>.endif</dt><dd><p>call cfunc /* exc_page_fault <a href="#id48"><span class="problematic" id="id49">*</span></a>/
jmp error_return</p>
</dd>
</dl>
</div></blockquote>
<p>.endm
<a href="#id50"><span class="problematic" id="id51">``</span></a><a href="#id52"><span class="problematic" id="id53">`</span></a></p>
<p>#### 调用exc_page_fault</p>
<p><a href="#id54"><span class="problematic" id="id55">``</span></a><a href="#id56"><span class="problematic" id="id57">`</span></a>ruby
arch/x86/inclue/asm/idtentry.h</p>
<dl>
<dt>/*</dt><dd><dl>
<dt>DEFINE_IDTENTRY_RAW_ERRORCODE - Emit code for raw IDT entry points</dt><dd><p>&#64;func:  Function name of the entry point
&#64;func is called from ASM entry code with interrupts disabled</p>
<p>The macro is written so it acts as function definition,Append the body with a pair of curly brackets.</p>
<p>Contrary to DEFINE_IDTENTRY_ERRORCODE() this does not invoke the irqentry_enter/exit() helpers before and after the body invocation.This needs to be done in the body itself if applicable.Use if extra work is required before the enter/exit() helpers are invoked.</p>
</dd>
</dl>
</dd>
</dl>
<p><a href="#id58"><span class="problematic" id="id59">*</span></a>/</p>
<dl class="simple">
<dt>#define DEFINE_IDTENTRY_RAW_ERRORCODE(func)</dt><dd><p>__visible noinstr void func(struct pt_regs <a href="#id60"><span class="problematic" id="id61">*</span></a>regs,unsigned long error_code)</p>
</dd>
</dl>
<p><a href="#id62"><span class="problematic" id="id63">``</span></a><a href="#id64"><span class="problematic" id="id65">`</span></a></p>
<p><a href="#id66"><span class="problematic" id="id67">``</span></a><a href="#id68"><span class="problematic" id="id69">`</span></a>ruby
arch/x86/mm/fault.c</p>
<p>DEFINE_IDTENTRY_RAW_ERRORCODE(exc_page_fault) /* 函数展开如下：即最终执行函数*/
/* __visible noinstr void exc_page_fault(struct pt_regs <a href="#id70"><span class="problematic" id="id71">*</span></a>regs,unsigned long error_code) <a href="#id72"><span class="problematic" id="id73">*</span></a>/
{</p>
<blockquote>
<div><p>unsigned long address = read_cr2();/* 产生page fault 的虚拟地址(线性地址?) <a href="#id74"><span class="problematic" id="id75">*</span></a>/
irqentry_state_t state;
prefetchw(&amp;current-&gt;mm-&gt;mmap_lock);</p>
</div></blockquote>
<dl>
<dt>/*</dt><dd><p>For KVM</p>
</dd>
<dt><a href="#id76"><span class="problematic" id="id77">*</span></a>/</dt><dd><dl class="simple">
<dt>if(kvm_handle_async_pf(regs,(u32)address))/* 这部分不做说明 <a href="#id78"><span class="problematic" id="id79">*</span></a>/</dt><dd><p>return;</p>
</dd>
</dl>
</dd>
<dt>/*</dt><dd><dl class="simple">
<dt>Entry handling for valid #PF from kernel mode is slightly different:RCU is already watching and</dt><dd><p>rcu_irq_enter() must not be invoked because a kernel fault on a user space address might sleep.</p>
</dd>
</dl>
<p>In case the fault hit a RCU idle region the conditional entry code reenabled RCU to avoid subsequent wreckage which helps debugability.</p>
</dd>
<dt><a href="#id80"><span class="problematic" id="id81">*</span></a>/</dt><dd><blockquote>
<div><p>state = irqentry_enter(regs);</p>
</div></blockquote>
<dl class="simple">
<dt>instrumentation_begin();</dt><dd><p>handle_page_fault(regs,error_code,address);/* 函数主题 <a href="#id82"><span class="problematic" id="id83">*</span></a>/
instrumentation_end();
irqentry_exit(regs,state);</p>
</dd>
</dl>
</dd>
</dl>
<div class="section" id="id84">
<h2>}<a class="headerlink" href="#id84" title="Permalink to this headline">¶</a></h2>
<p>#### 调用handle_page_fault：</p>
<p><a href="#id85"><span class="problematic" id="id86">``</span></a><a href="#id87"><span class="problematic" id="id88">`</span></a>ruby
static __always_inline void handle_page_fault(struct pt_regs <a href="#id89"><span class="problematic" id="id90">*</span></a>regs,unsigned long error_code unsigned long address)
{</p>
<blockquote>
<div><p>trace_page_fault_entries(regs,error_code,address);
if(unlikely(kmmio_fault(regs,address)))</p>
<blockquote>
<div><p>return;</p>
</div></blockquote>
<dl class="simple">
<dt>if(unlikely(fault_in_kernel_space(address))) {</dt><dd><p>do_kern_addr_fault(regs,error_code,address);/* 主体:内核空间 <a href="#id91"><span class="problematic" id="id92">*</span></a>/</p>
</dd>
<dt>} else {</dt><dd><p>do_user_addr_fault(regs,error_code,address); /* 主体:应用空间 <a href="#id93"><span class="problematic" id="id94">*</span></a>/
local_irq_disable();</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</div>
<div class="section" id="id95">
<h2>}<a class="headerlink" href="#id95" title="Permalink to this headline">¶</a></h2>
<p>##### do_kern_addr_fault</p>
<p><a href="#id96"><span class="problematic" id="id97">``</span></a><a href="#id98"><span class="problematic" id="id99">`</span></a>ruby
/*</p>
<blockquote>
<div><p>注意，内核处理部分，因为内核在满足某些要求时不存在换出的问题，具体分析如下。</p>
</div></blockquote>
<p><em>/
static void do_kern_addr_fault(struct pt_regs *regs,unsigned long hw_error_code,unsigned long address)
{
/</em></p>
<blockquote>
<div><p>Protection keys exceptions only happen on user pages.We have no user pages in the kernel portion of the address spae,so do not expect them here.</p>
</div></blockquote>
<p><em>/
WARN_ON_ONCE(hw_error_code &amp; X86_PF_PK);
/</em></p>
<blockquote>
<div><p>Was the fault spurious,caused by lazy TLB invalidation?</p>
</div></blockquote>
<p><em>/
if(spurious_kernel_fault(hw_error_code,address))/</em> 虚拟#PF，这个要深入分析。 <a href="#id100"><span class="problematic" id="id101">*</span></a>/</p>
<blockquote>
<div><p>return;</p>
</div></blockquote>
<dl class="simple">
<dt>/*</dt><dd><p>kprobes do not want to hook the spurious faults:</p>
</dd>
</dl>
<p><em>/
if(kprobe_page_fault(regs,X86_TRAP_PF)) /</em> kprobe来处理page fault:这个要做实验，很重要 <a href="#id102"><span class="problematic" id="id103">*</span></a>/</p>
<blockquote>
<div><p>return;</p>
</div></blockquote>
<dl class="simple">
<dt>/*</dt><dd><p>Note,despite being a “bad area”,there are quite a few acceptable reasons to get here,such a erratum fixups and handling kernel code that can fault,like get_user().
Do not take the mm semaphore here.If we fixup a prefetch fault we could otherwise deadlock;</p>
</dd>
</dl>
<p><em>/
bad_area_nosemaphore(regs,hw_error_code,address);/</em> 进行详细处理 <a href="#id104"><span class="problematic" id="id105">*</span></a>/
}
<a href="#id106"><span class="problematic" id="id107">``</span></a>`
##### do_user_addr_fault</p>
<p><a href="#id108"><span class="problematic" id="id109">``</span></a><a href="#id110"><span class="problematic" id="id111">`</span></a>ruby
/*</p>
<blockquote>
<div><p>用户空间,这部分是重点</p>
</div></blockquote>
<p><a href="#id112"><span class="problematic" id="id113">*</span></a>/
static inline void do_user_addr_fault(struct pt_regs <a href="#id114"><span class="problematic" id="id115">*</span></a>regs,unsigned long hw_error_code,unsigned long address)
{</p>
<blockquote>
<div><blockquote>
<div><p>struct vm_area_struct <em>vma;
struct task_struct *tsk;
struct mm_struct *mm;/</em> 针对task_struct 的内存空间 <a href="#id116"><span class="problematic" id="id117">*</span></a>/
vm_fault_t fault;
unsigned int flags = FAULT_FALG_DEFAULT;</p>
<p>tsk = current;
mm = tsk-&gt;mm;
/*
Kprobes do not want to hook the spurious faults:
<a href="#id118"><span class="problematic" id="id119">*</span></a>/
if(unlikely(kprobe_page_fault(regs,X86_TRAP_PF)))</p>
<blockquote>
<div><p>return;</p>
</div></blockquote>
</div></blockquote>
<dl>
<dt>/*</dt><dd><p>Reserved bits are never expected to be set on entries in the user portion of the page tables.
<a href="#id120"><span class="problematic" id="id121">*</span></a>/</p>
</dd>
<dt>if(unlikely(hw_error_code &amp; X86_PF_RSVD))</dt><dd><blockquote>
<div><p>pgtable_bad(regs,hw_error_code,address)</p>
</div></blockquote>
<dl class="simple">
<dt>/*</dt><dd><dl class="simple">
<dt>If SMAP is on,check for invalid kernel(supervisor) access to user</dt><dd><dl class="simple">
<dt>page in the user address space.The odd case here is WRUSS which,according to the preliminary documentation,does not respect</dt><dd><p>SMAP and will have the USER bit set so,in all cases,SMAP enforcement appears to be consistent whith the USER bit <a href="#id122"><span class="problematic" id="id123">*</span></a>/</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>if(unlikely(cpu_feature_enabled(X86_FEATURE_SMAP) &amp;&amp;</dt><dd><p>!(hw_error_code &amp; X86_PF_USER) &amp;&amp;
!(regs-&gt;flags &amp; X86_EFLAGS_AC)))</p>
</dd>
</dl>
<dl class="simple">
<dt>{</dt><dd><p>bad_area_nosemaphore(regs,hw_error_code,address);
return;</p>
</dd>
</dl>
<p>}
/*</p>
<blockquote>
<div><dl class="simple">
<dt>If we are in an interrupt,have no user context or are running</dt><dd><p>in a region with pagefaults disabled then we must not take the fault</p>
</dd>
</dl>
</div></blockquote>
<p><a href="#id124"><span class="problematic" id="id125">*</span></a>/
if(unlikely(faulthandler_disabled() || !mm)){</p>
<blockquote>
<div><p>bad_area_nosemaphore(regs,hw_error_code,address);
return;</p>
</div></blockquote>
<p>}
/*</p>
<blockquote>
<div><p>It is safe to allow irqs after cr2 has been saved and the vmalloc fault has been handled.
User-mod eregisters count as a user access even for any potential system fault or CPU buglet</p>
</div></blockquote>
<p><a href="#id126"><span class="problematic" id="id127">*</span></a>/
if(user_mode(regs)) {</p>
<blockquote>
<div><p>local_irq_enable();
flags <a href="#id128"><span class="problematic" id="id129">|</span></a>= FAULT_FLAG_USER;</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><dl class="simple">
<dt>if(regs-&gt;flags &amp; X86_EFLAGS_IF)</dt><dd><p>local_irq_enable();</p>
</dd>
</dl>
</dd>
</dl>
<p>}
perf_sw_event(PERF_COUNT_SW_PAGE_PAULTS,1,regs,address);
if(hw_error_code &amp; X86_PF_WRITE)</p>
<blockquote>
<div><p>flags <a href="#id130"><span class="problematic" id="id131">|</span></a>= FAULT_FLAG_WRITE;</p>
</div></blockquote>
<dl class="simple">
<dt>if(hw_error_code &amp; X86_PF_INSTR)</dt><dd><p>flags <a href="#id132"><span class="problematic" id="id133">|</span></a>= FAULT_FLAG_INSTRUCTION;</p>
</dd>
<dt>/*</dt><dd><p>只描述X86_64:</p>
</dd>
</dl>
<p>Faults in the vsyscall page might need emulation:…
此处不作为重点进行分析
<a href="#id134"><span class="problematic" id="id135">*</span></a>/
if(is_vsyscall_vaddr(address)) {</p>
<blockquote>
<div><dl class="simple">
<dt>if(emulate_vsyscall(hw_error_code),regs,address))</dt><dd><p>return;</p>
</dd>
</dl>
</div></blockquote>
<p>}
/*</p>
<blockquote>
<div><p>保证正确处理顺序的措施</p>
</div></blockquote>
<p><a href="#id136"><span class="problematic" id="id137">*</span></a>/</p>
<dl>
<dt>if(unlikely(!mmap_read_trylock(mm))) {</dt><dd><dl class="simple">
<dt>if(!user_mode(regs) &amp;&amp; !search_exception_tables(regs-&gt;ip)) {</dt><dd><p>/*</p>
</dd>
<dt>Fault from code in kernel from which we do not expect faults.</dt><dd><p><a href="#id138"><span class="problematic" id="id139">*</span></a>/
bad_area_nosemaphore(regs,hw_error_code,address);
return;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>retry:</dt><dd><blockquote>
<div><p>mmap_read_lock(mm);</p>
</div></blockquote>
<p>} else {
/*</p>
<blockquote>
<div><p>The above down_read_trylock() might have succeeded in which case we will have missed the might_sleep() from down_read():</p>
</div></blockquote>
<dl class="simple">
<dt><a href="#id140"><span class="problematic" id="id141">*</span></a>/</dt><dd><p>might_sleep();</p>
</dd>
</dl>
<p>}
vma = find_vma(mm,address); /* 处理主体:找到包含虚拟地址的内存空间 <em>/
if(unlikely(!vma)) {/</em> 不在进程地址空间中 <a href="#id142"><span class="problematic" id="id143">*</span></a>/</p>
<blockquote>
<div><p>bad_area(regs,hw_error_code,address);
return;</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if(likely(vma-&gt;vm_start &lt;= address)) /* 包含在空间中 <a href="#id144"><span class="problematic" id="id145">*</span></a>/</dt><dd><p>goto good_area;</p>
</dd>
<dt>if(unlikely(!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))) {/* 此时 address &lt; vm_start,若非向小增加,则出错. <a href="#id146"><span class="problematic" id="id147">*</span></a>/</dt><dd><p>bad_area(regs,hw_error_code,address);
return;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if(unlikely(expand_stack(vma,address))) { /* 若非栈,则… <a href="#id148"><span class="problematic" id="id149">*</span></a>/</dt><dd><p>bad_area(regs,hw_error_code,address);
return;</p>
</dd>
</dl>
<p>}
/*</p>
<blockquote>
<div><p>处理主题:Ok,we have a good vm_area for this memory access,so we can handle it …</p>
</div></blockquote>
<p><a href="#id150"><span class="problematic" id="id151">*</span></a>/</p>
</dd>
<dt>good_area:</dt><dd><dl class="simple">
<dt>if(unlikely(access_error(hw_error_code,vma))) {/* 因为权限等错误引起的#PG <a href="#id152"><span class="problematic" id="id153">*</span></a>/</dt><dd><p>bad_area_access_error(regs,hw_error_code,address,vma);
return;</p>
</dd>
</dl>
<p>}
/*
<em>/
fault = handle_mm_fault(vma,address,flags,regs);/</em> 处理主体 <em>/
/</em></p>
<blockquote>
<div><p>Quick path to respond to signals</p>
</div></blockquote>
<p><a href="#id154"><span class="problematic" id="id155">*</span></a>/
if(fault_signal_pending(fault,regs)) {</p>
<blockquote>
<div><dl class="simple">
<dt>if(!user_mode(regs))</dt><dd><p>no_context(regs,hw_error_code,address,SIGBUS,BUS_ADRERR);</p>
</dd>
</dl>
<p>return;</p>
</div></blockquote>
<p>}
/*</p>
<blockquote>
<div><p>If we need to retry the mmap_lock has already been released,and if there is fatal signal pending there</p>
</div></blockquote>
<p>is no guarantee that we made any progress.Handle this case first.
<a href="#id156"><span class="problematic" id="id157">*</span></a>/
if(unlikely((fault &amp; VM_FAULT_RETRY) &amp;&amp; (flags &amp; FAULT_FLAG_ALLOW_RETRY))) {</p>
<blockquote>
<div><p>flags <a href="#id158"><span class="problematic" id="id159">|</span></a>= FAULT_FLAG_TRIED;
goto retry;</p>
</div></blockquote>
<p>}</p>
<p>mmap_read_unlock(mm);
if(unlikely(fault &amp; VM_FAULT_ERROR)) {/* 错误处理 <a href="#id160"><span class="problematic" id="id161">*</span></a>/</p>
<blockquote>
<div><p>mm_fault_error(regs,hw_error_code,address,fault);
return;</p>
</div></blockquote>
<p>}
check_v8086_mode(regs,address,tsk);</p>
</dd>
</dl>
<p>}</p>
<p><a href="#id162"><span class="problematic" id="id163">``</span></a>`
###### handle_mm_fault</p>
<p><a href="#id164"><span class="problematic" id="id165">``</span></a><a href="#id166"><span class="problematic" id="id167">`</span></a>ruby
/*</p>
<blockquote>
<div><dl class="simple">
<dt>By the time we get here,we already hold the mm semaphore</dt><dd><p>The mmap_lock may have been released depending on flags and our return value.See filemap_fault() and __lock_page_or_retry().</p>
</dd>
</dl>
</div></blockquote>
<p><a href="#id168"><span class="problematic" id="id169">*</span></a>/
vm_fault_t handle_mm_fault(struct vm_area_struct <a href="#id170"><span class="problematic" id="id171">*</span></a>vma,unsigned long address,unsigned int flags,struct pt_regs <a href="#id172"><span class="problematic" id="id173">*</span></a>regs)
{</p>
<blockquote>
<div><p>vm_fault_t ret;
__set_current_state(TASK_RUNNING);
count_vm_event(PGFAULT); /* 计数 <em>/
count_memcg_event_mm(vma-&gt;vm_mm,PGFAULT);
/</em>
do counter updates before entering really critical section
<em>/
check_sync_rss_stat(current); /</em> 统计数据更新 <a href="#id174"><span class="problematic" id="id175">*</span></a>/
if(!arch_vma_access_permitted(vma,flags &amp; FAULT_FLAG_WRITE,flags &amp; FAULT_FLAG_INSTRUCTION,flags &amp; FAULT_FLAG_REMOTE))</p>
<blockquote>
<div><p>return VM_FAULT_SIGSEGV;</p>
</div></blockquote>
<dl class="simple">
<dt>/*</dt><dd><p>Enable the memcg OOM handling for faults triggered in user space.Kernel faults are handled more gracefully.</p>
</dd>
</dl>
<p><a href="#id176"><span class="problematic" id="id177">*</span></a>/
if(flags &amp; FAULT_FLAG_USER)</p>
<blockquote>
<div><p>mem_cgroup_enter_user_fault();</p>
</div></blockquote>
<dl>
<dt>if(unlikely(is_vm_hugetlb_page(vma)))</dt><dd><p>ret = hugetlb_fault(vma-&gt;vm_mm,vma,address,flags);/* 处理主体 <a href="#id178"><span class="problematic" id="id179">*</span></a>/</p>
</dd>
<dt>else</dt><dd><p>ret = __handle_mm_fault(vma,address,falgs); /* 处理主体 <a href="#id180"><span class="problematic" id="id181">*</span></a>/</p>
</dd>
<dt>if(flags &amp; FAULT_FLAG_USER) {</dt><dd><blockquote>
<div><p>mem_cgroup_exit_user_fault();
/*</p>
</div></blockquote>
<dl>
<dt>The task may have entered a memcg OOM situation but if the allocation error was handled gracefully(no VM_FAULT_OOM),there is no need to kill anything.Just clean up the OOM state peacefully.</dt><dd><p><a href="#id182"><span class="problematic" id="id183">*</span></a>/
if(task_in_memcg_oom(current) &amp;&amp; !(ret &amp; VM_FAULT_OOM))</p>
<blockquote>
<div><p>mem_cgroup_oom_synchronize(false);</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>mm_account_fault(regs,address,flags,ret);/* 统计信息更新 <a href="#id184"><span class="problematic" id="id185">*</span></a>/</p>
<p>return ret;</p>
</div></blockquote>
</div>
<div class="section" id="id186">
<h2>}<a class="headerlink" href="#id186" title="Permalink to this headline">¶</a></h2>
<p>###### 调用__handle_mm_fault</p>
<p><a href="#id187"><span class="problematic" id="id188">``</span></a><a href="#id189"><span class="problematic" id="id190">`</span></a>ruby
/*</p>
<blockquote>
<div><dl class="simple">
<dt>By the time we get here,we already hold the mm semaphore</dt><dd><p>The mmap_lock may have been released depending on flags and our return value.See filemap_fault() and __lock_page_or_retry().</p>
</dd>
</dl>
</div></blockquote>
<p><a href="#id191"><span class="problematic" id="id192">*</span></a>/
static vm_fault_t __handle_mm_fault(struct vm_area_struct <a href="#id193"><span class="problematic" id="id194">*</span></a>vma,unsigned long address,unsigned int flags)
{</p>
<blockquote>
<div><dl class="simple">
<dt>struct vm_fault vmf = { /* 这个结构我们需要注意 <a href="#id195"><span class="problematic" id="id196">*</span></a>/</dt><dd><p>.vma = vma,
.address = address &amp; PAGE_MASK,
.flags = flags,
.pgoff = linear_page_index(vma,address);
.gfp_mask = __get_fault_gfp_mask(vma),</p>
</dd>
</dl>
<p>};
unsigned int dirty = flags &amp; FAULT_FLAG_WRITE;
struct mm_struct <a href="#id197"><span class="problematic" id="id198">*</span></a>mm = vma-&gt;vm_mm;
pgd_t <a href="#id199"><span class="problematic" id="id200">*</span></a>pgd;
p4d_t <a href="#id201"><span class="problematic" id="id202">*</span></a>p4d;
vm_fault_t ret;
pgd = pgd_offset(mm,address);
p4d = p4d_alloc(mm,pgd,address);
if(!p4d)</p>
<blockquote>
<div><p>return VM_FAULT_OOM;</p>
</div></blockquote>
<p>vmf.pud = pud_alloc(mm,p4d,address);
if(!vmf.pud)</p>
<blockquote>
<div><p>return VM_FAULT_OOM;</p>
</div></blockquote>
</div></blockquote>
<dl>
<dt>retry_pud:</dt><dd><dl>
<dt>if(pud_none(<a href="#id203"><span class="problematic" id="id204">*</span></a>vmf.pud) &amp;&amp; __transparent_hugepage_enabled(vma)) {</dt><dd><p>ret = ceate_huge_pud(&amp;vmf);
if(!(ret &amp; VM_FAULT_FALLBACK))</p>
<blockquote>
<div><p>return ret;</p>
</div></blockquote>
</dd>
<dt>} else {</dt><dd><p>pud_t orig_pud = <a href="#id205"><span class="problematic" id="id206">*</span></a>vmf.pud;</p>
<p>barrier();
if(pud_trans_huge(orig_pud) || pud_devmap(orig_pud)) {</p>
<blockquote>
<div><dl>
<dt>/*</dt><dd><p><a href="#id207"><span class="problematic" id="id208">*</span></a>/</p>
</dd>
<dt>if(dirty &amp;&amp; !pud_write(orig_pud)) {</dt><dd><p>ret = wp_huge_pud(&amp;vmf,orig_pud);
if(!(ret &amp; VM_FAULT_FALLBACK))</p>
<blockquote>
<div><p>return ret;</p>
</div></blockquote>
</dd>
<dt>} else {</dt><dd><p>huge_pud_set_accessed(&amp;vmf,orig_pud);
return 0;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
vmf.pmd = pmd_alloc(mm,vmf.pud,address);
if(!vmf.pmd)</p>
<blockquote>
<div><p>return VM_FAULT_OOM;</p>
</div></blockquote>
<p>/*
<a href="#id209"><span class="problematic" id="id210">*</span></a>/
if(pud_trans_unstable(vmf.pud))</p>
<blockquote>
<div><p>goto retry_pud;</p>
</div></blockquote>
<dl>
<dt>if(pmd_none(<a href="#id211"><span class="problematic" id="id212">*</span></a>vmf.pmd) &amp;&amp; __transparent_hugepage_enabled(vma)) {</dt><dd><p>ret = create_huge_pmd(&amp;vmf);
if(!(ret &amp; VM_FAULT_FALLBACK))</p>
<blockquote>
<div><p>return ret;</p>
</div></blockquote>
</dd>
<dt>} else {</dt><dd><p>pmd_t orig_pmd = <a href="#id213"><span class="problematic" id="id214">*</span></a>vmf.pmd;
barrier();
if(unlikely(is_swap_pmd(orig_pmd))) {</p>
<blockquote>
<div><dl class="simple">
<dt>VM_BUG_ON(thp_migration_supported() &amp;&amp;</dt><dd><p>!is_pmd_migration_entry(orig_pmd));</p>
</dd>
<dt>if(is_pmd_migration_entry(orig_pmd))</dt><dd><p>pmd_migration_entry_wait(mm,vmf.pmd);</p>
</dd>
</dl>
<p>return 0;</p>
</div></blockquote>
<p>}
if(pmd_trans_huge(orig_pmd) || pmd_devmap(orig_pmd)) {</p>
<blockquote>
<div><dl>
<dt>if(pmd_protnone(orig_pmd) &amp;&amp; vma_is_acessible(vma))</dt><dd><p>return do_huge_pmd_numa_page(&amp;vmf,orig_pmd);</p>
</dd>
<dt>if(dirty &amp;&amp; !pmd_write(orig_pmd)) {</dt><dd><p>ret = wp_huge_pmd(&amp;vmf,orig_pmd);
if(!(ret &amp; VM_FAULT_FALLBACK))</p>
<blockquote>
<div><p>return ret;</p>
</div></blockquote>
</dd>
<dt>} else {</dt><dd><p>huge_pmd_set_accessed(&amp;vmf,orig_pmd);
return 0;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
return handle_pte_fault(&amp;vmf);/* 处理主体 <a href="#id215"><span class="problematic" id="id216">*</span></a>/</p>
</dd>
</dl>
</div>
<div class="section" id="id217">
<h2>}<a class="headerlink" href="#id217" title="Permalink to this headline">¶</a></h2>
<p>###### 调用handle_pte_fault</p>
<p><a href="#id218"><span class="problematic" id="id219">``</span></a><a href="#id220"><span class="problematic" id="id221">`</span></a>ruby
/*</p>
<blockquote>
<div><dl class="simple">
<dt>By the time we get here,we already hold the mm semaphore</dt><dd><p>The mmap_lock may have been released depending on flags and our return value.See filemap_fault() and __lock_page_or_retry().</p>
</dd>
</dl>
</div></blockquote>
<p><a href="#id222"><span class="problematic" id="id223">*</span></a>/
static vm_fault_t handle_pte_fault(struct vm_fault <a href="#id224"><span class="problematic" id="id225">*</span></a>vmf)
{</p>
<blockquote>
<div><p>pte_t entry;
if(unlikely(pmd_none(<em>vmf-&gt;pmd))) {
/</em>
<a href="#id226"><span class="problematic" id="id227">*</span></a>/</p>
<blockquote>
<div><p>vmf-&gt;pte = NULL;</p>
</div></blockquote>
<p>} else {
/* <a href="#id228"><span class="problematic" id="id229">*</span></a>/</p>
<blockquote>
<div><dl class="simple">
<dt>if(pmd_devmap_trans_unstable(vmf-&gt;pmd))</dt><dd><p>return 0;</p>
</dd>
</dl>
<p>/*
<em>/
vmf-&gt;pte = pte_offset_map(vmf-&gt;pmd,vmf-&gt;address);
vmf-&gt;orig_pte = *vmf-&gt;pte;
/</em>
<a href="#id230"><span class="problematic" id="id231">*</span></a>/
barrier();
if(pte_none(vmf-&gt;orig_pte)){</p>
<blockquote>
<div><p>pte_unmap(vmf-&gt;pte);
vmf-&gt;pte = NULL;</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
if(!vmf-&gt;pte){</p>
<blockquote>
<div><dl class="simple">
<dt>if(vma_is_anonymous(vmf-&gt;vma))</dt><dd><p>return do_anonymous_page(vmf);/* 匿名映射:代码段,数据段,栈段: 第一次映射 <a href="#id232"><span class="problematic" id="id233">*</span></a>/</p>
</dd>
<dt>else</dt><dd><p>return do_fault(vmf); /* 非匿名映射: 第一次映射*/</p>
</dd>
</dl>
</div></blockquote>
<p>}
if(!pte_present(vmf-&gt;orig_pte))</p>
<blockquote>
<div><p>return do_swap_page(vmf); /* 交换分区部分 <a href="#id234"><span class="problematic" id="id235">*</span></a>/</p>
</div></blockquote>
<dl class="simple">
<dt>if(pte_protnone(vmf-&gt;orig_pte) &amp;&amp; vma_is_accessible(vmf-&gt;vma))</dt><dd><p>return do_numa_page(vmf);/* <a href="#id236"><span class="problematic" id="id237">*</span></a>/</p>
</dd>
</dl>
<p>vmf-&gt;ptl = pte_lockptr(vmf-&gt;vma-&gt;vm_mm,vmf-&gt;pmd);
spin_lock(vmf-&gt;ptl);
entry = vmf-&gt;orig_pte;
if(unlikely(!pte_same(<a href="#id238"><span class="problematic" id="id239">*</span></a>vmf-&gt;pte,entry))) {</p>
<blockquote>
<div><p>update_mmu_tlb(vmf-&gt;vma,vmf-&gt;address,vmf-&gt;pte);
goto unlock;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>if(vmf-&gt;flags &amp; FAULT_FLAG_WRITE) {</dt><dd><dl class="simple">
<dt>if(!pte_write(entry))</dt><dd><p>return do_wp_page(vmf);</p>
</dd>
</dl>
<p>entry = pte_mkdirty(entry);</p>
</dd>
</dl>
<p>}
entry = pte_mkyoung(entry);
if(ptep_set_access_flags(vmf-&gt;vma,vmf-&gt;address,vmf-&gt;pte,entry,vmf-&gt;flags &amp; FAULT_FLAG_WRITE)) {</p>
<blockquote>
<div><p>update_mmu_cache(vmf-&gt;vma,vmf-&gt;address,vmf-&gt;pte);</p>
</div></blockquote>
<p>} else {
/* <a href="#id240"><span class="problematic" id="id241">*</span></a>/</p>
<blockquote>
<div><dl class="simple">
<dt>if(vmf-&gt;flags &amp; FAULT_FLAG_TRIED)</dt><dd><p>goto unlock;
/*
<a href="#id242"><span class="problematic" id="id243">*</span></a>/</p>
</dd>
</dl>
<p>if(vmf-&gt;flags &amp; FAULT_FLAG_WRITE)
flush_tlb_fix_spurious_fault(vmf-&gt;vma,vmf-&gt;address);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>unlock:</dt><dd><p>pte_unmap_unlock(vmf-&gt;pte,vmf-&gt;ptl);
return 0;</p>
</dd>
</dl>
</div>
<div class="section" id="id244">
<h2>}<a class="headerlink" href="#id244" title="Permalink to this headline">¶</a></h2>
<p><a href="#id245"><span class="problematic" id="id246">``</span></a><a href="#id247"><span class="problematic" id="id248">`</span></a>ruby
我们先看重要结构：
/*</p>
<blockquote>
<div><p>由pagefault处理程序填充，并传递给vma’s的fault function句柄。vma’s-&gt;fault负责返回一个以VM_FAULT_XX格式的位掩码标志，描述错误处理细节。
MM层负责为页面分配填充gfp_mask，但是如果其实现需要不同的分配上下文，则故障处理程序可能会对其进行更改 。
如果可能，应该使用pgoff来支持virtual_address。</p>
</div></blockquote>
<p><a href="#id249"><span class="problematic" id="id250">*</span></a>/
struct vm_fault {</p>
<blockquote>
<div><p>struct vm_area_struct <em>vma; /*目标VMA */
unsigned ing flags; /</em> FAULT_FLAG_xxx 标志 <em>/
gfp_t gfp_mask; /*用于分配器的gfp掩码 */
pgoff_t pgoff; /</em> 基于vma的逻辑页偏移 <em>/
unsigned long address; /</em> 产生错误的虚拟地址 <em>/
pmd_t *pmd; /</em> 与”address”对应的pmd项 <em>/
pud_t *pud; /</em> 与 “address”对应的pud项 <em>/
pte_t orig_pte; /</em> 发生错误时的PTE值 <em>/
struct page *cow_page; /</em> COW fault可能用的页处理程序 <em>/
struct page *page; /</em> 除非设置了VM_FAULT_NOPAGE（VM_FAULT_ERROR也暗示了这一点，如何理解？）,否则这个地方的-&gt;fault 处理程序应该返回一个页面*/
/* 以下三个条目，仅在获取到ptl锁时才有效  <em>/
pte_t *pte; /*指向”address”对应的pte entry。如果页表没有分配，则为NULL。 */
spinlock_t *ptl; /</em> 页表锁。</p>
<blockquote>
<div><ul class="simple">
<li><p>如果”pte”不为NULL，则保护页表，否则保护pmd。 <a href="#id251"><span class="problematic" id="id252">*</span></a>/</p></li>
</ul>
</div></blockquote>
<p>pgtable_t prealloc_pte; /* 预分配的PTE 页表。vm_ops-&gt;map_pages()从原子上下文调用alloc_set_pte()。</p>
</div></blockquote>
</div>
<div class="section" id="id253">
<h2>}<a class="headerlink" href="#id253" title="Permalink to this headline">¶</a></h2>
<p><a href="#id254"><span class="problematic" id="id255">``</span></a><a href="#id256"><span class="problematic" id="id257">`</span></a>ruby
下面看错误对应的处理方式：
!vmf-&gt;pte：第一次映射</p>
<blockquote>
<div><dl class="simple">
<dt>if(vma_is_anonymous(vmf-&gt;vma))</dt><dd><p>return do_anonymous_page(vmf);/* 匿名映射 <a href="#id258"><span class="problematic" id="id259">*</span></a>/</p>
</dd>
<dt>else</dt><dd><p>return do_fault(vmf); /* 文件映射 <a href="#id260"><span class="problematic" id="id261">*</span></a>/</p>
</dd>
</dl>
<p>分析：</p>
</div></blockquote>
<dl class="simple">
<dt>!pte_present(vmf-&gt;orig_pte)：已经有PTE，如果只是不在内存，就在交换分区。</dt><dd><p>do_swap_page(vmf);</p>
</dd>
</dl>
<p><a href="#id262"><span class="problematic" id="id263">``</span></a><a href="#id264"><span class="problematic" id="id265">`</span></a></p>
<p><a href="#id266"><span class="problematic" id="id267">``</span></a><a href="#id268"><span class="problematic" id="id269">`</span></a>ruby
do_anonymous_page(vmf): mm/memory.c
/*</p>
<blockquote>
<div><p>匿名映射</p>
</div></blockquote>
<p><a href="#id270"><span class="problematic" id="id271">*</span></a>/
static vm_fault_t do_anonymous_page(struct vm_fault <a href="#id272"><span class="problematic" id="id273">*</span></a>vmf)
{</p>
<blockquote>
<div><p>handle_userfault(vmf,VM_UFFD_MISSING);/* 分配页面 <a href="#id274"><span class="problematic" id="id275">*</span></a>/</p>
</div></blockquote>
</div>
<div class="section" id="id276">
<h2>}<a class="headerlink" href="#id276" title="Permalink to this headline">¶</a></h2>
<p><a href="#id277"><span class="problematic" id="id278">``</span></a><a href="#id279"><span class="problematic" id="id280">`</span></a>ruby
do_fault(vmf): mm/memory.c
/*</p>
<blockquote>
<div><p>文件映射</p>
</div></blockquote>
<p><a href="#id281"><span class="problematic" id="id282">*</span></a>/
static vm_fault_t do_fault(struct vm_fault <a href="#id283"><span class="problematic" id="id284">*</span></a>vmf)
{</p>
<blockquote>
<div><p>!FAULT_FALG_WRITE: do_read_fault(vmf);
FAULT_FLAG_WRITE &amp;&amp; (!VM_SHARED): do_cow_fault(vmf);
FAULT_FALG_WRITE &amp;&amp; VM_SHARED: do_shared_fault;</p>
</div></blockquote>
</div>
<div class="section" id="id285">
<h2>}<a class="headerlink" href="#id285" title="Permalink to this headline">¶</a></h2>
<p><a href="#id286"><span class="problematic" id="id287">``</span></a><a href="#id288"><span class="problematic" id="id289">`</span></a>ruby
do_swap_page(vmf)
/*</p>
<blockquote>
<div><p>顺便把交换分区给搞定了：
交换分区应该做为文件系统处理吗？
/proc/swaps
mkswap /dev/…：将分区或文件创建成swap空间。</p>
<p>kswapd 进程: mm/vmscan.c
内存回收主要针对内存中的文件页面（file cache)和匿名页
1：anon 匿名页内存主要回收手段是swap;
2:file-backed的文件映射页，主要的释放手段是写回和清空。因为有硬盘文件对应，所以不走交换分区路径，直接写回，并清空内存（也就是说保存映射结构，但释放掉物理页）。</p>
</div></blockquote>
<p><a href="#id290"><span class="problematic" id="id291">*</span></a>/
vm_fault_t do_swap_page(struct vm_fault <a href="#id292"><span class="problematic" id="id293">*</span></a>vmf)
{</p>
<blockquote>
<div><blockquote>
<div><p>struct vm_area_struct <a href="#id294"><span class="problematic" id="id295">*</span></a>vma = vmf-&gt;vma;
struct page <a href="#id296"><span class="problematic" id="id297">*</span></a>page = NULL,*swapcache;
swp_entry_t entry;
pte_t pte;
int locked;
int exclusive = 0;
vm_fault_t ret = 0;
void <a href="#id298"><span class="problematic" id="id299">*</span></a>shadow = NULL;</p>
<p>entry = pte_to_swp_entry(vmf-&gt;orig_pte);
delayacct_set_flag(DELAYACCT_PF_SWAPIN);</p>
</div></blockquote>
<p>page = lookup_swap_cache(entry,vma,vmf-&gt;address);
swapcache = page;</p>
</div></blockquote>
</div>
<div class="section" id="id300">
<h2>}<a class="headerlink" href="#id300" title="Permalink to this headline">¶</a></h2>
<p>#### 函数流程图</p>
<p>&lt;pre&gt;&lt;code class=”language-mermaid”&gt;
graph TB
pgh0(“asm_exc_page_fault”) –&gt;pgh1(“exc_page_fault”);
pgh1 –&gt; pgh10(“pre:上下文相关处理”)
pgh10 –&gt; pgh2(“handle_page_fault”);
pgh2 -.”kmmio_fault:true”.-&gt; pgh20001(“return”)
pgh2-.”kmmio_fault:false”.-&gt; pgh20002(“fault_in_kernel_space”)
pgh20002 -. “true:#PF发生在内核空间” .-&gt; pgh20(“do_kern_addr_fault:内核空间处理”)
pgh20 -. “spurious fault” .-&gt; pgh201(“spurious_kernel_fault_check”)
pgh20 -. “地址非法” .-&gt; pgh202(“bad_area_nosemaphore”)
pgh202 -.-&gt; pgh2020(“is_f00f_bug”)
pgh2020 -.-&gt; pgh2021(“no_context”)
pgh2021 -.-&gt; noc0(“fixup_exception”)
noc0 -.”in_interrupt”.-&gt; noc1(“return”)
noc0 -.”!in_interrupt”.-&gt; noc2(“处理信号 SIGSEGV”) -.-&gt; noc3(“return”)
pgh2021 -.-&gt;noc4(“!fixup_exception”)
noc4 -.”CONFIG_VMAP_STACK:stack overflow”.-&gt;noc5(“handle_stack_overflow”)
noc5 -.-&gt;noc6(“1:jmp 1b:kernel stack overflow:进入死循环:系统卡死”)
noc4 -. “is_prefetch:” .-&gt; noc8(“return”)
noc4 -. “is_errata93:” .-&gt; noc9(“return”)
noc4 -. “CONFIG_EFI”.-&gt; noc10(“efi_recover_from_page_fault”)  -.-&gt; noc11(“oops”)
noc4 -. “!CONFIG_EFI”.-&gt;noc12(“oops”)
pgh2 -. “#PF发生在用户空间” .-&gt; pgh21(“do_user_addr_fault:用户空间处理”)
pgh21 -.”hw_error_code:合法缺页外的错误码”.-&gt;pgh22(“hw_error_code:处理”)
pgh21 -.”hw_error_code:缺页: 非进程空间：越界”.-&gt; pgh23(“bad_area_acess_error:return”)
pgh21 -.”hw_error_code:缺页：vma进程空间内”.-&gt;pgh24(“handle_mm_fault”)
pgh24 -.-&gt; pgh25(“__handle_mm_fault”)
pgh25 -.-&gt; pgh26(“handle_pte_fault”)
pgh26 -.”匿名空间:无pte”.-&gt;pgh27(“do_anonymous_page”)
pgh26 -.”非匿名空间:无pte”.-&gt;pgh28(“do_fault”)
pgh26 -.”pte:!pte_present:交换空间”.-&gt;pgh29(“do_swap_page”)
pgh2 –&gt; pgh55(“post:上下文处理:返回”) –&gt; pgh56(“INTERRUPT_RETURN”)
&lt;/code&gt;&lt;/pre&gt;</p>
<p>#### 总结</p>
<p>以上是缺页中断的所有描述，针对linux 代码后期会完善所有注释，注意最终的页面分配，在内存部分进行整理。</p>
</div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Rachel.Sun.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>