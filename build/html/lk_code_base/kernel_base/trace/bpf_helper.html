<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BPF-HELPERS &mdash; Rachel&#39;s E-book 1.0 documentation</title><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> Rachel's E-book
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../os_base/index.html">linux 操作系统概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lk_devel/index.html">linux 内核开发基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../x86_kernel_base.html">linux X86内核基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lk_code/index.html">linux 内核基础代码分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../pm.html">电源管理框架</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ps.html">进程管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mem.html">内存管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fs.html">文件系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../driver.html">设备驱动管理框架</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sec.html">linux 内核安全</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dot.html">dot画图</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Rachel's E-book</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>BPF-HELPERS</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/lk_code_base/kernel_base/trace/bpf_helper.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="bpf-helpers">
<h1>BPF-HELPERS<a class="headerlink" href="#bpf-helpers" title="Permalink to this headline">¶</a></h1>
<div class="section" id="list-of-ebpf-helper-functions-bpf-kernel">
<h2>list of eBPF helper functions: bpf kernel 部分只能调用这部分函数<a class="headerlink" href="#list-of-ebpf-helper-functions-bpf-kernel" title="Permalink to this headline">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">Manual section</dt>
<dd class="field-odd"><p>7</p>
</dd>
</dl>
<div class="section" id="description">
<h3>DESCRIPTION<a class="headerlink" href="#description" title="Permalink to this headline">¶</a></h3>
<p>The extended Berkeley Packet Filter (eBPF) subsystem consists in programs
written in a pseudo-assembly language, then attached to one of the several
kernel hooks and run in reaction of specific events. This framework differs
from the older, “classic” BPF (or “cBPF”) in several aspects, one of them being
the ability to call special functions (or “helpers”) from within a program.
These functions are restricted to a white-list of helpers defined in the
kernel.</p>
<p>These helpers are used by eBPF programs to interact with the system, or with
the context in which they work. For instance, they can be used to print
debugging messages, to get the time since the system was booted, to interact
with eBPF maps, or to manipulate network packets. Since there are several eBPF
program types, and that they do not run in the same context, each program type
can only call a subset of those helpers.</p>
<p>Due to eBPF conventions, a helper can not have more than five arguments.</p>
<p>Internally, eBPF programs call directly into the compiled helper functions
without requiring any foreign-function interface. As a result, calling helpers
introduces no overhead, thus offering excellent performance.</p>
<p>This document is an attempt to list and document the helpers available to eBPF
developers. They are sorted by chronological order (the oldest helpers in the
kernel at the top).</p>
</div>
<div class="section" id="helpers">
<h3>HELPERS<a class="headerlink" href="#helpers" title="Permalink to this headline">¶</a></h3>
<dl>
<dt><strong>void *bpf_map_lookup_elem(struct bpf_map *</strong><em>map</em><strong>, const void *</strong><em>key</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Perform a lookup in <em>map</em> for an entry associated to <em>key</em>.</p>
</dd>
<dt>Return</dt><dd><p>Map value associated to <em>key</em>, or <strong>NULL</strong> if no entry was
found.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_map_update_elem(struct bpf_map *</strong><em>map</em><strong>, const void *</strong><em>key</em><strong>, const void *</strong><em>value</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Add or update the value of the entry associated to <em>key</em> in
<em>map</em> with <em>value</em>. <em>flags</em> is one of:</p>
<dl class="simple">
<dt><strong>BPF_NOEXIST</strong></dt><dd><p>The entry for <em>key</em> must not exist in the map.</p>
</dd>
<dt><strong>BPF_EXIST</strong></dt><dd><p>The entry for <em>key</em> must already exist in the map.</p>
</dd>
<dt><strong>BPF_ANY</strong></dt><dd><p>No condition on the existence of the entry for <em>key</em>.</p>
</dd>
</dl>
<p>Flag value <strong>BPF_NOEXIST</strong> cannot be used for maps of types
<strong>BPF_MAP_TYPE_ARRAY</strong> or <strong>BPF_MAP_TYPE_PERCPU_ARRAY</strong>  (all
elements always exist), the helper would return an error.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_map_delete_elem(struct bpf_map *</strong><em>map</em><strong>, const void *</strong><em>key</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Delete entry with <em>key</em> from <em>map</em>.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_probe_read(void *</strong><em>dst</em><strong>, u32</strong> <em>size</em><strong>, const void *</strong><em>unsafe_ptr</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>For tracing programs, safely attempt to read <em>size</em> bytes from
kernel space address <em>unsafe_ptr</em> and store the data in <em>dst</em>.</p>
<p>Generally, use <strong>bpf_probe_read_user</strong>() or
<strong>bpf_probe_read_kernel</strong>() instead.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_ktime_get_ns(void)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Return the time elapsed since system boot, in nanoseconds.
Does not include time the system was suspended.
See: <strong>clock_gettime</strong>(<strong>CLOCK_MONOTONIC</strong>)</p>
</dd>
<dt>Return</dt><dd><p>Current <em>ktime</em>.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_trace_printk(const char *</strong><em>fmt</em><strong>, u32</strong> <em>fmt_size</em><strong>, …)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>This helper is a “printk()-like” facility for debugging. It
prints a message defined by format <em>fmt</em> (of size <em>fmt_size</em>)
to file <em>/sys/kernel/debug/tracing/trace</em> from DebugFS, if
available. It can take up to three additional <strong>u64</strong>
arguments (as an eBPF helpers, the total number of arguments is
limited to five).</p>
<p>Each time the helper is called, it appends a line to the trace.
Lines are discarded while <em>/sys/kernel/debug/tracing/trace</em> is
open, use <em>/sys/kernel/debug/tracing/trace_pipe</em> to avoid this.
The format of the trace is customizable, and the exact output
one will get depends on the options set in
<em>/sys/kernel/debug/tracing/trace_options</em> (see also the
<em>README</em> file under the same directory). However, it usually
defaults to something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">telnet</span><span class="o">-</span><span class="mi">470</span>   <span class="p">[</span><span class="mi">001</span><span class="p">]</span> <span class="o">.</span><span class="n">N</span><span class="o">..</span> <span class="mf">419421.045894</span><span class="p">:</span> <span class="mh">0x00000001</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">formatted</span> <span class="n">msg</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>In the above:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">telnet</span></code> is the name of the current task.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">470</span></code> is the PID of the current task.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">001</span></code> is the CPU number on which the task is
running.</p></li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">.N..</span></code>, each character refers to a set of
options (whether irqs are enabled, scheduling
options, whether hard/softirqs are running, level of
preempt_disabled respectively). <strong>N</strong> means that
<strong>TIF_NEED_RESCHED</strong> and <strong>PREEMPT_NEED_RESCHED</strong>
are set.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">419421.045894</span></code> is a timestamp.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0x00000001</span></code> is a fake value used by BPF for the
instruction pointer register.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;formatted</span> <span class="pre">msg&gt;</span></code> is the message formatted with
<em>fmt</em>.</p></li>
</ul>
</div></blockquote>
<p>The conversion specifiers supported by <em>fmt</em> are similar, but
more limited than for printk(). They are <strong>%d</strong>, <strong>%i</strong>,
<strong>%u</strong>, <strong>%x</strong>, <strong>%ld</strong>, <strong>%li</strong>, <strong>%lu</strong>, <strong>%lx</strong>, <strong>%lld</strong>,
<strong>%lli</strong>, <strong>%llu</strong>, <strong>%llx</strong>, <strong>%p</strong>, <strong>%s</strong>. No modifier (size
of field, padding with zeroes, etc.) is available, and the
helper will return <strong>-EINVAL</strong> (but print nothing) if it
encounters an unknown specifier.</p>
<p>Also, note that <strong>bpf_trace_printk</strong>() is slow, and should
only be used for debugging purposes. For this reason, a notice
block (spanning several lines) is printed to kernel logs and
states that the helper should not be used “for production use”
the first time this helper is used (or more precisely, when
<strong>trace_printk</strong>() buffers are allocated). For passing values
to user space, perf events should be preferred.</p>
</dd>
<dt>Return</dt><dd><p>The number of bytes written to the buffer, or a negative error
in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>u32 bpf_get_prandom_u32(void)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Get a pseudo-random number.</p>
<p>From a security point of view, this helper uses its own
pseudo-random internal state, and cannot be used to infer the
seed of other random functions in the kernel. However, it is
essential to note that the generator used by the helper is not
cryptographically secure.</p>
</dd>
<dt>Return</dt><dd><p>A random 32-bit unsigned value.</p>
</dd>
</dl>
</dd>
<dt><strong>u32 bpf_get_smp_processor_id(void)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Get the SMP (symmetric multiprocessing) processor id. Note that
all programs run with preemption disabled, which means that the
SMP processor id is stable during all the execution of the
program.</p>
</dd>
<dt>Return</dt><dd><p>The SMP id of the processor running the program.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_skb_store_bytes(struct sk_buff *</strong><em>skb</em><strong>, u32</strong> <em>offset</em><strong>, const void *</strong><em>from</em><strong>, u32</strong> <em>len</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Store <em>len</em> bytes from address <em>from</em> into the packet
associated to <em>skb</em>, at <em>offset</em>. <em>flags</em> are a combination of
<strong>BPF_F_RECOMPUTE_CSUM</strong> (automatically recompute the
checksum for the packet after storing the bytes) and
<strong>BPF_F_INVALIDATE_HASH</strong> (set <em>skb</em><strong>-&gt;hash</strong>, <em>skb</em><strong>-&gt;swhash</strong> and <em>skb</em><strong>-&gt;l4hash</strong> to 0).</p>
<p>A call to this helper is susceptible to change the underlying
packet buffer. Therefore, at load time, all checks on pointers
previously done by the verifier are invalidated and must be
performed again, if the helper is used in combination with
direct packet access.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_l3_csum_replace(struct sk_buff *</strong><em>skb</em><strong>, u32</strong> <em>offset</em><strong>, u64</strong> <em>from</em><strong>, u64</strong> <em>to</em><strong>, u64</strong> <em>size</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Recompute the layer 3 (e.g. IP) checksum for the packet
associated to <em>skb</em>. Computation is incremental, so the helper
must know the former value of the header field that was
modified (<em>from</em>), the new value of this field (<em>to</em>), and the
number of bytes (2 or 4) for this field, stored in <em>size</em>.
Alternatively, it is possible to store the difference between
the previous and the new values of the header field in <em>to</em>, by
setting <em>from</em> and <em>size</em> to 0. For both methods, <em>offset</em>
indicates the location of the IP checksum within the packet.</p>
<p>This helper works in combination with <strong>bpf_csum_diff</strong>(),
which does not update the checksum in-place, but offers more
flexibility and can handle sizes larger than 2 or 4 for the
checksum to update.</p>
<p>A call to this helper is susceptible to change the underlying
packet buffer. Therefore, at load time, all checks on pointers
previously done by the verifier are invalidated and must be
performed again, if the helper is used in combination with
direct packet access.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_l4_csum_replace(struct sk_buff *</strong><em>skb</em><strong>, u32</strong> <em>offset</em><strong>, u64</strong> <em>from</em><strong>, u64</strong> <em>to</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Recompute the layer 4 (e.g. TCP, UDP or ICMP) checksum for the
packet associated to <em>skb</em>. Computation is incremental, so the
helper must know the former value of the header field that was
modified (<em>from</em>), the new value of this field (<em>to</em>), and the
number of bytes (2 or 4) for this field, stored on the lowest
four bits of <em>flags</em>. Alternatively, it is possible to store
the difference between the previous and the new values of the
header field in <em>to</em>, by setting <em>from</em> and the four lowest
bits of <em>flags</em> to 0. For both methods, <em>offset</em> indicates the
location of the IP checksum within the packet. In addition to
the size of the field, <em>flags</em> can be added (bitwise OR) actual
flags. With <strong>BPF_F_MARK_MANGLED_0</strong>, a null checksum is left
untouched (unless <strong>BPF_F_MARK_ENFORCE</strong> is added as well), and
for updates resulting in a null checksum the value is set to
<strong>CSUM_MANGLED_0</strong> instead. Flag <strong>BPF_F_PSEUDO_HDR</strong> indicates
the checksum is to be computed against a pseudo-header.</p>
<p>This helper works in combination with <strong>bpf_csum_diff</strong>(),
which does not update the checksum in-place, but offers more
flexibility and can handle sizes larger than 2 or 4 for the
checksum to update.</p>
<p>A call to this helper is susceptible to change the underlying
packet buffer. Therefore, at load time, all checks on pointers
previously done by the verifier are invalidated and must be
performed again, if the helper is used in combination with
direct packet access.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_tail_call(void *</strong><em>ctx</em><strong>, struct bpf_map *</strong><em>prog_array_map</em><strong>, u32</strong> <em>index</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>This special helper is used to trigger a “tail call”, or in
other words, to jump into another eBPF program. The same stack
frame is used (but values on stack and in registers for the
caller are not accessible to the callee). This mechanism allows
for program chaining, either for raising the maximum number of
available eBPF instructions, or to execute given programs in
conditional blocks. For security reasons, there is an upper
limit to the number of successive tail calls that can be
performed.</p>
<p>Upon call of this helper, the program attempts to jump into a
program referenced at index <em>index</em> in <em>prog_array_map</em>, a
special map of type <strong>BPF_MAP_TYPE_PROG_ARRAY</strong>, and passes
<em>ctx</em>, a pointer to the context.</p>
<p>If the call succeeds, the kernel immediately runs the first
instruction of the new program. This is not a function call,
and it never returns to the previous program. If the call
fails, then the helper has no effect, and the caller continues
to run its subsequent instructions. A call can fail if the
destination program for the jump does not exist (i.e. <em>index</em>
is superior to the number of entries in <em>prog_array_map</em>), or
if the maximum number of tail calls has been reached for this
chain of programs. This limit is defined in the kernel by the
macro <strong>MAX_TAIL_CALL_CNT</strong> (not accessible to user space),
which is currently set to 32.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_clone_redirect(struct sk_buff *</strong><em>skb</em><strong>, u32</strong> <em>ifindex</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Clone and redirect the packet associated to <em>skb</em> to another
net device of index <em>ifindex</em>. Both ingress and egress
interfaces can be used for redirection. The <strong>BPF_F_INGRESS</strong>
value in <em>flags</em> is used to make the distinction (ingress path
is selected if the flag is present, egress path otherwise).
This is the only flag supported for now.</p>
<p>In comparison with <strong>bpf_redirect</strong>() helper,
<strong>bpf_clone_redirect</strong>() has the associated cost of
duplicating the packet buffer, but this can be executed out of
the eBPF program. Conversely, <strong>bpf_redirect</strong>() is more
efficient, but it is handled through an action code where the
redirection happens only after the eBPF program has returned.</p>
<p>A call to this helper is susceptible to change the underlying
packet buffer. Therefore, at load time, all checks on pointers
previously done by the verifier are invalidated and must be
performed again, if the helper is used in combination with
direct packet access.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_get_current_pid_tgid(void)</strong></dt><dd><dl class="simple">
<dt>Return</dt><dd><p>A 64-bit integer containing the current tgid and pid, and
created as such:
<em>current_task</em><strong>-&gt;tgid &lt;&lt; 32 |</strong>
<em>current_task</em><strong>-&gt;pid</strong>.</p>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_get_current_uid_gid(void)</strong></dt><dd><dl class="simple">
<dt>Return</dt><dd><p>A 64-bit integer containing the current GID and UID, and
created as such: <em>current_gid</em> <strong>&lt;&lt; 32 |</strong> <em>current_uid</em>.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_get_current_comm(void *</strong><em>buf</em><strong>, u32</strong> <em>size_of_buf</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Copy the <strong>comm</strong> attribute of the current task into <em>buf</em> of
<em>size_of_buf</em>. The <strong>comm</strong> attribute contains the name of
the executable (excluding the path) for the current task. The
<em>size_of_buf</em> must be strictly positive. On success, the
helper makes sure that the <em>buf</em> is NUL-terminated. On failure,
it is filled with zeroes.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>u32 bpf_get_cgroup_classid(struct sk_buff *</strong><em>skb</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Retrieve the classid for the current task, i.e. for the net_cls
cgroup to which <em>skb</em> belongs.</p>
<p>This helper can be used on TC egress path, but not on ingress.</p>
<p>The net_cls cgroup provides an interface to tag network packets
based on a user-provided identifier for all traffic coming from
the tasks belonging to the related cgroup. See also the related
kernel documentation, available from the Linux sources in file
<em>Documentation/admin-guide/cgroup-v1/net_cls.rst</em>.</p>
<p>The Linux kernel has two versions for cgroups: there are
cgroups v1 and cgroups v2. Both are available to users, who can
use a mixture of them, but note that the net_cls cgroup is for
cgroup v1 only. This makes it incompatible with BPF programs
run on cgroups, which is a cgroup-v2-only feature (a socket can
only hold data for one version of cgroups at a time).</p>
<p>This helper is only available is the kernel was compiled with
the <strong>CONFIG_CGROUP_NET_CLASSID</strong> configuration option set to
“<strong>y</strong>” or to “<strong>m</strong>”.</p>
</dd>
<dt>Return</dt><dd><p>The classid, or 0 for the default unconfigured classid.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_skb_vlan_push(struct sk_buff *</strong><em>skb</em><strong>, __be16</strong> <em>vlan_proto</em><strong>, u16</strong> <em>vlan_tci</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Push a <em>vlan_tci</em> (VLAN tag control information) of protocol
<em>vlan_proto</em> to the packet associated to <em>skb</em>, then update
the checksum. Note that if <em>vlan_proto</em> is different from
<strong>ETH_P_8021Q</strong> and <strong>ETH_P_8021AD</strong>, it is considered to
be <strong>ETH_P_8021Q</strong>.</p>
<p>A call to this helper is susceptible to change the underlying
packet buffer. Therefore, at load time, all checks on pointers
previously done by the verifier are invalidated and must be
performed again, if the helper is used in combination with
direct packet access.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_skb_vlan_pop(struct sk_buff *</strong><em>skb</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Pop a VLAN header from the packet associated to <em>skb</em>.</p>
<p>A call to this helper is susceptible to change the underlying
packet buffer. Therefore, at load time, all checks on pointers
previously done by the verifier are invalidated and must be
performed again, if the helper is used in combination with
direct packet access.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_skb_get_tunnel_key(struct sk_buff *</strong><em>skb</em><strong>, struct bpf_tunnel_key *</strong><em>key</em><strong>, u32</strong> <em>size</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Get tunnel metadata. This helper takes a pointer <em>key</em> to an
empty <strong>struct bpf_tunnel_key</strong> of <strong>size</strong>, that will be
filled with tunnel metadata for the packet associated to <em>skb</em>.
The <em>flags</em> can be set to <strong>BPF_F_TUNINFO_IPV6</strong>, which
indicates that the tunnel is based on IPv6 protocol instead of
IPv4.</p>
<p>The <strong>struct bpf_tunnel_key</strong> is an object that generalizes the
principal parameters used by various tunneling protocols into a
single struct. This way, it can be used to easily make a
decision based on the contents of the encapsulation header,
“summarized” in this struct. In particular, it holds the IP
address of the remote end (IPv4 or IPv6, depending on the case)
in <em>key</em><strong>-&gt;remote_ipv4</strong> or <em>key</em><strong>-&gt;remote_ipv6</strong>. Also,
this struct exposes the <em>key</em><strong>-&gt;tunnel_id</strong>, which is
generally mapped to a VNI (Virtual Network Identifier), making
it programmable together with the <strong>bpf_skb_set_tunnel_key</strong>() helper.</p>
<p>Let’s imagine that the following code is part of a program
attached to the TC ingress interface, on one end of a GRE
tunnel, and is supposed to filter out all messages coming from
remote ends with IPv4 address other than 10.0.0.1:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">ret</span><span class="p">;</span>
<span class="n">struct</span> <span class="n">bpf_tunnel_key</span> <span class="n">key</span> <span class="o">=</span> <span class="p">{};</span>

<span class="n">ret</span> <span class="o">=</span> <span class="n">bpf_skb_get_tunnel_key</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TC_ACT_SHOT</span><span class="p">;</span>     <span class="o">//</span> <span class="n">drop</span> <span class="n">packet</span>

<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">remote_ipv4</span> <span class="o">!=</span> <span class="mh">0x0a000001</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TC_ACT_SHOT</span><span class="p">;</span>     <span class="o">//</span> <span class="n">drop</span> <span class="n">packet</span>

<span class="k">return</span> <span class="n">TC_ACT_OK</span><span class="p">;</span>               <span class="o">//</span> <span class="n">accept</span> <span class="n">packet</span>
</pre></div>
</div>
<p>This interface can also be used with all encapsulation devices
that can operate in “collect metadata” mode: instead of having
one network device per specific configuration, the “collect
metadata” mode only requires a single device where the
configuration can be extracted from this helper.</p>
<p>This can be used together with various tunnels such as VXLan,
Geneve, GRE or IP in IP (IPIP).</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_skb_set_tunnel_key(struct sk_buff *</strong><em>skb</em><strong>, struct bpf_tunnel_key *</strong><em>key</em><strong>, u32</strong> <em>size</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Populate tunnel metadata for packet associated to <em>skb.</em> The
tunnel metadata is set to the contents of <em>key</em>, of <em>size</em>. The
<em>flags</em> can be set to a combination of the following values:</p>
<dl class="simple">
<dt><strong>BPF_F_TUNINFO_IPV6</strong></dt><dd><p>Indicate that the tunnel is based on IPv6 protocol
instead of IPv4.</p>
</dd>
<dt><strong>BPF_F_ZERO_CSUM_TX</strong></dt><dd><p>For IPv4 packets, add a flag to tunnel metadata
indicating that checksum computation should be skipped
and checksum set to zeroes.</p>
</dd>
<dt><strong>BPF_F_DONT_FRAGMENT</strong></dt><dd><p>Add a flag to tunnel metadata indicating that the
packet should not be fragmented.</p>
</dd>
<dt><strong>BPF_F_SEQ_NUMBER</strong></dt><dd><p>Add a flag to tunnel metadata indicating that a
sequence number should be added to tunnel header before
sending the packet. This flag was added for GRE
encapsulation, but might be used with other protocols
as well in the future.</p>
</dd>
</dl>
<p>Here is a typical usage on the transmit path:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">bpf_tunnel_key</span> <span class="n">key</span><span class="p">;</span>
     <span class="n">populate</span> <span class="n">key</span> <span class="o">...</span>
<span class="n">bpf_skb_set_tunnel_key</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">bpf_clone_redirect</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">vxlan_dev_ifindex</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>See also the description of the <strong>bpf_skb_get_tunnel_key</strong>()
helper for additional information.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_perf_event_read(struct bpf_map *</strong><em>map</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Read the value of a perf event counter. This helper relies on a
<em>map</em> of type <strong>BPF_MAP_TYPE_PERF_EVENT_ARRAY</strong>. The nature of
the perf event counter is selected when <em>map</em> is updated with
perf event file descriptors. The <em>map</em> is an array whose size
is the number of available CPUs, and each cell contains a value
relative to one CPU. The value to retrieve is indicated by
<em>flags</em>, that contains the index of the CPU to look up, masked
with <strong>BPF_F_INDEX_MASK</strong>. Alternatively, <em>flags</em> can be set to
<strong>BPF_F_CURRENT_CPU</strong> to indicate that the value for the
current CPU should be retrieved.</p>
<p>Note that before Linux 4.13, only hardware perf event can be
retrieved.</p>
<p>Also, be aware that the newer helper
<strong>bpf_perf_event_read_value</strong>() is recommended over
<strong>bpf_perf_event_read</strong>() in general. The latter has some ABI
quirks where error and counter value are used as a return code
(which is wrong to do since ranges may overlap). This issue is
fixed with <strong>bpf_perf_event_read_value</strong>(), which at the same
time provides more features over the <strong>bpf_perf_event_read</strong>() interface. Please refer to the description of
<strong>bpf_perf_event_read_value</strong>() for details.</p>
</dd>
<dt>Return</dt><dd><p>The value of the perf event counter read from the map, or a
negative error code in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_redirect(u32</strong> <em>ifindex</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Redirect the packet to another net device of index <em>ifindex</em>.
This helper is somewhat similar to <strong>bpf_clone_redirect</strong>(), except that the packet is not cloned, which provides
increased performance.</p>
<p>Except for XDP, both ingress and egress interfaces can be used
for redirection. The <strong>BPF_F_INGRESS</strong> value in <em>flags</em> is used
to make the distinction (ingress path is selected if the flag
is present, egress path otherwise). Currently, XDP only
supports redirection to the egress interface, and accepts no
flag at all.</p>
<p>The same effect can also be attained with the more generic
<strong>bpf_redirect_map</strong>(), which uses a BPF map to store the
redirect target instead of providing it directly to the helper.</p>
</dd>
<dt>Return</dt><dd><p>For XDP, the helper returns <strong>XDP_REDIRECT</strong> on success or
<strong>XDP_ABORTED</strong> on error. For other program types, the values
are <strong>TC_ACT_REDIRECT</strong> on success or <strong>TC_ACT_SHOT</strong> on
error.</p>
</dd>
</dl>
</dd>
<dt><strong>u32 bpf_get_route_realm(struct sk_buff *</strong><em>skb</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Retrieve the realm or the route, that is to say the
<strong>tclassid</strong> field of the destination for the <em>skb</em>. The
identifier retrieved is a user-provided tag, similar to the
one used with the net_cls cgroup (see description for
<strong>bpf_get_cgroup_classid</strong>() helper), but here this tag is
held by a route (a destination entry), not by a task.</p>
<p>Retrieving this identifier works with the clsact TC egress hook
(see also <strong>tc-bpf(8)</strong>), or alternatively on conventional
classful egress qdiscs, but not on TC ingress path. In case of
clsact TC egress hook, this has the advantage that, internally,
the destination entry has not been dropped yet in the transmit
path. Therefore, the destination entry does not need to be
artificially held via <strong>netif_keep_dst</strong>() for a classful
qdisc until the <em>skb</em> is freed.</p>
<p>This helper is available only if the kernel was compiled with
<strong>CONFIG_IP_ROUTE_CLASSID</strong> configuration option.</p>
</dd>
<dt>Return</dt><dd><p>The realm of the route for the packet associated to <em>skb</em>, or 0
if none was found.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_perf_event_output(void *</strong><em>ctx</em><strong>, struct bpf_map *</strong><em>map</em><strong>, u64</strong> <em>flags</em><strong>, void *</strong><em>data</em><strong>, u64</strong> <em>size</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Write raw <em>data</em> blob into a special BPF perf event held by
<em>map</em> of type <strong>BPF_MAP_TYPE_PERF_EVENT_ARRAY</strong>. This perf
event must have the following attributes: <strong>PERF_SAMPLE_RAW</strong>
as <strong>sample_type</strong>, <strong>PERF_TYPE_SOFTWARE</strong> as <strong>type</strong>, and
<strong>PERF_COUNT_SW_BPF_OUTPUT</strong> as <strong>config</strong>.</p>
<p>The <em>flags</em> are used to indicate the index in <em>map</em> for which
the value must be put, masked with <strong>BPF_F_INDEX_MASK</strong>.
Alternatively, <em>flags</em> can be set to <strong>BPF_F_CURRENT_CPU</strong>
to indicate that the index of the current CPU core should be
used.</p>
<p>The value to write, of <em>size</em>, is passed through eBPF stack and
pointed by <em>data</em>.</p>
<p>The context of the program <em>ctx</em> needs also be passed to the
helper.</p>
<p>On user space, a program willing to read the values needs to
call <strong>perf_event_open</strong>() on the perf event (either for
one or for all CPUs) and to store the file descriptor into the
<em>map</em>. This must be done before the eBPF program can send data
into it. An example is available in file
<em>samples/bpf/trace_output_user.c</em> in the Linux kernel source
tree (the eBPF program counterpart is in
<em>samples/bpf/trace_output_kern.c</em>).</p>
<p><strong>bpf_perf_event_output</strong>() achieves better performance
than <strong>bpf_trace_printk</strong>() for sharing data with user
space, and is much better suitable for streaming data from eBPF
programs.</p>
<p>Note that this helper is not restricted to tracing use cases
and can be used with programs attached to TC or XDP as well,
where it allows for passing data to user space listeners. Data
can be:</p>
<ul class="simple">
<li><p>Only custom structs,</p></li>
<li><p>Only the packet payload, or</p></li>
<li><p>A combination of both.</p></li>
</ul>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_skb_load_bytes(const void *</strong><em>skb</em><strong>, u32</strong> <em>offset</em><strong>, void *</strong><em>to</em><strong>, u32</strong> <em>len</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>This helper was provided as an easy way to load data from a
packet. It can be used to load <em>len</em> bytes from <em>offset</em> from
the packet associated to <em>skb</em>, into the buffer pointed by
<em>to</em>.</p>
<p>Since Linux 4.7, usage of this helper has mostly been replaced
by “direct packet access”, enabling packet data to be
manipulated with <em>skb</em><strong>-&gt;data</strong> and <em>skb</em><strong>-&gt;data_end</strong>
pointing respectively to the first byte of packet data and to
the byte after the last byte of packet data. However, it
remains useful if one wishes to read large quantities of data
at once from a packet into the eBPF stack.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_get_stackid(void *</strong><em>ctx</em><strong>, struct bpf_map *</strong><em>map</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Walk a user or a kernel stack and return its id. To achieve
this, the helper needs <em>ctx</em>, which is a pointer to the context
on which the tracing program is executed, and a pointer to a
<em>map</em> of type <strong>BPF_MAP_TYPE_STACK_TRACE</strong>.</p>
<p>The last argument, <em>flags</em>, holds the number of stack frames to
skip (from 0 to 255), masked with
<strong>BPF_F_SKIP_FIELD_MASK</strong>. The next bits can be used to set
a combination of the following flags:</p>
<dl class="simple">
<dt><strong>BPF_F_USER_STACK</strong></dt><dd><p>Collect a user space stack instead of a kernel stack.</p>
</dd>
<dt><strong>BPF_F_FAST_STACK_CMP</strong></dt><dd><p>Compare stacks by hash only.</p>
</dd>
<dt><strong>BPF_F_REUSE_STACKID</strong></dt><dd><p>If two different stacks hash into the same <em>stackid</em>,
discard the old one.</p>
</dd>
</dl>
<p>The stack id retrieved is a 32 bit long integer handle which
can be further combined with other data (including other stack
ids) and used as a key into maps. This can be useful for
generating a variety of graphs (such as flame graphs or off-cpu
graphs).</p>
<p>For walking a stack, this helper is an improvement over
<strong>bpf_probe_read</strong>(), which can be used with unrolled loops
but is not efficient and consumes a lot of eBPF instructions.
Instead, <strong>bpf_get_stackid</strong>() can collect up to
<strong>PERF_MAX_STACK_DEPTH</strong> both kernel and user frames. Note that
this limit can be controlled with the <strong>sysctl</strong> program, and
that it should be manually increased in order to profile long
user stacks (such as stacks for Java programs). To do so, use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># sysctl kernel.perf_event_max_stack=&lt;new value&gt;</span>
</pre></div>
</div>
</dd>
<dt>Return</dt><dd><p>The positive or null stack id on success, or a negative error
in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>s64 bpf_csum_diff(__be32 *</strong><em>from</em><strong>, u32</strong> <em>from_size</em><strong>, __be32 *</strong><em>to</em><strong>, u32</strong> <em>to_size</em><strong>, __wsum</strong> <em>seed</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Compute a checksum difference, from the raw buffer pointed by
<em>from</em>, of length <em>from_size</em> (that must be a multiple of 4),
towards the raw buffer pointed by <em>to</em>, of size <em>to_size</em>
(same remark). An optional <em>seed</em> can be added to the value
(this can be cascaded, the seed may come from a previous call
to the helper).</p>
<p>This is flexible enough to be used in several ways:</p>
<ul class="simple">
<li><p>With <em>from_size</em> == 0, <em>to_size</em> &gt; 0 and <em>seed</em> set to
checksum, it can be used when pushing new data.</p></li>
<li><p>With <em>from_size</em> &gt; 0, <em>to_size</em> == 0 and <em>seed</em> set to
checksum, it can be used when removing data from a packet.</p></li>
<li><p>With <em>from_size</em> &gt; 0, <em>to_size</em> &gt; 0 and <em>seed</em> set to 0, it
can be used to compute a diff. Note that <em>from_size</em> and
<em>to_size</em> do not need to be equal.</p></li>
</ul>
<p>This helper can be used in combination with
<strong>bpf_l3_csum_replace</strong>() and <strong>bpf_l4_csum_replace</strong>(), to
which one can feed in the difference computed with
<strong>bpf_csum_diff</strong>().</p>
</dd>
<dt>Return</dt><dd><p>The checksum result, or a negative error code in case of
failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_skb_get_tunnel_opt(struct sk_buff *</strong><em>skb</em><strong>, void *</strong><em>opt</em><strong>, u32</strong> <em>size</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Retrieve tunnel options metadata for the packet associated to
<em>skb</em>, and store the raw tunnel option data to the buffer <em>opt</em>
of <em>size</em>.</p>
<p>This helper can be used with encapsulation devices that can
operate in “collect metadata” mode (please refer to the related
note in the description of <strong>bpf_skb_get_tunnel_key</strong>() for
more details). A particular example where this can be used is
in combination with the Geneve encapsulation protocol, where it
allows for pushing (with <strong>bpf_skb_get_tunnel_opt</strong>() helper)
and retrieving arbitrary TLVs (Type-Length-Value headers) from
the eBPF program. This allows for full customization of these
headers.</p>
</dd>
<dt>Return</dt><dd><p>The size of the option data retrieved.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_skb_set_tunnel_opt(struct sk_buff *</strong><em>skb</em><strong>, void *</strong><em>opt</em><strong>, u32</strong> <em>size</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Set tunnel options metadata for the packet associated to <em>skb</em>
to the option data contained in the raw buffer <em>opt</em> of <em>size</em>.</p>
<p>See also the description of the <strong>bpf_skb_get_tunnel_opt</strong>()
helper for additional information.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_skb_change_proto(struct sk_buff *</strong><em>skb</em><strong>, __be16</strong> <em>proto</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Change the protocol of the <em>skb</em> to <em>proto</em>. Currently
supported are transition from IPv4 to IPv6, and from IPv6 to
IPv4. The helper takes care of the groundwork for the
transition, including resizing the socket buffer. The eBPF
program is expected to fill the new headers, if any, via
<strong>skb_store_bytes</strong>() and to recompute the checksums with
<strong>bpf_l3_csum_replace</strong>() and <strong>bpf_l4_csum_replace</strong>(). The main case for this helper is to perform NAT64
operations out of an eBPF program.</p>
<p>Internally, the GSO type is marked as dodgy so that headers are
checked and segments are recalculated by the GSO/GRO engine.
The size for GSO target is adapted as well.</p>
<p>All values for <em>flags</em> are reserved for future usage, and must
be left at zero.</p>
<p>A call to this helper is susceptible to change the underlying
packet buffer. Therefore, at load time, all checks on pointers
previously done by the verifier are invalidated and must be
performed again, if the helper is used in combination with
direct packet access.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_skb_change_type(struct sk_buff *</strong><em>skb</em><strong>, u32</strong> <em>type</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Change the packet type for the packet associated to <em>skb</em>. This
comes down to setting <em>skb</em><strong>-&gt;pkt_type</strong> to <em>type</em>, except
the eBPF program does not have a write access to <em>skb</em><strong>-&gt;pkt_type</strong> beside this helper. Using a helper here allows
for graceful handling of errors.</p>
<p>The major use case is to change incoming <em>skb*s to
**PACKET_HOST*</em> in a programmatic way instead of having to
recirculate via <strong>redirect</strong>(…, <strong>BPF_F_INGRESS</strong>), for
example.</p>
<p>Note that <em>type</em> only allows certain values. At this time, they
are:</p>
<dl class="simple">
<dt><strong>PACKET_HOST</strong></dt><dd><p>Packet is for us.</p>
</dd>
<dt><strong>PACKET_BROADCAST</strong></dt><dd><p>Send packet to all.</p>
</dd>
<dt><strong>PACKET_MULTICAST</strong></dt><dd><p>Send packet to group.</p>
</dd>
<dt><strong>PACKET_OTHERHOST</strong></dt><dd><p>Send packet to someone else.</p>
</dd>
</dl>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_skb_under_cgroup(struct sk_buff *</strong><em>skb</em><strong>, struct bpf_map *</strong><em>map</em><strong>, u32</strong> <em>index</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Check whether <em>skb</em> is a descendant of the cgroup2 held by
<em>map</em> of type <strong>BPF_MAP_TYPE_CGROUP_ARRAY</strong>, at <em>index</em>.</p>
</dd>
<dt>Return</dt><dd><p>The return value depends on the result of the test, and can be:</p>
<ul class="simple">
<li><p>0, if the <em>skb</em> failed the cgroup2 descendant test.</p></li>
<li><p>1, if the <em>skb</em> succeeded the cgroup2 descendant test.</p></li>
<li><p>A negative error code, if an error occurred.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>u32 bpf_get_hash_recalc(struct sk_buff *</strong><em>skb</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Retrieve the hash of the packet, <em>skb</em><strong>-&gt;hash</strong>. If it is
not set, in particular if the hash was cleared due to mangling,
recompute this hash. Later accesses to the hash can be done
directly with <em>skb</em><strong>-&gt;hash</strong>.</p>
<p>Calling <strong>bpf_set_hash_invalid</strong>(), changing a packet
prototype with <strong>bpf_skb_change_proto</strong>(), or calling
<strong>bpf_skb_store_bytes</strong>() with the
<strong>BPF_F_INVALIDATE_HASH</strong> are actions susceptible to clear
the hash and to trigger a new computation for the next call to
<strong>bpf_get_hash_recalc</strong>().</p>
</dd>
<dt>Return</dt><dd><p>The 32-bit hash.</p>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_get_current_task(void)</strong></dt><dd><dl class="simple">
<dt>Return</dt><dd><p>A pointer to the current task struct.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_probe_write_user(void *</strong><em>dst</em><strong>, const void *</strong><em>src</em><strong>, u32</strong> <em>len</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Attempt in a safe way to write <em>len</em> bytes from the buffer
<em>src</em> to <em>dst</em> in memory. It only works for threads that are in
user context, and <em>dst</em> must be a valid user space address.</p>
<p>This helper should not be used to implement any kind of
security mechanism because of TOC-TOU attacks, but rather to
debug, divert, and manipulate execution of semi-cooperative
processes.</p>
<p>Keep in mind that this feature is meant for experiments, and it
has a risk of crashing the system and running programs.
Therefore, when an eBPF program using this helper is attached,
a warning including PID and process name is printed to kernel
logs.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_current_task_under_cgroup(struct bpf_map *</strong><em>map</em><strong>, u32</strong> <em>index</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Check whether the probe is being run is the context of a given
subset of the cgroup2 hierarchy. The cgroup2 to test is held by
<em>map</em> of type <strong>BPF_MAP_TYPE_CGROUP_ARRAY</strong>, at <em>index</em>.</p>
</dd>
<dt>Return</dt><dd><p>The return value depends on the result of the test, and can be:</p>
<ul class="simple">
<li><p>0, if current task belongs to the cgroup2.</p></li>
<li><p>1, if current task does not belong to the cgroup2.</p></li>
<li><p>A negative error code, if an error occurred.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>long bpf_skb_change_tail(struct sk_buff *</strong><em>skb</em><strong>, u32</strong> <em>len</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Resize (trim or grow) the packet associated to <em>skb</em> to the
new <em>len</em>. The <em>flags</em> are reserved for future usage, and must
be left at zero.</p>
<p>The basic idea is that the helper performs the needed work to
change the size of the packet, then the eBPF program rewrites
the rest via helpers like <strong>bpf_skb_store_bytes</strong>(),
<strong>bpf_l3_csum_replace</strong>(), <strong>bpf_l3_csum_replace</strong>()
and others. This helper is a slow path utility intended for
replies with control messages. And because it is targeted for
slow path, the helper itself can afford to be slow: it
implicitly linearizes, unclones and drops offloads from the
<em>skb</em>.</p>
<p>A call to this helper is susceptible to change the underlying
packet buffer. Therefore, at load time, all checks on pointers
previously done by the verifier are invalidated and must be
performed again, if the helper is used in combination with
direct packet access.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_skb_pull_data(struct sk_buff *</strong><em>skb</em><strong>, u32</strong> <em>len</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Pull in non-linear data in case the <em>skb</em> is non-linear and not
all of <em>len</em> are part of the linear section. Make <em>len</em> bytes
from <em>skb</em> readable and writable. If a zero value is passed for
<em>len</em>, then the whole length of the <em>skb</em> is pulled.</p>
<p>This helper is only needed for reading and writing with direct
packet access.</p>
<p>For direct packet access, testing that offsets to access
are within packet boundaries (test on <em>skb</em><strong>-&gt;data_end</strong>) is
susceptible to fail if offsets are invalid, or if the requested
data is in non-linear parts of the <em>skb</em>. On failure the
program can just bail out, or in the case of a non-linear
buffer, use a helper to make the data available. The
<strong>bpf_skb_load_bytes</strong>() helper is a first solution to access
the data. Another one consists in using <strong>bpf_skb_pull_data</strong>
to pull in once the non-linear parts, then retesting and
eventually access the data.</p>
<p>At the same time, this also makes sure the <em>skb</em> is uncloned,
which is a necessary condition for direct write. As this needs
to be an invariant for the write part only, the verifier
detects writes and adds a prologue that is calling
<strong>bpf_skb_pull_data()</strong> to effectively unclone the <em>skb</em> from
the very beginning in case it is indeed cloned.</p>
<p>A call to this helper is susceptible to change the underlying
packet buffer. Therefore, at load time, all checks on pointers
previously done by the verifier are invalidated and must be
performed again, if the helper is used in combination with
direct packet access.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>s64 bpf_csum_update(struct sk_buff *</strong><em>skb</em><strong>, __wsum</strong> <em>csum</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Add the checksum <em>csum</em> into <em>skb</em><strong>-&gt;csum</strong> in case the
driver has supplied a checksum for the entire packet into that
field. Return an error otherwise. This helper is intended to be
used in combination with <strong>bpf_csum_diff</strong>(), in particular
when the checksum needs to be updated after data has been
written into the packet through direct packet access.</p>
</dd>
<dt>Return</dt><dd><p>The checksum on success, or a negative error code in case of
failure.</p>
</dd>
</dl>
</dd>
<dt><strong>void bpf_set_hash_invalid(struct sk_buff *</strong><em>skb</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Invalidate the current <em>skb</em><strong>-&gt;hash</strong>. It can be used after
mangling on headers through direct packet access, in order to
indicate that the hash is outdated and to trigger a
recalculation the next time the kernel tries to access this
hash or when the <strong>bpf_get_hash_recalc</strong>() helper is called.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_get_numa_node_id(void)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Return the id of the current NUMA node. The primary use case
for this helper is the selection of sockets for the local NUMA
node, when the program is attached to sockets using the
<strong>SO_ATTACH_REUSEPORT_EBPF</strong> option (see also <strong>socket(7)</strong>),
but the helper is also available to other eBPF program types,
similarly to <strong>bpf_get_smp_processor_id</strong>().</p>
</dd>
<dt>Return</dt><dd><p>The id of current NUMA node.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_skb_change_head(struct sk_buff *</strong><em>skb</em><strong>, u32</strong> <em>len</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Grows headroom of packet associated to <em>skb</em> and adjusts the
offset of the MAC header accordingly, adding <em>len</em> bytes of
space. It automatically extends and reallocates memory as
required.</p>
<p>This helper can be used on a layer 3 <em>skb</em> to push a MAC header
for redirection into a layer 2 device.</p>
<p>All values for <em>flags</em> are reserved for future usage, and must
be left at zero.</p>
<p>A call to this helper is susceptible to change the underlying
packet buffer. Therefore, at load time, all checks on pointers
previously done by the verifier are invalidated and must be
performed again, if the helper is used in combination with
direct packet access.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_xdp_adjust_head(struct xdp_buff *</strong><em>xdp_md</em><strong>, int</strong> <em>delta</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Adjust (move) <em>xdp_md</em><strong>-&gt;data</strong> by <em>delta</em> bytes. Note that
it is possible to use a negative value for <em>delta</em>. This helper
can be used to prepare the packet for pushing or popping
headers.</p>
<p>A call to this helper is susceptible to change the underlying
packet buffer. Therefore, at load time, all checks on pointers
previously done by the verifier are invalidated and must be
performed again, if the helper is used in combination with
direct packet access.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_probe_read_str(void *</strong><em>dst</em><strong>, u32</strong> <em>size</em><strong>, const void *</strong><em>unsafe_ptr</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Copy a NUL terminated string from an unsafe kernel address
<em>unsafe_ptr</em> to <em>dst</em>. See <strong>bpf_probe_read_kernel_str</strong>() for
more details.</p>
<p>Generally, use <strong>bpf_probe_read_user_str</strong>() or
<strong>bpf_probe_read_kernel_str</strong>() instead.</p>
</dd>
<dt>Return</dt><dd><p>On success, the strictly positive length of the string,
including the trailing NUL character. On error, a negative
value.</p>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_get_socket_cookie(struct sk_buff *</strong><em>skb</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>If the <strong>struct sk_buff</strong> pointed by <em>skb</em> has a known socket,
retrieve the cookie (generated by the kernel) of this socket.
If no cookie has been set yet, generate a new cookie. Once
generated, the socket cookie remains stable for the life of the
socket. This helper can be useful for monitoring per socket
networking traffic statistics as it provides a global socket
identifier that can be assumed unique.</p>
</dd>
<dt>Return</dt><dd><p>A 8-byte long unique number on success, or 0 if the socket
field is missing inside <em>skb</em>.</p>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_get_socket_cookie(struct bpf_sock_addr *</strong><em>ctx</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Equivalent to bpf_get_socket_cookie() helper that accepts
<em>skb</em>, but gets socket from <strong>struct bpf_sock_addr</strong> context.</p>
</dd>
<dt>Return</dt><dd><p>A 8-byte long unique number.</p>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_get_socket_cookie(struct bpf_sock_ops *</strong><em>ctx</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Equivalent to <strong>bpf_get_socket_cookie</strong>() helper that accepts
<em>skb</em>, but gets socket from <strong>struct bpf_sock_ops</strong> context.</p>
</dd>
<dt>Return</dt><dd><p>A 8-byte long unique number.</p>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_get_socket_cookie(struct sock *</strong><em>sk</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Equivalent to <strong>bpf_get_socket_cookie</strong>() helper that accepts
<em>sk</em>, but gets socket from a BTF <strong>struct sock</strong>. This helper
also works for sleepable programs.</p>
</dd>
<dt>Return</dt><dd><p>A 8-byte long unique number or 0 if <em>sk</em> is NULL.</p>
</dd>
</dl>
</dd>
<dt><strong>u32 bpf_get_socket_uid(struct sk_buff *</strong><em>skb</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Return</dt><dd><p>The owner UID of the socket associated to <em>skb</em>. If the socket
is <strong>NULL</strong>, or if it is not a full socket (i.e. if it is a
time-wait or a request socket instead), <strong>overflowuid</strong> value
is returned (note that <strong>overflowuid</strong> might also be the actual
UID value for the socket).</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_set_hash(struct sk_buff *</strong><em>skb</em><strong>, u32</strong> <em>hash</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Set the full hash for <em>skb</em> (set the field <em>skb</em><strong>-&gt;hash</strong>)
to value <em>hash</em>.</p>
</dd>
<dt>Return</dt><dd><p>0</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_setsockopt(void *</strong><em>bpf_socket</em><strong>, int</strong> <em>level</em><strong>, int</strong> <em>optname</em><strong>, void *</strong><em>optval</em><strong>, int</strong> <em>optlen</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Emulate a call to <strong>setsockopt()</strong> on the socket associated to
<em>bpf_socket</em>, which must be a full socket. The <em>level</em> at
which the option resides and the name <em>optname</em> of the option
must be specified, see <strong>setsockopt(2)</strong> for more information.
The option value of length <em>optlen</em> is pointed by <em>optval</em>.</p>
<p><em>bpf_socket</em> should be one of the following:</p>
<ul class="simple">
<li><p><strong>struct bpf_sock_ops</strong> for <strong>BPF_PROG_TYPE_SOCK_OPS</strong>.</p></li>
<li><p><strong>struct bpf_sock_addr</strong> for <strong>BPF_CGROUP_INET4_CONNECT</strong>
and <strong>BPF_CGROUP_INET6_CONNECT</strong>.</p></li>
</ul>
<p>This helper actually implements a subset of <strong>setsockopt()</strong>.
It supports the following <em>level</em>s:</p>
<ul class="simple">
<li><p><strong>SOL_SOCKET</strong>, which supports the following <em>optname</em>s:
<strong>SO_RCVBUF</strong>, <strong>SO_SNDBUF</strong>, <strong>SO_MAX_PACING_RATE</strong>,
<strong>SO_PRIORITY</strong>, <strong>SO_RCVLOWAT</strong>, <strong>SO_MARK</strong>,
<strong>SO_BINDTODEVICE</strong>, <strong>SO_KEEPALIVE</strong>.</p></li>
<li><p><strong>IPPROTO_TCP</strong>, which supports the following <em>optname</em>s:
<strong>TCP_CONGESTION</strong>, <strong>TCP_BPF_IW</strong>,
<strong>TCP_BPF_SNDCWND_CLAMP</strong>, <strong>TCP_SAVE_SYN</strong>,
<strong>TCP_KEEPIDLE</strong>, <strong>TCP_KEEPINTVL</strong>, <strong>TCP_KEEPCNT</strong>,
<strong>TCP_SYNCNT</strong>, <strong>TCP_USER_TIMEOUT</strong>, <strong>TCP_NOTSENT_LOWAT</strong>.</p></li>
<li><p><strong>IPPROTO_IP</strong>, which supports <em>optname</em> <strong>IP_TOS</strong>.</p></li>
<li><p><strong>IPPROTO_IPV6</strong>, which supports <em>optname</em> <strong>IPV6_TCLASS</strong>.</p></li>
</ul>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_skb_adjust_room(struct sk_buff *</strong><em>skb</em><strong>, s32</strong> <em>len_diff</em><strong>, u32</strong> <em>mode</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Grow or shrink the room for data in the packet associated to
<em>skb</em> by <em>len_diff</em>, and according to the selected <em>mode</em>.</p>
<p>By default, the helper will reset any offloaded checksum
indicator of the skb to CHECKSUM_NONE. This can be avoided
by the following flag:</p>
<ul class="simple">
<li><p><strong>BPF_F_ADJ_ROOM_NO_CSUM_RESET</strong>: Do not reset offloaded
checksum data of the skb to CHECKSUM_NONE.</p></li>
</ul>
<p>There are two supported modes at this time:</p>
<ul class="simple">
<li><p><strong>BPF_ADJ_ROOM_MAC</strong>: Adjust room at the mac layer
(room space is added or removed below the layer 2 header).</p></li>
<li><p><strong>BPF_ADJ_ROOM_NET</strong>: Adjust room at the network layer
(room space is added or removed below the layer 3 header).</p></li>
</ul>
<p>The following flags are supported at this time:</p>
<ul class="simple">
<li><p><strong>BPF_F_ADJ_ROOM_FIXED_GSO</strong>: Do not adjust gso_size.
Adjusting mss in this way is not allowed for datagrams.</p></li>
<li><p><strong>BPF_F_ADJ_ROOM_ENCAP_L3_IPV4</strong>,
<strong>BPF_F_ADJ_ROOM_ENCAP_L3_IPV6</strong>:
Any new space is reserved to hold a tunnel header.
Configure skb offsets and other fields accordingly.</p></li>
<li><p><strong>BPF_F_ADJ_ROOM_ENCAP_L4_GRE</strong>,
<strong>BPF_F_ADJ_ROOM_ENCAP_L4_UDP</strong>:
Use with ENCAP_L3 flags to further specify the tunnel type.</p></li>
<li><p><strong>BPF_F_ADJ_ROOM_ENCAP_L2</strong>(<em>len</em>):
Use with ENCAP_L3/L4 flags to further specify the tunnel
type; <em>len</em> is the length of the inner MAC header.</p></li>
<li><p><strong>BPF_F_ADJ_ROOM_ENCAP_L2_ETH</strong>:
Use with BPF_F_ADJ_ROOM_ENCAP_L2 flag to further specify the
L2 type as Ethernet.</p></li>
</ul>
<p>A call to this helper is susceptible to change the underlying
packet buffer. Therefore, at load time, all checks on pointers
previously done by the verifier are invalidated and must be
performed again, if the helper is used in combination with
direct packet access.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_redirect_map(struct bpf_map *</strong><em>map</em><strong>, u32</strong> <em>key</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Redirect the packet to the endpoint referenced by <em>map</em> at
index <em>key</em>. Depending on its type, this <em>map</em> can contain
references to net devices (for forwarding packets through other
ports), or to CPUs (for redirecting XDP frames to another CPU;
but this is only implemented for native XDP (with driver
support) as of this writing).</p>
<p>The lower two bits of <em>flags</em> are used as the return code if
the map lookup fails. This is so that the return value can be
one of the XDP program return codes up to <strong>XDP_TX</strong>, as chosen
by the caller. The higher bits of <em>flags</em> can be set to
BPF_F_BROADCAST or BPF_F_EXCLUDE_INGRESS as defined below.</p>
<p>With BPF_F_BROADCAST the packet will be broadcasted to all the
interfaces in the map, with BPF_F_EXCLUDE_INGRESS the ingress
interface will be excluded when do broadcasting.</p>
<p>See also <strong>bpf_redirect</strong>(), which only supports redirecting
to an ifindex, but doesn’t require a map to do so.</p>
</dd>
<dt>Return</dt><dd><p><strong>XDP_REDIRECT</strong> on success, or the value of the two lower bits
of the <em>flags</em> argument on error.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_sk_redirect_map(struct sk_buff *</strong><em>skb</em><strong>, struct bpf_map *</strong><em>map</em><strong>, u32</strong> <em>key</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Redirect the packet to the socket referenced by <em>map</em> (of type
<strong>BPF_MAP_TYPE_SOCKMAP</strong>) at index <em>key</em>. Both ingress and
egress interfaces can be used for redirection. The
<strong>BPF_F_INGRESS</strong> value in <em>flags</em> is used to make the
distinction (ingress path is selected if the flag is present,
egress path otherwise). This is the only flag supported for now.</p>
</dd>
<dt>Return</dt><dd><p><strong>SK_PASS</strong> on success, or <strong>SK_DROP</strong> on error.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_sock_map_update(struct bpf_sock_ops *</strong><em>skops</em><strong>, struct bpf_map *</strong><em>map</em><strong>, void *</strong><em>key</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Add an entry to, or update a <em>map</em> referencing sockets. The
<em>skops</em> is used as a new value for the entry associated to
<em>key</em>. <em>flags</em> is one of:</p>
<dl class="simple">
<dt><strong>BPF_NOEXIST</strong></dt><dd><p>The entry for <em>key</em> must not exist in the map.</p>
</dd>
<dt><strong>BPF_EXIST</strong></dt><dd><p>The entry for <em>key</em> must already exist in the map.</p>
</dd>
<dt><strong>BPF_ANY</strong></dt><dd><p>No condition on the existence of the entry for <em>key</em>.</p>
</dd>
</dl>
<p>If the <em>map</em> has eBPF programs (parser and verdict), those will
be inherited by the socket being added. If the socket is
already attached to eBPF programs, this results in an error.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_xdp_adjust_meta(struct xdp_buff *</strong><em>xdp_md</em><strong>, int</strong> <em>delta</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Adjust the address pointed by <em>xdp_md</em><strong>-&gt;data_meta</strong> by
<em>delta</em> (which can be positive or negative). Note that this
operation modifies the address stored in <em>xdp_md</em><strong>-&gt;data</strong>,
so the latter must be loaded only after the helper has been
called.</p>
<p>The use of <em>xdp_md</em><strong>-&gt;data_meta</strong> is optional and programs
are not required to use it. The rationale is that when the
packet is processed with XDP (e.g. as DoS filter), it is
possible to push further meta data along with it before passing
to the stack, and to give the guarantee that an ingress eBPF
program attached as a TC classifier on the same device can pick
this up for further post-processing. Since TC works with socket
buffers, it remains possible to set from XDP the <strong>mark</strong> or
<strong>priority</strong> pointers, or other pointers for the socket buffer.
Having this scratch space generic and programmable allows for
more flexibility as the user is free to store whatever meta
data they need.</p>
<p>A call to this helper is susceptible to change the underlying
packet buffer. Therefore, at load time, all checks on pointers
previously done by the verifier are invalidated and must be
performed again, if the helper is used in combination with
direct packet access.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_perf_event_read_value(struct bpf_map *</strong><em>map</em><strong>, u64</strong> <em>flags</em><strong>, struct bpf_perf_event_value *</strong><em>buf</em><strong>, u32</strong> <em>buf_size</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Read the value of a perf event counter, and store it into <em>buf</em>
of size <em>buf_size</em>. This helper relies on a <em>map</em> of type
<strong>BPF_MAP_TYPE_PERF_EVENT_ARRAY</strong>. The nature of the perf event
counter is selected when <em>map</em> is updated with perf event file
descriptors. The <em>map</em> is an array whose size is the number of
available CPUs, and each cell contains a value relative to one
CPU. The value to retrieve is indicated by <em>flags</em>, that
contains the index of the CPU to look up, masked with
<strong>BPF_F_INDEX_MASK</strong>. Alternatively, <em>flags</em> can be set to
<strong>BPF_F_CURRENT_CPU</strong> to indicate that the value for the
current CPU should be retrieved.</p>
<p>This helper behaves in a way close to
<strong>bpf_perf_event_read</strong>() helper, save that instead of
just returning the value observed, it fills the <em>buf</em>
structure. This allows for additional data to be retrieved: in
particular, the enabled and running times (in <em>buf</em><strong>-&gt;enabled</strong> and <em>buf</em><strong>-&gt;running</strong>, respectively) are
copied. In general, <strong>bpf_perf_event_read_value</strong>() is
recommended over <strong>bpf_perf_event_read</strong>(), which has some
ABI issues and provides fewer functionalities.</p>
<p>These values are interesting, because hardware PMU (Performance
Monitoring Unit) counters are limited resources. When there are
more PMU based perf events opened than available counters,
kernel will multiplex these events so each event gets certain
percentage (but not all) of the PMU time. In case that
multiplexing happens, the number of samples or counter value
will not reflect the case compared to when no multiplexing
occurs. This makes comparison between different runs difficult.
Typically, the counter value should be normalized before
comparing to other experiments. The usual normalization is done
as follows.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">normalized_counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">*</span> <span class="n">t_enabled</span> <span class="o">/</span> <span class="n">t_running</span>
</pre></div>
</div>
<p>Where t_enabled is the time enabled for event and t_running is
the time running for event since last normalization. The
enabled and running times are accumulated since the perf event
open. To achieve scaling factor between two invocations of an
eBPF program, users can use CPU id as the key (which is
typical for perf array usage model) to remember the previous
value and do the calculation inside the eBPF program.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_perf_prog_read_value(struct bpf_perf_event_data *</strong><em>ctx</em><strong>, struct bpf_perf_event_value *</strong><em>buf</em><strong>, u32</strong> <em>buf_size</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>For en eBPF program attached to a perf event, retrieve the
value of the event counter associated to <em>ctx</em> and store it in
the structure pointed by <em>buf</em> and of size <em>buf_size</em>. Enabled
and running times are also stored in the structure (see
description of helper <strong>bpf_perf_event_read_value</strong>() for
more details).</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_getsockopt(void *</strong><em>bpf_socket</em><strong>, int</strong> <em>level</em><strong>, int</strong> <em>optname</em><strong>, void *</strong><em>optval</em><strong>, int</strong> <em>optlen</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Emulate a call to <strong>getsockopt()</strong> on the socket associated to
<em>bpf_socket</em>, which must be a full socket. The <em>level</em> at
which the option resides and the name <em>optname</em> of the option
must be specified, see <strong>getsockopt(2)</strong> for more information.
The retrieved value is stored in the structure pointed by
<em>opval</em> and of length <em>optlen</em>.</p>
<p><em>bpf_socket</em> should be one of the following:</p>
<ul class="simple">
<li><p><strong>struct bpf_sock_ops</strong> for <strong>BPF_PROG_TYPE_SOCK_OPS</strong>.</p></li>
<li><p><strong>struct bpf_sock_addr</strong> for <strong>BPF_CGROUP_INET4_CONNECT</strong>
and <strong>BPF_CGROUP_INET6_CONNECT</strong>.</p></li>
</ul>
<p>This helper actually implements a subset of <strong>getsockopt()</strong>.
It supports the following <em>level</em>s:</p>
<ul class="simple">
<li><p><strong>IPPROTO_TCP</strong>, which supports <em>optname</em>
<strong>TCP_CONGESTION</strong>.</p></li>
<li><p><strong>IPPROTO_IP</strong>, which supports <em>optname</em> <strong>IP_TOS</strong>.</p></li>
<li><p><strong>IPPROTO_IPV6</strong>, which supports <em>optname</em> <strong>IPV6_TCLASS</strong>.</p></li>
</ul>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_override_return(struct pt_regs *</strong><em>regs</em><strong>, u64</strong> <em>rc</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Used for error injection, this helper uses kprobes to override
the return value of the probed function, and to set it to <em>rc</em>.
The first argument is the context <em>regs</em> on which the kprobe
works.</p>
<p>This helper works by setting the PC (program counter)
to an override function which is run in place of the original
probed function. This means the probed function is not run at
all. The replacement function just returns with the required
value.</p>
<p>This helper has security implications, and thus is subject to
restrictions. It is only available if the kernel was compiled
with the <strong>CONFIG_BPF_KPROBE_OVERRIDE</strong> configuration
option, and in this case it only works on functions tagged with
<strong>ALLOW_ERROR_INJECTION</strong> in the kernel code.</p>
<p>Also, the helper is only available for the architectures having
the CONFIG_FUNCTION_ERROR_INJECTION option. As of this writing,
x86 architecture is the only one to support this feature.</p>
</dd>
<dt>Return</dt><dd><p>0</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_sock_ops_cb_flags_set(struct bpf_sock_ops *</strong><em>bpf_sock</em><strong>, int</strong> <em>argval</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Attempt to set the value of the <strong>bpf_sock_ops_cb_flags</strong> field
for the full TCP socket associated to <em>bpf_sock_ops</em> to
<em>argval</em>.</p>
<p>The primary use of this field is to determine if there should
be calls to eBPF programs of type
<strong>BPF_PROG_TYPE_SOCK_OPS</strong> at various points in the TCP
code. A program of the same type can change its value, per
connection and as necessary, when the connection is
established. This field is directly accessible for reading, but
this helper must be used for updates in order to return an
error if an eBPF program tries to set a callback that is not
supported in the current kernel.</p>
<p><em>argval</em> is a flag array which can combine these flags:</p>
<ul class="simple">
<li><p><strong>BPF_SOCK_OPS_RTO_CB_FLAG</strong> (retransmission time out)</p></li>
<li><p><strong>BPF_SOCK_OPS_RETRANS_CB_FLAG</strong> (retransmission)</p></li>
<li><p><strong>BPF_SOCK_OPS_STATE_CB_FLAG</strong> (TCP state change)</p></li>
<li><p><strong>BPF_SOCK_OPS_RTT_CB_FLAG</strong> (every RTT)</p></li>
</ul>
<p>Therefore, this function can be used to clear a callback flag by
setting the appropriate bit to zero. e.g. to disable the RTO
callback:</p>
<dl class="simple">
<dt><strong>bpf_sock_ops_cb_flags_set(bpf_sock,</strong></dt><dd><p><strong>bpf_sock-&gt;bpf_sock_ops_cb_flags &amp; ~BPF_SOCK_OPS_RTO_CB_FLAG)</strong></p>
</dd>
</dl>
<p>Here are some examples of where one could call such eBPF
program:</p>
<ul class="simple">
<li><p>When RTO fires.</p></li>
<li><p>When a packet is retransmitted.</p></li>
<li><p>When the connection terminates.</p></li>
<li><p>When a packet is sent.</p></li>
<li><p>When a packet is received.</p></li>
</ul>
</dd>
<dt>Return</dt><dd><p>Code <strong>-EINVAL</strong> if the socket is not a full TCP socket;
otherwise, a positive number containing the bits that could not
be set is returned (which comes down to 0 if all bits were set
as required).</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_msg_redirect_map(struct sk_msg_buff *</strong><em>msg</em><strong>, struct bpf_map *</strong><em>map</em><strong>, u32</strong> <em>key</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>This helper is used in programs implementing policies at the
socket level. If the message <em>msg</em> is allowed to pass (i.e. if
the verdict eBPF program returns <strong>SK_PASS</strong>), redirect it to
the socket referenced by <em>map</em> (of type
<strong>BPF_MAP_TYPE_SOCKMAP</strong>) at index <em>key</em>. Both ingress and
egress interfaces can be used for redirection. The
<strong>BPF_F_INGRESS</strong> value in <em>flags</em> is used to make the
distinction (ingress path is selected if the flag is present,
egress path otherwise). This is the only flag supported for now.</p>
</dd>
<dt>Return</dt><dd><p><strong>SK_PASS</strong> on success, or <strong>SK_DROP</strong> on error.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_msg_apply_bytes(struct sk_msg_buff *</strong><em>msg</em><strong>, u32</strong> <em>bytes</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>For socket policies, apply the verdict of the eBPF program to
the next <em>bytes</em> (number of bytes) of message <em>msg</em>.</p>
<p>For example, this helper can be used in the following cases:</p>
<ul class="simple">
<li><p>A single <strong>sendmsg</strong>() or <strong>sendfile</strong>() system call
contains multiple logical messages that the eBPF program is
supposed to read and for which it should apply a verdict.</p></li>
<li><p>An eBPF program only cares to read the first <em>bytes</em> of a
<em>msg</em>. If the message has a large payload, then setting up
and calling the eBPF program repeatedly for all bytes, even
though the verdict is already known, would create unnecessary
overhead.</p></li>
</ul>
<p>When called from within an eBPF program, the helper sets a
counter internal to the BPF infrastructure, that is used to
apply the last verdict to the next <em>bytes</em>. If <em>bytes</em> is
smaller than the current data being processed from a
<strong>sendmsg</strong>() or <strong>sendfile</strong>() system call, the first
<em>bytes</em> will be sent and the eBPF program will be re-run with
the pointer for start of data pointing to byte number <em>bytes</em>
<strong>+ 1</strong>. If <em>bytes</em> is larger than the current data being
processed, then the eBPF verdict will be applied to multiple
<strong>sendmsg</strong>() or <strong>sendfile</strong>() calls until <em>bytes</em> are
consumed.</p>
<p>Note that if a socket closes with the internal counter holding
a non-zero value, this is not a problem because data is not
being buffered for <em>bytes</em> and is sent as it is received.</p>
</dd>
<dt>Return</dt><dd><p>0</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_msg_cork_bytes(struct sk_msg_buff *</strong><em>msg</em><strong>, u32</strong> <em>bytes</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>For socket policies, prevent the execution of the verdict eBPF
program for message <em>msg</em> until <em>bytes</em> (byte number) have been
accumulated.</p>
<p>This can be used when one needs a specific number of bytes
before a verdict can be assigned, even if the data spans
multiple <strong>sendmsg</strong>() or <strong>sendfile</strong>() calls. The extreme
case would be a user calling <strong>sendmsg</strong>() repeatedly with
1-byte long message segments. Obviously, this is bad for
performance, but it is still valid. If the eBPF program needs
<em>bytes</em> bytes to validate a header, this helper can be used to
prevent the eBPF program to be called again until <em>bytes</em> have
been accumulated.</p>
</dd>
<dt>Return</dt><dd><p>0</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_msg_pull_data(struct sk_msg_buff *</strong><em>msg</em><strong>, u32</strong> <em>start</em><strong>, u32</strong> <em>end</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>For socket policies, pull in non-linear data from user space
for <em>msg</em> and set pointers <em>msg</em><strong>-&gt;data</strong> and <em>msg</em><strong>-&gt;data_end</strong> to <em>start</em> and <em>end</em> bytes offsets into <em>msg</em>,
respectively.</p>
<p>If a program of type <strong>BPF_PROG_TYPE_SK_MSG</strong> is run on a
<em>msg</em> it can only parse data that the (<strong>data</strong>, <strong>data_end</strong>)
pointers have already consumed. For <strong>sendmsg</strong>() hooks this
is likely the first scatterlist element. But for calls relying
on the <strong>sendpage</strong> handler (e.g. <strong>sendfile</strong>()) this will
be the range (<strong>0</strong>, <strong>0</strong>) because the data is shared with
user space and by default the objective is to avoid allowing
user space to modify data while (or after) eBPF verdict is
being decided. This helper can be used to pull in data and to
set the start and end pointer to given values. Data will be
copied if necessary (i.e. if data was not linear and if start
and end pointers do not point to the same chunk).</p>
<p>A call to this helper is susceptible to change the underlying
packet buffer. Therefore, at load time, all checks on pointers
previously done by the verifier are invalidated and must be
performed again, if the helper is used in combination with
direct packet access.</p>
<p>All values for <em>flags</em> are reserved for future usage, and must
be left at zero.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_bind(struct bpf_sock_addr *</strong><em>ctx</em><strong>, struct sockaddr *</strong><em>addr</em><strong>, int</strong> <em>addr_len</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Bind the socket associated to <em>ctx</em> to the address pointed by
<em>addr</em>, of length <em>addr_len</em>. This allows for making outgoing
connection from the desired IP address, which can be useful for
example when all processes inside a cgroup should use one
single IP address on a host that has multiple IP configured.</p>
<p>This helper works for IPv4 and IPv6, TCP and UDP sockets. The
domain (<em>addr</em><strong>-&gt;sa_family</strong>) must be <strong>AF_INET</strong> (or
<strong>AF_INET6</strong>). It’s advised to pass zero port (<strong>sin_port</strong>
or <strong>sin6_port</strong>) which triggers IP_BIND_ADDRESS_NO_PORT-like
behavior and lets the kernel efficiently pick up an unused
port as long as 4-tuple is unique. Passing non-zero port might
lead to degraded performance.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_xdp_adjust_tail(struct xdp_buff *</strong><em>xdp_md</em><strong>, int</strong> <em>delta</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Adjust (move) <em>xdp_md</em><strong>-&gt;data_end</strong> by <em>delta</em> bytes. It is
possible to both shrink and grow the packet tail.
Shrink done via <em>delta</em> being a negative integer.</p>
<p>A call to this helper is susceptible to change the underlying
packet buffer. Therefore, at load time, all checks on pointers
previously done by the verifier are invalidated and must be
performed again, if the helper is used in combination with
direct packet access.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_skb_get_xfrm_state(struct sk_buff *</strong><em>skb</em><strong>, u32</strong> <em>index</em><strong>, struct bpf_xfrm_state *</strong><em>xfrm_state</em><strong>, u32</strong> <em>size</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Retrieve the XFRM state (IP transform framework, see also
<strong>ip-xfrm(8)</strong>) at <em>index</em> in XFRM “security path” for <em>skb</em>.</p>
<p>The retrieved value is stored in the <strong>struct bpf_xfrm_state</strong>
pointed by <em>xfrm_state</em> and of length <em>size</em>.</p>
<p>All values for <em>flags</em> are reserved for future usage, and must
be left at zero.</p>
<p>This helper is available only if the kernel was compiled with
<strong>CONFIG_XFRM</strong> configuration option.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_get_stack(void *</strong><em>ctx</em><strong>, void *</strong><em>buf</em><strong>, u32</strong> <em>size</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Return a user or a kernel stack in bpf program provided buffer.
To achieve this, the helper needs <em>ctx</em>, which is a pointer
to the context on which the tracing program is executed.
To store the stacktrace, the bpf program provides <em>buf</em> with
a nonnegative <em>size</em>.</p>
<p>The last argument, <em>flags</em>, holds the number of stack frames to
skip (from 0 to 255), masked with
<strong>BPF_F_SKIP_FIELD_MASK</strong>. The next bits can be used to set
the following flags:</p>
<dl class="simple">
<dt><strong>BPF_F_USER_STACK</strong></dt><dd><p>Collect a user space stack instead of a kernel stack.</p>
</dd>
<dt><strong>BPF_F_USER_BUILD_ID</strong></dt><dd><p>Collect buildid+offset instead of ips for user stack,
only valid if <strong>BPF_F_USER_STACK</strong> is also specified.</p>
</dd>
</dl>
<p><strong>bpf_get_stack</strong>() can collect up to
<strong>PERF_MAX_STACK_DEPTH</strong> both kernel and user frames, subject
to sufficient large buffer size. Note that
this limit can be controlled with the <strong>sysctl</strong> program, and
that it should be manually increased in order to profile long
user stacks (such as stacks for Java programs). To do so, use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># sysctl kernel.perf_event_max_stack=&lt;new value&gt;</span>
</pre></div>
</div>
</dd>
<dt>Return</dt><dd><p>A non-negative value equal to or less than <em>size</em> on success,
or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_skb_load_bytes_relative(const void *</strong><em>skb</em><strong>, u32</strong> <em>offset</em><strong>, void *</strong><em>to</em><strong>, u32</strong> <em>len</em><strong>, u32</strong> <em>start_header</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>This helper is similar to <strong>bpf_skb_load_bytes</strong>() in that
it provides an easy way to load <em>len</em> bytes from <em>offset</em>
from the packet associated to <em>skb</em>, into the buffer pointed
by <em>to</em>. The difference to <strong>bpf_skb_load_bytes</strong>() is that
a fifth argument <em>start_header</em> exists in order to select a
base offset to start from. <em>start_header</em> can be one of:</p>
<dl class="simple">
<dt><strong>BPF_HDR_START_MAC</strong></dt><dd><p>Base offset to load data from is <em>skb</em>’s mac header.</p>
</dd>
<dt><strong>BPF_HDR_START_NET</strong></dt><dd><p>Base offset to load data from is <em>skb</em>’s network header.</p>
</dd>
</dl>
<p>In general, “direct packet access” is the preferred method to
access packet data, however, this helper is in particular useful
in socket filters where <em>skb</em><strong>-&gt;data</strong> does not always point
to the start of the mac header and where “direct packet access”
is not available.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_fib_lookup(void *</strong><em>ctx</em><strong>, struct bpf_fib_lookup *</strong><em>params</em><strong>, int</strong> <em>plen</em><strong>, u32</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Do FIB lookup in kernel tables using parameters in <em>params</em>.
If lookup is successful and result shows packet is to be
forwarded, the neighbor tables are searched for the nexthop.
If successful (ie., FIB lookup shows forwarding and nexthop
is resolved), the nexthop address is returned in ipv4_dst
or ipv6_dst based on family, smac is set to mac address of
egress device, dmac is set to nexthop mac address, rt_metric
is set to metric from route (IPv4/IPv6 only), and ifindex
is set to the device index of the nexthop from the FIB lookup.</p>
<p><em>plen</em> argument is the size of the passed in struct.
<em>flags</em> argument can be a combination of one or more of the
following values:</p>
<dl class="simple">
<dt><strong>BPF_FIB_LOOKUP_DIRECT</strong></dt><dd><p>Do a direct table lookup vs full lookup using FIB
rules.</p>
</dd>
<dt><strong>BPF_FIB_LOOKUP_OUTPUT</strong></dt><dd><p>Perform lookup from an egress perspective (default is
ingress).</p>
</dd>
</dl>
<p><em>ctx</em> is either <strong>struct xdp_md</strong> for XDP programs or
<strong>struct sk_buff</strong> tc cls_act programs.</p>
</dd>
<dt>Return</dt><dd><ul class="simple">
<li><p>&lt; 0 if any input argument is invalid</p></li>
<li><p>0 on success (packet is forwarded, nexthop neighbor exists)</p></li>
<li><p>&gt; 0 one of <strong>BPF_FIB_LKUP_RET_</strong> codes explaining why the
packet is not forwarded or needs assist from full stack</p></li>
</ul>
<p>If lookup fails with BPF_FIB_LKUP_RET_FRAG_NEEDED, then the MTU
was exceeded and output params-&gt;mtu_result contains the MTU.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_sock_hash_update(struct bpf_sock_ops *</strong><em>skops</em><strong>, struct bpf_map *</strong><em>map</em><strong>, void *</strong><em>key</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Add an entry to, or update a sockhash <em>map</em> referencing sockets.
The <em>skops</em> is used as a new value for the entry associated to
<em>key</em>. <em>flags</em> is one of:</p>
<dl class="simple">
<dt><strong>BPF_NOEXIST</strong></dt><dd><p>The entry for <em>key</em> must not exist in the map.</p>
</dd>
<dt><strong>BPF_EXIST</strong></dt><dd><p>The entry for <em>key</em> must already exist in the map.</p>
</dd>
<dt><strong>BPF_ANY</strong></dt><dd><p>No condition on the existence of the entry for <em>key</em>.</p>
</dd>
</dl>
<p>If the <em>map</em> has eBPF programs (parser and verdict), those will
be inherited by the socket being added. If the socket is
already attached to eBPF programs, this results in an error.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_msg_redirect_hash(struct sk_msg_buff *</strong><em>msg</em><strong>, struct bpf_map *</strong><em>map</em><strong>, void *</strong><em>key</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>This helper is used in programs implementing policies at the
socket level. If the message <em>msg</em> is allowed to pass (i.e. if
the verdict eBPF program returns <strong>SK_PASS</strong>), redirect it to
the socket referenced by <em>map</em> (of type
<strong>BPF_MAP_TYPE_SOCKHASH</strong>) using hash <em>key</em>. Both ingress and
egress interfaces can be used for redirection. The
<strong>BPF_F_INGRESS</strong> value in <em>flags</em> is used to make the
distinction (ingress path is selected if the flag is present,
egress path otherwise). This is the only flag supported for now.</p>
</dd>
<dt>Return</dt><dd><p><strong>SK_PASS</strong> on success, or <strong>SK_DROP</strong> on error.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_sk_redirect_hash(struct sk_buff *</strong><em>skb</em><strong>, struct bpf_map *</strong><em>map</em><strong>, void *</strong><em>key</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>This helper is used in programs implementing policies at the
skb socket level. If the sk_buff <em>skb</em> is allowed to pass (i.e.
if the verdict eBPF program returns <strong>SK_PASS</strong>), redirect it
to the socket referenced by <em>map</em> (of type
<strong>BPF_MAP_TYPE_SOCKHASH</strong>) using hash <em>key</em>. Both ingress and
egress interfaces can be used for redirection. The
<strong>BPF_F_INGRESS</strong> value in <em>flags</em> is used to make the
distinction (ingress path is selected if the flag is present,
egress otherwise). This is the only flag supported for now.</p>
</dd>
<dt>Return</dt><dd><p><strong>SK_PASS</strong> on success, or <strong>SK_DROP</strong> on error.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_lwt_push_encap(struct sk_buff *</strong><em>skb</em><strong>, u32</strong> <em>type</em><strong>, void *</strong><em>hdr</em><strong>, u32</strong> <em>len</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Encapsulate the packet associated to <em>skb</em> within a Layer 3
protocol header. This header is provided in the buffer at
address <em>hdr</em>, with <em>len</em> its size in bytes. <em>type</em> indicates
the protocol of the header and can be one of:</p>
<dl class="simple">
<dt><strong>BPF_LWT_ENCAP_SEG6</strong></dt><dd><p>IPv6 encapsulation with Segment Routing Header
(<strong>struct ipv6_sr_hdr</strong>). <em>hdr</em> only contains the SRH,
the IPv6 header is computed by the kernel.</p>
</dd>
<dt><strong>BPF_LWT_ENCAP_SEG6_INLINE</strong></dt><dd><p>Only works if <em>skb</em> contains an IPv6 packet. Insert a
Segment Routing Header (<strong>struct ipv6_sr_hdr</strong>) inside
the IPv6 header.</p>
</dd>
<dt><strong>BPF_LWT_ENCAP_IP</strong></dt><dd><p>IP encapsulation (GRE/GUE/IPIP/etc). The outer header
must be IPv4 or IPv6, followed by zero or more
additional headers, up to <strong>LWT_BPF_MAX_HEADROOM</strong>
total bytes in all prepended headers. Please note that
if <strong>skb_is_gso</strong>(<em>skb</em>) is true, no more than two
headers can be prepended, and the inner header, if
present, should be either GRE or UDP/GUE.</p>
</dd>
</dl>
<p><strong>BPF_LWT_ENCAP_SEG6</strong>* types can be called by BPF programs
of type <strong>BPF_PROG_TYPE_LWT_IN</strong>; <strong>BPF_LWT_ENCAP_IP</strong> type can
be called by bpf programs of types <strong>BPF_PROG_TYPE_LWT_IN</strong> and
<strong>BPF_PROG_TYPE_LWT_XMIT</strong>.</p>
<p>A call to this helper is susceptible to change the underlying
packet buffer. Therefore, at load time, all checks on pointers
previously done by the verifier are invalidated and must be
performed again, if the helper is used in combination with
direct packet access.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_lwt_seg6_store_bytes(struct sk_buff *</strong><em>skb</em><strong>, u32</strong> <em>offset</em><strong>, const void *</strong><em>from</em><strong>, u32</strong> <em>len</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Store <em>len</em> bytes from address <em>from</em> into the packet
associated to <em>skb</em>, at <em>offset</em>. Only the flags, tag and TLVs
inside the outermost IPv6 Segment Routing Header can be
modified through this helper.</p>
<p>A call to this helper is susceptible to change the underlying
packet buffer. Therefore, at load time, all checks on pointers
previously done by the verifier are invalidated and must be
performed again, if the helper is used in combination with
direct packet access.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_lwt_seg6_adjust_srh(struct sk_buff *</strong><em>skb</em><strong>, u32</strong> <em>offset</em><strong>, s32</strong> <em>delta</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Adjust the size allocated to TLVs in the outermost IPv6
Segment Routing Header contained in the packet associated to
<em>skb</em>, at position <em>offset</em> by <em>delta</em> bytes. Only offsets
after the segments are accepted. <em>delta</em> can be as well
positive (growing) as negative (shrinking).</p>
<p>A call to this helper is susceptible to change the underlying
packet buffer. Therefore, at load time, all checks on pointers
previously done by the verifier are invalidated and must be
performed again, if the helper is used in combination with
direct packet access.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_lwt_seg6_action(struct sk_buff *</strong><em>skb</em><strong>, u32</strong> <em>action</em><strong>, void *</strong><em>param</em><strong>, u32</strong> <em>param_len</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Apply an IPv6 Segment Routing action of type <em>action</em> to the
packet associated to <em>skb</em>. Each action takes a parameter
contained at address <em>param</em>, and of length <em>param_len</em> bytes.
<em>action</em> can be one of:</p>
<dl class="simple">
<dt><strong>SEG6_LOCAL_ACTION_END_X</strong></dt><dd><p>End.X action: Endpoint with Layer-3 cross-connect.
Type of <em>param</em>: <strong>struct in6_addr</strong>.</p>
</dd>
<dt><strong>SEG6_LOCAL_ACTION_END_T</strong></dt><dd><p>End.T action: Endpoint with specific IPv6 table lookup.
Type of <em>param</em>: <strong>int</strong>.</p>
</dd>
<dt><strong>SEG6_LOCAL_ACTION_END_B6</strong></dt><dd><p>End.B6 action: Endpoint bound to an SRv6 policy.
Type of <em>param</em>: <strong>struct ipv6_sr_hdr</strong>.</p>
</dd>
<dt><strong>SEG6_LOCAL_ACTION_END_B6_ENCAP</strong></dt><dd><p>End.B6.Encap action: Endpoint bound to an SRv6
encapsulation policy.
Type of <em>param</em>: <strong>struct ipv6_sr_hdr</strong>.</p>
</dd>
</dl>
<p>A call to this helper is susceptible to change the underlying
packet buffer. Therefore, at load time, all checks on pointers
previously done by the verifier are invalidated and must be
performed again, if the helper is used in combination with
direct packet access.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_rc_repeat(void *</strong><em>ctx</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>This helper is used in programs implementing IR decoding, to
report a successfully decoded repeat key message. This delays
the generation of a key up event for previously generated
key down event.</p>
<p>Some IR protocols like NEC have a special IR message for
repeating last button, for when a button is held down.</p>
<p>The <em>ctx</em> should point to the lirc sample as passed into
the program.</p>
<p>This helper is only available is the kernel was compiled with
the <strong>CONFIG_BPF_LIRC_MODE2</strong> configuration option set to
“<strong>y</strong>”.</p>
</dd>
<dt>Return</dt><dd><p>0</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_rc_keydown(void *</strong><em>ctx</em><strong>, u32</strong> <em>protocol</em><strong>, u64</strong> <em>scancode</em><strong>, u32</strong> <em>toggle</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>This helper is used in programs implementing IR decoding, to
report a successfully decoded key press with <em>scancode</em>,
<em>toggle</em> value in the given <em>protocol</em>. The scancode will be
translated to a keycode using the rc keymap, and reported as
an input key down event. After a period a key up event is
generated. This period can be extended by calling either
<strong>bpf_rc_keydown</strong>() again with the same values, or calling
<strong>bpf_rc_repeat</strong>().</p>
<p>Some protocols include a toggle bit, in case the button was
released and pressed again between consecutive scancodes.</p>
<p>The <em>ctx</em> should point to the lirc sample as passed into
the program.</p>
<p>The <em>protocol</em> is the decoded protocol number (see
<strong>enum rc_proto</strong> for some predefined values).</p>
<p>This helper is only available is the kernel was compiled with
the <strong>CONFIG_BPF_LIRC_MODE2</strong> configuration option set to
“<strong>y</strong>”.</p>
</dd>
<dt>Return</dt><dd><p>0</p>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_skb_cgroup_id(struct sk_buff *</strong><em>skb</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Return the cgroup v2 id of the socket associated with the <em>skb</em>.
This is roughly similar to the <strong>bpf_get_cgroup_classid</strong>()
helper for cgroup v1 by providing a tag resp. identifier that
can be matched on or used for map lookups e.g. to implement
policy. The cgroup v2 id of a given path in the hierarchy is
exposed in user space through the f_handle API in order to get
to the same 64-bit id.</p>
<p>This helper can be used on TC egress path, but not on ingress,
and is available only if the kernel was compiled with the
<strong>CONFIG_SOCK_CGROUP_DATA</strong> configuration option.</p>
</dd>
<dt>Return</dt><dd><p>The id is returned or 0 in case the id could not be retrieved.</p>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_get_current_cgroup_id(void)</strong></dt><dd><dl class="simple">
<dt>Return</dt><dd><p>A 64-bit integer containing the current cgroup id based
on the cgroup within which the current task is running.</p>
</dd>
</dl>
</dd>
<dt><strong>void *bpf_get_local_storage(void *</strong><em>map</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Get the pointer to the local storage area.
The type and the size of the local storage is defined
by the <em>map</em> argument.
The <em>flags</em> meaning is specific for each map type,
and has to be 0 for cgroup local storage.</p>
<p>Depending on the BPF program type, a local storage area
can be shared between multiple instances of the BPF program,
running simultaneously.</p>
<p>A user should care about the synchronization by himself.
For example, by using the <strong>BPF_ATOMIC</strong> instructions to alter
the shared data.</p>
</dd>
<dt>Return</dt><dd><p>A pointer to the local storage area.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_sk_select_reuseport(struct sk_reuseport_md *</strong><em>reuse</em><strong>, struct bpf_map *</strong><em>map</em><strong>, void *</strong><em>key</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Select a <strong>SO_REUSEPORT</strong> socket from a
<strong>BPF_MAP_TYPE_REUSEPORT_SOCKARRAY</strong> <em>map</em>.
It checks the selected socket is matching the incoming
request in the socket buffer.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_skb_ancestor_cgroup_id(struct sk_buff *</strong><em>skb</em><strong>, int</strong> <em>ancestor_level</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Return id of cgroup v2 that is ancestor of cgroup associated
with the <em>skb</em> at the <em>ancestor_level</em>.  The root cgroup is at
<em>ancestor_level</em> zero and each step down the hierarchy
increments the level. If <em>ancestor_level</em> == level of cgroup
associated with <em>skb</em>, then return value will be same as that
of <strong>bpf_skb_cgroup_id</strong>().</p>
<p>The helper is useful to implement policies based on cgroups
that are upper in hierarchy than immediate cgroup associated
with <em>skb</em>.</p>
<p>The format of returned id and helper limitations are same as in
<strong>bpf_skb_cgroup_id</strong>().</p>
</dd>
<dt>Return</dt><dd><p>The id is returned or 0 in case the id could not be retrieved.</p>
</dd>
</dl>
</dd>
<dt><strong>struct bpf_sock *bpf_sk_lookup_tcp(void *</strong><em>ctx</em><strong>, struct bpf_sock_tuple *</strong><em>tuple</em><strong>, u32</strong> <em>tuple_size</em><strong>, u64</strong> <em>netns</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Look for TCP socket matching <em>tuple</em>, optionally in a child
network namespace <em>netns</em>. The return value must be checked,
and if non-<strong>NULL</strong>, released via <strong>bpf_sk_release</strong>().</p>
<p>The <em>ctx</em> should point to the context of the program, such as
the skb or socket (depending on the hook in use). This is used
to determine the base network namespace for the lookup.</p>
<p><em>tuple_size</em> must be one of:</p>
<dl class="simple">
<dt><strong>sizeof</strong>(<em>tuple</em><strong>-&gt;ipv4</strong>)</dt><dd><p>Look for an IPv4 socket.</p>
</dd>
<dt><strong>sizeof</strong>(<em>tuple</em><strong>-&gt;ipv6</strong>)</dt><dd><p>Look for an IPv6 socket.</p>
</dd>
</dl>
<p>If the <em>netns</em> is a negative signed 32-bit integer, then the
socket lookup table in the netns associated with the <em>ctx</em>
will be used. For the TC hooks, this is the netns of the device
in the skb. For socket hooks, this is the netns of the socket.
If <em>netns</em> is any other signed 32-bit value greater than or
equal to zero then it specifies the ID of the netns relative to
the netns associated with the <em>ctx</em>. <em>netns</em> values beyond the
range of 32-bit integers are reserved for future use.</p>
<p>All values for <em>flags</em> are reserved for future usage, and must
be left at zero.</p>
<p>This helper is available only if the kernel was compiled with
<strong>CONFIG_NET</strong> configuration option.</p>
</dd>
<dt>Return</dt><dd><p>Pointer to <strong>struct bpf_sock</strong>, or <strong>NULL</strong> in case of failure.
For sockets with reuseport option, the <strong>struct bpf_sock</strong>
result is from <em>reuse</em><strong>-&gt;socks</strong>[] using the hash of the
tuple.</p>
</dd>
</dl>
</dd>
<dt><strong>struct bpf_sock *bpf_sk_lookup_udp(void *</strong><em>ctx</em><strong>, struct bpf_sock_tuple *</strong><em>tuple</em><strong>, u32</strong> <em>tuple_size</em><strong>, u64</strong> <em>netns</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Look for UDP socket matching <em>tuple</em>, optionally in a child
network namespace <em>netns</em>. The return value must be checked,
and if non-<strong>NULL</strong>, released via <strong>bpf_sk_release</strong>().</p>
<p>The <em>ctx</em> should point to the context of the program, such as
the skb or socket (depending on the hook in use). This is used
to determine the base network namespace for the lookup.</p>
<p><em>tuple_size</em> must be one of:</p>
<dl class="simple">
<dt><strong>sizeof</strong>(<em>tuple</em><strong>-&gt;ipv4</strong>)</dt><dd><p>Look for an IPv4 socket.</p>
</dd>
<dt><strong>sizeof</strong>(<em>tuple</em><strong>-&gt;ipv6</strong>)</dt><dd><p>Look for an IPv6 socket.</p>
</dd>
</dl>
<p>If the <em>netns</em> is a negative signed 32-bit integer, then the
socket lookup table in the netns associated with the <em>ctx</em>
will be used. For the TC hooks, this is the netns of the device
in the skb. For socket hooks, this is the netns of the socket.
If <em>netns</em> is any other signed 32-bit value greater than or
equal to zero then it specifies the ID of the netns relative to
the netns associated with the <em>ctx</em>. <em>netns</em> values beyond the
range of 32-bit integers are reserved for future use.</p>
<p>All values for <em>flags</em> are reserved for future usage, and must
be left at zero.</p>
<p>This helper is available only if the kernel was compiled with
<strong>CONFIG_NET</strong> configuration option.</p>
</dd>
<dt>Return</dt><dd><p>Pointer to <strong>struct bpf_sock</strong>, or <strong>NULL</strong> in case of failure.
For sockets with reuseport option, the <strong>struct bpf_sock</strong>
result is from <em>reuse</em><strong>-&gt;socks</strong>[] using the hash of the
tuple.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_sk_release(void *</strong><em>sock</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Release the reference held by <em>sock</em>. <em>sock</em> must be a
non-<strong>NULL</strong> pointer that was returned from
<strong>bpf_sk_lookup_xxx</strong>().</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_map_push_elem(struct bpf_map *</strong><em>map</em><strong>, const void *</strong><em>value</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Push an element <em>value</em> in <em>map</em>. <em>flags</em> is one of:</p>
<dl class="simple">
<dt><strong>BPF_EXIST</strong></dt><dd><p>If the queue/stack is full, the oldest element is
removed to make room for this.</p>
</dd>
</dl>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_map_pop_elem(struct bpf_map *</strong><em>map</em><strong>, void *</strong><em>value</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Pop an element from <em>map</em>.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_map_peek_elem(struct bpf_map *</strong><em>map</em><strong>, void *</strong><em>value</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Get an element from <em>map</em> without removing it.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_msg_push_data(struct sk_msg_buff *</strong><em>msg</em><strong>, u32</strong> <em>start</em><strong>, u32</strong> <em>len</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>For socket policies, insert <em>len</em> bytes into <em>msg</em> at offset
<em>start</em>.</p>
<p>If a program of type <strong>BPF_PROG_TYPE_SK_MSG</strong> is run on a
<em>msg</em> it may want to insert metadata or options into the <em>msg</em>.
This can later be read and used by any of the lower layer BPF
hooks.</p>
<p>This helper may fail if under memory pressure (a malloc
fails) in these cases BPF programs will get an appropriate
error and BPF programs will need to handle them.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_msg_pop_data(struct sk_msg_buff *</strong><em>msg</em><strong>, u32</strong> <em>start</em><strong>, u32</strong> <em>len</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Will remove <em>len</em> bytes from a <em>msg</em> starting at byte <em>start</em>.
This may result in <strong>ENOMEM</strong> errors under certain situations if
an allocation and copy are required due to a full ring buffer.
However, the helper will try to avoid doing the allocation
if possible. Other errors can occur if input parameters are
invalid either due to <em>start</em> byte not being valid part of <em>msg</em>
payload and/or <em>pop</em> value being to large.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_rc_pointer_rel(void *</strong><em>ctx</em><strong>, s32</strong> <em>rel_x</em><strong>, s32</strong> <em>rel_y</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>This helper is used in programs implementing IR decoding, to
report a successfully decoded pointer movement.</p>
<p>The <em>ctx</em> should point to the lirc sample as passed into
the program.</p>
<p>This helper is only available is the kernel was compiled with
the <strong>CONFIG_BPF_LIRC_MODE2</strong> configuration option set to
“<strong>y</strong>”.</p>
</dd>
<dt>Return</dt><dd><p>0</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_spin_lock(struct bpf_spin_lock *</strong><em>lock</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Acquire a spinlock represented by the pointer <em>lock</em>, which is
stored as part of a value of a map. Taking the lock allows to
safely update the rest of the fields in that value. The
spinlock can (and must) later be released with a call to
<strong>bpf_spin_unlock</strong>(<em>lock</em>).</p>
<p>Spinlocks in BPF programs come with a number of restrictions
and constraints:</p>
<ul class="simple">
<li><p><strong>bpf_spin_lock</strong> objects are only allowed inside maps of
types <strong>BPF_MAP_TYPE_HASH</strong> and <strong>BPF_MAP_TYPE_ARRAY</strong> (this
list could be extended in the future).</p></li>
<li><p>BTF description of the map is mandatory.</p></li>
<li><p>The BPF program can take ONE lock at a time, since taking two
or more could cause dead locks.</p></li>
<li><p>Only one <strong>struct bpf_spin_lock</strong> is allowed per map element.</p></li>
<li><p>When the lock is taken, calls (either BPF to BPF or helpers)
are not allowed.</p></li>
<li><p>The <strong>BPF_LD_ABS</strong> and <strong>BPF_LD_IND</strong> instructions are not
allowed inside a spinlock-ed region.</p></li>
<li><p>The BPF program MUST call <strong>bpf_spin_unlock</strong>() to release
the lock, on all execution paths, before it returns.</p></li>
<li><p>The BPF program can access <strong>struct bpf_spin_lock</strong> only via
the <strong>bpf_spin_lock</strong>() and <strong>bpf_spin_unlock</strong>()
helpers. Loading or storing data into the <strong>struct
bpf_spin_lock</strong> <em>lock</em><strong>;</strong> field of a map is not allowed.</p></li>
<li><p>To use the <strong>bpf_spin_lock</strong>() helper, the BTF description
of the map value must be a struct and have <strong>struct
bpf_spin_lock</strong> <em>anyname</em><strong>;</strong> field at the top level.
Nested lock inside another struct is not allowed.</p></li>
<li><p>The <strong>struct bpf_spin_lock</strong> <em>lock</em> field in a map value must
be aligned on a multiple of 4 bytes in that value.</p></li>
<li><p>Syscall with command <strong>BPF_MAP_LOOKUP_ELEM</strong> does not copy
the <strong>bpf_spin_lock</strong> field to user space.</p></li>
<li><p>Syscall with command <strong>BPF_MAP_UPDATE_ELEM</strong>, or update from
a BPF program, do not update the <strong>bpf_spin_lock</strong> field.</p></li>
<li><p><strong>bpf_spin_lock</strong> cannot be on the stack or inside a
networking packet (it can only be inside of a map values).</p></li>
<li><p><strong>bpf_spin_lock</strong> is available to root only.</p></li>
<li><p>Tracing programs and socket filter programs cannot use
<strong>bpf_spin_lock</strong>() due to insufficient preemption checks
(but this may change in the future).</p></li>
<li><p><strong>bpf_spin_lock</strong> is not allowed in inner maps of map-in-map.</p></li>
</ul>
</dd>
<dt>Return</dt><dd><p>0</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_spin_unlock(struct bpf_spin_lock *</strong><em>lock</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Release the <em>lock</em> previously locked by a call to
<strong>bpf_spin_lock</strong>(<em>lock</em>).</p>
</dd>
<dt>Return</dt><dd><p>0</p>
</dd>
</dl>
</dd>
<dt><strong>struct bpf_sock *bpf_sk_fullsock(struct bpf_sock *</strong><em>sk</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>This helper gets a <strong>struct bpf_sock</strong> pointer such
that all the fields in this <strong>bpf_sock</strong> can be accessed.</p>
</dd>
<dt>Return</dt><dd><p>A <strong>struct bpf_sock</strong> pointer on success, or <strong>NULL</strong> in
case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>struct bpf_tcp_sock *bpf_tcp_sock(struct bpf_sock *</strong><em>sk</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>This helper gets a <strong>struct bpf_tcp_sock</strong> pointer from a
<strong>struct bpf_sock</strong> pointer.</p>
</dd>
<dt>Return</dt><dd><p>A <strong>struct bpf_tcp_sock</strong> pointer on success, or <strong>NULL</strong> in
case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_skb_ecn_set_ce(struct sk_buff *</strong><em>skb</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Set ECN (Explicit Congestion Notification) field of IP header
to <strong>CE</strong> (Congestion Encountered) if current value is <strong>ECT</strong>
(ECN Capable Transport). Otherwise, do nothing. Works with IPv6
and IPv4.</p>
</dd>
<dt>Return</dt><dd><p>1 if the <strong>CE</strong> flag is set (either by the current helper call
or because it was already present), 0 if it is not set.</p>
</dd>
</dl>
</dd>
<dt><strong>struct bpf_sock *bpf_get_listener_sock(struct bpf_sock *</strong><em>sk</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Return a <strong>struct bpf_sock</strong> pointer in <strong>TCP_LISTEN</strong> state.
<strong>bpf_sk_release</strong>() is unnecessary and not allowed.</p>
</dd>
<dt>Return</dt><dd><p>A <strong>struct bpf_sock</strong> pointer on success, or <strong>NULL</strong> in
case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>struct bpf_sock *bpf_skc_lookup_tcp(void *</strong><em>ctx</em><strong>, struct bpf_sock_tuple *</strong><em>tuple</em><strong>, u32</strong> <em>tuple_size</em><strong>, u64</strong> <em>netns</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Look for TCP socket matching <em>tuple</em>, optionally in a child
network namespace <em>netns</em>. The return value must be checked,
and if non-<strong>NULL</strong>, released via <strong>bpf_sk_release</strong>().</p>
<p>This function is identical to <strong>bpf_sk_lookup_tcp</strong>(), except
that it also returns timewait or request sockets. Use
<strong>bpf_sk_fullsock</strong>() or <strong>bpf_tcp_sock</strong>() to access the
full structure.</p>
<p>This helper is available only if the kernel was compiled with
<strong>CONFIG_NET</strong> configuration option.</p>
</dd>
<dt>Return</dt><dd><p>Pointer to <strong>struct bpf_sock</strong>, or <strong>NULL</strong> in case of failure.
For sockets with reuseport option, the <strong>struct bpf_sock</strong>
result is from <em>reuse</em><strong>-&gt;socks</strong>[] using the hash of the
tuple.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_tcp_check_syncookie(void *</strong><em>sk</em><strong>, void *</strong><em>iph</em><strong>, u32</strong> <em>iph_len</em><strong>, struct tcphdr *</strong><em>th</em><strong>, u32</strong> <em>th_len</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Check whether <em>iph</em> and <em>th</em> contain a valid SYN cookie ACK for
the listening socket in <em>sk</em>.</p>
<p><em>iph</em> points to the start of the IPv4 or IPv6 header, while
<em>iph_len</em> contains <strong>sizeof</strong>(<strong>struct iphdr</strong>) or
<strong>sizeof</strong>(<strong>struct ip6hdr</strong>).</p>
<p><em>th</em> points to the start of the TCP header, while <em>th_len</em>
contains <strong>sizeof</strong>(<strong>struct tcphdr</strong>).</p>
</dd>
<dt>Return</dt><dd><p>0 if <em>iph</em> and <em>th</em> are a valid SYN cookie ACK, or a negative
error otherwise.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_sysctl_get_name(struct bpf_sysctl *</strong><em>ctx</em><strong>, char *</strong><em>buf</em><strong>, size_t</strong> <em>buf_len</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Get name of sysctl in /proc/sys/ and copy it into provided by
program buffer <em>buf</em> of size <em>buf_len</em>.</p>
<p>The buffer is always NUL terminated, unless it’s zero-sized.</p>
<p>If <em>flags</em> is zero, full name (e.g. “net/ipv4/tcp_mem”) is
copied. Use <strong>BPF_F_SYSCTL_BASE_NAME</strong> flag to copy base name
only (e.g. “tcp_mem”).</p>
</dd>
<dt>Return</dt><dd><p>Number of character copied (not including the trailing NUL).</p>
<p><strong>-E2BIG</strong> if the buffer wasn’t big enough (<em>buf</em> will contain
truncated name in this case).</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_sysctl_get_current_value(struct bpf_sysctl *</strong><em>ctx</em><strong>, char *</strong><em>buf</em><strong>, size_t</strong> <em>buf_len</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Get current value of sysctl as it is presented in /proc/sys
(incl. newline, etc), and copy it as a string into provided
by program buffer <em>buf</em> of size <em>buf_len</em>.</p>
<p>The whole value is copied, no matter what file position user
space issued e.g. sys_read at.</p>
<p>The buffer is always NUL terminated, unless it’s zero-sized.</p>
</dd>
<dt>Return</dt><dd><p>Number of character copied (not including the trailing NUL).</p>
<p><strong>-E2BIG</strong> if the buffer wasn’t big enough (<em>buf</em> will contain
truncated name in this case).</p>
<p><strong>-EINVAL</strong> if current value was unavailable, e.g. because
sysctl is uninitialized and read returns -EIO for it.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_sysctl_get_new_value(struct bpf_sysctl *</strong><em>ctx</em><strong>, char *</strong><em>buf</em><strong>, size_t</strong> <em>buf_len</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Get new value being written by user space to sysctl (before
the actual write happens) and copy it as a string into
provided by program buffer <em>buf</em> of size <em>buf_len</em>.</p>
<p>User space may write new value at file position &gt; 0.</p>
<p>The buffer is always NUL terminated, unless it’s zero-sized.</p>
</dd>
<dt>Return</dt><dd><p>Number of character copied (not including the trailing NUL).</p>
<p><strong>-E2BIG</strong> if the buffer wasn’t big enough (<em>buf</em> will contain
truncated name in this case).</p>
<p><strong>-EINVAL</strong> if sysctl is being read.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_sysctl_set_new_value(struct bpf_sysctl *</strong><em>ctx</em><strong>, const char *</strong><em>buf</em><strong>, size_t</strong> <em>buf_len</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Override new value being written by user space to sysctl with
value provided by program in buffer <em>buf</em> of size <em>buf_len</em>.</p>
<p><em>buf</em> should contain a string in same form as provided by user
space on sysctl write.</p>
<p>User space may write new value at file position &gt; 0. To override
the whole sysctl value file position should be set to zero.</p>
</dd>
<dt>Return</dt><dd><p>0 on success.</p>
<p><strong>-E2BIG</strong> if the <em>buf_len</em> is too big.</p>
<p><strong>-EINVAL</strong> if sysctl is being read.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_strtol(const char *</strong><em>buf</em><strong>, size_t</strong> <em>buf_len</em><strong>, u64</strong> <em>flags</em><strong>, long *</strong><em>res</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Convert the initial part of the string from buffer <em>buf</em> of
size <em>buf_len</em> to a long integer according to the given base
and save the result in <em>res</em>.</p>
<p>The string may begin with an arbitrary amount of white space
(as determined by <strong>isspace</strong>(3)) followed by a single
optional ‘<strong>-</strong>‘ sign.</p>
<p>Five least significant bits of <em>flags</em> encode base, other bits
are currently unused.</p>
<p>Base must be either 8, 10, 16 or 0 to detect it automatically
similar to user space <strong>strtol</strong>(3).</p>
</dd>
<dt>Return</dt><dd><p>Number of characters consumed on success. Must be positive but
no more than <em>buf_len</em>.</p>
<p><strong>-EINVAL</strong> if no valid digits were found or unsupported base
was provided.</p>
<p><strong>-ERANGE</strong> if resulting value was out of range.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_strtoul(const char *</strong><em>buf</em><strong>, size_t</strong> <em>buf_len</em><strong>, u64</strong> <em>flags</em><strong>, unsigned long *</strong><em>res</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Convert the initial part of the string from buffer <em>buf</em> of
size <em>buf_len</em> to an unsigned long integer according to the
given base and save the result in <em>res</em>.</p>
<p>The string may begin with an arbitrary amount of white space
(as determined by <strong>isspace</strong>(3)).</p>
<p>Five least significant bits of <em>flags</em> encode base, other bits
are currently unused.</p>
<p>Base must be either 8, 10, 16 or 0 to detect it automatically
similar to user space <strong>strtoul</strong>(3).</p>
</dd>
<dt>Return</dt><dd><p>Number of characters consumed on success. Must be positive but
no more than <em>buf_len</em>.</p>
<p><strong>-EINVAL</strong> if no valid digits were found or unsupported base
was provided.</p>
<p><strong>-ERANGE</strong> if resulting value was out of range.</p>
</dd>
</dl>
</dd>
<dt><strong>void *bpf_sk_storage_get(struct bpf_map *</strong><em>map</em><strong>, void *</strong><em>sk</em><strong>, void *</strong><em>value</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Get a bpf-local-storage from a <em>sk</em>.</p>
<p>Logically, it could be thought of getting the value from
a <em>map</em> with <em>sk</em> as the <strong>key</strong>.  From this
perspective,  the usage is not much different from
<strong>bpf_map_lookup_elem</strong>(<em>map</em>, <strong>&amp;</strong><em>sk</em>) except this
helper enforces the key must be a full socket and the map must
be a <strong>BPF_MAP_TYPE_SK_STORAGE</strong> also.</p>
<p>Underneath, the value is stored locally at <em>sk</em> instead of
the <em>map</em>.  The <em>map</em> is used as the bpf-local-storage
“type”. The bpf-local-storage “type” (i.e. the <em>map</em>) is
searched against all bpf-local-storages residing at <em>sk</em>.</p>
<p><em>sk</em> is a kernel <strong>struct sock</strong> pointer for LSM program.
<em>sk</em> is a <strong>struct bpf_sock</strong> pointer for other program types.</p>
<p>An optional <em>flags</em> (<strong>BPF_SK_STORAGE_GET_F_CREATE</strong>) can be
used such that a new bpf-local-storage will be
created if one does not exist.  <em>value</em> can be used
together with <strong>BPF_SK_STORAGE_GET_F_CREATE</strong> to specify
the initial value of a bpf-local-storage.  If <em>value</em> is
<strong>NULL</strong>, the new bpf-local-storage will be zero initialized.</p>
</dd>
<dt>Return</dt><dd><p>A bpf-local-storage pointer is returned on success.</p>
<p><strong>NULL</strong> if not found or there was an error in adding
a new bpf-local-storage.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_sk_storage_delete(struct bpf_map *</strong><em>map</em><strong>, void *</strong><em>sk</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Delete a bpf-local-storage from a <em>sk</em>.</p>
</dd>
<dt>Return</dt><dd><p>0 on success.</p>
<p><strong>-ENOENT</strong> if the bpf-local-storage cannot be found.
<strong>-EINVAL</strong> if sk is not a fullsock (e.g. a request_sock).</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_send_signal(u32</strong> <em>sig</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Send signal <em>sig</em> to the process of the current task.
The signal may be delivered to any of this process’s threads.</p>
</dd>
<dt>Return</dt><dd><p>0 on success or successfully queued.</p>
<p><strong>-EBUSY</strong> if work queue under nmi is full.</p>
<p><strong>-EINVAL</strong> if <em>sig</em> is invalid.</p>
<p><strong>-EPERM</strong> if no permission to send the <em>sig</em>.</p>
<p><strong>-EAGAIN</strong> if bpf program can try again.</p>
</dd>
</dl>
</dd>
<dt><strong>s64 bpf_tcp_gen_syncookie(void *</strong><em>sk</em><strong>, void *</strong><em>iph</em><strong>, u32</strong> <em>iph_len</em><strong>, struct tcphdr *</strong><em>th</em><strong>, u32</strong> <em>th_len</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Try to issue a SYN cookie for the packet with corresponding
IP/TCP headers, <em>iph</em> and <em>th</em>, on the listening socket in <em>sk</em>.</p>
<p><em>iph</em> points to the start of the IPv4 or IPv6 header, while
<em>iph_len</em> contains <strong>sizeof</strong>(<strong>struct iphdr</strong>) or
<strong>sizeof</strong>(<strong>struct ip6hdr</strong>).</p>
<p><em>th</em> points to the start of the TCP header, while <em>th_len</em>
contains the length of the TCP header.</p>
</dd>
<dt>Return</dt><dd><p>On success, lower 32 bits hold the generated SYN cookie in
followed by 16 bits which hold the MSS value for that cookie,
and the top 16 bits are unused.</p>
<p>On failure, the returned value is one of the following:</p>
<p><strong>-EINVAL</strong> SYN cookie cannot be issued due to error</p>
<p><strong>-ENOENT</strong> SYN cookie should not be issued (no SYN flood)</p>
<p><strong>-EOPNOTSUPP</strong> kernel configuration does not enable SYN cookies</p>
<p><strong>-EPROTONOSUPPORT</strong> IP packet version is not 4 or 6</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_skb_output(void *</strong><em>ctx</em><strong>, struct bpf_map *</strong><em>map</em><strong>, u64</strong> <em>flags</em><strong>, void *</strong><em>data</em><strong>, u64</strong> <em>size</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Write raw <em>data</em> blob into a special BPF perf event held by
<em>map</em> of type <strong>BPF_MAP_TYPE_PERF_EVENT_ARRAY</strong>. This perf
event must have the following attributes: <strong>PERF_SAMPLE_RAW</strong>
as <strong>sample_type</strong>, <strong>PERF_TYPE_SOFTWARE</strong> as <strong>type</strong>, and
<strong>PERF_COUNT_SW_BPF_OUTPUT</strong> as <strong>config</strong>.</p>
<p>The <em>flags</em> are used to indicate the index in <em>map</em> for which
the value must be put, masked with <strong>BPF_F_INDEX_MASK</strong>.
Alternatively, <em>flags</em> can be set to <strong>BPF_F_CURRENT_CPU</strong>
to indicate that the index of the current CPU core should be
used.</p>
<p>The value to write, of <em>size</em>, is passed through eBPF stack and
pointed by <em>data</em>.</p>
<p><em>ctx</em> is a pointer to in-kernel struct sk_buff.</p>
<p>This helper is similar to <strong>bpf_perf_event_output</strong>() but
restricted to raw_tracepoint bpf programs.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_probe_read_user(void *</strong><em>dst</em><strong>, u32</strong> <em>size</em><strong>, const void *</strong><em>unsafe_ptr</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Safely attempt to read <em>size</em> bytes from user space address
<em>unsafe_ptr</em> and store the data in <em>dst</em>.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_probe_read_kernel(void *</strong><em>dst</em><strong>, u32</strong> <em>size</em><strong>, const void *</strong><em>unsafe_ptr</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Safely attempt to read <em>size</em> bytes from kernel space address
<em>unsafe_ptr</em> and store the data in <em>dst</em>.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_probe_read_user_str(void *</strong><em>dst</em><strong>, u32</strong> <em>size</em><strong>, const void *</strong><em>unsafe_ptr</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Copy a NUL terminated string from an unsafe user address
<em>unsafe_ptr</em> to <em>dst</em>. The <em>size</em> should include the
terminating NUL byte. In case the string length is smaller than
<em>size</em>, the target is not padded with further NUL bytes. If the
string length is larger than <em>size</em>, just <em>size</em>-1 bytes are
copied and the last byte is set to NUL.</p>
<p>On success, returns the number of bytes that were written,
including the terminal NUL. This makes this helper useful in
tracing programs for reading strings, and more importantly to
get its length at runtime. See the following snippet:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SEC</span><span class="p">(</span><span class="s2">&quot;kprobe/sys_open&quot;</span><span class="p">)</span>
<span class="n">void</span> <span class="n">bpf_sys_open</span><span class="p">(</span><span class="n">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">PATHLEN</span><span class="p">];</span> <span class="o">//</span> <span class="n">PATHLEN</span> <span class="ow">is</span> <span class="n">defined</span> <span class="n">to</span> <span class="mi">256</span>
        <span class="nb">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">bpf_probe_read_user_str</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span>
                                          <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">di</span><span class="p">);</span>

        <span class="o">//</span> <span class="n">Consume</span> <span class="n">buf</span><span class="p">,</span> <span class="k">for</span> <span class="n">example</span> <span class="n">push</span> <span class="n">it</span> <span class="n">to</span>
        <span class="o">//</span> <span class="n">userspace</span> <span class="n">via</span> <span class="n">bpf_perf_event_output</span><span class="p">();</span> <span class="n">we</span>
        <span class="o">//</span> <span class="n">can</span> <span class="n">use</span> <span class="n">res</span> <span class="p">(</span><span class="n">the</span> <span class="n">string</span> <span class="n">length</span><span class="p">)</span> <span class="k">as</span> <span class="n">event</span>
        <span class="o">//</span> <span class="n">size</span><span class="p">,</span> <span class="n">after</span> <span class="n">checking</span> <span class="n">its</span> <span class="n">boundaries</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In comparison, using <strong>bpf_probe_read_user</strong>() helper here
instead to read the string would require to estimate the length
at compile time, and would often result in copying more memory
than necessary.</p>
<p>Another useful use case is when parsing individual process
arguments or individual environment variables navigating
<em>current</em><strong>-&gt;mm-&gt;arg_start</strong> and <em>current</em><strong>-&gt;mm-&gt;env_start</strong>: using this helper and the return value,
one can quickly iterate at the right offset of the memory area.</p>
</dd>
<dt>Return</dt><dd><p>On success, the strictly positive length of the output string,
including the trailing NUL character. On error, a negative
value.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_probe_read_kernel_str(void *</strong><em>dst</em><strong>, u32</strong> <em>size</em><strong>, const void *</strong><em>unsafe_ptr</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Copy a NUL terminated string from an unsafe kernel address <em>unsafe_ptr</em>
to <em>dst</em>. Same semantics as with <strong>bpf_probe_read_user_str</strong>() apply.</p>
</dd>
<dt>Return</dt><dd><p>On success, the strictly positive length of the string, including
the trailing NUL character. On error, a negative value.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_tcp_send_ack(void *</strong><em>tp</em><strong>, u32</strong> <em>rcv_nxt</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Send out a tcp-ack. <em>tp</em> is the in-kernel struct <strong>tcp_sock</strong>.
<em>rcv_nxt</em> is the ack_seq to be sent out.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_send_signal_thread(u32</strong> <em>sig</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Send signal <em>sig</em> to the thread corresponding to the current task.</p>
</dd>
<dt>Return</dt><dd><p>0 on success or successfully queued.</p>
<p><strong>-EBUSY</strong> if work queue under nmi is full.</p>
<p><strong>-EINVAL</strong> if <em>sig</em> is invalid.</p>
<p><strong>-EPERM</strong> if no permission to send the <em>sig</em>.</p>
<p><strong>-EAGAIN</strong> if bpf program can try again.</p>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_jiffies64(void)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Obtain the 64bit jiffies</p>
</dd>
<dt>Return</dt><dd><p>The 64 bit jiffies</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_read_branch_records(struct bpf_perf_event_data *</strong><em>ctx</em><strong>, void *</strong><em>buf</em><strong>, u32</strong> <em>size</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>For an eBPF program attached to a perf event, retrieve the
branch records (<strong>struct perf_branch_entry</strong>) associated to <em>ctx</em>
and store it in the buffer pointed by <em>buf</em> up to size
<em>size</em> bytes.</p>
</dd>
<dt>Return</dt><dd><p>On success, number of bytes written to <em>buf</em>. On error, a
negative value.</p>
<p>The <em>flags</em> can be set to <strong>BPF_F_GET_BRANCH_RECORDS_SIZE</strong> to
instead return the number of bytes required to store all the
branch entries. If this flag is set, <em>buf</em> may be NULL.</p>
<p><strong>-EINVAL</strong> if arguments invalid or <strong>size</strong> not a multiple
of <strong>sizeof</strong>(<strong>struct perf_branch_entry</strong>).</p>
<p><strong>-ENOENT</strong> if architecture does not support branch records.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_get_ns_current_pid_tgid(u64</strong> <em>dev</em><strong>, u64</strong> <em>ino</em><strong>, struct bpf_pidns_info *</strong><em>nsdata</em><strong>, u32</strong> <em>size</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Returns 0 on success, values for <em>pid</em> and <em>tgid</em> as seen from the current
<em>namespace</em> will be returned in <em>nsdata</em>.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or one of the following in case of failure:</p>
<p><strong>-EINVAL</strong> if dev and inum supplied don’t match dev_t and inode number
with nsfs of current task, or if dev conversion to dev_t lost high bits.</p>
<p><strong>-ENOENT</strong> if pidns does not exists for the current task.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_xdp_output(void *</strong><em>ctx</em><strong>, struct bpf_map *</strong><em>map</em><strong>, u64</strong> <em>flags</em><strong>, void *</strong><em>data</em><strong>, u64</strong> <em>size</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Write raw <em>data</em> blob into a special BPF perf event held by
<em>map</em> of type <strong>BPF_MAP_TYPE_PERF_EVENT_ARRAY</strong>. This perf
event must have the following attributes: <strong>PERF_SAMPLE_RAW</strong>
as <strong>sample_type</strong>, <strong>PERF_TYPE_SOFTWARE</strong> as <strong>type</strong>, and
<strong>PERF_COUNT_SW_BPF_OUTPUT</strong> as <strong>config</strong>.</p>
<p>The <em>flags</em> are used to indicate the index in <em>map</em> for which
the value must be put, masked with <strong>BPF_F_INDEX_MASK</strong>.
Alternatively, <em>flags</em> can be set to <strong>BPF_F_CURRENT_CPU</strong>
to indicate that the index of the current CPU core should be
used.</p>
<p>The value to write, of <em>size</em>, is passed through eBPF stack and
pointed by <em>data</em>.</p>
<p><em>ctx</em> is a pointer to in-kernel struct xdp_buff.</p>
<p>This helper is similar to <strong>bpf_perf_eventoutput</strong>() but
restricted to raw_tracepoint bpf programs.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_get_netns_cookie(void *</strong><em>ctx</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Retrieve the cookie (generated by the kernel) of the network
namespace the input <em>ctx</em> is associated with. The network
namespace cookie remains stable for its lifetime and provides
a global identifier that can be assumed unique. If <em>ctx</em> is
NULL, then the helper returns the cookie for the initial
network namespace. The cookie itself is very similar to that
of <strong>bpf_get_socket_cookie</strong>() helper, but for network
namespaces instead of sockets.</p>
</dd>
<dt>Return</dt><dd><p>A 8-byte long opaque number.</p>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_get_current_ancestor_cgroup_id(int</strong> <em>ancestor_level</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Return id of cgroup v2 that is ancestor of the cgroup associated
with the current task at the <em>ancestor_level</em>. The root cgroup
is at <em>ancestor_level</em> zero and each step down the hierarchy
increments the level. If <em>ancestor_level</em> == level of cgroup
associated with the current task, then return value will be the
same as that of <strong>bpf_get_current_cgroup_id</strong>().</p>
<p>The helper is useful to implement policies based on cgroups
that are upper in hierarchy than immediate cgroup associated
with the current task.</p>
<p>The format of returned id and helper limitations are same as in
<strong>bpf_get_current_cgroup_id</strong>().</p>
</dd>
<dt>Return</dt><dd><p>The id is returned or 0 in case the id could not be retrieved.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_sk_assign(struct sk_buff *</strong><em>skb</em><strong>, void *</strong><em>sk</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Helper is overloaded depending on BPF program type. This
description applies to <strong>BPF_PROG_TYPE_SCHED_CLS</strong> and
<strong>BPF_PROG_TYPE_SCHED_ACT</strong> programs.</p>
<p>Assign the <em>sk</em> to the <em>skb</em>. When combined with appropriate
routing configuration to receive the packet towards the socket,
will cause <em>skb</em> to be delivered to the specified socket.
Subsequent redirection of <em>skb</em> via  <strong>bpf_redirect</strong>(),
<strong>bpf_clone_redirect</strong>() or other methods outside of BPF may
interfere with successful delivery to the socket.</p>
<p>This operation is only valid from TC ingress path.</p>
<p>The <em>flags</em> argument must be zero.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure:</p>
<p><strong>-EINVAL</strong> if specified <em>flags</em> are not supported.</p>
<p><strong>-ENOENT</strong> if the socket is unavailable for assignment.</p>
<p><strong>-ENETUNREACH</strong> if the socket is unreachable (wrong netns).</p>
<p><strong>-EOPNOTSUPP</strong> if the operation is not supported, for example
a call from outside of TC ingress.</p>
<p><strong>-ESOCKTNOSUPPORT</strong> if the socket type is not supported
(reuseport).</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_sk_assign(struct bpf_sk_lookup *</strong><em>ctx</em><strong>, struct bpf_sock *</strong><em>sk</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Helper is overloaded depending on BPF program type. This
description applies to <strong>BPF_PROG_TYPE_SK_LOOKUP</strong> programs.</p>
<p>Select the <em>sk</em> as a result of a socket lookup.</p>
<p>For the operation to succeed passed socket must be compatible
with the packet description provided by the <em>ctx</em> object.</p>
<p>L4 protocol (<strong>IPPROTO_TCP</strong> or <strong>IPPROTO_UDP</strong>) must
be an exact match. While IP family (<strong>AF_INET</strong> or
<strong>AF_INET6</strong>) must be compatible, that is IPv6 sockets
that are not v6-only can be selected for IPv4 packets.</p>
<p>Only TCP listeners and UDP unconnected sockets can be
selected. <em>sk</em> can also be NULL to reset any previous
selection.</p>
<p><em>flags</em> argument can combination of following values:</p>
<ul class="simple">
<li><p><strong>BPF_SK_LOOKUP_F_REPLACE</strong> to override the previous
socket selection, potentially done by a BPF program
that ran before us.</p></li>
<li><p><strong>BPF_SK_LOOKUP_F_NO_REUSEPORT</strong> to skip
load-balancing within reuseport group for the socket
being selected.</p></li>
</ul>
<p>On success <em>ctx-&gt;sk</em> will point to the selected socket.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative errno in case of failure.</p>
<ul class="simple">
<li><p><strong>-EAFNOSUPPORT</strong> if socket family (<em>sk-&gt;family</em>) is
not compatible with packet family (<em>ctx-&gt;family</em>).</p></li>
<li><p><strong>-EEXIST</strong> if socket has been already selected,
potentially by another program, and
<strong>BPF_SK_LOOKUP_F_REPLACE</strong> flag was not specified.</p></li>
<li><p><strong>-EINVAL</strong> if unsupported flags were specified.</p></li>
<li><p><strong>-EPROTOTYPE</strong> if socket L4 protocol
(<em>sk-&gt;protocol</em>) doesn’t match packet protocol
(<em>ctx-&gt;protocol</em>).</p></li>
<li><p><strong>-ESOCKTNOSUPPORT</strong> if socket is not in allowed
state (TCP listening or UDP unconnected).</p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_ktime_get_boot_ns(void)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Return the time elapsed since system boot, in nanoseconds.
Does include the time the system was suspended.
See: <strong>clock_gettime</strong>(<strong>CLOCK_BOOTTIME</strong>)</p>
</dd>
<dt>Return</dt><dd><p>Current <em>ktime</em>.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_seq_printf(struct seq_file *</strong><em>m</em><strong>, const char *</strong><em>fmt</em><strong>, u32</strong> <em>fmt_size</em><strong>, const void *</strong><em>data</em><strong>, u32</strong> <em>data_len</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p><strong>bpf_seq_printf</strong>() uses seq_file <strong>seq_printf</strong>() to print
out the format string.
The <em>m</em> represents the seq_file. The <em>fmt</em> and <em>fmt_size</em> are for
the format string itself. The <em>data</em> and <em>data_len</em> are format string
arguments. The <em>data</em> are a <strong>u64</strong> array and corresponding format string
values are stored in the array. For strings and pointers where pointees
are accessed, only the pointer values are stored in the <em>data</em> array.
The <em>data_len</em> is the size of <em>data</em> in bytes.</p>
<p>Formats <strong>%s</strong>, <strong>%p{i,I}{4,6}</strong> requires to read kernel memory.
Reading kernel memory may fail due to either invalid address or
valid address but requiring a major memory fault. If reading kernel memory
fails, the string for <strong>%s</strong> will be an empty string, and the ip
address for <strong>%p{i,I}{4,6}</strong> will be 0. Not returning error to
bpf program is consistent with what <strong>bpf_trace_printk</strong>() does for now.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure:</p>
<p><strong>-EBUSY</strong> if per-CPU memory copy buffer is busy, can try again
by returning 1 from bpf program.</p>
<p><strong>-EINVAL</strong> if arguments are invalid, or if <em>fmt</em> is invalid/unsupported.</p>
<p><strong>-E2BIG</strong> if <em>fmt</em> contains too many format specifiers.</p>
<p><strong>-EOVERFLOW</strong> if an overflow happened: The same object will be tried again.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_seq_write(struct seq_file *</strong><em>m</em><strong>, const void *</strong><em>data</em><strong>, u32</strong> <em>len</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p><strong>bpf_seq_write</strong>() uses seq_file <strong>seq_write</strong>() to write the data.
The <em>m</em> represents the seq_file. The <em>data</em> and <em>len</em> represent the
data to write in bytes.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure:</p>
<p><strong>-EOVERFLOW</strong> if an overflow happened: The same object will be tried again.</p>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_sk_cgroup_id(void *</strong><em>sk</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Return the cgroup v2 id of the socket <em>sk</em>.</p>
<p><em>sk</em> must be a non-<strong>NULL</strong> pointer to a socket, e.g. one
returned from <strong>bpf_sk_lookup_xxx</strong>(),
<strong>bpf_sk_fullsock</strong>(), etc. The format of returned id is
same as in <strong>bpf_skb_cgroup_id</strong>().</p>
<p>This helper is available only if the kernel was compiled with
the <strong>CONFIG_SOCK_CGROUP_DATA</strong> configuration option.</p>
</dd>
<dt>Return</dt><dd><p>The id is returned or 0 in case the id could not be retrieved.</p>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_sk_ancestor_cgroup_id(void *</strong><em>sk</em><strong>, int</strong> <em>ancestor_level</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Return id of cgroup v2 that is ancestor of cgroup associated
with the <em>sk</em> at the <em>ancestor_level</em>.  The root cgroup is at
<em>ancestor_level</em> zero and each step down the hierarchy
increments the level. If <em>ancestor_level</em> == level of cgroup
associated with <em>sk</em>, then return value will be same as that
of <strong>bpf_sk_cgroup_id</strong>().</p>
<p>The helper is useful to implement policies based on cgroups
that are upper in hierarchy than immediate cgroup associated
with <em>sk</em>.</p>
<p>The format of returned id and helper limitations are same as in
<strong>bpf_sk_cgroup_id</strong>().</p>
</dd>
<dt>Return</dt><dd><p>The id is returned or 0 in case the id could not be retrieved.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_ringbuf_output(void *</strong><em>ringbuf</em><strong>, void *</strong><em>data</em><strong>, u64</strong> <em>size</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Copy <em>size</em> bytes from <em>data</em> into a ring buffer <em>ringbuf</em>.
If <strong>BPF_RB_NO_WAKEUP</strong> is specified in <em>flags</em>, no notification
of new data availability is sent.
If <strong>BPF_RB_FORCE_WAKEUP</strong> is specified in <em>flags</em>, notification
of new data availability is sent unconditionally.
If <strong>0</strong> is specified in <em>flags</em>, an adaptive notification
of new data availability is sent.</p>
<p>An adaptive notification is a notification sent whenever the user-space
process has caught up and consumed all available payloads. In case the user-space
process is still processing a previous payload, then no notification is needed
as it will process the newly added payload automatically.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>void *bpf_ringbuf_reserve(void *</strong><em>ringbuf</em><strong>, u64</strong> <em>size</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Reserve <em>size</em> bytes of payload in a ring buffer <em>ringbuf</em>.
<em>flags</em> must be 0.</p>
</dd>
<dt>Return</dt><dd><p>Valid pointer with <em>size</em> bytes of memory available; NULL,
otherwise.</p>
</dd>
</dl>
</dd>
<dt><strong>void bpf_ringbuf_submit(void *</strong><em>data</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Submit reserved ring buffer sample, pointed to by <em>data</em>.
If <strong>BPF_RB_NO_WAKEUP</strong> is specified in <em>flags</em>, no notification
of new data availability is sent.
If <strong>BPF_RB_FORCE_WAKEUP</strong> is specified in <em>flags</em>, notification
of new data availability is sent unconditionally.
If <strong>0</strong> is specified in <em>flags</em>, an adaptive notification
of new data availability is sent.</p>
<p>See ‘bpf_ringbuf_output()’ for the definition of adaptive notification.</p>
</dd>
<dt>Return</dt><dd><p>Nothing. Always succeeds.</p>
</dd>
</dl>
</dd>
<dt><strong>void bpf_ringbuf_discard(void *</strong><em>data</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Discard reserved ring buffer sample, pointed to by <em>data</em>.
If <strong>BPF_RB_NO_WAKEUP</strong> is specified in <em>flags</em>, no notification
of new data availability is sent.
If <strong>BPF_RB_FORCE_WAKEUP</strong> is specified in <em>flags</em>, notification
of new data availability is sent unconditionally.
If <strong>0</strong> is specified in <em>flags</em>, an adaptive notification
of new data availability is sent.</p>
<p>See ‘bpf_ringbuf_output()’ for the definition of adaptive notification.</p>
</dd>
<dt>Return</dt><dd><p>Nothing. Always succeeds.</p>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_ringbuf_query(void *</strong><em>ringbuf</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Query various characteristics of provided ring buffer. What
exactly is queries is determined by <em>flags</em>:</p>
<ul class="simple">
<li><p><strong>BPF_RB_AVAIL_DATA</strong>: Amount of data not yet consumed.</p></li>
<li><p><strong>BPF_RB_RING_SIZE</strong>: The size of ring buffer.</p></li>
<li><p><strong>BPF_RB_CONS_POS</strong>: Consumer position (can wrap around).</p></li>
<li><p><strong>BPF_RB_PROD_POS</strong>: Producer(s) position (can wrap around).</p></li>
</ul>
<p>Data returned is just a momentary snapshot of actual values
and could be inaccurate, so this facility should be used to
power heuristics and for reporting, not to make 100% correct
calculation.</p>
</dd>
<dt>Return</dt><dd><p>Requested value, or 0, if <em>flags</em> are not recognized.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_csum_level(struct sk_buff *</strong><em>skb</em><strong>, u64</strong> <em>level</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Change the skbs checksum level by one layer up or down, or
reset it entirely to none in order to have the stack perform
checksum validation. The level is applicable to the following
protocols: TCP, UDP, GRE, SCTP, FCOE. For example, a decap of
| ETH | IP | UDP | GUE | IP | TCP | into | ETH | IP | TCP |
through <strong>bpf_skb_adjust_room</strong>() helper with passing in
<strong>BPF_F_ADJ_ROOM_NO_CSUM_RESET</strong> flag would require one call
to <strong>bpf_csum_level</strong>() with <strong>BPF_CSUM_LEVEL_DEC</strong> since
the UDP header is removed. Similarly, an encap of the latter
into the former could be accompanied by a helper call to
<strong>bpf_csum_level</strong>() with <strong>BPF_CSUM_LEVEL_INC</strong> if the
skb is still intended to be processed in higher layers of the
stack instead of just egressing at tc.</p>
<p>There are three supported level settings at this time:</p>
<ul class="simple">
<li><p><strong>BPF_CSUM_LEVEL_INC</strong>: Increases skb-&gt;csum_level for skbs
with CHECKSUM_UNNECESSARY.</p></li>
<li><p><strong>BPF_CSUM_LEVEL_DEC</strong>: Decreases skb-&gt;csum_level for skbs
with CHECKSUM_UNNECESSARY.</p></li>
<li><p><strong>BPF_CSUM_LEVEL_RESET</strong>: Resets skb-&gt;csum_level to 0 and
sets CHECKSUM_NONE to force checksum validation by the stack.</p></li>
<li><p><strong>BPF_CSUM_LEVEL_QUERY</strong>: No-op, returns the current
skb-&gt;csum_level.</p></li>
</ul>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure. In the
case of <strong>BPF_CSUM_LEVEL_QUERY</strong>, the current skb-&gt;csum_level
is returned or the error code -EACCES in case the skb is not
subject to CHECKSUM_UNNECESSARY.</p>
</dd>
</dl>
</dd>
<dt><strong>struct tcp6_sock *bpf_skc_to_tcp6_sock(void *</strong><em>sk</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Dynamically cast a <em>sk</em> pointer to a <em>tcp6_sock</em> pointer.</p>
</dd>
<dt>Return</dt><dd><p><em>sk</em> if casting is valid, or <strong>NULL</strong> otherwise.</p>
</dd>
</dl>
</dd>
<dt><strong>struct tcp_sock *bpf_skc_to_tcp_sock(void *</strong><em>sk</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Dynamically cast a <em>sk</em> pointer to a <em>tcp_sock</em> pointer.</p>
</dd>
<dt>Return</dt><dd><p><em>sk</em> if casting is valid, or <strong>NULL</strong> otherwise.</p>
</dd>
</dl>
</dd>
<dt><strong>struct tcp_timewait_sock *bpf_skc_to_tcp_timewait_sock(void *</strong><em>sk</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Dynamically cast a <em>sk</em> pointer to a <em>tcp_timewait_sock</em> pointer.</p>
</dd>
<dt>Return</dt><dd><p><em>sk</em> if casting is valid, or <strong>NULL</strong> otherwise.</p>
</dd>
</dl>
</dd>
<dt><strong>struct tcp_request_sock *bpf_skc_to_tcp_request_sock(void *</strong><em>sk</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Dynamically cast a <em>sk</em> pointer to a <em>tcp_request_sock</em> pointer.</p>
</dd>
<dt>Return</dt><dd><p><em>sk</em> if casting is valid, or <strong>NULL</strong> otherwise.</p>
</dd>
</dl>
</dd>
<dt><strong>struct udp6_sock *bpf_skc_to_udp6_sock(void *</strong><em>sk</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Dynamically cast a <em>sk</em> pointer to a <em>udp6_sock</em> pointer.</p>
</dd>
<dt>Return</dt><dd><p><em>sk</em> if casting is valid, or <strong>NULL</strong> otherwise.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_get_task_stack(struct task_struct *</strong><em>task</em><strong>, void *</strong><em>buf</em><strong>, u32</strong> <em>size</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Return a user or a kernel stack in bpf program provided buffer.
To achieve this, the helper needs <em>task</em>, which is a valid
pointer to <strong>struct task_struct</strong>. To store the stacktrace, the
bpf program provides <em>buf</em> with a nonnegative <em>size</em>.</p>
<p>The last argument, <em>flags</em>, holds the number of stack frames to
skip (from 0 to 255), masked with
<strong>BPF_F_SKIP_FIELD_MASK</strong>. The next bits can be used to set
the following flags:</p>
<dl class="simple">
<dt><strong>BPF_F_USER_STACK</strong></dt><dd><p>Collect a user space stack instead of a kernel stack.</p>
</dd>
<dt><strong>BPF_F_USER_BUILD_ID</strong></dt><dd><p>Collect buildid+offset instead of ips for user stack,
only valid if <strong>BPF_F_USER_STACK</strong> is also specified.</p>
</dd>
</dl>
<p><strong>bpf_get_task_stack</strong>() can collect up to
<strong>PERF_MAX_STACK_DEPTH</strong> both kernel and user frames, subject
to sufficient large buffer size. Note that
this limit can be controlled with the <strong>sysctl</strong> program, and
that it should be manually increased in order to profile long
user stacks (such as stacks for Java programs). To do so, use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># sysctl kernel.perf_event_max_stack=&lt;new value&gt;</span>
</pre></div>
</div>
</dd>
<dt>Return</dt><dd><p>A non-negative value equal to or less than <em>size</em> on success,
or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_load_hdr_opt(struct bpf_sock_ops *</strong><em>skops</em><strong>, void *</strong><em>searchby_res</em><strong>, u32</strong> <em>len</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Load header option.  Support reading a particular TCP header
option for bpf program (<strong>BPF_PROG_TYPE_SOCK_OPS</strong>).</p>
<p>If <em>flags</em> is 0, it will search the option from the
<em>skops</em><strong>-&gt;skb_data</strong>.  The comment in <strong>struct bpf_sock_ops</strong>
has details on what skb_data contains under different
<em>skops</em><strong>-&gt;op</strong>.</p>
<p>The first byte of the <em>searchby_res</em> specifies the
kind that it wants to search.</p>
<p>If the searching kind is an experimental kind
(i.e. 253 or 254 according to RFC6994).  It also
needs to specify the “magic” which is either
2 bytes or 4 bytes.  It then also needs to
specify the size of the magic by using
the 2nd byte which is “kind-length” of a TCP
header option and the “kind-length” also
includes the first 2 bytes “kind” and “kind-length”
itself as a normal TCP header option also does.</p>
<p>For example, to search experimental kind 254 with
2 byte magic 0xeB9F, the searchby_res should be
[ 254, 4, 0xeB, 0x9F, 0, 0, …. 0 ].</p>
<p>To search for the standard window scale option (3),
the <em>searchby_res</em> should be [ 3, 0, 0, …. 0 ].
Note, kind-length must be 0 for regular option.</p>
<p>Searching for No-Op (0) and End-of-Option-List (1) are
not supported.</p>
<p><em>len</em> must be at least 2 bytes which is the minimal size
of a header option.</p>
<p>Supported flags:</p>
<ul class="simple">
<li><p><strong>BPF_LOAD_HDR_OPT_TCP_SYN</strong> to search from the
saved_syn packet or the just-received syn packet.</p></li>
</ul>
</dd>
<dt>Return</dt><dd><p>&gt; 0 when found, the header option is copied to <em>searchby_res</em>.
The return value is the total length copied. On failure, a
negative error code is returned:</p>
<p><strong>-EINVAL</strong> if a parameter is invalid.</p>
<p><strong>-ENOMSG</strong> if the option is not found.</p>
<p><strong>-ENOENT</strong> if no syn packet is available when
<strong>BPF_LOAD_HDR_OPT_TCP_SYN</strong> is used.</p>
<p><strong>-ENOSPC</strong> if there is not enough space.  Only <em>len</em> number of
bytes are copied.</p>
<p><strong>-EFAULT</strong> on failure to parse the header options in the
packet.</p>
<p><strong>-EPERM</strong> if the helper cannot be used under the current
<em>skops</em><strong>-&gt;op</strong>.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_store_hdr_opt(struct bpf_sock_ops *</strong><em>skops</em><strong>, const void *</strong><em>from</em><strong>, u32</strong> <em>len</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Store header option.  The data will be copied
from buffer <em>from</em> with length <em>len</em> to the TCP header.</p>
<p>The buffer <em>from</em> should have the whole option that
includes the kind, kind-length, and the actual
option data.  The <em>len</em> must be at least kind-length
long.  The kind-length does not have to be 4 byte
aligned.  The kernel will take care of the padding
and setting the 4 bytes aligned value to th-&gt;doff.</p>
<p>This helper will check for duplicated option
by searching the same option in the outgoing skb.</p>
<p>This helper can only be called during
<strong>BPF_SOCK_OPS_WRITE_HDR_OPT_CB</strong>.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or negative error in case of failure:</p>
<p><strong>-EINVAL</strong> If param is invalid.</p>
<p><strong>-ENOSPC</strong> if there is not enough space in the header.
Nothing has been written</p>
<p><strong>-EEXIST</strong> if the option already exists.</p>
<p><strong>-EFAULT</strong> on failrue to parse the existing header options.</p>
<p><strong>-EPERM</strong> if the helper cannot be used under the current
<em>skops</em><strong>-&gt;op</strong>.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_reserve_hdr_opt(struct bpf_sock_ops *</strong><em>skops</em><strong>, u32</strong> <em>len</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Reserve <em>len</em> bytes for the bpf header option.  The
space will be used by <strong>bpf_store_hdr_opt</strong>() later in
<strong>BPF_SOCK_OPS_WRITE_HDR_OPT_CB</strong>.</p>
<p>If <strong>bpf_reserve_hdr_opt</strong>() is called multiple times,
the total number of bytes will be reserved.</p>
<p>This helper can only be called during
<strong>BPF_SOCK_OPS_HDR_OPT_LEN_CB</strong>.</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or negative error in case of failure:</p>
<p><strong>-EINVAL</strong> if a parameter is invalid.</p>
<p><strong>-ENOSPC</strong> if there is not enough space in the header.</p>
<p><strong>-EPERM</strong> if the helper cannot be used under the current
<em>skops</em><strong>-&gt;op</strong>.</p>
</dd>
</dl>
</dd>
<dt><strong>void *bpf_inode_storage_get(struct bpf_map *</strong><em>map</em><strong>, void *</strong><em>inode</em><strong>, void *</strong><em>value</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Get a bpf_local_storage from an <em>inode</em>.</p>
<p>Logically, it could be thought of as getting the value from
a <em>map</em> with <em>inode</em> as the <strong>key</strong>.  From this
perspective,  the usage is not much different from
<strong>bpf_map_lookup_elem</strong>(<em>map</em>, <strong>&amp;</strong><em>inode</em>) except this
helper enforces the key must be an inode and the map must also
be a <strong>BPF_MAP_TYPE_INODE_STORAGE</strong>.</p>
<p>Underneath, the value is stored locally at <em>inode</em> instead of
the <em>map</em>.  The <em>map</em> is used as the bpf-local-storage
“type”. The bpf-local-storage “type” (i.e. the <em>map</em>) is
searched against all bpf_local_storage residing at <em>inode</em>.</p>
<p>An optional <em>flags</em> (<strong>BPF_LOCAL_STORAGE_GET_F_CREATE</strong>) can be
used such that a new bpf_local_storage will be
created if one does not exist.  <em>value</em> can be used
together with <strong>BPF_LOCAL_STORAGE_GET_F_CREATE</strong> to specify
the initial value of a bpf_local_storage.  If <em>value</em> is
<strong>NULL</strong>, the new bpf_local_storage will be zero initialized.</p>
</dd>
<dt>Return</dt><dd><p>A bpf_local_storage pointer is returned on success.</p>
<p><strong>NULL</strong> if not found or there was an error in adding
a new bpf_local_storage.</p>
</dd>
</dl>
</dd>
<dt><strong>int bpf_inode_storage_delete(struct bpf_map *</strong><em>map</em><strong>, void *</strong><em>inode</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Delete a bpf_local_storage from an <em>inode</em>.</p>
</dd>
<dt>Return</dt><dd><p>0 on success.</p>
<p><strong>-ENOENT</strong> if the bpf_local_storage cannot be found.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_d_path(struct path *</strong><em>path</em><strong>, char *</strong><em>buf</em><strong>, u32</strong> <em>sz</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Return full path for given <strong>struct path</strong> object, which
needs to be the kernel BTF <em>path</em> object. The path is
returned in the provided buffer <em>buf</em> of size <em>sz</em> and
is zero terminated.</p>
</dd>
<dt>Return</dt><dd><p>On success, the strictly positive length of the string,
including the trailing NUL character. On error, a negative
value.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_copy_from_user(void *</strong><em>dst</em><strong>, u32</strong> <em>size</em><strong>, const void *</strong><em>user_ptr</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Read <em>size</em> bytes from user space address <em>user_ptr</em> and store
the data in <em>dst</em>. This is a wrapper of <strong>copy_from_user</strong>().</p>
</dd>
<dt>Return</dt><dd><p>0 on success, or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_snprintf_btf(char *</strong><em>str</em><strong>, u32</strong> <em>str_size</em><strong>, struct btf_ptr *</strong><em>ptr</em><strong>, u32</strong> <em>btf_ptr_size</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Use BTF to store a string representation of <em>ptr</em>-&gt;ptr in <em>str</em>,
using <em>ptr</em>-&gt;type_id.  This value should specify the type
that <em>ptr</em>-&gt;ptr points to. LLVM __builtin_btf_type_id(type, 1)
can be used to look up vmlinux BTF type ids. Traversing the
data structure using BTF, the type information and values are
stored in the first <em>str_size</em> - 1 bytes of <em>str</em>.  Safe copy of
the pointer data is carried out to avoid kernel crashes during
operation.  Smaller types can use string space on the stack;
larger programs can use map data to store the string
representation.</p>
<p>The string can be subsequently shared with userspace via
bpf_perf_event_output() or ring buffer interfaces.
bpf_trace_printk() is to be avoided as it places too small
a limit on string size to be useful.</p>
<p><em>flags</em> is a combination of</p>
<dl class="simple">
<dt><strong>BTF_F_COMPACT</strong></dt><dd><p>no formatting around type information</p>
</dd>
<dt><strong>BTF_F_NONAME</strong></dt><dd><p>no struct/union member names/types</p>
</dd>
<dt><strong>BTF_F_PTR_RAW</strong></dt><dd><p>show raw (unobfuscated) pointer values;
equivalent to printk specifier %px.</p>
</dd>
<dt><strong>BTF_F_ZERO</strong></dt><dd><p>show zero-valued struct/union members; they
are not displayed by default</p>
</dd>
</dl>
</dd>
<dt>Return</dt><dd><p>The number of bytes that were written (or would have been
written if output had to be truncated due to string size),
or a negative error in cases of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_seq_printf_btf(struct seq_file *</strong><em>m</em><strong>, struct btf_ptr *</strong><em>ptr</em><strong>, u32</strong> <em>ptr_size</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Use BTF to write to seq_write a string representation of
<em>ptr</em>-&gt;ptr, using <em>ptr</em>-&gt;type_id as per bpf_snprintf_btf().
<em>flags</em> are identical to those used for bpf_snprintf_btf.</p>
</dd>
<dt>Return</dt><dd><p>0 on success or a negative error in case of failure.</p>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_skb_cgroup_classid(struct sk_buff *</strong><em>skb</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>See <strong>bpf_get_cgroup_classid</strong>() for the main description.
This helper differs from <strong>bpf_get_cgroup_classid</strong>() in that
the cgroup v1 net_cls class is retrieved only from the <em>skb</em>’s
associated socket instead of the current process.</p>
</dd>
<dt>Return</dt><dd><p>The id is returned or 0 in case the id could not be retrieved.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_redirect_neigh(u32</strong> <em>ifindex</em><strong>, struct bpf_redir_neigh *</strong><em>params</em><strong>, int</strong> <em>plen</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Redirect the packet to another net device of index <em>ifindex</em>
and fill in L2 addresses from neighboring subsystem. This helper
is somewhat similar to <strong>bpf_redirect</strong>(), except that it
populates L2 addresses as well, meaning, internally, the helper
relies on the neighbor lookup for the L2 address of the nexthop.</p>
<p>The helper will perform a FIB lookup based on the skb’s
networking header to get the address of the next hop, unless
this is supplied by the caller in the <em>params</em> argument. The
<em>plen</em> argument indicates the len of <em>params</em> and should be set
to 0 if <em>params</em> is NULL.</p>
<p>The <em>flags</em> argument is reserved and must be 0. The helper is
currently only supported for tc BPF program types, and enabled
for IPv4 and IPv6 protocols.</p>
</dd>
<dt>Return</dt><dd><p>The helper returns <strong>TC_ACT_REDIRECT</strong> on success or
<strong>TC_ACT_SHOT</strong> on error.</p>
</dd>
</dl>
</dd>
<dt><strong>void *bpf_per_cpu_ptr(const void *</strong><em>percpu_ptr</em><strong>, u32</strong> <em>cpu</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Take a pointer to a percpu ksym, <em>percpu_ptr</em>, and return a
pointer to the percpu kernel variable on <em>cpu</em>. A ksym is an
extern variable decorated with ‘__ksym’. For ksym, there is a
global var (either static or global) defined of the same name
in the kernel. The ksym is percpu if the global var is percpu.
The returned pointer points to the global percpu var on <em>cpu</em>.</p>
<p>bpf_per_cpu_ptr() has the same semantic as per_cpu_ptr() in the
kernel, except that bpf_per_cpu_ptr() may return NULL. This
happens if <em>cpu</em> is larger than nr_cpu_ids. The caller of
bpf_per_cpu_ptr() must check the returned value.</p>
</dd>
<dt>Return</dt><dd><p>A pointer pointing to the kernel percpu variable on <em>cpu</em>, or
NULL, if <em>cpu</em> is invalid.</p>
</dd>
</dl>
</dd>
<dt><strong>void *bpf_this_cpu_ptr(const void *</strong><em>percpu_ptr</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Take a pointer to a percpu ksym, <em>percpu_ptr</em>, and return a
pointer to the percpu kernel variable on this cpu. See the
description of ‘ksym’ in <strong>bpf_per_cpu_ptr</strong>().</p>
<p>bpf_this_cpu_ptr() has the same semantic as this_cpu_ptr() in
the kernel. Different from <strong>bpf_per_cpu_ptr</strong>(), it would
never return NULL.</p>
</dd>
<dt>Return</dt><dd><p>A pointer pointing to the kernel percpu variable on this cpu.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_redirect_peer(u32</strong> <em>ifindex</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Redirect the packet to another net device of index <em>ifindex</em>.
This helper is somewhat similar to <strong>bpf_redirect</strong>(), except
that the redirection happens to the <em>ifindex</em>’ peer device and
the netns switch takes place from ingress to ingress without
going through the CPU’s backlog queue.</p>
<p>The <em>flags</em> argument is reserved and must be 0. The helper is
currently only supported for tc BPF program types at the ingress
hook and for veth device types. The peer device must reside in a
different network namespace.</p>
</dd>
<dt>Return</dt><dd><p>The helper returns <strong>TC_ACT_REDIRECT</strong> on success or
<strong>TC_ACT_SHOT</strong> on error.</p>
</dd>
</dl>
</dd>
<dt><strong>void *bpf_task_storage_get(struct bpf_map *</strong><em>map</em><strong>, struct task_struct *</strong><em>task</em><strong>, void *</strong><em>value</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Get a bpf_local_storage from the <em>task</em>.</p>
<p>Logically, it could be thought of as getting the value from
a <em>map</em> with <em>task</em> as the <strong>key</strong>.  From this
perspective,  the usage is not much different from
<strong>bpf_map_lookup_elem</strong>(<em>map</em>, <strong>&amp;</strong><em>task</em>) except this
helper enforces the key must be an task_struct and the map must also
be a <strong>BPF_MAP_TYPE_TASK_STORAGE</strong>.</p>
<p>Underneath, the value is stored locally at <em>task</em> instead of
the <em>map</em>.  The <em>map</em> is used as the bpf-local-storage
“type”. The bpf-local-storage “type” (i.e. the <em>map</em>) is
searched against all bpf_local_storage residing at <em>task</em>.</p>
<p>An optional <em>flags</em> (<strong>BPF_LOCAL_STORAGE_GET_F_CREATE</strong>) can be
used such that a new bpf_local_storage will be
created if one does not exist.  <em>value</em> can be used
together with <strong>BPF_LOCAL_STORAGE_GET_F_CREATE</strong> to specify
the initial value of a bpf_local_storage.  If <em>value</em> is
<strong>NULL</strong>, the new bpf_local_storage will be zero initialized.</p>
</dd>
<dt>Return</dt><dd><p>A bpf_local_storage pointer is returned on success.</p>
<p><strong>NULL</strong> if not found or there was an error in adding
a new bpf_local_storage.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_task_storage_delete(struct bpf_map *</strong><em>map</em><strong>, struct task_struct *</strong><em>task</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Delete a bpf_local_storage from a <em>task</em>.</p>
</dd>
<dt>Return</dt><dd><p>0 on success.</p>
<p><strong>-ENOENT</strong> if the bpf_local_storage cannot be found.</p>
</dd>
</dl>
</dd>
<dt><strong>struct task_struct *bpf_get_current_task_btf(void)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Return a BTF pointer to the “current” task.
This pointer can also be used in helpers that accept an
<em>ARG_PTR_TO_BTF_ID</em> of type <em>task_struct</em>.</p>
</dd>
<dt>Return</dt><dd><p>Pointer to the current task.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_bprm_opts_set(struct linux_binprm *</strong><em>bprm</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Set or clear certain options on <em>bprm</em>:</p>
<p><strong>BPF_F_BPRM_SECUREEXEC</strong> Set the secureexec bit
which sets the <strong>AT_SECURE</strong> auxv for glibc. The bit
is cleared if the flag is not specified.</p>
</dd>
<dt>Return</dt><dd><p><strong>-EINVAL</strong> if invalid <em>flags</em> are passed, zero otherwise.</p>
</dd>
</dl>
</dd>
<dt><strong>u64 bpf_ktime_get_coarse_ns(void)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Return a coarse-grained version of the time elapsed since
system boot, in nanoseconds. Does not include time the system
was suspended.</p>
<p>See: <strong>clock_gettime</strong>(<strong>CLOCK_MONOTONIC_COARSE</strong>)</p>
</dd>
<dt>Return</dt><dd><p>Current <em>ktime</em>.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_ima_inode_hash(struct inode *</strong><em>inode</em><strong>, void *</strong><em>dst</em><strong>, u32</strong> <em>size</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Returns the stored IMA hash of the <em>inode</em> (if it’s avaialable).
If the hash is larger than <em>size</em>, then only <em>size</em>
bytes will be copied to <em>dst</em></p>
</dd>
<dt>Return</dt><dd><p>The <strong>hash_algo</strong> is returned on success,
<strong>-EOPNOTSUP</strong> if IMA is disabled or <strong>-EINVAL</strong> if
invalid arguments are passed.</p>
</dd>
</dl>
</dd>
<dt><strong>struct socket *bpf_sock_from_file(struct file *</strong><em>file</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>If the given file represents a socket, returns the associated
socket.</p>
</dd>
<dt>Return</dt><dd><p>A pointer to a struct socket on success or NULL if the file is
not a socket.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_check_mtu(void *</strong><em>ctx</em><strong>, u32</strong> <em>ifindex</em><strong>, u32 *</strong><em>mtu_len</em><strong>, s32</strong> <em>len_diff</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Check packet size against exceeding MTU of net device (based
on <em>ifindex</em>).  This helper will likely be used in combination
with helpers that adjust/change the packet size.</p>
<p>The argument <em>len_diff</em> can be used for querying with a planned
size change. This allows to check MTU prior to changing packet
ctx. Providing an <em>len_diff</em> adjustment that is larger than the
actual packet size (resulting in negative packet size) will in
principle not exceed the MTU, why it is not considered a
failure.  Other BPF-helpers are needed for performing the
planned size change, why the responsability for catch a negative
packet size belong in those helpers.</p>
<p>Specifying <em>ifindex</em> zero means the MTU check is performed
against the current net device.  This is practical if this isn’t
used prior to redirect.</p>
<p>On input <em>mtu_len</em> must be a valid pointer, else verifier will
reject BPF program.  If the value <em>mtu_len</em> is initialized to
zero then the ctx packet size is use.  When value <em>mtu_len</em> is
provided as input this specify the L3 length that the MTU check
is done against. Remember XDP and TC length operate at L2, but
this value is L3 as this correlate to MTU and IP-header tot_len
values which are L3 (similar behavior as bpf_fib_lookup).</p>
<p>The Linux kernel route table can configure MTUs on a more
specific per route level, which is not provided by this helper.
For route level MTU checks use the <strong>bpf_fib_lookup</strong>()
helper.</p>
<p><em>ctx</em> is either <strong>struct xdp_md</strong> for XDP programs or
<strong>struct sk_buff</strong> for tc cls_act programs.</p>
<p>The <em>flags</em> argument can be a combination of one or more of the
following values:</p>
<dl class="simple">
<dt><strong>BPF_MTU_CHK_SEGS</strong></dt><dd><p>This flag will only works for <em>ctx</em> <strong>struct sk_buff</strong>.
If packet context contains extra packet segment buffers
(often knows as GSO skb), then MTU check is harder to
check at this point, because in transmit path it is
possible for the skb packet to get re-segmented
(depending on net device features).  This could still be
a MTU violation, so this flag enables performing MTU
check against segments, with a different violation
return code to tell it apart. Check cannot use len_diff.</p>
</dd>
</dl>
<p>On return <em>mtu_len</em> pointer contains the MTU value of the net
device.  Remember the net device configured MTU is the L3 size,
which is returned here and XDP and TC length operate at L2.
Helper take this into account for you, but remember when using
MTU value in your BPF-code.</p>
</dd>
<dt>Return</dt><dd><ul class="simple">
<li><p>0 on success, and populate MTU value in <em>mtu_len</em> pointer.</p></li>
<li><p>&lt; 0 if any input argument is invalid (<em>mtu_len</em> not updated)</p></li>
</ul>
<p>MTU violations return positive values, but also populate MTU
value in <em>mtu_len</em> pointer, as this can be needed for
implementing PMTU handing:</p>
<ul class="simple">
<li><p><strong>BPF_MTU_CHK_RET_FRAG_NEEDED</strong></p></li>
<li><p><strong>BPF_MTU_CHK_RET_SEGS_TOOBIG</strong></p></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>long bpf_for_each_map_elem(struct bpf_map *</strong><em>map</em><strong>, void *</strong><em>callback_fn</em><strong>, void *</strong><em>callback_ctx</em><strong>, u64</strong> <em>flags</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>For each element in <strong>map</strong>, call <strong>callback_fn</strong> function with
<strong>map</strong>, <strong>callback_ctx</strong> and other map-specific parameters.
The <strong>callback_fn</strong> should be a static function and
the <strong>callback_ctx</strong> should be a pointer to the stack.
The <strong>flags</strong> is used to control certain aspects of the helper.
Currently, the <strong>flags</strong> must be 0.</p>
<p>The following are a list of supported map types and their
respective expected callback signatures:</p>
<p>BPF_MAP_TYPE_HASH, BPF_MAP_TYPE_PERCPU_HASH,
BPF_MAP_TYPE_LRU_HASH, BPF_MAP_TYPE_LRU_PERCPU_HASH,
BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY</p>
<p>long (*callback_fn)(struct bpf_map *map, const void *key, void *value, void *ctx);</p>
<p>For per_cpu maps, the map_value is the value on the cpu where the
bpf_prog is running.</p>
<p>If <strong>callback_fn</strong> return 0, the helper will continue to the next
element. If return value is 1, the helper will skip the rest of
elements and return. Other return values are not used now.</p>
</dd>
<dt>Return</dt><dd><p>The number of traversed map elements for success, <strong>-EINVAL</strong> for
invalid <strong>flags</strong>.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_snprintf(char *</strong><em>str</em><strong>, u32</strong> <em>str_size</em><strong>, const char *</strong><em>fmt</em><strong>, u64 *</strong><em>data</em><strong>, u32</strong> <em>data_len</em><strong>)</strong></dt><dd><dl>
<dt>Description</dt><dd><p>Outputs a string into the <strong>str</strong> buffer of size <strong>str_size</strong>
based on a format string stored in a read-only map pointed by
<strong>fmt</strong>.</p>
<p>Each format specifier in <strong>fmt</strong> corresponds to one u64 element
in the <strong>data</strong> array. For strings and pointers where pointees
are accessed, only the pointer values are stored in the <em>data</em>
array. The <em>data_len</em> is the size of <em>data</em> in bytes.</p>
<p>Formats <strong>%s</strong> and <strong>%p{i,I}{4,6}</strong> require to read kernel
memory. Reading kernel memory may fail due to either invalid
address or valid address but requiring a major memory fault. If
reading kernel memory fails, the string for <strong>%s</strong> will be an
empty string, and the ip address for <strong>%p{i,I}{4,6}</strong> will be 0.
Not returning error to bpf program is consistent with what
<strong>bpf_trace_printk</strong>() does for now.</p>
</dd>
<dt>Return</dt><dd><p>The strictly positive length of the formatted string, including
the trailing zero character. If the return value is greater than
<strong>str_size</strong>, <strong>str</strong> contains a truncated string, guaranteed to
be zero-terminated except when <strong>str_size</strong> is 0.</p>
<p>Or <strong>-EBUSY</strong> if the per-CPU memory copy buffer is busy.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_sys_bpf(u32</strong> <em>cmd</em><strong>, void *</strong><em>attr</em><strong>, u32</strong> <em>attr_size</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Execute bpf syscall with given arguments.</p>
</dd>
<dt>Return</dt><dd><p>A syscall result.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_btf_find_by_name_kind(char *</strong><em>name</em><strong>, int</strong> <em>name_sz</em><strong>, u32</strong> <em>kind</em><strong>, int</strong> <em>flags</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Find BTF type with given name and kind in vmlinux BTF or in module’s BTFs.</p>
</dd>
<dt>Return</dt><dd><p>Returns btf_id and btf_obj_fd in lower and upper 32 bits.</p>
</dd>
</dl>
</dd>
<dt><strong>long bpf_sys_close(u32</strong> <em>fd</em><strong>)</strong></dt><dd><dl class="simple">
<dt>Description</dt><dd><p>Execute close syscall for given FD.</p>
</dd>
<dt>Return</dt><dd><p>A syscall result.</p>
</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="examples">
<h3>EXAMPLES<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<p>Example usage for most of the eBPF helpers listed in this manual page are
available within the Linux kernel sources, at the following locations:</p>
<ul class="simple">
<li><p><em>samples/bpf/</em></p></li>
<li><p><em>tools/testing/selftests/bpf/</em></p></li>
</ul>
</div>
<div class="section" id="license">
<h3>LICENSE<a class="headerlink" href="#license" title="Permalink to this headline">¶</a></h3>
<p>eBPF programs can have an associated license, passed along with the bytecode
instructions to the kernel when the programs are loaded. The format for that
string is identical to the one in use for kernel modules (Dual licenses, such
as “Dual BSD/GPL”, may be used). Some helper functions are only accessible to
programs that are compatible with the GNU Privacy License (GPL).</p>
<p>In order to use such helpers, the eBPF program must be loaded with the correct
license string passed (via <strong>attr</strong>) to the <strong>bpf</strong>() system call, and this
generally translates into the C source code of the program containing a line
similar to the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">char</span> <span class="n">____license</span><span class="p">[]</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">section</span><span class="p">(</span><span class="s2">&quot;license&quot;</span><span class="p">),</span> <span class="n">used</span><span class="p">))</span> <span class="o">=</span> <span class="s2">&quot;GPL&quot;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="implementation">
<h3>IMPLEMENTATION<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h3>
<p>This manual page is an effort to document the existing eBPF helper functions.
But as of this writing, the BPF sub-system is under heavy development. New eBPF
program or map types are added, along with new helper functions. Some helpers
are occasionally made available for additional program types. So in spite of
the efforts of the community, this page might not be up-to-date. If you want to
check by yourself what helper functions exist in your kernel, or what types of
programs they can support, here are some files among the kernel tree that you
may be interested in:</p>
<ul class="simple">
<li><p><em>include/uapi/linux/bpf.h</em> is the main BPF header. It contains the full list
of all helper functions, as well as many other BPF definitions including most
of the flags, structs or constants used by the helpers.</p></li>
<li><p><em>net/core/filter.c</em> contains the definition of most network-related helper
functions, and the list of program types from which they can be used.</p></li>
<li><p><em>kernel/trace/bpf_trace.c</em> is the equivalent for most tracing program-related
helpers.</p></li>
<li><p><em>kernel/bpf/verifier.c</em> contains the functions used to check that valid types
of eBPF maps are used with a given helper function.</p></li>
<li><p><em>kernel/bpf/</em> directory contains other files in which additional helpers are
defined (for cgroups, sockmaps, etc.).</p></li>
<li><p>The bpftool utility can be used to probe the availability of helper functions
on the system (as well as supported program and map types, and a number of
other parameters). To do so, run <strong>bpftool feature probe</strong> (see
<strong>bpftool-feature</strong>(8) for details). Add the <strong>unprivileged</strong> keyword to
list features available to unprivileged users.</p></li>
</ul>
<p>Compatibility between helper functions and program types can generally be found
in the files where helper functions are defined. Look for the <strong>struct
bpf_func_proto</strong> objects and for functions returning them: these functions
contain a list of helpers that a given program type can call. Note that the
<strong>default:</strong> label of the <strong>switch … case</strong> used to filter helpers can call
other functions, themselves allowing access to additional helpers. The
requirement for GPL license is also in those <strong>struct bpf_func_proto</strong>.</p>
<p>Compatibility between helper functions and map types can be found in the
<strong>check_map_func_compatibility</strong>() function in file <em>kernel/bpf/verifier.c</em>.</p>
<p>Helper functions that invalidate the checks on <strong>data</strong> and <strong>data_end</strong>
pointers for network processing are listed in function
<strong>bpf_helper_changes_pkt_data</strong>() in file <em>net/core/filter.c</em>.</p>
</div>
<div class="section" id="see-also">
<h3>SEE ALSO<a class="headerlink" href="#see-also" title="Permalink to this headline">¶</a></h3>
<p><strong>bpf</strong>(2),
<strong>bpftool</strong>(8),
<strong>cgroups</strong>(7),
<strong>ip</strong>(8),
<strong>perf_event_open</strong>(2),
<strong>sendmsg</strong>(2),
<strong>socket</strong>(7),
<strong>tc-bpf</strong>(8)</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Rachel.Sun.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>