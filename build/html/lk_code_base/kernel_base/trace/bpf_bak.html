<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>linux bpf/ebpf &mdash; Rachel&#39;s E-book 1.0 documentation</title><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> Rachel's E-book
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../os_base/index.html">linux 操作系统概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lk_devel/index.html">linux 内核开发基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../x86_kernel_base.html">linux X86内核基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../lk_code/index.html">linux 内核基础代码分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../pm.html">电源管理框架</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cpu.html">cpu管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../driver.html">设备驱动</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ps.html">进程管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mem.html">内存管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fs.html">文件系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sec.html">linux 内核安全</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../yocto_kernel.html">yocto uboot与内核模块、内核开发总结</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../uboot.html">uboot理解</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dot.html">dot画图</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bpf_helper.html">BPF-HELPERS</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Rachel's E-book</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>linux bpf/ebpf</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/lk_code_base/kernel_base/trace/bpf_bak.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="linux-bpf-ebpf">
<h1>linux bpf/ebpf<a class="headerlink" href="#linux-bpf-ebpf" title="Permalink to this headline">¶</a></h1>
<div class="section" id="uapi-linux-bpf-h">
<h2>内核导出头文件：uapi/linux/bpf.h<a class="headerlink" href="#uapi-linux-bpf-h" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>BPF syscall commands, see bpf(2) man-page for more details. <a href="#id1"><span class="problematic" id="id2">*</span></a>/</p></li>
</ul>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>DOC: eBPF Syscall Preamble</p></li>
<li></li>
<li><p>The operation to be performed by the <strong>bpf</strong>() system call is determined</p></li>
<li><p>by the <em>cmd</em> argument. Each operation takes an accompanying argument,</p></li>
<li><p>provided via <em>attr</em>, which is a pointer to a union of type <em>bpf_attr</em> (see</p></li>
<li><p>below). The size argument is the size of the union pointed to by <em>attr</em>.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>DOC: eBPF Syscall Commands</p></li>
<li></li>
<li><p>BPF_MAP_CREATE</p></li>
<li><p>Description</p></li>
<li><p>Create a map and return a file descriptor that refers to the</p></li>
<li><p>map. The close-on-exec file descriptor flag (see <strong>fcntl</strong>(2))</p></li>
<li><p>is automatically enabled for the new file descriptor.</p></li>
<li></li>
<li><p>Applying <strong>close</strong>(2) to the file descriptor returned by</p></li>
<li><p><strong>BPF_MAP_CREATE</strong> will delete the map (but see NOTES).</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>A new file descriptor (a nonnegative integer), or -1 if an</p></li>
<li><p>error occurred (in which case, <em>errno</em> is set appropriately).</p></li>
<li></li>
<li><p>BPF_MAP_LOOKUP_ELEM</p></li>
<li><p>Description</p></li>
<li><p>Look up an element with a given <em>key</em> in the map referred to</p></li>
<li><p>by the file descriptor <em>map_fd</em>.</p></li>
<li></li>
<li><p>The <em>flags</em> argument may be specified as one of the</p></li>
<li><p>following:</p></li>
<li></li>
<li><p><strong>BPF_F_LOCK</strong></p></li>
<li><p>Look up the value of a spin-locked map without</p></li>
<li><p>returning the lock. This must be specified if the</p></li>
<li><p>elements contain a spinlock.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, -1 is returned and <em>errno</em></p></li>
<li><p>is set appropriately.</p></li>
<li></li>
<li><p>BPF_MAP_UPDATE_ELEM</p></li>
<li><p>Description</p></li>
<li><p>Create or update an element (key/value pair) in a specified map.</p></li>
<li></li>
<li><p>The <em>flags</em> argument should be specified as one of the</p></li>
<li><p>following:</p></li>
<li></li>
<li><p><strong>BPF_ANY</strong></p></li>
<li><p>Create a new element or update an existing element.</p></li>
<li><p><strong>BPF_NOEXIST</strong></p></li>
<li><p>Create a new element only if it did not exist.</p></li>
<li><p><strong>BPF_EXIST</strong></p></li>
<li><p>Update an existing element.</p></li>
<li><p><strong>BPF_F_LOCK</strong></p></li>
<li><p>Update a spin_lock-ed map element.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, -1 is returned and <em>errno</em></p></li>
<li><p>is set appropriately.</p></li>
<li></li>
<li><p>May set <em>errno</em> to <strong>EINVAL</strong>, <strong>EPERM</strong>, <strong>ENOMEM</strong>,</p></li>
<li><p><strong>E2BIG</strong>, <strong>EEXIST</strong>, or <strong>ENOENT</strong>.</p></li>
<li></li>
<li><p><strong>E2BIG</strong></p></li>
<li><p>The number of elements in the map reached the</p></li>
<li><p><em>max_entries</em> limit specified at map creation time.</p></li>
<li><p><strong>EEXIST</strong></p></li>
<li><p>If <em>flags</em> specifies <strong>BPF_NOEXIST</strong> and the element</p></li>
<li><p>with <em>key</em> already exists in the map.</p></li>
<li><p><strong>ENOENT</strong></p></li>
<li><p>If <em>flags</em> specifies <strong>BPF_EXIST</strong> and the element with</p></li>
<li><p><em>key</em> does not exist in the map.</p></li>
<li></li>
<li><p>BPF_MAP_DELETE_ELEM</p></li>
<li><p>Description</p></li>
<li><p>Look up and delete an element by key in a specified map.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, -1 is returned and <em>errno</em></p></li>
<li><p>is set appropriately.</p></li>
<li></li>
<li><p>BPF_MAP_GET_NEXT_KEY</p></li>
<li><p>Description</p></li>
<li><p>Look up an element by key in a specified map and return the key</p></li>
<li><p>of the next element. Can be used to iterate over all elements</p></li>
<li><p>in the map.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, -1 is returned and <em>errno</em></p></li>
<li><p>is set appropriately.</p></li>
<li></li>
<li><p>The following cases can be used to iterate over all elements of</p></li>
<li><p>the map:</p></li>
<li></li>
<li><ul>
<li><p>If <em>key</em> is not found, the operation returns zero and sets</p></li>
</ul>
</li>
<li><p>the <em>next_key</em> pointer to the key of the first element.</p></li>
<li><ul>
<li><p>If <em>key</em> is found, the operation returns zero and sets the</p></li>
</ul>
</li>
<li><p><em>next_key</em> pointer to the key of the next element.</p></li>
<li><ul>
<li><p>If <em>key</em> is the last element, returns -1 and <em>errno</em> is set</p></li>
</ul>
</li>
<li><p>to <strong>ENOENT</strong>.</p></li>
<li></li>
<li><p>May set <em>errno</em> to <strong>ENOMEM</strong>, <strong>EFAULT</strong>, <strong>EPERM</strong>, or</p></li>
<li><p><strong>EINVAL</strong> on error.</p></li>
<li></li>
<li><p>BPF_PROG_LOAD</p></li>
<li><p>Description</p></li>
<li><p>Verify and load an eBPF program, returning a new file</p></li>
<li><p>descriptor associated with the program.</p></li>
<li></li>
<li><p>Applying <strong>close</strong>(2) to the file descriptor returned by</p></li>
<li><p><strong>BPF_PROG_LOAD</strong> will unload the eBPF program (but see NOTES).</p></li>
<li></li>
<li><p>The close-on-exec file descriptor flag (see <strong>fcntl</strong>(2)) is</p></li>
<li><p>automatically enabled for the new file descriptor.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>A new file descriptor (a nonnegative integer), or -1 if an</p></li>
<li><p>error occurred (in which case, <em>errno</em> is set appropriately).</p></li>
<li></li>
<li><p>BPF_OBJ_PIN</p></li>
<li><p>Description</p></li>
<li><p>Pin an eBPF program or map referred by the specified <em>bpf_fd</em></p></li>
<li><p>to the provided <em>pathname</em> on the filesystem.</p></li>
<li></li>
<li><p>The <em>pathname</em> argument must not contain a dot (“.”).</p></li>
<li></li>
<li><p>On success, <em>pathname</em> retains a reference to the eBPF object,</p></li>
<li><p>preventing deallocation of the object when the original</p></li>
<li><p><em>bpf_fd</em> is closed. This allow the eBPF object to live beyond</p></li>
<li><p><strong>close</strong>(<em>bpf_fd</em>), and hence the lifetime of the parent</p></li>
<li><p>process.</p></li>
<li></li>
<li><p>Applying <strong>unlink</strong>(2) or similar calls to the <em>pathname</em></p></li>
<li><p>unpins the object from the filesystem, removing the reference.</p></li>
<li><p>If no other file descriptors or filesystem nodes refer to the</p></li>
<li><p>same object, it will be deallocated (see NOTES).</p></li>
<li></li>
<li><p>The filesystem type for the parent directory of <em>pathname</em> must</p></li>
<li><p>be <strong>BPF_FS_MAGIC</strong>.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, -1 is returned and <em>errno</em></p></li>
<li><p>is set appropriately.</p></li>
<li></li>
<li><p>BPF_OBJ_GET</p></li>
<li><p>Description</p></li>
<li><p>Open a file descriptor for the eBPF object pinned to the</p></li>
<li><p>specified <em>pathname</em>.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>A new file descriptor (a nonnegative integer), or -1 if an</p></li>
<li><p>error occurred (in which case, <em>errno</em> is set appropriately).</p></li>
<li></li>
<li><p>BPF_PROG_ATTACH</p></li>
<li><p>Description</p></li>
<li><p>Attach an eBPF program to a <em>target_fd</em> at the specified</p></li>
<li><p><em>attach_type</em> hook.</p></li>
<li></li>
<li><p>The <em>attach_type</em> specifies the eBPF attachment point to</p></li>
<li><p>attach the program to, and must be one of <em>bpf_attach_type</em></p></li>
<li><p>(see below).</p></li>
<li></li>
<li><p>The <em>attach_bpf_fd</em> must be a valid file descriptor for a</p></li>
<li><p>loaded eBPF program of a cgroup, flow dissector, LIRC, sockmap</p></li>
<li><p>or sock_ops type corresponding to the specified <em>attach_type</em>.</p></li>
<li></li>
<li><p>The <em>target_fd</em> must be a valid file descriptor for a kernel</p></li>
<li><p>object which depends on the attach type of <em>attach_bpf_fd</em>:</p></li>
<li></li>
<li><p><strong>BPF_PROG_TYPE_CGROUP_DEVICE</strong>,</p></li>
<li><p><strong>BPF_PROG_TYPE_CGROUP_SKB</strong>,</p></li>
<li><p><strong>BPF_PROG_TYPE_CGROUP_SOCK</strong>,</p></li>
<li><p><strong>BPF_PROG_TYPE_CGROUP_SOCK_ADDR</strong>,</p></li>
<li><p><strong>BPF_PROG_TYPE_CGROUP_SOCKOPT</strong>,</p></li>
<li><p><strong>BPF_PROG_TYPE_CGROUP_SYSCTL</strong>,</p></li>
<li><p><strong>BPF_PROG_TYPE_SOCK_OPS</strong></p></li>
<li></li>
<li><p>Control Group v2 hierarchy with the eBPF controller</p></li>
<li><p>enabled. Requires the kernel to be compiled with</p></li>
<li><p><strong>CONFIG_CGROUP_BPF</strong>.</p></li>
<li></li>
<li><p><strong>BPF_PROG_TYPE_FLOW_DISSECTOR</strong></p></li>
<li></li>
<li><p>Network namespace (eg /proc/self/ns/net).</p></li>
<li></li>
<li><p><strong>BPF_PROG_TYPE_LIRC_MODE2</strong></p></li>
<li></li>
<li><p>LIRC device path (eg /dev/lircN). Requires the kernel</p></li>
<li><p>to be compiled with <strong>CONFIG_BPF_LIRC_MODE2</strong>.</p></li>
<li></li>
<li><p><strong>BPF_PROG_TYPE_SK_SKB</strong>,</p></li>
<li><p><strong>BPF_PROG_TYPE_SK_MSG</strong></p></li>
<li></li>
<li><p>eBPF map of socket type (eg <strong>BPF_MAP_TYPE_SOCKHASH</strong>).</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, -1 is returned and <em>errno</em></p></li>
<li><p>is set appropriately.</p></li>
<li></li>
<li><p>BPF_PROG_DETACH</p></li>
<li><p>Description</p></li>
<li><p>Detach the eBPF program associated with the <em>target_fd</em> at the</p></li>
<li><p>hook specified by <em>attach_type</em>. The program must have been</p></li>
<li><p>previously attached using <strong>BPF_PROG_ATTACH</strong>.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, -1 is returned and <em>errno</em></p></li>
<li><p>is set appropriately.</p></li>
<li></li>
<li><p>BPF_PROG_TEST_RUN</p></li>
<li><p>Description</p></li>
<li><p>Run the eBPF program associated with the <em>prog_fd</em> a <em>repeat</em></p></li>
<li><p>number of times against a provided program context <em>ctx_in</em> and</p></li>
<li><p>data <em>data_in</em>, and return the modified program context</p></li>
<li><p><em>ctx_out</em>, <em>data_out</em> (for example, packet data), result of the</p></li>
<li><p>execution <em>retval</em>, and <em>duration</em> of the test run.</p></li>
<li></li>
<li><p>The sizes of the buffers provided as input and output</p></li>
<li><p>parameters <em>ctx_in</em>, <em>ctx_out</em>, <em>data_in</em>, and <em>data_out</em> must</p></li>
<li><p>be provided in the corresponding variables <em>ctx_size_in</em>,</p></li>
<li><p><em>ctx_size_out</em>, <em>data_size_in</em>, and/or <em>data_size_out</em>. If any</p></li>
<li><p>of these parameters are not provided (ie set to NULL), the</p></li>
<li><p>corresponding size field must be zero.</p></li>
<li></li>
<li><p>Some program types have particular requirements:</p></li>
<li></li>
<li><p><strong>BPF_PROG_TYPE_SK_LOOKUP</strong></p></li>
<li><p><em>data_in</em> and <em>data_out</em> must be NULL.</p></li>
<li></li>
<li><p><strong>BPF_PROG_TYPE_XDP</strong></p></li>
<li><p><em>ctx_in</em> and <em>ctx_out</em> must be NULL.</p></li>
<li></li>
<li><p><strong>BPF_PROG_TYPE_RAW_TRACEPOINT</strong>,</p></li>
<li><p><strong>BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE</strong></p></li>
<li></li>
<li><p><em>ctx_out</em>, <em>data_in</em> and <em>data_out</em> must be NULL.</p></li>
<li><p><em>repeat</em> must be zero.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, -1 is returned and <em>errno</em></p></li>
<li><p>is set appropriately.</p></li>
<li></li>
<li><p><strong>ENOSPC</strong></p></li>
<li><p>Either <em>data_size_out</em> or <em>ctx_size_out</em> is too small.</p></li>
<li><p><strong>ENOTSUPP</strong></p></li>
<li><p>This command is not supported by the program type of</p></li>
<li><p>the program referred to by <em>prog_fd</em>.</p></li>
<li></li>
<li><p>BPF_PROG_GET_NEXT_ID</p></li>
<li><p>Description</p></li>
<li><p>Fetch the next eBPF program currently loaded into the kernel.</p></li>
<li></li>
<li><p>Looks for the eBPF program with an id greater than <em>start_id</em></p></li>
<li><p>and updates <em>next_id</em> on success. If no other eBPF programs</p></li>
<li><p>remain with ids higher than <em>start_id</em>, returns -1 and sets</p></li>
<li><p><em>errno</em> to <strong>ENOENT</strong>.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, or when no id remains, -1</p></li>
<li><p>is returned and <em>errno</em> is set appropriately.</p></li>
<li></li>
<li><p>BPF_MAP_GET_NEXT_ID</p></li>
<li><p>Description</p></li>
<li><p>Fetch the next eBPF map currently loaded into the kernel.</p></li>
<li></li>
<li><p>Looks for the eBPF map with an id greater than <em>start_id</em></p></li>
<li><p>and updates <em>next_id</em> on success. If no other eBPF maps</p></li>
<li><p>remain with ids higher than <em>start_id</em>, returns -1 and sets</p></li>
<li><p><em>errno</em> to <strong>ENOENT</strong>.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, or when no id remains, -1</p></li>
<li><p>is returned and <em>errno</em> is set appropriately.</p></li>
<li></li>
<li><p>BPF_PROG_GET_FD_BY_ID</p></li>
<li><p>Description</p></li>
<li><p>Open a file descriptor for the eBPF program corresponding to</p></li>
<li><p><em>prog_id</em>.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>A new file descriptor (a nonnegative integer), or -1 if an</p></li>
<li><p>error occurred (in which case, <em>errno</em> is set appropriately).</p></li>
<li></li>
<li><p>BPF_MAP_GET_FD_BY_ID</p></li>
<li><p>Description</p></li>
<li><p>Open a file descriptor for the eBPF map corresponding to</p></li>
<li><p><em>map_id</em>.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>A new file descriptor (a nonnegative integer), or -1 if an</p></li>
<li><p>error occurred (in which case, <em>errno</em> is set appropriately).</p></li>
<li></li>
<li><p>BPF_OBJ_GET_INFO_BY_FD</p></li>
<li><p>Description</p></li>
<li><p>Obtain information about the eBPF object corresponding to</p></li>
<li><p><em>bpf_fd</em>.</p></li>
<li></li>
<li><p>Populates up to <em>info_len</em> bytes of <em>info</em>, which will be in</p></li>
<li><p>one of the following formats depending on the eBPF object type</p></li>
<li><p>of <em>bpf_fd</em>:</p></li>
<li></li>
<li><ul>
<li><p><strong>struct bpf_prog_info</strong></p></li>
</ul>
</li>
<li><ul>
<li><p><strong>struct bpf_map_info</strong></p></li>
</ul>
</li>
<li><ul>
<li><p><strong>struct bpf_btf_info</strong></p></li>
</ul>
</li>
<li><ul>
<li><p><strong>struct bpf_link_info</strong></p></li>
</ul>
</li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, -1 is returned and <em>errno</em></p></li>
<li><p>is set appropriately.</p></li>
<li></li>
<li><p>BPF_PROG_QUERY</p></li>
<li><p>Description</p></li>
<li><p>Obtain information about eBPF programs associated with the</p></li>
<li><p>specified <em>attach_type</em> hook.</p></li>
<li></li>
<li><p>The <em>target_fd</em> must be a valid file descriptor for a kernel</p></li>
<li><p>object which depends on the attach type of <em>attach_bpf_fd</em>:</p></li>
<li></li>
<li><p><strong>BPF_PROG_TYPE_CGROUP_DEVICE</strong>,</p></li>
<li><p><strong>BPF_PROG_TYPE_CGROUP_SKB</strong>,</p></li>
<li><p><strong>BPF_PROG_TYPE_CGROUP_SOCK</strong>,</p></li>
<li><p><strong>BPF_PROG_TYPE_CGROUP_SOCK_ADDR</strong>,</p></li>
<li><p><strong>BPF_PROG_TYPE_CGROUP_SOCKOPT</strong>,</p></li>
<li><p><strong>BPF_PROG_TYPE_CGROUP_SYSCTL</strong>,</p></li>
<li><p><strong>BPF_PROG_TYPE_SOCK_OPS</strong></p></li>
<li></li>
<li><p>Control Group v2 hierarchy with the eBPF controller</p></li>
<li><p>enabled. Requires the kernel to be compiled with</p></li>
<li><p><strong>CONFIG_CGROUP_BPF</strong>.</p></li>
<li></li>
<li><p><strong>BPF_PROG_TYPE_FLOW_DISSECTOR</strong></p></li>
<li></li>
<li><p>Network namespace (eg /proc/self/ns/net).</p></li>
<li></li>
<li><p><strong>BPF_PROG_TYPE_LIRC_MODE2</strong></p></li>
<li></li>
<li><p>LIRC device path (eg /dev/lircN). Requires the kernel</p></li>
<li><p>to be compiled with <strong>CONFIG_BPF_LIRC_MODE2</strong>.</p></li>
<li></li>
<li><p><strong>BPF_PROG_QUERY</strong> always fetches the number of programs</p></li>
<li><p>attached and the <em>attach_flags</em> which were used to attach those</p></li>
<li><p>programs. Additionally, if <em>prog_ids</em> is nonzero and the number</p></li>
<li><p>of attached programs is less than <em>prog_cnt</em>, populates</p></li>
<li><p><em>prog_ids</em> with the eBPF program ids of the programs attached</p></li>
<li><p>at <em>target_fd</em>.</p></li>
<li></li>
<li><p>The following flags may alter the result:</p></li>
<li></li>
<li><p><strong>BPF_F_QUERY_EFFECTIVE</strong></p></li>
<li><p>Only return information regarding programs which are</p></li>
<li><p>currently effective at the specified <em>target_fd</em>.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, -1 is returned and <em>errno</em></p></li>
<li><p>is set appropriately.</p></li>
<li></li>
<li><p>BPF_RAW_TRACEPOINT_OPEN</p></li>
<li><p>Description</p></li>
<li><p>Attach an eBPF program to a tracepoint <em>name</em> to access kernel</p></li>
<li><p>internal arguments of the tracepoint in their raw form.</p></li>
<li></li>
<li><p>The <em>prog_fd</em> must be a valid file descriptor associated with</p></li>
<li><p>a loaded eBPF program of type <strong>BPF_PROG_TYPE_RAW_TRACEPOINT</strong>.</p></li>
<li></li>
<li><p>No ABI guarantees are made about the content of tracepoint</p></li>
<li><p>arguments exposed to the corresponding eBPF program.</p></li>
<li></li>
<li><p>Applying <strong>close</strong>(2) to the file descriptor returned by</p></li>
<li><p><strong>BPF_RAW_TRACEPOINT_OPEN</strong> will delete the map (but see NOTES).</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>A new file descriptor (a nonnegative integer), or -1 if an</p></li>
<li><p>error occurred (in which case, <em>errno</em> is set appropriately).</p></li>
<li></li>
<li><p>BPF_BTF_LOAD</p></li>
<li><p>Description</p></li>
<li><p>Verify and load BPF Type Format (BTF) metadata into the kernel,</p></li>
<li><p>returning a new file descriptor associated with the metadata.</p></li>
<li><p>BTF is described in more detail at</p></li>
<li><p><a class="reference external" href="https://www.kernel.org/doc/html/latest/bpf/btf.html">https://www.kernel.org/doc/html/latest/bpf/btf.html</a>.</p></li>
<li></li>
<li><p>The <em>btf</em> parameter must point to valid memory providing</p></li>
<li><p><em>btf_size</em> bytes of BTF binary metadata.</p></li>
<li></li>
<li><p>The returned file descriptor can be passed to other <strong>bpf</strong>()</p></li>
<li><p>subcommands such as <strong>BPF_PROG_LOAD</strong> or <strong>BPF_MAP_CREATE</strong> to</p></li>
<li><p>associate the BTF with those objects.</p></li>
<li></li>
<li><p>Similar to <strong>BPF_PROG_LOAD</strong>, <strong>BPF_BTF_LOAD</strong> has optional</p></li>
<li><p>parameters to specify a <em>btf_log_buf</em>, <em>btf_log_size</em> and</p></li>
<li><p><em>btf_log_level</em> which allow the kernel to return freeform log</p></li>
<li><p>output regarding the BTF verification process.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>A new file descriptor (a nonnegative integer), or -1 if an</p></li>
<li><p>error occurred (in which case, <em>errno</em> is set appropriately).</p></li>
<li></li>
<li><p>BPF_BTF_GET_FD_BY_ID</p></li>
<li><p>Description</p></li>
<li><p>Open a file descriptor for the BPF Type Format (BTF)</p></li>
<li><p>corresponding to <em>btf_id</em>.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>A new file descriptor (a nonnegative integer), or -1 if an</p></li>
<li><p>error occurred (in which case, <em>errno</em> is set appropriately).</p></li>
<li></li>
<li><p>BPF_TASK_FD_QUERY</p></li>
<li><p>Description</p></li>
<li><p>Obtain information about eBPF programs associated with the</p></li>
<li><p>target process identified by <em>pid</em> and <em>fd</em>.</p></li>
<li></li>
<li><p>If the <em>pid</em> and <em>fd</em> are associated with a tracepoint, kprobe</p></li>
<li><p>or uprobe perf event, then the <em>prog_id</em> and <em>fd_type</em> will</p></li>
<li><p>be populated with the eBPF program id and file descriptor type</p></li>
<li><p>of type <strong>bpf_task_fd_type</strong>. If associated with a kprobe or</p></li>
<li><p>uprobe, the  <em>probe_offset</em> and <em>probe_addr</em> will also be</p></li>
<li><p>populated. Optionally, if <em>buf</em> is provided, then up to</p></li>
<li><p><em>buf_len</em> bytes of <em>buf</em> will be populated with the name of</p></li>
<li><p>the tracepoint, kprobe or uprobe.</p></li>
<li></li>
<li><p>The resulting <em>prog_id</em> may be introspected in deeper detail</p></li>
<li><p>using <strong>BPF_PROG_GET_FD_BY_ID</strong> and <strong>BPF_OBJ_GET_INFO_BY_FD</strong>.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, -1 is returned and <em>errno</em></p></li>
<li><p>is set appropriately.</p></li>
<li></li>
<li><p>BPF_MAP_LOOKUP_AND_DELETE_ELEM</p></li>
<li><p>Description</p></li>
<li><p>Look up an element with the given <em>key</em> in the map referred to</p></li>
<li><p>by the file descriptor <em>fd</em>, and if found, delete the element.</p></li>
<li></li>
<li><p>For <strong>BPF_MAP_TYPE_QUEUE</strong> and <strong>BPF_MAP_TYPE_STACK</strong> map</p></li>
<li><p>types, the <em>flags</em> argument needs to be set to 0, but for other</p></li>
<li><p>map types, it may be specified as:</p></li>
<li></li>
<li><p><strong>BPF_F_LOCK</strong></p></li>
<li><p>Look up and delete the value of a spin-locked map</p></li>
<li><p>without returning the lock. This must be specified if</p></li>
<li><p>the elements contain a spinlock.</p></li>
<li></li>
<li><p>The <strong>BPF_MAP_TYPE_QUEUE</strong> and <strong>BPF_MAP_TYPE_STACK</strong> map types</p></li>
<li><p>implement this command as a “pop” operation, deleting the top</p></li>
<li><p>element rather than one corresponding to <em>key</em>.</p></li>
<li><p>The <em>key</em> and <em>key_len</em> parameters should be zeroed when</p></li>
<li><p>issuing this operation for these map types.</p></li>
<li></li>
<li><p>This command is only valid for the following map types:</p></li>
<li><ul>
<li><p><strong>BPF_MAP_TYPE_QUEUE</strong></p></li>
</ul>
</li>
<li><ul>
<li><p><strong>BPF_MAP_TYPE_STACK</strong></p></li>
</ul>
</li>
<li><ul>
<li><p><strong>BPF_MAP_TYPE_HASH</strong></p></li>
</ul>
</li>
<li><ul>
<li><p><strong>BPF_MAP_TYPE_PERCPU_HASH</strong></p></li>
</ul>
</li>
<li><ul>
<li><p><strong>BPF_MAP_TYPE_LRU_HASH</strong></p></li>
</ul>
</li>
<li><ul>
<li><p><strong>BPF_MAP_TYPE_LRU_PERCPU_HASH</strong></p></li>
</ul>
</li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, -1 is returned and <em>errno</em></p></li>
<li><p>is set appropriately.</p></li>
<li></li>
<li><p>BPF_MAP_FREEZE</p></li>
<li><p>Description</p></li>
<li><p>Freeze the permissions of the specified map.</p></li>
<li></li>
<li><p>Write permissions may be frozen by passing zero <em>flags</em>.</p></li>
<li><p>Upon success, no future syscall invocations may alter the</p></li>
<li><p>map state of <em>map_fd</em>. Write operations from eBPF programs</p></li>
<li><p>are still possible for a frozen map.</p></li>
<li></li>
<li><p>Not supported for maps of type <strong>BPF_MAP_TYPE_STRUCT_OPS</strong>.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, -1 is returned and <em>errno</em></p></li>
<li><p>is set appropriately.</p></li>
<li></li>
<li><p>BPF_BTF_GET_NEXT_ID</p></li>
<li><p>Description</p></li>
<li><p>Fetch the next BPF Type Format (BTF) object currently loaded</p></li>
<li><p>into the kernel.</p></li>
<li></li>
<li><p>Looks for the BTF object with an id greater than <em>start_id</em></p></li>
<li><p>and updates <em>next_id</em> on success. If no other BTF objects</p></li>
<li><p>remain with ids higher than <em>start_id</em>, returns -1 and sets</p></li>
<li><p><em>errno</em> to <strong>ENOENT</strong>.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, or when no id remains, -1</p></li>
<li><p>is returned and <em>errno</em> is set appropriately.</p></li>
<li></li>
<li><p>BPF_MAP_LOOKUP_BATCH</p></li>
<li><p>Description</p></li>
<li><p>Iterate and fetch multiple elements in a map.</p></li>
<li></li>
<li><p>Two opaque values are used to manage batch operations,</p></li>
<li><p><em>in_batch</em> and <em>out_batch</em>. Initially, <em>in_batch</em> must be set</p></li>
<li><p>to NULL to begin the batched operation. After each subsequent</p></li>
<li><p><strong>BPF_MAP_LOOKUP_BATCH</strong>, the caller should pass the resultant</p></li>
<li><p><em>out_batch</em> as the <em>in_batch</em> for the next operation to</p></li>
<li><p>continue iteration from the current point.</p></li>
<li></li>
<li><p>The <em>keys</em> and <em>values</em> are output parameters which must point</p></li>
<li><p>to memory large enough to hold <em>count</em> items based on the key</p></li>
<li><p>and value size of the map <em>map_fd</em>. The <em>keys</em> buffer must be</p></li>
<li><p>of <em>key_size</em> * <em>count</em>. The <em>values</em> buffer must be of</p></li>
<li><p><em>value_size</em> * <em>count</em>.</p></li>
<li></li>
<li><p>The <em>elem_flags</em> argument may be specified as one of the</p></li>
<li><p>following:</p></li>
<li></li>
<li><p><strong>BPF_F_LOCK</strong></p></li>
<li><p>Look up the value of a spin-locked map without</p></li>
<li><p>returning the lock. This must be specified if the</p></li>
<li><p>elements contain a spinlock.</p></li>
<li></li>
<li><p>On success, <em>count</em> elements from the map are copied into the</p></li>
<li><p>user buffer, with the keys copied into <em>keys</em> and the values</p></li>
<li><p>copied into the corresponding indices in <em>values</em>.</p></li>
<li></li>
<li><p>If an error is returned and <em>errno</em> is not <strong>EFAULT</strong>, <em>count</em></p></li>
<li><p>is set to the number of successfully processed elements.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, -1 is returned and <em>errno</em></p></li>
<li><p>is set appropriately.</p></li>
<li></li>
<li><p>May set <em>errno</em> to <strong>ENOSPC</strong> to indicate that <em>keys</em> or</p></li>
<li><p><em>values</em> is too small to dump an entire bucket during</p></li>
<li><p>iteration of a hash-based map type.</p></li>
<li></li>
<li><p>BPF_MAP_LOOKUP_AND_DELETE_BATCH</p></li>
<li><p>Description</p></li>
<li><p>Iterate and delete all elements in a map.</p></li>
<li></li>
<li><p>This operation has the same behavior as</p></li>
<li><p><strong>BPF_MAP_LOOKUP_BATCH</strong> with two exceptions:</p></li>
<li></li>
<li><ul>
<li><p>Every element that is successfully returned is also deleted</p></li>
</ul>
</li>
<li><p>from the map. This is at least <em>count</em> elements. Note that</p></li>
<li><p><em>count</em> is both an input and an output parameter.</p></li>
<li><ul>
<li><p>Upon returning with <em>errno</em> set to <strong>EFAULT</strong>, up to</p></li>
</ul>
</li>
<li><p><em>count</em> elements may be deleted without returning the keys</p></li>
<li><p>and values of the deleted elements.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, -1 is returned and <em>errno</em></p></li>
<li><p>is set appropriately.</p></li>
<li></li>
<li><p>BPF_MAP_UPDATE_BATCH</p></li>
<li><p>Description</p></li>
<li><p>Update multiple elements in a map by <em>key</em>.</p></li>
<li></li>
<li><p>The <em>keys</em> and <em>values</em> are input parameters which must point</p></li>
<li><p>to memory large enough to hold <em>count</em> items based on the key</p></li>
<li><p>and value size of the map <em>map_fd</em>. The <em>keys</em> buffer must be</p></li>
<li><p>of <em>key_size</em> * <em>count</em>. The <em>values</em> buffer must be of</p></li>
<li><p><em>value_size</em> * <em>count</em>.</p></li>
<li></li>
<li><p>Each element specified in <em>keys</em> is sequentially updated to the</p></li>
<li><p>value in the corresponding index in <em>values</em>. The <em>in_batch</em></p></li>
<li><p>and <em>out_batch</em> parameters are ignored and should be zeroed.</p></li>
<li></li>
<li><p>The <em>elem_flags</em> argument should be specified as one of the</p></li>
<li><p>following:</p></li>
<li></li>
<li><p><strong>BPF_ANY</strong></p></li>
<li><p>Create new elements or update a existing elements.</p></li>
<li><p><strong>BPF_NOEXIST</strong></p></li>
<li><p>Create new elements only if they do not exist.</p></li>
<li><p><strong>BPF_EXIST</strong></p></li>
<li><p>Update existing elements.</p></li>
<li><p><strong>BPF_F_LOCK</strong></p></li>
<li><p>Update spin_lock-ed map elements. This must be</p></li>
<li><p>specified if the map value contains a spinlock.</p></li>
<li></li>
<li><p>On success, <em>count</em> elements from the map are updated.</p></li>
<li></li>
<li><p>If an error is returned and <em>errno</em> is not <strong>EFAULT</strong>, <em>count</em></p></li>
<li><p>is set to the number of successfully processed elements.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, -1 is returned and <em>errno</em></p></li>
<li><p>is set appropriately.</p></li>
<li></li>
<li><p>May set <em>errno</em> to <strong>EINVAL</strong>, <strong>EPERM</strong>, <strong>ENOMEM</strong>, or</p></li>
<li><p><strong>E2BIG</strong>. <strong>E2BIG</strong> indicates that the number of elements in</p></li>
<li><p>the map reached the <em>max_entries</em> limit specified at map</p></li>
<li><p>creation time.</p></li>
<li></li>
<li><p>May set <em>errno</em> to one of the following error codes under</p></li>
<li><p>specific circumstances:</p></li>
<li></li>
<li><p><strong>EEXIST</strong></p></li>
<li><p>If <em>flags</em> specifies <strong>BPF_NOEXIST</strong> and the element</p></li>
<li><p>with <em>key</em> already exists in the map.</p></li>
<li><p><strong>ENOENT</strong></p></li>
<li><p>If <em>flags</em> specifies <strong>BPF_EXIST</strong> and the element with</p></li>
<li><p><em>key</em> does not exist in the map.</p></li>
<li></li>
<li><p>BPF_MAP_DELETE_BATCH</p></li>
<li><p>Description</p></li>
<li><p>Delete multiple elements in a map by <em>key</em>.</p></li>
<li></li>
<li><p>The <em>keys</em> parameter is an input parameter which must point</p></li>
<li><p>to memory large enough to hold <em>count</em> items based on the key</p></li>
<li><p>size of the map <em>map_fd</em>, that is, <em>key_size</em> * <em>count</em>.</p></li>
<li></li>
<li><p>Each element specified in <em>keys</em> is sequentially deleted. The</p></li>
<li><p><em>in_batch</em>, <em>out_batch</em>, and <em>values</em> parameters are ignored</p></li>
<li><p>and should be zeroed.</p></li>
<li></li>
<li><p>The <em>elem_flags</em> argument may be specified as one of the</p></li>
<li><p>following:</p></li>
<li></li>
<li><p><strong>BPF_F_LOCK</strong></p></li>
<li><p>Look up the value of a spin-locked map without</p></li>
<li><p>returning the lock. This must be specified if the</p></li>
<li><p>elements contain a spinlock.</p></li>
<li></li>
<li><p>On success, <em>count</em> elements from the map are updated.</p></li>
<li></li>
<li><p>If an error is returned and <em>errno</em> is not <strong>EFAULT</strong>, <em>count</em></p></li>
<li><p>is set to the number of successfully processed elements. If</p></li>
<li><p><em>errno</em> is <strong>EFAULT</strong>, up to <em>count</em> elements may be been</p></li>
<li><p>deleted.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, -1 is returned and <em>errno</em></p></li>
<li><p>is set appropriately.</p></li>
<li></li>
<li><p>BPF_LINK_CREATE</p></li>
<li><p>Description</p></li>
<li><p>Attach an eBPF program to a <em>target_fd</em> at the specified</p></li>
<li><p><em>attach_type</em> hook and return a file descriptor handle for</p></li>
<li><p>managing the link.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>A new file descriptor (a nonnegative integer), or -1 if an</p></li>
<li><p>error occurred (in which case, <em>errno</em> is set appropriately).</p></li>
<li></li>
<li><p>BPF_LINK_UPDATE</p></li>
<li><p>Description</p></li>
<li><p>Update the eBPF program in the specified <em>link_fd</em> to</p></li>
<li><p><em>new_prog_fd</em>.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, -1 is returned and <em>errno</em></p></li>
<li><p>is set appropriately.</p></li>
<li></li>
<li><p>BPF_LINK_GET_FD_BY_ID</p></li>
<li><p>Description</p></li>
<li><p>Open a file descriptor for the eBPF Link corresponding to</p></li>
<li><p><em>link_id</em>.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>A new file descriptor (a nonnegative integer), or -1 if an</p></li>
<li><p>error occurred (in which case, <em>errno</em> is set appropriately).</p></li>
<li></li>
<li><p>BPF_LINK_GET_NEXT_ID</p></li>
<li><p>Description</p></li>
<li><p>Fetch the next eBPF link currently loaded into the kernel.</p></li>
<li></li>
<li><p>Looks for the eBPF link with an id greater than <em>start_id</em></p></li>
<li><p>and updates <em>next_id</em> on success. If no other eBPF links</p></li>
<li><p>remain with ids higher than <em>start_id</em>, returns -1 and sets</p></li>
<li><p><em>errno</em> to <strong>ENOENT</strong>.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, or when no id remains, -1</p></li>
<li><p>is returned and <em>errno</em> is set appropriately.</p></li>
<li></li>
<li><p>BPF_ENABLE_STATS</p></li>
<li><p>Description</p></li>
<li><p>Enable eBPF runtime statistics gathering.</p></li>
<li></li>
<li><p>Runtime statistics gathering for the eBPF runtime is disabled</p></li>
<li><p>by default to minimize the corresponding performance overhead.</p></li>
<li><p>This command enables statistics globally.</p></li>
<li></li>
<li><p>Multiple programs may independently enable statistics.</p></li>
<li><p>After gathering the desired statistics, eBPF runtime statistics</p></li>
<li><p>may be disabled again by calling <strong>close</strong>(2) for the file</p></li>
<li><p>descriptor returned by this function. Statistics will only be</p></li>
<li><p>disabled system-wide when all outstanding file descriptors</p></li>
<li><p>returned by prior calls for this subcommand are closed.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>A new file descriptor (a nonnegative integer), or -1 if an</p></li>
<li><p>error occurred (in which case, <em>errno</em> is set appropriately).</p></li>
<li></li>
<li><p>BPF_ITER_CREATE</p></li>
<li><p>Description</p></li>
<li><p>Create an iterator on top of the specified <em>link_fd</em> (as</p></li>
<li><p>previously created using <strong>BPF_LINK_CREATE</strong>) and return a</p></li>
<li><p>file descriptor that can be used to trigger the iteration.</p></li>
<li></li>
<li><p>If the resulting file descriptor is pinned to the filesystem</p></li>
<li><p>using  <strong>BPF_OBJ_PIN</strong>, then subsequent <strong>read</strong>(2) syscalls</p></li>
<li><p>for that path will trigger the iterator to read kernel state</p></li>
<li><p>using the eBPF program attached to <em>link_fd</em>.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>A new file descriptor (a nonnegative integer), or -1 if an</p></li>
<li><p>error occurred (in which case, <em>errno</em> is set appropriately).</p></li>
<li></li>
<li><p>BPF_LINK_DETACH</p></li>
<li><p>Description</p></li>
<li><p>Forcefully detach the specified <em>link_fd</em> from its</p></li>
<li><p>corresponding attachment point.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, -1 is returned and <em>errno</em></p></li>
<li><p>is set appropriately.</p></li>
<li></li>
<li><p>BPF_PROG_BIND_MAP</p></li>
<li><p>Description</p></li>
<li><p>Bind a map to the lifetime of an eBPF program.</p></li>
<li></li>
<li><p>The map identified by <em>map_fd</em> is bound to the program</p></li>
<li><p>identified by <em>prog_fd</em> and only released when <em>prog_fd</em> is</p></li>
<li><p>released. This may be used in cases where metadata should be</p></li>
<li><p>associated with a program which otherwise does not contain any</p></li>
<li><p>references to the map (for example, embedded in the eBPF</p></li>
<li><p>program instructions).</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>Returns zero on success. On error, -1 is returned and <em>errno</em></p></li>
<li><p>is set appropriately.</p></li>
<li></li>
<li><p>NOTES</p></li>
<li><p>eBPF objects (maps and programs) can be shared between processes.</p></li>
<li></li>
<li><ul>
<li><p>After <strong>fork</strong>(2), the child inherits file descriptors</p></li>
</ul>
</li>
<li><p>referring to the same eBPF objects.</p></li>
<li><ul>
<li><p>File descriptors referring to eBPF objects can be transferred over</p></li>
</ul>
</li>
<li><p><strong>unix</strong>(7) domain sockets.</p></li>
<li><ul>
<li><p>File descriptors referring to eBPF objects can be duplicated in the</p></li>
</ul>
</li>
<li><p>usual way, using <strong>dup</strong>(2) and similar calls.</p></li>
<li><ul>
<li><p>File descriptors referring to eBPF objects can be pinned to the</p></li>
</ul>
</li>
<li><p>filesystem using the <strong>BPF_OBJ_PIN</strong> command of <strong>bpf</strong>(2).</p></li>
<li></li>
<li><p>An eBPF object is deallocated only after all file descriptors referring</p></li>
<li><p>to the object have been closed and no references remain pinned to the</p></li>
<li><p>filesystem or attached (for example, bound to a program or device).</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
<dl class="simple">
<dt>enum bpf_cmd {</dt><dd><p>BPF_MAP_CREATE,
BPF_MAP_LOOKUP_ELEM,
BPF_MAP_UPDATE_ELEM,
BPF_MAP_DELETE_ELEM,
BPF_MAP_GET_NEXT_KEY,
BPF_PROG_LOAD,
BPF_OBJ_PIN,
BPF_OBJ_GET,
BPF_PROG_ATTACH,
BPF_PROG_DETACH,
BPF_PROG_TEST_RUN,
BPF_PROG_RUN = BPF_PROG_TEST_RUN,
BPF_PROG_GET_NEXT_ID,
BPF_MAP_GET_NEXT_ID,
BPF_PROG_GET_FD_BY_ID,
BPF_MAP_GET_FD_BY_ID,
BPF_OBJ_GET_INFO_BY_FD,
BPF_PROG_QUERY,
BPF_RAW_TRACEPOINT_OPEN,
BPF_BTF_LOAD,
BPF_BTF_GET_FD_BY_ID,
BPF_TASK_FD_QUERY,
BPF_MAP_LOOKUP_AND_DELETE_ELEM,
BPF_MAP_FREEZE,
BPF_BTF_GET_NEXT_ID,
BPF_MAP_LOOKUP_BATCH,
BPF_MAP_LOOKUP_AND_DELETE_BATCH,
BPF_MAP_UPDATE_BATCH,
BPF_MAP_DELETE_BATCH,
BPF_LINK_CREATE,
BPF_LINK_UPDATE,
BPF_LINK_GET_FD_BY_ID,
BPF_LINK_GET_NEXT_ID,
BPF_ENABLE_STATS,
BPF_ITER_CREATE,
BPF_LINK_DETACH,
BPF_PROG_BIND_MAP,</p>
</dd>
</dl>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>enum bpf_map_type {</dt><dd><p>BPF_MAP_TYPE_UNSPEC,
BPF_MAP_TYPE_HASH,
BPF_MAP_TYPE_ARRAY,
BPF_MAP_TYPE_PROG_ARRAY,
BPF_MAP_TYPE_PERF_EVENT_ARRAY,
BPF_MAP_TYPE_PERCPU_HASH,
BPF_MAP_TYPE_PERCPU_ARRAY,
BPF_MAP_TYPE_STACK_TRACE,
BPF_MAP_TYPE_CGROUP_ARRAY,
BPF_MAP_TYPE_LRU_HASH,
BPF_MAP_TYPE_LRU_PERCPU_HASH,
BPF_MAP_TYPE_LPM_TRIE,
BPF_MAP_TYPE_ARRAY_OF_MAPS,
BPF_MAP_TYPE_HASH_OF_MAPS,
BPF_MAP_TYPE_DEVMAP,
BPF_MAP_TYPE_SOCKMAP,
BPF_MAP_TYPE_CPUMAP,
BPF_MAP_TYPE_XSKMAP,
BPF_MAP_TYPE_SOCKHASH,
BPF_MAP_TYPE_CGROUP_STORAGE,
BPF_MAP_TYPE_REUSEPORT_SOCKARRAY,
BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE,
BPF_MAP_TYPE_QUEUE,
BPF_MAP_TYPE_STACK,
BPF_MAP_TYPE_SK_STORAGE,
BPF_MAP_TYPE_DEVMAP_HASH,
BPF_MAP_TYPE_STRUCT_OPS,
BPF_MAP_TYPE_RINGBUF,
BPF_MAP_TYPE_INODE_STORAGE,
BPF_MAP_TYPE_TASK_STORAGE,</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>/* Note that tracing related programs such as</dt><dd><ul class="simple">
<li><p>BPF_PROG_TYPE_{KPROBE,TRACEPOINT,PERF_EVENT,RAW_TRACEPOINT}</p></li>
<li><p>are not subject to a stable API since kernel internal data</p></li>
<li><p>structures can change from release to release and may</p></li>
<li><p>therefore break existing tracing BPF programs. Tracing BPF</p></li>
<li><p>programs correspond to /a/ specific kernel which is to be</p></li>
<li><p>analyzed, and not /a/ specific kernel /and/ all future ones.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>enum bpf_prog_type {</dt><dd><p>BPF_PROG_TYPE_UNSPEC,
BPF_PROG_TYPE_SOCKET_FILTER,
BPF_PROG_TYPE_KPROBE,
BPF_PROG_TYPE_SCHED_CLS,
BPF_PROG_TYPE_SCHED_ACT,
BPF_PROG_TYPE_TRACEPOINT,
BPF_PROG_TYPE_XDP,
BPF_PROG_TYPE_PERF_EVENT,
BPF_PROG_TYPE_CGROUP_SKB,
BPF_PROG_TYPE_CGROUP_SOCK,
BPF_PROG_TYPE_LWT_IN,
BPF_PROG_TYPE_LWT_OUT,
BPF_PROG_TYPE_LWT_XMIT,
BPF_PROG_TYPE_SOCK_OPS,
BPF_PROG_TYPE_SK_SKB,
BPF_PROG_TYPE_CGROUP_DEVICE,
BPF_PROG_TYPE_SK_MSG,
BPF_PROG_TYPE_RAW_TRACEPOINT,
BPF_PROG_TYPE_CGROUP_SOCK_ADDR,
BPF_PROG_TYPE_LWT_SEG6LOCAL,
BPF_PROG_TYPE_LIRC_MODE2,
BPF_PROG_TYPE_SK_REUSEPORT,
BPF_PROG_TYPE_FLOW_DISSECTOR,
BPF_PROG_TYPE_CGROUP_SYSCTL,
BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE,
BPF_PROG_TYPE_CGROUP_SOCKOPT,
BPF_PROG_TYPE_TRACING,
BPF_PROG_TYPE_STRUCT_OPS,
BPF_PROG_TYPE_EXT,
BPF_PROG_TYPE_LSM,
BPF_PROG_TYPE_SK_LOOKUP,
BPF_PROG_TYPE_SYSCALL, /* a program that can execute syscalls <a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>enum bpf_attach_type {</dt><dd><p>BPF_CGROUP_INET_INGRESS,
BPF_CGROUP_INET_EGRESS,
BPF_CGROUP_INET_SOCK_CREATE,
BPF_CGROUP_SOCK_OPS,
BPF_SK_SKB_STREAM_PARSER,
BPF_SK_SKB_STREAM_VERDICT,
BPF_CGROUP_DEVICE,
BPF_SK_MSG_VERDICT,
BPF_CGROUP_INET4_BIND,
BPF_CGROUP_INET6_BIND,
BPF_CGROUP_INET4_CONNECT,
BPF_CGROUP_INET6_CONNECT,
BPF_CGROUP_INET4_POST_BIND,
BPF_CGROUP_INET6_POST_BIND,
BPF_CGROUP_UDP4_SENDMSG,
BPF_CGROUP_UDP6_SENDMSG,
BPF_LIRC_MODE2,
BPF_FLOW_DISSECTOR,
BPF_CGROUP_SYSCTL,
BPF_CGROUP_UDP4_RECVMSG,
BPF_CGROUP_UDP6_RECVMSG,
BPF_CGROUP_GETSOCKOPT,
BPF_CGROUP_SETSOCKOPT,
BPF_TRACE_RAW_TP,
BPF_TRACE_FENTRY,
BPF_TRACE_FEXIT,
BPF_MODIFY_RETURN,
BPF_LSM_MAC,
BPF_TRACE_ITER,
BPF_CGROUP_INET4_GETPEERNAME,
BPF_CGROUP_INET6_GETPEERNAME,
BPF_CGROUP_INET4_GETSOCKNAME,
BPF_CGROUP_INET6_GETSOCKNAME,
BPF_XDP_DEVMAP,
BPF_CGROUP_INET_SOCK_RELEASE,
BPF_XDP_CPUMAP,
BPF_SK_LOOKUP,
BPF_XDP,
BPF_SK_SKB_VERDICT,
BPF_SK_REUSEPORT_SELECT,
BPF_SK_REUSEPORT_SELECT_OR_MIGRATE,
__MAX_BPF_ATTACH_TYPE</p>
</dd>
</dl>
<p>};</p>
<p>#define MAX_BPF_ATTACH_TYPE __MAX_BPF_ATTACH_TYPE</p>
<dl>
<dt>enum bpf_link_type {</dt><dd><p>BPF_LINK_TYPE_UNSPEC = 0,
BPF_LINK_TYPE_RAW_TRACEPOINT = 1,
BPF_LINK_TYPE_TRACING = 2,
BPF_LINK_TYPE_CGROUP = 3,
BPF_LINK_TYPE_ITER = 4,
BPF_LINK_TYPE_NETNS = 5,
BPF_LINK_TYPE_XDP = 6,</p>
<p>MAX_BPF_LINK_TYPE,</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>/* cgroup-bpf attach flags used in BPF_PROG_ATTACH command</dt><dd><ul class="simple">
<li></li>
<li><p>NONE(default): No further bpf programs allowed in the subtree.</p></li>
<li></li>
<li><p>BPF_F_ALLOW_OVERRIDE: If a sub-cgroup installs some bpf program,</p></li>
<li><p>the program in this cgroup yields to sub-cgroup program.</p></li>
<li></li>
<li><p>BPF_F_ALLOW_MULTI: If a sub-cgroup installs some bpf program,</p></li>
<li><p>that cgroup program gets run in addition to the program in this cgroup.</p></li>
<li></li>
<li><p>Only one program is allowed to be attached to a cgroup with</p></li>
<li><p>NONE or BPF_F_ALLOW_OVERRIDE flag.</p></li>
<li><p>Attaching another program on top of NONE or BPF_F_ALLOW_OVERRIDE will</p></li>
<li><p>release old program and attach the new one. Attach flags has to match.</p></li>
<li></li>
<li><p>Multiple programs are allowed to be attached to a cgroup with</p></li>
<li><p>BPF_F_ALLOW_MULTI flag. They are executed in FIFO order</p></li>
<li><p>(those that were attached first, run first)</p></li>
<li><p>The programs of sub-cgroup are executed first, then programs of</p></li>
<li><p>this cgroup and then programs of parent cgroup.</p></li>
<li><p>When children program makes decision (like picking TCP CA or sock bind)</p></li>
<li><p>parent program has a chance to override it.</p></li>
<li></li>
<li><p>With BPF_F_ALLOW_MULTI a new program is added to the end of the list of</p></li>
<li><p>programs for a cgroup. Though it’s possible to replace an old program at</p></li>
<li><p>any position by also specifying BPF_F_REPLACE flag and position itself in</p></li>
<li><p>replace_bpf_fd attribute. Old program at this position will be released.</p></li>
<li></li>
<li><p>A cgroup with MULTI or OVERRIDE flag allows any attach flags in sub-cgroups.</p></li>
<li><p>A cgroup with NONE doesn’t allow any programs in sub-cgroups.</p></li>
<li><p>Ex1:</p></li>
<li><p>cgrp1 (MULTI progs A, B) -&gt;</p></li>
<li><p>cgrp2 (OVERRIDE prog C) -&gt;</p></li>
<li><p>cgrp3 (MULTI prog D) -&gt;</p></li>
<li><p>cgrp4 (OVERRIDE prog E) -&gt;</p></li>
<li><p>cgrp5 (NONE prog F)</p></li>
<li><p>the event in cgrp5 triggers execution of F,D,A,B in that order.</p></li>
<li><p>if prog F is detached, the execution is E,D,A,B</p></li>
<li><p>if prog F and D are detached, the execution is E,A,B</p></li>
<li><p>if prog F, E and D are detached, the execution is C,A,B</p></li>
<li></li>
<li><p>All eligible programs are executed regardless of return code from</p></li>
<li><p>earlier programs.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
</dl>
<p>#define BPF_F_ALLOW_OVERRIDE    (1U &lt;&lt; 0)
#define BPF_F_ALLOW_MULTI       (1U &lt;&lt; 1)
#define BPF_F_REPLACE           (1U &lt;&lt; 2)</p>
<dl>
<dt>/* If BPF_F_STRICT_ALIGNMENT is used in BPF_PROG_LOAD command, the</dt><dd><ul class="simple">
<li><p>verifier will perform strict alignment checking as if the kernel</p></li>
<li><p>has been built with CONFIG_EFFICIENT_UNALIGNED_ACCESS not set,</p></li>
<li><p>and NET_IP_ALIGN defined to 2.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
</dl>
<p>#define BPF_F_STRICT_ALIGNMENT  (1U &lt;&lt; 0)</p>
<dl>
<dt>/* If BPF_F_ANY_ALIGNMENT is used in BPF_PROF_LOAD command, the</dt><dd><ul class="simple">
<li><p>verifier will allow any alignment whatsoever.  On platforms</p></li>
<li><p>with strict alignment requirements for loads ands stores (such</p></li>
<li><p>as sparc and mips) the verifier validates that all loads and</p></li>
<li><p>stores provably follow this requirement.  This flag turns that</p></li>
<li><p>checking and enforcement off.</p></li>
<li></li>
<li><p>It is mostly used for testing when we want to validate the</p></li>
<li><p>context and memory access aspects of the verifier, but because</p></li>
<li><p>of an unaligned access the alignment check would trigger before</p></li>
<li><p>the one we are interested in.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
</dl>
<p>#define BPF_F_ANY_ALIGNMENT     (1U &lt;&lt; 1)</p>
<dl>
<dt>/* BPF_F_TEST_RND_HI32 is used in BPF_PROG_LOAD command for testing purpose.</dt><dd><ul class="simple">
<li><p>Verifier does sub-register def/use analysis and identifies instructions whose</p></li>
<li><p>def only matters for low 32-bit, high 32-bit is never referenced later</p></li>
<li><p>through implicit zero extension. Therefore verifier notifies JIT back-ends</p></li>
<li><p>that it is safe to ignore clearing high 32-bit for these instructions. This</p></li>
<li><p>saves some back-ends a lot of code-gen. However such optimization is not</p></li>
<li><p>necessary on some arches, for example x86_64, arm64 etc, whose JIT back-ends</p></li>
<li><p>hence hasn’t used verifier’s analysis result. But, we really want to have a</p></li>
<li><p>way to be able to verify the correctness of the described optimization on</p></li>
<li><p>x86_64 on which testsuites are frequently exercised.</p></li>
<li></li>
<li><p>So, this flag is introduced. Once it is set, verifier will randomize high</p></li>
<li><p>32-bit for those instructions who has been identified as safe to ignore them.</p></li>
<li><p>Then, if verifier is not doing correct analysis, such randomization will</p></li>
<li><p>regress tests to expose bugs.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
</dl>
<p>#define BPF_F_TEST_RND_HI32     (1U &lt;&lt; 2)</p>
<p>/* The verifier internal test flag. Behavior is undefined <a href="#id19"><span class="problematic" id="id20">*</span></a>/
#define BPF_F_TEST_STATE_FREQ   (1U &lt;&lt; 3)</p>
<dl>
<dt>/* If BPF_F_SLEEPABLE is used in BPF_PROG_LOAD command, the verifier will</dt><dd><ul class="simple">
<li><p>restrict map and helper usage for such programs. Sleepable BPF programs can</p></li>
<li><p>only be attached to hooks where kernel execution context allows sleeping.</p></li>
<li><p>Such programs are allowed to use helpers that may sleep like</p></li>
<li><p>bpf_copy_from_user().</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
</dl>
<p>#define BPF_F_SLEEPABLE         (1U &lt;&lt; 4)</p>
<dl>
<dt>/* When BPF ldimm64’s insn[0].src_reg != 0 then this can have</dt><dd><ul class="simple">
<li><p>the following extensions:</p></li>
<li></li>
<li><p>insn[0].src_reg:  BPF_PSEUDO_MAP_[FD|IDX]</p></li>
<li><p>insn[0].imm:      map fd or fd_idx</p></li>
<li><p>insn[1].imm:      0</p></li>
<li><p>insn[0].off:      0</p></li>
<li><p>insn[1].off:      0</p></li>
<li><p>ldimm64 rewrite:  address of map</p></li>
<li><p>verifier type:    CONST_PTR_TO_MAP</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
</dl>
<p>#define BPF_PSEUDO_MAP_FD       1
#define BPF_PSEUDO_MAP_IDX      5</p>
<dl>
<dt>/* insn[0].src_reg:  BPF_PSEUDO_MAP_[<a href="#id1239"><span class="problematic" id="id1240">IDX_</span></a>]VALUE</dt><dd><ul class="simple">
<li><p>insn[0].imm:      map fd or fd_idx</p></li>
<li><p>insn[1].imm:      offset into value</p></li>
<li><p>insn[0].off:      0</p></li>
<li><p>insn[1].off:      0</p></li>
<li><p>ldimm64 rewrite:  address of map[0]+offset</p></li>
<li><p>verifier type:    PTR_TO_MAP_VALUE</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
</dl>
<p>#define BPF_PSEUDO_MAP_VALUE            2
#define BPF_PSEUDO_MAP_IDX_VALUE        6</p>
<dl>
<dt>/* insn[0].src_reg:  BPF_PSEUDO_BTF_ID</dt><dd><ul class="simple">
<li><p>insn[0].imm:      kernel btd id of VAR</p></li>
<li><p>insn[1].imm:      0</p></li>
<li><p>insn[0].off:      0</p></li>
<li><p>insn[1].off:      0</p></li>
<li><p>ldimm64 rewrite:  address of the kernel variable</p></li>
<li><p>verifier type:    PTR_TO_BTF_ID or PTR_TO_MEM, depending on whether the var</p></li>
<li><p>is struct/union.</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
</dl>
<p>#define BPF_PSEUDO_BTF_ID       3
/* insn[0].src_reg:  BPF_PSEUDO_FUNC</p>
<blockquote>
<div><ul class="simple">
<li><p>insn[0].imm:      insn offset to the func</p></li>
<li><p>insn[1].imm:      0</p></li>
<li><p>insn[0].off:      0</p></li>
<li><p>insn[1].off:      0</p></li>
<li><p>ldimm64 rewrite:  address of the function</p></li>
<li><p>verifier type:    PTR_TO_FUNC.</p></li>
</ul>
<p><a href="#id29"><span class="problematic" id="id30">*</span></a>/</p>
</div></blockquote>
<p>#define BPF_PSEUDO_FUNC         4</p>
<dl>
<dt>/* when bpf_call-&gt;src_reg == BPF_PSEUDO_CALL, bpf_call-&gt;imm == pc-relative</dt><dd><ul class="simple">
<li><p>offset to another bpf function</p></li>
</ul>
<p><a href="#id31"><span class="problematic" id="id32">*</span></a>/</p>
</dd>
</dl>
<p>#define BPF_PSEUDO_CALL         1
/* when bpf_call-&gt;src_reg == BPF_PSEUDO_KFUNC_CALL,</p>
<blockquote>
<div><ul class="simple">
<li><p>bpf_call-&gt;imm == btf_id of a BTF_KIND_FUNC in the running kernel</p></li>
</ul>
<p><a href="#id33"><span class="problematic" id="id34">*</span></a>/</p>
</div></blockquote>
<p>#define BPF_PSEUDO_KFUNC_CALL   2</p>
<p>/* flags for BPF_MAP_UPDATE_ELEM command <a href="#id35"><span class="problematic" id="id36">*</span></a>/
enum {</p>
<blockquote>
<div><p>BPF_ANY         = 0, /* create new element or update existing <em>/
BPF_NOEXIST     = 1, /</em> create new element if it didn’t exist <em>/
BPF_EXIST       = 2, /</em> update existing element <em>/
BPF_F_LOCK      = 4, /</em> spin_lock-ed map_lookup/map_update <a href="#id37"><span class="problematic" id="id38">*</span></a>/</p>
</div></blockquote>
<p>};</p>
<p>/* flags for BPF_MAP_CREATE command <a href="#id39"><span class="problematic" id="id40">*</span></a>/
enum {</p>
<blockquote>
<div><p>BPF_F_NO_PREALLOC       = (1U &lt;&lt; 0),</p>
</div></blockquote>
<dl>
<dt>/* Instead of having one common LRU list in the</dt><dd><ul class="simple">
<li><p>BPF_MAP_TYPE_LRU_[<a href="#id1241"><span class="problematic" id="id1242">PERCPU_</span></a>]HASH map, use a percpu LRU list</p></li>
<li><p>which can scale and perform better.</p></li>
<li><p>Note, the LRU nodes (including free nodes) cannot be moved</p></li>
<li><p>across different LRU lists.</p></li>
</ul>
<dl class="simple">
<dt><a href="#id41"><span class="problematic" id="id42">*</span></a>/</dt><dd><p>BPF_F_NO_COMMON_LRU     = (1U &lt;&lt; 1),</p>
</dd>
</dl>
</dd>
<dt>/* Specify numa node during map creation <a href="#id43"><span class="problematic" id="id44">*</span></a>/</dt><dd><p>BPF_F_NUMA_NODE         = (1U &lt;&lt; 2),</p>
</dd>
<dt>/* Flags for accessing BPF object from syscall side. <a href="#id45"><span class="problematic" id="id46">*</span></a>/</dt><dd><p>BPF_F_RDONLY            = (1U &lt;&lt; 3),
BPF_F_WRONLY            = (1U &lt;&lt; 4),</p>
</dd>
<dt>/* Flag for stack_map, store build_id+offset instead of pointer <a href="#id47"><span class="problematic" id="id48">*</span></a>/</dt><dd><p>BPF_F_STACK_BUILD_ID    = (1U &lt;&lt; 5),</p>
</dd>
<dt>/* Zero-initialize hash function seed. This should only be used for testing. <a href="#id49"><span class="problematic" id="id50">*</span></a>/</dt><dd><p>BPF_F_ZERO_SEED         = (1U &lt;&lt; 6),</p>
</dd>
<dt>/* Flags for accessing BPF object from program side. <a href="#id51"><span class="problematic" id="id52">*</span></a>/</dt><dd><p>BPF_F_RDONLY_PROG       = (1U &lt;&lt; 7),
BPF_F_WRONLY_PROG       = (1U &lt;&lt; 8),</p>
</dd>
<dt>/* Clone map from listener for newly accepted socket <a href="#id53"><span class="problematic" id="id54">*</span></a>/</dt><dd><p>BPF_F_CLONE             = (1U &lt;&lt; 9),</p>
</dd>
<dt>/* Enable memory-mapping BPF map <a href="#id55"><span class="problematic" id="id56">*</span></a>/</dt><dd><p>BPF_F_MMAPABLE          = (1U &lt;&lt; 10),</p>
</dd>
<dt>/* Share perf_event among processes <a href="#id57"><span class="problematic" id="id58">*</span></a>/</dt><dd><p>BPF_F_PRESERVE_ELEMS    = (1U &lt;&lt; 11),</p>
</dd>
<dt>/* Create a map that is suitable to be an inner map with dynamic max entries <a href="#id59"><span class="problematic" id="id60">*</span></a>/</dt><dd><p>BPF_F_INNER_MAP         = (1U &lt;&lt; 12),</p>
</dd>
</dl>
<p>};</p>
<p>/* Flags for BPF_PROG_QUERY. <a href="#id61"><span class="problematic" id="id62">*</span></a>/</p>
<dl>
<dt>/* Query effective (directly attached + inherited from ancestor cgroups)</dt><dd><ul class="simple">
<li><p>programs that will be executed for events within a cgroup.</p></li>
<li><p>attach_flags with this flag are returned only for directly attached programs.</p></li>
</ul>
<p><a href="#id63"><span class="problematic" id="id64">*</span></a>/</p>
</dd>
</dl>
<p>#define BPF_F_QUERY_EFFECTIVE   (1U &lt;&lt; 0)</p>
<p>/* Flags for BPF_PROG_TEST_RUN <a href="#id65"><span class="problematic" id="id66">*</span></a>/</p>
<p>/* If set, run the test on the cpu specified by bpf_attr.test.cpu <a href="#id67"><span class="problematic" id="id68">*</span></a>/
#define BPF_F_TEST_RUN_ON_CPU   (1U &lt;&lt; 0)</p>
<p>/* type for BPF_ENABLE_STATS <a href="#id69"><span class="problematic" id="id70">*</span></a>/
enum bpf_stats_type {</p>
<blockquote>
<div><p>/* enabled run_time_ns and run_cnt <a href="#id71"><span class="problematic" id="id72">*</span></a>/
BPF_STATS_RUN_TIME = 0,</p>
</div></blockquote>
<p>};</p>
<dl class="simple">
<dt>enum bpf_stack_build_id_status {</dt><dd><p>/* user space need an empty entry to identify end of a trace <em>/
BPF_STACK_BUILD_ID_EMPTY = 0,
/</em> with valid build_id and offset <em>/
BPF_STACK_BUILD_ID_VALID = 1,
/</em> couldn’t get build_id, fallback to ip <a href="#id73"><span class="problematic" id="id74">*</span></a>/
BPF_STACK_BUILD_ID_IP = 2,</p>
</dd>
</dl>
<p>};</p>
<p>#define BPF_BUILD_ID_SIZE 20
struct bpf_stack_build_id {</p>
<blockquote>
<div><p>__s32           status;
unsigned char   build_id[BPF_BUILD_ID_SIZE];
union {</p>
<blockquote>
<div><p>__u64   offset;
__u64   ip;</p>
</div></blockquote>
<p>};</p>
</div></blockquote>
<p>};</p>
<p>#define BPF_OBJ_NAME_LEN 16U</p>
<dl>
<dt>union bpf_attr {</dt><dd><dl>
<dt>struct { /* anonymous struct used by BPF_MAP_CREATE command <a href="#id75"><span class="problematic" id="id76">*</span></a>/</dt><dd><p>__u32   map_type;       /* one of enum bpf_map_type <em>/
__u32   key_size;       /</em> size of key in bytes <em>/
__u32   value_size;     /</em> size of value in bytes <em>/
__u32   max_entries;    /</em> max number of entries in a map <em>/
__u32   map_flags;      /</em> BPF_MAP_CREATE related</p>
<blockquote>
<div><ul class="simple">
<li><p>flags defined above.</p></li>
</ul>
<p><a href="#id77"><span class="problematic" id="id78">*</span></a>/</p>
</div></blockquote>
<p>__u32   inner_map_fd;   /* fd pointing to the inner map <em>/
__u32   numa_node;      /</em> numa node (effective only if</p>
<blockquote>
<div><ul class="simple">
<li><p>BPF_F_NUMA_NODE is set).</p></li>
</ul>
<p><a href="#id79"><span class="problematic" id="id80">*</span></a>/</p>
</div></blockquote>
<p>char    map_name[BPF_OBJ_NAME_LEN];
__u32   map_ifindex;    /* ifindex of netdev to create on <em>/
__u32   btf_fd;         /</em> fd pointing to a BTF type data <em>/
__u32   btf_key_type_id;        /</em> BTF type_id of the key <em>/
__u32   btf_value_type_id;      /</em> BTF type_id of the value <em>/
__u32   btf_vmlinux_value_type_id;/</em> BTF type_id of a kernel-</p>
<blockquote>
<div><ul class="simple">
<li><p>struct stored as the</p></li>
<li><p>map value</p></li>
</ul>
<p><a href="#id81"><span class="problematic" id="id82">*</span></a>/</p>
</div></blockquote>
</dd>
</dl>
<p>};</p>
<dl>
<dt>struct { /* anonymous struct used by BPF_MAP_*_ELEM commands <a href="#id83"><span class="problematic" id="id84">*</span></a>/</dt><dd><p>__u32           map_fd;
__aligned_u64   key;
union {</p>
<blockquote>
<div><p>__aligned_u64 value;
__aligned_u64 next_key;</p>
</div></blockquote>
<p>};
__u64           flags;</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>struct { /* struct used by BPF_MAP_*_BATCH commands <a href="#id85"><span class="problematic" id="id86">*</span></a>/</dt><dd><dl>
<dt>__aligned_u64   in_batch;       /* start batch,</dt><dd><ul class="simple">
<li><p>NULL to start from beginning</p></li>
</ul>
<p><a href="#id87"><span class="problematic" id="id88">*</span></a>/</p>
</dd>
</dl>
<p>__aligned_u64   out_batch;      /* output: next start batch <em>/
__aligned_u64   keys;
__aligned_u64   values;
__u32           count;          /</em> input/output:</p>
<blockquote>
<div><ul class="simple">
<li><p>input: # of key/value</p></li>
<li><p>elements</p></li>
<li><p>output: # of filled elements</p></li>
</ul>
<p><a href="#id89"><span class="problematic" id="id90">*</span></a>/</p>
</div></blockquote>
<p>__u32           map_fd;
__u64           elem_flags;
__u64           flags;</p>
</dd>
</dl>
<p>} batch;</p>
<dl>
<dt>struct { /* anonymous struct used by BPF_PROG_LOAD command <a href="#id91"><span class="problematic" id="id92">*</span></a>/</dt><dd><p>__u32           prog_type;      /* one of enum bpf_prog_type <em>/
__u32           insn_cnt;
__aligned_u64   insns;
__aligned_u64   license;
__u32           log_level;      /</em> verbosity level of verifier <em>/
__u32           log_size;       /</em> size of user buffer <em>/
__aligned_u64   log_buf;        /</em> user supplied buffer <em>/
__u32           kern_version;   /</em> not used <em>/
__u32           prog_flags;
char            prog_name[BPF_OBJ_NAME_LEN];
__u32           prog_ifindex;   /</em> ifindex of netdev to prep for <em>/
/</em> For some prog types expected attach type must be known at</p>
<blockquote>
<div><ul class="simple">
<li><p>load time to verify attach type specific parts of prog</p></li>
<li><p>(context accesses, allowed helpers, etc).</p></li>
</ul>
<p><a href="#id93"><span class="problematic" id="id94">*</span></a>/</p>
</div></blockquote>
<p>__u32           expected_attach_type;
__u32           prog_btf_fd;    /* fd pointing to BTF type data <em>/
__u32           func_info_rec_size;     /</em> userspace bpf_func_info size <em>/
__aligned_u64   func_info;      /</em> func info <em>/
__u32           func_info_cnt;  /</em> number of bpf_func_info records <em>/
__u32           line_info_rec_size;     /</em> userspace bpf_line_info size <em>/
__aligned_u64   line_info;      /</em> line info <em>/
__u32           line_info_cnt;  /</em> number of bpf_line_info records <em>/
__u32           attach_btf_id;  /</em> in-kernel BTF type id to attach to <a href="#id95"><span class="problematic" id="id96">*</span></a>/
union {</p>
<blockquote>
<div><p>/* valid prog_fd to attach to bpf prog <em>/
__u32           attach_prog_fd;
/</em> or valid module BTF object fd or 0 to attach to vmlinux <a href="#id97"><span class="problematic" id="id98">*</span></a>/
__u32           attach_btf_obj_fd;</p>
</div></blockquote>
<p>};
__u32           :32;            /* pad <em>/
__aligned_u64   fd_array;       /</em> array of FDs <a href="#id99"><span class="problematic" id="id100">*</span></a>/</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>struct { /* anonymous struct used by BPF_OBJ_* commands <a href="#id101"><span class="problematic" id="id102">*</span></a>/</dt><dd><p>__aligned_u64   pathname;
__u32           bpf_fd;
__u32           file_flags;</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>struct { /* anonymous struct used by BPF_PROG_ATTACH/DETACH commands <a href="#id103"><span class="problematic" id="id104">*</span></a>/</dt><dd><p>__u32           target_fd;      /* container object to attach to <em>/
__u32           attach_bpf_fd;  /</em> eBPF program to attach <em>/
__u32           attach_type;
__u32           attach_flags;
__u32           replace_bpf_fd; /</em> previously attached eBPF</p>
<blockquote>
<div><ul class="simple">
<li><p>program to replace if</p></li>
<li><p>BPF_F_REPLACE is used</p></li>
</ul>
<p><a href="#id105"><span class="problematic" id="id106">*</span></a>/</p>
</div></blockquote>
</dd>
</dl>
<p>};</p>
<dl>
<dt>struct { /* anonymous struct used by BPF_PROG_TEST_RUN command <a href="#id107"><span class="problematic" id="id108">*</span></a>/</dt><dd><p>__u32           prog_fd;
__u32           retval;
__u32           data_size_in;   /* input: len of data_in <em>/
__u32           data_size_out;  /</em> input/output: len of data_out</p>
<blockquote>
<div><ul class="simple">
<li><p>returns ENOSPC if data_out</p></li>
<li><p>is too small.</p></li>
</ul>
<p><a href="#id109"><span class="problematic" id="id110">*</span></a>/</p>
</div></blockquote>
<p>__aligned_u64   data_in;
__aligned_u64   data_out;
__u32           repeat;
__u32           duration;
__u32           ctx_size_in;    /* input: len of ctx_in <em>/
__u32           ctx_size_out;   /</em> input/output: len of ctx_out</p>
<blockquote>
<div><ul class="simple">
<li><p>returns ENOSPC if ctx_out</p></li>
<li><p>is too small.</p></li>
</ul>
<p><a href="#id111"><span class="problematic" id="id112">*</span></a>/</p>
</div></blockquote>
<p>__aligned_u64   ctx_in;
__aligned_u64   ctx_out;
__u32           flags;
__u32           cpu;</p>
</dd>
</dl>
<p>} test;</p>
<dl>
<dt>struct { /* anonymous struct used by BPF_*_GET_*_ID <a href="#id113"><span class="problematic" id="id114">*</span></a>/</dt><dd><dl class="simple">
<dt>union {</dt><dd><p>__u32           start_id;
__u32           prog_id;
__u32           map_id;
__u32           btf_id;
__u32           link_id;</p>
</dd>
</dl>
<p>};
__u32           next_id;
__u32           open_flags;</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>struct { /* anonymous struct used by BPF_OBJ_GET_INFO_BY_FD <a href="#id115"><span class="problematic" id="id116">*</span></a>/</dt><dd><p>__u32           bpf_fd;
__u32           info_len;
__aligned_u64   info;</p>
</dd>
</dl>
<p>} info;</p>
<dl class="simple">
<dt>struct { /* anonymous struct used by BPF_PROG_QUERY command <a href="#id117"><span class="problematic" id="id118">*</span></a>/</dt><dd><p>__u32           target_fd;      /* container object to query <a href="#id119"><span class="problematic" id="id120">*</span></a>/
__u32           attach_type;
__u32           query_flags;
__u32           attach_flags;
__aligned_u64   prog_ids;
__u32           prog_cnt;</p>
</dd>
</dl>
<p>} query;</p>
<dl class="simple">
<dt>struct { /* anonymous struct used by BPF_RAW_TRACEPOINT_OPEN command <a href="#id121"><span class="problematic" id="id122">*</span></a>/</dt><dd><p>__u64 name;
__u32 prog_fd;</p>
</dd>
</dl>
<p>} raw_tracepoint;</p>
<dl class="simple">
<dt>struct { /* anonymous struct for BPF_BTF_LOAD <a href="#id123"><span class="problematic" id="id124">*</span></a>/</dt><dd><p>__aligned_u64   btf;
__aligned_u64   btf_log_buf;
__u32           btf_size;
__u32           btf_log_size;
__u32           btf_log_level;</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>struct {</dt><dd><p>__u32           pid;            /* input: pid <em>/
__u32           fd;             /</em> input: fd <em>/
__u32           flags;          /</em> input: flags <em>/
__u32           buf_len;        /</em> input/output: buf len <em>/
__aligned_u64   buf;            /</em> input/output:</p>
<blockquote>
<div><ul class="simple">
<li><p>tp_name for tracepoint</p></li>
<li><p>symbol for kprobe</p></li>
<li><p>filename for uprobe</p></li>
</ul>
<p><a href="#id125"><span class="problematic" id="id126">*</span></a>/</p>
</div></blockquote>
<p>__u32           prog_id;        /* output: prod_id <em>/
__u32           fd_type;        /</em> output: BPF_FD_TYPE_* <em>/
__u64           probe_offset;   /</em> output: probe_offset <em>/
__u64           probe_addr;     /</em> output: probe_addr <a href="#id127"><span class="problematic" id="id128">*</span></a>/</p>
</dd>
</dl>
<p>} task_fd_query;</p>
<dl>
<dt>struct { /* struct used by BPF_LINK_CREATE command <a href="#id129"><span class="problematic" id="id130">*</span></a>/</dt><dd><p>__u32           prog_fd;        /* eBPF program to attach <a href="#id131"><span class="problematic" id="id132">*</span></a>/
union {</p>
<blockquote>
<div><p>__u32           target_fd;      /* object to attach to <em>/
__u32           target_ifindex; /</em> target ifindex <a href="#id133"><span class="problematic" id="id134">*</span></a>/</p>
</div></blockquote>
<p>};
__u32           attach_type;    /* attach type <em>/
__u32           flags;          /</em> extra flags <a href="#id135"><span class="problematic" id="id136">*</span></a>/
union {</p>
<blockquote>
<div><p>__u32           target_btf_id;  /* btf_id of target to attach to <a href="#id137"><span class="problematic" id="id138">*</span></a>/
struct {</p>
<blockquote>
<div><p>__aligned_u64   iter_info;      /* extra bpf_iter_link_info <em>/
__u32           iter_info_len;  /</em> iter_info length <a href="#id139"><span class="problematic" id="id140">*</span></a>/</p>
</div></blockquote>
<p>};</p>
</div></blockquote>
<p>};</p>
</dd>
</dl>
<p>} link_create;</p>
<dl>
<dt>struct { /* struct used by BPF_LINK_UPDATE command <a href="#id141"><span class="problematic" id="id142">*</span></a>/</dt><dd><p>__u32           link_fd;        /* link fd <em>/
/</em> new program fd to update link with <em>/
__u32           new_prog_fd;
__u32           flags;          /</em> extra flags <em>/
/</em> expected link’s program fd; is specified only if</p>
<blockquote>
<div><ul class="simple">
<li><p>BPF_F_REPLACE flag is set in flags <a href="#id143"><span class="problematic" id="id144">*</span></a>/</p></li>
</ul>
</div></blockquote>
<p>__u32           old_prog_fd;</p>
</dd>
</dl>
<p>} link_update;</p>
<dl class="simple">
<dt>struct {</dt><dd><p>__u32           link_fd;</p>
</dd>
</dl>
<p>} link_detach;</p>
<dl class="simple">
<dt>struct { /* struct used by BPF_ENABLE_STATS command <a href="#id145"><span class="problematic" id="id146">*</span></a>/</dt><dd><p>__u32           type;</p>
</dd>
</dl>
<p>} enable_stats;</p>
<dl class="simple">
<dt>struct { /* struct used by BPF_ITER_CREATE command <a href="#id147"><span class="problematic" id="id148">*</span></a>/</dt><dd><p>__u32           link_fd;
__u32           flags;</p>
</dd>
</dl>
<p>} iter_create;</p>
<dl class="simple">
<dt>struct { /* struct used by BPF_PROG_BIND_MAP command <a href="#id149"><span class="problematic" id="id150">*</span></a>/</dt><dd><p>__u32           prog_fd;
__u32           map_fd;
__u32           flags;          /* extra flags <a href="#id151"><span class="problematic" id="id152">*</span></a>/</p>
</dd>
</dl>
<p>} prog_bind_map;</p>
</dd>
</dl>
<p>} __attribute__((aligned(8)));</p>
<dl>
<dt>/* The description below is an attempt at providing documentation to eBPF</dt><dd><ul>
<li><p>developers about the multiple available eBPF helper functions. It can be</p></li>
<li><p>parsed and used to produce a manual page. The workflow is the following,</p></li>
<li><p>and requires the rst2man utility:</p></li>
<li></li>
<li><p>$ ./scripts/bpf_doc.py </p></li>
<li><p>–filename include/uapi/linux/bpf.h &gt; /tmp/bpf-helpers.rst</p></li>
<li><p>$ rst2man /tmp/bpf-helpers.rst &gt; /tmp/bpf-helpers.7</p></li>
<li><p>$ man /tmp/bpf-helpers.7</p></li>
<li></li>
<li><p>Note that in order to produce this external documentation, some RST</p></li>
<li><p>formatting is used in the descriptions to get “bold” and “italics” in</p></li>
<li><p>manual pages. Also note that the few trailing white spaces are</p></li>
<li><p>intentional, removing them would break paragraphs for rst2man.</p></li>
<li></li>
<li><p>Start of BPF helper function descriptions:</p></li>
<li></li>
<li><p>void <a href="#id153"><span class="problematic" id="id154">*</span></a>bpf_map_lookup_elem(struct bpf_map <a href="#id155"><span class="problematic" id="id156">*</span></a>map, const void <a href="#id157"><span class="problematic" id="id158">*</span></a>key)</p></li>
<li><p>Description</p></li>
<li><p>Perform a lookup in <em>map</em> for an entry associated to <em>key</em>.</p></li>
<li><p>Return</p></li>
<li><p>Map value associated to <em>key</em>, or <strong>NULL</strong> if no entry was</p></li>
<li><p>found.</p></li>
<li></li>
<li><p>long bpf_map_update_elem(struct bpf_map <a href="#id159"><span class="problematic" id="id160">*</span></a>map, const void <a href="#id161"><span class="problematic" id="id162">*</span></a>key, const void <a href="#id163"><span class="problematic" id="id164">*</span></a>value, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Add or update the value of the entry associated to <em>key</em> in</p></li>
<li><p><em>map</em> with <em>value</em>. <em>flags</em> is one of:</p></li>
<li></li>
<li><p><strong>BPF_NOEXIST</strong></p></li>
<li><p>The entry for <em>key</em> must not exist in the map.</p></li>
<li><p><strong>BPF_EXIST</strong></p></li>
<li><p>The entry for <em>key</em> must already exist in the map.</p></li>
<li><p><strong>BPF_ANY</strong></p></li>
<li><p>No condition on the existence of the entry for <em>key</em>.</p></li>
<li></li>
<li><p>Flag value <strong>BPF_NOEXIST</strong> cannot be used for maps of types</p></li>
<li><p><strong>BPF_MAP_TYPE_ARRAY</strong> or <strong>BPF_MAP_TYPE_PERCPU_ARRAY</strong>  (all</p></li>
<li><p>elements always exist), the helper would return an error.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_map_delete_elem(struct bpf_map <a href="#id165"><span class="problematic" id="id166">*</span></a>map, const void <a href="#id167"><span class="problematic" id="id168">*</span></a>key)</p></li>
<li><p>Description</p></li>
<li><p>Delete entry with <em>key</em> from <em>map</em>.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_probe_read(void <a href="#id169"><span class="problematic" id="id170">*</span></a>dst, u32 size, const void <a href="#id171"><span class="problematic" id="id172">*</span></a>unsafe_ptr)</p></li>
<li><p>Description</p></li>
<li><p>For tracing programs, safely attempt to read <em>size</em> bytes from</p></li>
<li><p>kernel space address <em>unsafe_ptr</em> and store the data in <em>dst</em>.</p></li>
<li></li>
<li><p>Generally, use <strong>bpf_probe_read_user</strong>() or</p></li>
<li><p><strong>bpf_probe_read_kernel</strong>() instead.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>u64 bpf_ktime_get_ns(void)</p></li>
<li><p>Description</p></li>
<li><p>Return the time elapsed since system boot, in nanoseconds.</p></li>
<li><p>Does not include time the system was suspended.</p></li>
<li><p>See: <strong>clock_gettime</strong>(<strong>CLOCK_MONOTONIC</strong>)</p></li>
<li><p>Return</p></li>
<li><p>Current <em>ktime</em>.</p></li>
<li></li>
<li><p>long bpf_trace_printk(const char <a href="#id173"><span class="problematic" id="id174">*</span></a>fmt, u32 fmt_size, …)</p></li>
<li><p>Description</p></li>
<li><p>This helper is a “printk()-like” facility for debugging. It</p></li>
<li><p>prints a message defined by format <em>fmt</em> (of size <em>fmt_size</em>)</p></li>
<li><p>to file <em>/sys/kernel/debug/tracing/trace</em> from DebugFS, if</p></li>
<li><p>available. It can take up to three additional <strong>u64</strong></p></li>
<li><p>arguments (as an eBPF helpers, the total number of arguments is</p></li>
<li><p>limited to five).</p></li>
<li></li>
<li><p>Each time the helper is called, it appends a line to the trace.</p></li>
<li><p>Lines are discarded while <em>/sys/kernel/debug/tracing/trace</em> is</p></li>
<li><p>open, use <em>/sys/kernel/debug/tracing/trace_pipe</em> to avoid this.</p></li>
<li><p>The format of the trace is customizable, and the exact output</p></li>
<li><p>one will get depends on the options set in</p></li>
<li><p><em>/sys/kernel/debug/tracing/trace_options</em> (see also the</p></li>
<li><p><em>README</em> file under the same directory). However, it usually</p></li>
<li><p>defaults to something like:</p></li>
<li></li>
<li></li>
<li></li>
<li><p>telnet-470   [001] .N.. 419421.045894: 0x00000001: &lt;formatted msg&gt;</p></li>
<li></li>
<li><p>In the above:</p></li>
<li></li>
<li><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">telnet</span></code> is the name of the current task.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">470</span></code> is the PID of the current task.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">001</span></code> is the CPU number on which the task is</p></li>
</ul>
</li>
<li><p>running.</p></li>
<li><ul class="simple">
<li><p>In <code class="docutils literal notranslate"><span class="pre">.N..</span></code>, each character refers to a set of</p></li>
</ul>
</li>
<li><p>options (whether irqs are enabled, scheduling</p></li>
<li><p>options, whether hard/softirqs are running, level of</p></li>
<li><p>preempt_disabled respectively). <strong>N</strong> means that</p></li>
<li><p><strong>TIF_NEED_RESCHED</strong> and <strong>PREEMPT_NEED_RESCHED</strong></p></li>
<li><p>are set.</p></li>
<li><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">419421.045894</span></code> is a timestamp.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0x00000001</span></code> is a fake value used by BPF for the</p></li>
</ul>
</li>
<li><p>instruction pointer register.</p></li>
<li><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;formatted</span> <span class="pre">msg&gt;</span></code> is the message formatted with</p></li>
</ul>
</li>
<li><p><em>fmt</em>.</p></li>
<li></li>
<li><p>The conversion specifiers supported by <em>fmt</em> are similar, but</p></li>
<li><p>more limited than for printk(). They are <strong>%d</strong>, <strong>%i</strong>,</p></li>
<li><p><strong>%u</strong>, <strong>%x</strong>, <strong>%ld</strong>, <strong>%li</strong>, <strong>%lu</strong>, <strong>%lx</strong>, <strong>%lld</strong>,</p></li>
<li><p><strong>%lli</strong>, <strong>%llu</strong>, <strong>%llx</strong>, <strong>%p</strong>, <strong>%s</strong>. No modifier (size</p></li>
<li><p>of field, padding with zeroes, etc.) is available, and the</p></li>
<li><p>helper will return <strong>-EINVAL</strong> (but print nothing) if it</p></li>
<li><p>encounters an unknown specifier.</p></li>
<li></li>
<li><p>Also, note that <strong>bpf_trace_printk</strong>() is slow, and should</p></li>
<li><p>only be used for debugging purposes. For this reason, a notice</p></li>
<li><p>block (spanning several lines) is printed to kernel logs and</p></li>
<li><p>states that the helper should not be used “for production use”</p></li>
<li><p>the first time this helper is used (or more precisely, when</p></li>
<li><p><strong>trace_printk</strong>() buffers are allocated). For passing values</p></li>
<li><p>to user space, perf events should be preferred.</p></li>
<li><p>Return</p></li>
<li><p>The number of bytes written to the buffer, or a negative error</p></li>
<li><p>in case of failure.</p></li>
<li></li>
<li><p>u32 bpf_get_prandom_u32(void)</p></li>
<li><p>Description</p></li>
<li><p>Get a pseudo-random number.</p></li>
<li></li>
<li><p>From a security point of view, this helper uses its own</p></li>
<li><p>pseudo-random internal state, and cannot be used to infer the</p></li>
<li><p>seed of other random functions in the kernel. However, it is</p></li>
<li><p>essential to note that the generator used by the helper is not</p></li>
<li><p>cryptographically secure.</p></li>
<li><p>Return</p></li>
<li><p>A random 32-bit unsigned value.</p></li>
<li></li>
<li><p>u32 bpf_get_smp_processor_id(void)</p></li>
<li><p>Description</p></li>
<li><p>Get the SMP (symmetric multiprocessing) processor id. Note that</p></li>
<li><p>all programs run with preemption disabled, which means that the</p></li>
<li><p>SMP processor id is stable during all the execution of the</p></li>
<li><p>program.</p></li>
<li><p>Return</p></li>
<li><p>The SMP id of the processor running the program.</p></li>
<li></li>
<li><p>long bpf_skb_store_bytes(struct sk_buff <a href="#id175"><span class="problematic" id="id176">*</span></a>skb, u32 offset, const void <a href="#id177"><span class="problematic" id="id178">*</span></a>from, u32 len, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Store <em>len</em> bytes from address <em>from</em> into the packet</p></li>
<li><p>associated to <em>skb</em>, at <em>offset</em>. <em>flags</em> are a combination of</p></li>
<li><p><strong>BPF_F_RECOMPUTE_CSUM</strong> (automatically recompute the</p></li>
<li><p>checksum for the packet after storing the bytes) and</p></li>
<li><p><strong>BPF_F_INVALIDATE_HASH</strong> (set <em>skb</em><strong>-&gt;hash</strong>, <em>skb</em></p></li>
<li><p><strong>-&gt;swhash</strong> and <em>skb</em><strong>-&gt;l4hash</strong> to 0).</p></li>
<li></li>
<li><p>A call to this helper is susceptible to change the underlying</p></li>
<li><p>packet buffer. Therefore, at load time, all checks on pointers</p></li>
<li><p>previously done by the verifier are invalidated and must be</p></li>
<li><p>performed again, if the helper is used in combination with</p></li>
<li><p>direct packet access.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_l3_csum_replace(struct sk_buff <a href="#id179"><span class="problematic" id="id180">*</span></a>skb, u32 offset, u64 from, u64 to, u64 size)</p></li>
<li><p>Description</p></li>
<li><p>Recompute the layer 3 (e.g. IP) checksum for the packet</p></li>
<li><p>associated to <em>skb</em>. Computation is incremental, so the helper</p></li>
<li><p>must know the former value of the header field that was</p></li>
<li><p>modified (<em>from</em>), the new value of this field (<em>to</em>), and the</p></li>
<li><p>number of bytes (2 or 4) for this field, stored in <em>size</em>.</p></li>
<li><p>Alternatively, it is possible to store the difference between</p></li>
<li><p>the previous and the new values of the header field in <em>to</em>, by</p></li>
<li><p>setting <em>from</em> and <em>size</em> to 0. For both methods, <em>offset</em></p></li>
<li><p>indicates the location of the IP checksum within the packet.</p></li>
<li></li>
<li><p>This helper works in combination with <strong>bpf_csum_diff</strong>(),</p></li>
<li><p>which does not update the checksum in-place, but offers more</p></li>
<li><p>flexibility and can handle sizes larger than 2 or 4 for the</p></li>
<li><p>checksum to update.</p></li>
<li></li>
<li><p>A call to this helper is susceptible to change the underlying</p></li>
<li><p>packet buffer. Therefore, at load time, all checks on pointers</p></li>
<li><p>previously done by the verifier are invalidated and must be</p></li>
<li><p>performed again, if the helper is used in combination with</p></li>
<li><p>direct packet access.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_l4_csum_replace(struct sk_buff <a href="#id181"><span class="problematic" id="id182">*</span></a>skb, u32 offset, u64 from, u64 to, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Recompute the layer 4 (e.g. TCP, UDP or ICMP) checksum for the</p></li>
<li><p>packet associated to <em>skb</em>. Computation is incremental, so the</p></li>
<li><p>helper must know the former value of the header field that was</p></li>
<li><p>modified (<em>from</em>), the new value of this field (<em>to</em>), and the</p></li>
<li><p>number of bytes (2 or 4) for this field, stored on the lowest</p></li>
<li><p>four bits of <em>flags</em>. Alternatively, it is possible to store</p></li>
<li><p>the difference between the previous and the new values of the</p></li>
<li><p>header field in <em>to</em>, by setting <em>from</em> and the four lowest</p></li>
<li><p>bits of <em>flags</em> to 0. For both methods, <em>offset</em> indicates the</p></li>
<li><p>location of the IP checksum within the packet. In addition to</p></li>
<li><p>the size of the field, <em>flags</em> can be added (bitwise OR) actual</p></li>
<li><p>flags. With <strong>BPF_F_MARK_MANGLED_0</strong>, a null checksum is left</p></li>
<li><p>untouched (unless <strong>BPF_F_MARK_ENFORCE</strong> is added as well), and</p></li>
<li><p>for updates resulting in a null checksum the value is set to</p></li>
<li><p><strong>CSUM_MANGLED_0</strong> instead. Flag <strong>BPF_F_PSEUDO_HDR</strong> indicates</p></li>
<li><p>the checksum is to be computed against a pseudo-header.</p></li>
<li></li>
<li><p>This helper works in combination with <strong>bpf_csum_diff</strong>(),</p></li>
<li><p>which does not update the checksum in-place, but offers more</p></li>
<li><p>flexibility and can handle sizes larger than 2 or 4 for the</p></li>
<li><p>checksum to update.</p></li>
<li></li>
<li><p>A call to this helper is susceptible to change the underlying</p></li>
<li><p>packet buffer. Therefore, at load time, all checks on pointers</p></li>
<li><p>previously done by the verifier are invalidated and must be</p></li>
<li><p>performed again, if the helper is used in combination with</p></li>
<li><p>direct packet access.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_tail_call(void <a href="#id183"><span class="problematic" id="id184">*</span></a>ctx, struct bpf_map <a href="#id185"><span class="problematic" id="id186">*</span></a>prog_array_map, u32 index)</p></li>
<li><p>Description</p></li>
<li><p>This special helper is used to trigger a “tail call”, or in</p></li>
<li><p>other words, to jump into another eBPF program. The same stack</p></li>
<li><p>frame is used (but values on stack and in registers for the</p></li>
<li><p>caller are not accessible to the callee). This mechanism allows</p></li>
<li><p>for program chaining, either for raising the maximum number of</p></li>
<li><p>available eBPF instructions, or to execute given programs in</p></li>
<li><p>conditional blocks. For security reasons, there is an upper</p></li>
<li><p>limit to the number of successive tail calls that can be</p></li>
<li><p>performed.</p></li>
<li></li>
<li><p>Upon call of this helper, the program attempts to jump into a</p></li>
<li><p>program referenced at index <em>index</em> in <em>prog_array_map</em>, a</p></li>
<li><p>special map of type <strong>BPF_MAP_TYPE_PROG_ARRAY</strong>, and passes</p></li>
<li><p><em>ctx</em>, a pointer to the context.</p></li>
<li></li>
<li><p>If the call succeeds, the kernel immediately runs the first</p></li>
<li><p>instruction of the new program. This is not a function call,</p></li>
<li><p>and it never returns to the previous program. If the call</p></li>
<li><p>fails, then the helper has no effect, and the caller continues</p></li>
<li><p>to run its subsequent instructions. A call can fail if the</p></li>
<li><p>destination program for the jump does not exist (i.e. <em>index</em></p></li>
<li><p>is superior to the number of entries in <em>prog_array_map</em>), or</p></li>
<li><p>if the maximum number of tail calls has been reached for this</p></li>
<li><p>chain of programs. This limit is defined in the kernel by the</p></li>
<li><p>macro <strong>MAX_TAIL_CALL_CNT</strong> (not accessible to user space),</p></li>
<li><p>which is currently set to 32.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_clone_redirect(struct sk_buff <a href="#id187"><span class="problematic" id="id188">*</span></a>skb, u32 ifindex, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Clone and redirect the packet associated to <em>skb</em> to another</p></li>
<li><p>net device of index <em>ifindex</em>. Both ingress and egress</p></li>
<li><p>interfaces can be used for redirection. The <strong>BPF_F_INGRESS</strong></p></li>
<li><p>value in <em>flags</em> is used to make the distinction (ingress path</p></li>
<li><p>is selected if the flag is present, egress path otherwise).</p></li>
<li><p>This is the only flag supported for now.</p></li>
<li></li>
<li><p>In comparison with <strong>bpf_redirect</strong>() helper,</p></li>
<li><p><strong>bpf_clone_redirect</strong>() has the associated cost of</p></li>
<li><p>duplicating the packet buffer, but this can be executed out of</p></li>
<li><p>the eBPF program. Conversely, <strong>bpf_redirect</strong>() is more</p></li>
<li><p>efficient, but it is handled through an action code where the</p></li>
<li><p>redirection happens only after the eBPF program has returned.</p></li>
<li></li>
<li><p>A call to this helper is susceptible to change the underlying</p></li>
<li><p>packet buffer. Therefore, at load time, all checks on pointers</p></li>
<li><p>previously done by the verifier are invalidated and must be</p></li>
<li><p>performed again, if the helper is used in combination with</p></li>
<li><p>direct packet access.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>u64 bpf_get_current_pid_tgid(void)</p></li>
<li><p>Return</p></li>
<li><p>A 64-bit integer containing the current tgid and pid, and</p></li>
<li><p>created as such:</p></li>
<li><p><em>current_task</em><strong>-&gt;tgid &lt;&lt; 32 |</strong></p></li>
<li><p><em>current_task</em><strong>-&gt;pid</strong>.</p></li>
<li></li>
<li><p>u64 bpf_get_current_uid_gid(void)</p></li>
<li><p>Return</p></li>
<li><p>A 64-bit integer containing the current GID and UID, and</p></li>
<li><p>created as such: <em>current_gid</em> <strong>&lt;&lt; 32 |</strong> <em>current_uid</em>.</p></li>
<li></li>
<li><p>long bpf_get_current_comm(void <a href="#id189"><span class="problematic" id="id190">*</span></a>buf, u32 size_of_buf)</p></li>
<li><p>Description</p></li>
<li><p>Copy the <strong>comm</strong> attribute of the current task into <em>buf</em> of</p></li>
<li><p><em>size_of_buf</em>. The <strong>comm</strong> attribute contains the name of</p></li>
<li><p>the executable (excluding the path) for the current task. The</p></li>
<li><p><em>size_of_buf</em> must be strictly positive. On success, the</p></li>
<li><p>helper makes sure that the <em>buf</em> is NUL-terminated. On failure,</p></li>
<li><p>it is filled with zeroes.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>u32 bpf_get_cgroup_classid(struct sk_buff <a href="#id191"><span class="problematic" id="id192">*</span></a>skb)</p></li>
<li><p>Description</p></li>
<li><p>Retrieve the classid for the current task, i.e. for the net_cls</p></li>
<li><p>cgroup to which <em>skb</em> belongs.</p></li>
<li></li>
<li><p>This helper can be used on TC egress path, but not on ingress.</p></li>
<li></li>
<li><p>The net_cls cgroup provides an interface to tag network packets</p></li>
<li><p>based on a user-provided identifier for all traffic coming from</p></li>
<li><p>the tasks belonging to the related cgroup. See also the related</p></li>
<li><p>kernel documentation, available from the Linux sources in file</p></li>
<li><p><em>Documentation/admin-guide/cgroup-v1/net_cls.rst</em>.</p></li>
<li></li>
<li><p>The Linux kernel has two versions for cgroups: there are</p></li>
<li><p>cgroups v1 and cgroups v2. Both are available to users, who can</p></li>
<li><p>use a mixture of them, but note that the net_cls cgroup is for</p></li>
<li><p>cgroup v1 only. This makes it incompatible with BPF programs</p></li>
<li><p>run on cgroups, which is a cgroup-v2-only feature (a socket can</p></li>
<li><p>only hold data for one version of cgroups at a time).</p></li>
<li></li>
<li><p>This helper is only available is the kernel was compiled with</p></li>
<li><p>the <strong>CONFIG_CGROUP_NET_CLASSID</strong> configuration option set to</p></li>
<li><p>“<strong>y</strong>” or to “<strong>m</strong>”.</p></li>
<li><p>Return</p></li>
<li><p>The classid, or 0 for the default unconfigured classid.</p></li>
<li></li>
<li><p>long bpf_skb_vlan_push(struct sk_buff <a href="#id193"><span class="problematic" id="id194">*</span></a>skb, __be16 vlan_proto, u16 vlan_tci)</p></li>
<li><p>Description</p></li>
<li><p>Push a <em>vlan_tci</em> (VLAN tag control information) of protocol</p></li>
<li><p><em>vlan_proto</em> to the packet associated to <em>skb</em>, then update</p></li>
<li><p>the checksum. Note that if <em>vlan_proto</em> is different from</p></li>
<li><p><strong>ETH_P_8021Q</strong> and <strong>ETH_P_8021AD</strong>, it is considered to</p></li>
<li><p>be <strong>ETH_P_8021Q</strong>.</p></li>
<li></li>
<li><p>A call to this helper is susceptible to change the underlying</p></li>
<li><p>packet buffer. Therefore, at load time, all checks on pointers</p></li>
<li><p>previously done by the verifier are invalidated and must be</p></li>
<li><p>performed again, if the helper is used in combination with</p></li>
<li><p>direct packet access.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_skb_vlan_pop(struct sk_buff <a href="#id195"><span class="problematic" id="id196">*</span></a>skb)</p></li>
<li><p>Description</p></li>
<li><p>Pop a VLAN header from the packet associated to <em>skb</em>.</p></li>
<li></li>
<li><p>A call to this helper is susceptible to change the underlying</p></li>
<li><p>packet buffer. Therefore, at load time, all checks on pointers</p></li>
<li><p>previously done by the verifier are invalidated and must be</p></li>
<li><p>performed again, if the helper is used in combination with</p></li>
<li><p>direct packet access.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_skb_get_tunnel_key(struct sk_buff <a href="#id197"><span class="problematic" id="id198">*</span></a>skb, struct bpf_tunnel_key <a href="#id199"><span class="problematic" id="id200">*</span></a>key, u32 size, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Get tunnel metadata. This helper takes a pointer <em>key</em> to an</p></li>
<li><p>empty <strong>struct bpf_tunnel_key</strong> of <strong>size</strong>, that will be</p></li>
<li><p>filled with tunnel metadata for the packet associated to <em>skb</em>.</p></li>
<li><p>The <em>flags</em> can be set to <strong>BPF_F_TUNINFO_IPV6</strong>, which</p></li>
<li><p>indicates that the tunnel is based on IPv6 protocol instead of</p></li>
<li><p>IPv4.</p></li>
<li></li>
<li><p>The <strong>struct bpf_tunnel_key</strong> is an object that generalizes the</p></li>
<li><p>principal parameters used by various tunneling protocols into a</p></li>
<li><p>single struct. This way, it can be used to easily make a</p></li>
<li><p>decision based on the contents of the encapsulation header,</p></li>
<li><p>“summarized” in this struct. In particular, it holds the IP</p></li>
<li><p>address of the remote end (IPv4 or IPv6, depending on the case)</p></li>
<li><p>in <em>key</em><strong>-&gt;remote_ipv4</strong> or <em>key</em><strong>-&gt;remote_ipv6</strong>. Also,</p></li>
<li><p>this struct exposes the <em>key</em><strong>-&gt;tunnel_id</strong>, which is</p></li>
<li><p>generally mapped to a VNI (Virtual Network Identifier), making</p></li>
<li><p>it programmable together with the <strong>bpf_skb_set_tunnel_key</strong></p></li>
<li><p>() helper.</p></li>
<li></li>
<li><p>Let’s imagine that the following code is part of a program</p></li>
<li><p>attached to the TC ingress interface, on one end of a GRE</p></li>
<li><p>tunnel, and is supposed to filter out all messages coming from</p></li>
<li><p>remote ends with IPv4 address other than 10.0.0.1:</p></li>
<li></li>
<li></li>
<li></li>
<li><p>int ret;</p></li>
<li><p>struct bpf_tunnel_key key = {};</p></li>
<li></li>
<li><p>ret = bpf_skb_get_tunnel_key(skb, &amp;key, sizeof(key), 0);</p></li>
<li><p>if (ret &lt; 0)</p></li>
<li><p>return TC_ACT_SHOT;     // drop packet</p></li>
<li></li>
<li><p>if (key.remote_ipv4 != 0x0a000001)</p></li>
<li><p>return TC_ACT_SHOT;     // drop packet</p></li>
<li></li>
<li><p>return TC_ACT_OK;               // accept packet</p></li>
<li></li>
<li><p>This interface can also be used with all encapsulation devices</p></li>
<li><p>that can operate in “collect metadata” mode: instead of having</p></li>
<li><p>one network device per specific configuration, the “collect</p></li>
<li><p>metadata” mode only requires a single device where the</p></li>
<li><p>configuration can be extracted from this helper.</p></li>
<li></li>
<li><p>This can be used together with various tunnels such as VXLan,</p></li>
<li><p>Geneve, GRE or IP in IP (IPIP).</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_skb_set_tunnel_key(struct sk_buff <a href="#id201"><span class="problematic" id="id202">*</span></a>skb, struct bpf_tunnel_key <a href="#id203"><span class="problematic" id="id204">*</span></a>key, u32 size, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Populate tunnel metadata for packet associated to <em>skb.</em> The</p></li>
<li><p>tunnel metadata is set to the contents of <em>key</em>, of <em>size</em>. The</p></li>
<li><p><em>flags</em> can be set to a combination of the following values:</p></li>
<li></li>
<li><p><strong>BPF_F_TUNINFO_IPV6</strong></p></li>
<li><p>Indicate that the tunnel is based on IPv6 protocol</p></li>
<li><p>instead of IPv4.</p></li>
<li><p><strong>BPF_F_ZERO_CSUM_TX</strong></p></li>
<li><p>For IPv4 packets, add a flag to tunnel metadata</p></li>
<li><p>indicating that checksum computation should be skipped</p></li>
<li><p>and checksum set to zeroes.</p></li>
<li><p><strong>BPF_F_DONT_FRAGMENT</strong></p></li>
<li><p>Add a flag to tunnel metadata indicating that the</p></li>
<li><p>packet should not be fragmented.</p></li>
<li><p><strong>BPF_F_SEQ_NUMBER</strong></p></li>
<li><p>Add a flag to tunnel metadata indicating that a</p></li>
<li><p>sequence number should be added to tunnel header before</p></li>
<li><p>sending the packet. This flag was added for GRE</p></li>
<li><p>encapsulation, but might be used with other protocols</p></li>
<li><p>as well in the future.</p></li>
<li></li>
<li><p>Here is a typical usage on the transmit path:</p></li>
<li></li>
<li></li>
<li></li>
<li><p>struct bpf_tunnel_key key;</p></li>
<li><p>populate key …</p></li>
<li><p>bpf_skb_set_tunnel_key(skb, &amp;key, sizeof(key), 0);</p></li>
<li><p>bpf_clone_redirect(skb, vxlan_dev_ifindex, 0);</p></li>
<li></li>
<li><p>See also the description of the <strong>bpf_skb_get_tunnel_key</strong>()</p></li>
<li><p>helper for additional information.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>u64 bpf_perf_event_read(struct bpf_map <a href="#id205"><span class="problematic" id="id206">*</span></a>map, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Read the value of a perf event counter. This helper relies on a</p></li>
<li><p><em>map</em> of type <strong>BPF_MAP_TYPE_PERF_EVENT_ARRAY</strong>. The nature of</p></li>
<li><p>the perf event counter is selected when <em>map</em> is updated with</p></li>
<li><p>perf event file descriptors. The <em>map</em> is an array whose size</p></li>
<li><p>is the number of available CPUs, and each cell contains a value</p></li>
<li><p>relative to one CPU. The value to retrieve is indicated by</p></li>
<li><p><em>flags</em>, that contains the index of the CPU to look up, masked</p></li>
<li><p>with <strong>BPF_F_INDEX_MASK</strong>. Alternatively, <em>flags</em> can be set to</p></li>
<li><p><strong>BPF_F_CURRENT_CPU</strong> to indicate that the value for the</p></li>
<li><p>current CPU should be retrieved.</p></li>
<li></li>
<li><p>Note that before Linux 4.13, only hardware perf event can be</p></li>
<li><p>retrieved.</p></li>
<li></li>
<li><p>Also, be aware that the newer helper</p></li>
<li><p><strong>bpf_perf_event_read_value</strong>() is recommended over</p></li>
<li><p><strong>bpf_perf_event_read</strong>() in general. The latter has some ABI</p></li>
<li><p>quirks where error and counter value are used as a return code</p></li>
<li><p>(which is wrong to do since ranges may overlap). This issue is</p></li>
<li><p>fixed with <strong>bpf_perf_event_read_value</strong>(), which at the same</p></li>
<li><p>time provides more features over the <strong>bpf_perf_event_read</strong></p></li>
<li><p>() interface. Please refer to the description of</p></li>
<li><p><strong>bpf_perf_event_read_value</strong>() for details.</p></li>
<li><p>Return</p></li>
<li><p>The value of the perf event counter read from the map, or a</p></li>
<li><p>negative error code in case of failure.</p></li>
<li></li>
<li><p>long bpf_redirect(u32 ifindex, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Redirect the packet to another net device of index <em>ifindex</em>.</p></li>
<li><p>This helper is somewhat similar to <strong>bpf_clone_redirect</strong></p></li>
<li><p>(), except that the packet is not cloned, which provides</p></li>
<li><p>increased performance.</p></li>
<li></li>
<li><p>Except for XDP, both ingress and egress interfaces can be used</p></li>
<li><p>for redirection. The <strong>BPF_F_INGRESS</strong> value in <em>flags</em> is used</p></li>
<li><p>to make the distinction (ingress path is selected if the flag</p></li>
<li><p>is present, egress path otherwise). Currently, XDP only</p></li>
<li><p>supports redirection to the egress interface, and accepts no</p></li>
<li><p>flag at all.</p></li>
<li></li>
<li><p>The same effect can also be attained with the more generic</p></li>
<li><p><strong>bpf_redirect_map</strong>(), which uses a BPF map to store the</p></li>
<li><p>redirect target instead of providing it directly to the helper.</p></li>
<li><p>Return</p></li>
<li><p>For XDP, the helper returns <strong>XDP_REDIRECT</strong> on success or</p></li>
<li><p><strong>XDP_ABORTED</strong> on error. For other program types, the values</p></li>
<li><p>are <strong>TC_ACT_REDIRECT</strong> on success or <strong>TC_ACT_SHOT</strong> on</p></li>
<li><p>error.</p></li>
<li></li>
<li><p>u32 bpf_get_route_realm(struct sk_buff <a href="#id207"><span class="problematic" id="id208">*</span></a>skb)</p></li>
<li><p>Description</p></li>
<li><p>Retrieve the realm or the route, that is to say the</p></li>
<li><p><strong>tclassid</strong> field of the destination for the <em>skb</em>. The</p></li>
<li><p>identifier retrieved is a user-provided tag, similar to the</p></li>
<li><p>one used with the net_cls cgroup (see description for</p></li>
<li><p><strong>bpf_get_cgroup_classid</strong>() helper), but here this tag is</p></li>
<li><p>held by a route (a destination entry), not by a task.</p></li>
<li></li>
<li><p>Retrieving this identifier works with the clsact TC egress hook</p></li>
<li><p>(see also <strong>tc-bpf(8)</strong>), or alternatively on conventional</p></li>
<li><p>classful egress qdiscs, but not on TC ingress path. In case of</p></li>
<li><p>clsact TC egress hook, this has the advantage that, internally,</p></li>
<li><p>the destination entry has not been dropped yet in the transmit</p></li>
<li><p>path. Therefore, the destination entry does not need to be</p></li>
<li><p>artificially held via <strong>netif_keep_dst</strong>() for a classful</p></li>
<li><p>qdisc until the <em>skb</em> is freed.</p></li>
<li></li>
<li><p>This helper is available only if the kernel was compiled with</p></li>
<li><p><strong>CONFIG_IP_ROUTE_CLASSID</strong> configuration option.</p></li>
<li><p>Return</p></li>
<li><p>The realm of the route for the packet associated to <em>skb</em>, or 0</p></li>
<li><p>if none was found.</p></li>
<li></li>
<li><p>long bpf_perf_event_output(void <a href="#id209"><span class="problematic" id="id210">*</span></a>ctx, struct bpf_map <a href="#id211"><span class="problematic" id="id212">*</span></a>map, u64 flags, void <a href="#id213"><span class="problematic" id="id214">*</span></a>data, u64 size)</p></li>
<li><p>Description</p></li>
<li><p>Write raw <em>data</em> blob into a special BPF perf event held by</p></li>
<li><p><em>map</em> of type <strong>BPF_MAP_TYPE_PERF_EVENT_ARRAY</strong>. This perf</p></li>
<li><p>event must have the following attributes: <strong>PERF_SAMPLE_RAW</strong></p></li>
<li><p>as <strong>sample_type</strong>, <strong>PERF_TYPE_SOFTWARE</strong> as <strong>type</strong>, and</p></li>
<li><p><strong>PERF_COUNT_SW_BPF_OUTPUT</strong> as <strong>config</strong>.</p></li>
<li></li>
<li><p>The <em>flags</em> are used to indicate the index in <em>map</em> for which</p></li>
<li><p>the value must be put, masked with <strong>BPF_F_INDEX_MASK</strong>.</p></li>
<li><p>Alternatively, <em>flags</em> can be set to <strong>BPF_F_CURRENT_CPU</strong></p></li>
<li><p>to indicate that the index of the current CPU core should be</p></li>
<li><p>used.</p></li>
<li></li>
<li><p>The value to write, of <em>size</em>, is passed through eBPF stack and</p></li>
<li><p>pointed by <em>data</em>.</p></li>
<li></li>
<li><p>The context of the program <em>ctx</em> needs also be passed to the</p></li>
<li><p>helper.</p></li>
<li></li>
<li><p>On user space, a program willing to read the values needs to</p></li>
<li><p>call <strong>perf_event_open</strong>() on the perf event (either for</p></li>
<li><p>one or for all CPUs) and to store the file descriptor into the</p></li>
<li><p><em>map</em>. This must be done before the eBPF program can send data</p></li>
<li><p>into it. An example is available in file</p></li>
<li><p><em>samples/bpf/trace_output_user.c</em> in the Linux kernel source</p></li>
<li><p>tree (the eBPF program counterpart is in</p></li>
<li><p><em>samples/bpf/trace_output_kern.c</em>).</p></li>
<li></li>
<li><p><strong>bpf_perf_event_output</strong>() achieves better performance</p></li>
<li><p>than <strong>bpf_trace_printk</strong>() for sharing data with user</p></li>
<li><p>space, and is much better suitable for streaming data from eBPF</p></li>
<li><p>programs.</p></li>
<li></li>
<li><p>Note that this helper is not restricted to tracing use cases</p></li>
<li><p>and can be used with programs attached to TC or XDP as well,</p></li>
<li><p>where it allows for passing data to user space listeners. Data</p></li>
<li><p>can be:</p></li>
<li></li>
<li><ul class="simple">
<li><p>Only custom structs,</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p>Only the packet payload, or</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p>A combination of both.</p></li>
</ul>
</li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_skb_load_bytes(const void <a href="#id215"><span class="problematic" id="id216">*</span></a>skb, u32 offset, void <a href="#id217"><span class="problematic" id="id218">*</span></a>to, u32 len)</p></li>
<li><p>Description</p></li>
<li><p>This helper was provided as an easy way to load data from a</p></li>
<li><p>packet. It can be used to load <em>len</em> bytes from <em>offset</em> from</p></li>
<li><p>the packet associated to <em>skb</em>, into the buffer pointed by</p></li>
<li><p><em>to</em>.</p></li>
<li></li>
<li><p>Since Linux 4.7, usage of this helper has mostly been replaced</p></li>
<li><p>by “direct packet access”, enabling packet data to be</p></li>
<li><p>manipulated with <em>skb</em><strong>-&gt;data</strong> and <em>skb</em><strong>-&gt;data_end</strong></p></li>
<li><p>pointing respectively to the first byte of packet data and to</p></li>
<li><p>the byte after the last byte of packet data. However, it</p></li>
<li><p>remains useful if one wishes to read large quantities of data</p></li>
<li><p>at once from a packet into the eBPF stack.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_get_stackid(void <a href="#id219"><span class="problematic" id="id220">*</span></a>ctx, struct bpf_map <a href="#id221"><span class="problematic" id="id222">*</span></a>map, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Walk a user or a kernel stack and return its id. To achieve</p></li>
<li><p>this, the helper needs <em>ctx</em>, which is a pointer to the context</p></li>
<li><p>on which the tracing program is executed, and a pointer to a</p></li>
<li><p><em>map</em> of type <strong>BPF_MAP_TYPE_STACK_TRACE</strong>.</p></li>
<li></li>
<li><p>The last argument, <em>flags</em>, holds the number of stack frames to</p></li>
<li><p>skip (from 0 to 255), masked with</p></li>
<li><p><strong>BPF_F_SKIP_FIELD_MASK</strong>. The next bits can be used to set</p></li>
<li><p>a combination of the following flags:</p></li>
<li></li>
<li><p><strong>BPF_F_USER_STACK</strong></p></li>
<li><p>Collect a user space stack instead of a kernel stack.</p></li>
<li><p><strong>BPF_F_FAST_STACK_CMP</strong></p></li>
<li><p>Compare stacks by hash only.</p></li>
<li><p><strong>BPF_F_REUSE_STACKID</strong></p></li>
<li><p>If two different stacks hash into the same <em>stackid</em>,</p></li>
<li><p>discard the old one.</p></li>
<li></li>
<li><p>The stack id retrieved is a 32 bit long integer handle which</p></li>
<li><p>can be further combined with other data (including other stack</p></li>
<li><p>ids) and used as a key into maps. This can be useful for</p></li>
<li><p>generating a variety of graphs (such as flame graphs or off-cpu</p></li>
<li><p>graphs).</p></li>
<li></li>
<li><p>For walking a stack, this helper is an improvement over</p></li>
<li><p><strong>bpf_probe_read</strong>(), which can be used with unrolled loops</p></li>
<li><p>but is not efficient and consumes a lot of eBPF instructions.</p></li>
<li><p>Instead, <strong>bpf_get_stackid</strong>() can collect up to</p></li>
<li><p><strong>PERF_MAX_STACK_DEPTH</strong> both kernel and user frames. Note that</p></li>
<li><p>this limit can be controlled with the <strong>sysctl</strong> program, and</p></li>
<li><p>that it should be manually increased in order to profile long</p></li>
<li><p>user stacks (such as stacks for Java programs). To do so, use:</p></li>
<li></li>
<li></li>
<li></li>
<li><p># sysctl kernel.perf_event_max_stack=&lt;new value&gt;</p></li>
<li><p>Return</p></li>
<li><p>The positive or null stack id on success, or a negative error</p></li>
<li><p>in case of failure.</p></li>
<li></li>
<li><p>s64 bpf_csum_diff(__be32 <a href="#id223"><span class="problematic" id="id224">*</span></a>from, u32 from_size, __be32 <a href="#id225"><span class="problematic" id="id226">*</span></a>to, u32 to_size, __wsum seed)</p></li>
<li><p>Description</p></li>
<li><p>Compute a checksum difference, from the raw buffer pointed by</p></li>
<li><p><em>from</em>, of length <em>from_size</em> (that must be a multiple of 4),</p></li>
<li><p>towards the raw buffer pointed by <em>to</em>, of size <em>to_size</em></p></li>
<li><p>(same remark). An optional <em>seed</em> can be added to the value</p></li>
<li><p>(this can be cascaded, the seed may come from a previous call</p></li>
<li><p>to the helper).</p></li>
<li></li>
<li><p>This is flexible enough to be used in several ways:</p></li>
<li></li>
<li><ul class="simple">
<li><p>With <em>from_size</em> == 0, <em>to_size</em> &gt; 0 and <em>seed</em> set to</p></li>
</ul>
</li>
<li><p>checksum, it can be used when pushing new data.</p></li>
<li><ul class="simple">
<li><p>With <em>from_size</em> &gt; 0, <em>to_size</em> == 0 and <em>seed</em> set to</p></li>
</ul>
</li>
<li><p>checksum, it can be used when removing data from a packet.</p></li>
<li><ul class="simple">
<li><p>With <em>from_size</em> &gt; 0, <em>to_size</em> &gt; 0 and <em>seed</em> set to 0, it</p></li>
</ul>
</li>
<li><p>can be used to compute a diff. Note that <em>from_size</em> and</p></li>
<li><p><em>to_size</em> do not need to be equal.</p></li>
<li></li>
<li><p>This helper can be used in combination with</p></li>
<li><p><strong>bpf_l3_csum_replace</strong>() and <strong>bpf_l4_csum_replace</strong>(), to</p></li>
<li><p>which one can feed in the difference computed with</p></li>
<li><p><strong>bpf_csum_diff</strong>().</p></li>
<li><p>Return</p></li>
<li><p>The checksum result, or a negative error code in case of</p></li>
<li><p>failure.</p></li>
<li></li>
<li><p>long bpf_skb_get_tunnel_opt(struct sk_buff <a href="#id227"><span class="problematic" id="id228">*</span></a>skb, void <a href="#id229"><span class="problematic" id="id230">*</span></a>opt, u32 size)</p></li>
<li><p>Description</p></li>
<li><p>Retrieve tunnel options metadata for the packet associated to</p></li>
<li><p><em>skb</em>, and store the raw tunnel option data to the buffer <em>opt</em></p></li>
<li><p>of <em>size</em>.</p></li>
<li></li>
<li><p>This helper can be used with encapsulation devices that can</p></li>
<li><p>operate in “collect metadata” mode (please refer to the related</p></li>
<li><p>note in the description of <strong>bpf_skb_get_tunnel_key</strong>() for</p></li>
<li><p>more details). A particular example where this can be used is</p></li>
<li><p>in combination with the Geneve encapsulation protocol, where it</p></li>
<li><p>allows for pushing (with <strong>bpf_skb_get_tunnel_opt</strong>() helper)</p></li>
<li><p>and retrieving arbitrary TLVs (Type-Length-Value headers) from</p></li>
<li><p>the eBPF program. This allows for full customization of these</p></li>
<li><p>headers.</p></li>
<li><p>Return</p></li>
<li><p>The size of the option data retrieved.</p></li>
<li></li>
<li><p>long bpf_skb_set_tunnel_opt(struct sk_buff <a href="#id231"><span class="problematic" id="id232">*</span></a>skb, void <a href="#id233"><span class="problematic" id="id234">*</span></a>opt, u32 size)</p></li>
<li><p>Description</p></li>
<li><p>Set tunnel options metadata for the packet associated to <em>skb</em></p></li>
<li><p>to the option data contained in the raw buffer <em>opt</em> of <em>size</em>.</p></li>
<li></li>
<li><p>See also the description of the <strong>bpf_skb_get_tunnel_opt</strong>()</p></li>
<li><p>helper for additional information.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_skb_change_proto(struct sk_buff <a href="#id235"><span class="problematic" id="id236">*</span></a>skb, __be16 proto, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Change the protocol of the <em>skb</em> to <em>proto</em>. Currently</p></li>
<li><p>supported are transition from IPv4 to IPv6, and from IPv6 to</p></li>
<li><p>IPv4. The helper takes care of the groundwork for the</p></li>
<li><p>transition, including resizing the socket buffer. The eBPF</p></li>
<li><p>program is expected to fill the new headers, if any, via</p></li>
<li><p><strong>skb_store_bytes</strong>() and to recompute the checksums with</p></li>
<li><p><strong>bpf_l3_csum_replace</strong>() and <strong>bpf_l4_csum_replace</strong></p></li>
<li><p>(). The main case for this helper is to perform NAT64</p></li>
<li><p>operations out of an eBPF program.</p></li>
<li></li>
<li><p>Internally, the GSO type is marked as dodgy so that headers are</p></li>
<li><p>checked and segments are recalculated by the GSO/GRO engine.</p></li>
<li><p>The size for GSO target is adapted as well.</p></li>
<li></li>
<li><p>All values for <em>flags</em> are reserved for future usage, and must</p></li>
<li><p>be left at zero.</p></li>
<li></li>
<li><p>A call to this helper is susceptible to change the underlying</p></li>
<li><p>packet buffer. Therefore, at load time, all checks on pointers</p></li>
<li><p>previously done by the verifier are invalidated and must be</p></li>
<li><p>performed again, if the helper is used in combination with</p></li>
<li><p>direct packet access.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_skb_change_type(struct sk_buff <a href="#id237"><span class="problematic" id="id238">*</span></a>skb, u32 type)</p></li>
<li><p>Description</p></li>
<li><p>Change the packet type for the packet associated to <em>skb</em>. This</p></li>
<li><p>comes down to setting <em>skb</em><strong>-&gt;pkt_type</strong> to <em>type</em>, except</p></li>
<li><p>the eBPF program does not have a write access to <em>skb</em></p></li>
<li><p><strong>-&gt;pkt_type</strong> beside this helper. Using a helper here allows</p></li>
<li><p>for graceful handling of errors.</p></li>
<li></li>
<li><p>The major use case is to change incoming <a href="#id239"><span class="problematic" id="id240">*</span></a>skb*s to</p></li>
<li><p><strong>PACKET_HOST</strong> in a programmatic way instead of having to</p></li>
<li><p>recirculate via <strong>redirect</strong>(…, <strong>BPF_F_INGRESS</strong>), for</p></li>
<li><p>example.</p></li>
<li></li>
<li><p>Note that <em>type</em> only allows certain values. At this time, they</p></li>
<li><p>are:</p></li>
<li></li>
<li><p><strong>PACKET_HOST</strong></p></li>
<li><p>Packet is for us.</p></li>
<li><p><strong>PACKET_BROADCAST</strong></p></li>
<li><p>Send packet to all.</p></li>
<li><p><strong>PACKET_MULTICAST</strong></p></li>
<li><p>Send packet to group.</p></li>
<li><p><strong>PACKET_OTHERHOST</strong></p></li>
<li><p>Send packet to someone else.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_skb_under_cgroup(struct sk_buff <a href="#id241"><span class="problematic" id="id242">*</span></a>skb, struct bpf_map <a href="#id243"><span class="problematic" id="id244">*</span></a>map, u32 index)</p></li>
<li><p>Description</p></li>
<li><p>Check whether <em>skb</em> is a descendant of the cgroup2 held by</p></li>
<li><p><em>map</em> of type <strong>BPF_MAP_TYPE_CGROUP_ARRAY</strong>, at <em>index</em>.</p></li>
<li><p>Return</p></li>
<li><p>The return value depends on the result of the test, and can be:</p></li>
<li></li>
<li><ul class="simple">
<li><p>0, if the <em>skb</em> failed the cgroup2 descendant test.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p>1, if the <em>skb</em> succeeded the cgroup2 descendant test.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p>A negative error code, if an error occurred.</p></li>
</ul>
</li>
<li></li>
<li><p>u32 bpf_get_hash_recalc(struct sk_buff <a href="#id245"><span class="problematic" id="id246">*</span></a>skb)</p></li>
<li><p>Description</p></li>
<li><p>Retrieve the hash of the packet, <em>skb</em><strong>-&gt;hash</strong>. If it is</p></li>
<li><p>not set, in particular if the hash was cleared due to mangling,</p></li>
<li><p>recompute this hash. Later accesses to the hash can be done</p></li>
<li><p>directly with <em>skb</em><strong>-&gt;hash</strong>.</p></li>
<li></li>
<li><p>Calling <strong>bpf_set_hash_invalid</strong>(), changing a packet</p></li>
<li><p>prototype with <strong>bpf_skb_change_proto</strong>(), or calling</p></li>
<li><p><strong>bpf_skb_store_bytes</strong>() with the</p></li>
<li><p><strong>BPF_F_INVALIDATE_HASH</strong> are actions susceptible to clear</p></li>
<li><p>the hash and to trigger a new computation for the next call to</p></li>
<li><p><strong>bpf_get_hash_recalc</strong>().</p></li>
<li><p>Return</p></li>
<li><p>The 32-bit hash.</p></li>
<li></li>
<li><p>u64 bpf_get_current_task(void)</p></li>
<li><p>Return</p></li>
<li><p>A pointer to the current task struct.</p></li>
<li></li>
<li><p>long bpf_probe_write_user(void <a href="#id247"><span class="problematic" id="id248">*</span></a>dst, const void <a href="#id249"><span class="problematic" id="id250">*</span></a>src, u32 len)</p></li>
<li><p>Description</p></li>
<li><p>Attempt in a safe way to write <em>len</em> bytes from the buffer</p></li>
<li><p><em>src</em> to <em>dst</em> in memory. It only works for threads that are in</p></li>
<li><p>user context, and <em>dst</em> must be a valid user space address.</p></li>
<li></li>
<li><p>This helper should not be used to implement any kind of</p></li>
<li><p>security mechanism because of TOC-TOU attacks, but rather to</p></li>
<li><p>debug, divert, and manipulate execution of semi-cooperative</p></li>
<li><p>processes.</p></li>
<li></li>
<li><p>Keep in mind that this feature is meant for experiments, and it</p></li>
<li><p>has a risk of crashing the system and running programs.</p></li>
<li><p>Therefore, when an eBPF program using this helper is attached,</p></li>
<li><p>a warning including PID and process name is printed to kernel</p></li>
<li><p>logs.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_current_task_under_cgroup(struct bpf_map <a href="#id251"><span class="problematic" id="id252">*</span></a>map, u32 index)</p></li>
<li><p>Description</p></li>
<li><p>Check whether the probe is being run is the context of a given</p></li>
<li><p>subset of the cgroup2 hierarchy. The cgroup2 to test is held by</p></li>
<li><p><em>map</em> of type <strong>BPF_MAP_TYPE_CGROUP_ARRAY</strong>, at <em>index</em>.</p></li>
<li><p>Return</p></li>
<li><p>The return value depends on the result of the test, and can be:</p></li>
<li></li>
<li><ul class="simple">
<li><p>0, if current task belongs to the cgroup2.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p>1, if current task does not belong to the cgroup2.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p>A negative error code, if an error occurred.</p></li>
</ul>
</li>
<li></li>
<li><p>long bpf_skb_change_tail(struct sk_buff <a href="#id253"><span class="problematic" id="id254">*</span></a>skb, u32 len, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Resize (trim or grow) the packet associated to <em>skb</em> to the</p></li>
<li><p>new <em>len</em>. The <em>flags</em> are reserved for future usage, and must</p></li>
<li><p>be left at zero.</p></li>
<li></li>
<li><p>The basic idea is that the helper performs the needed work to</p></li>
<li><p>change the size of the packet, then the eBPF program rewrites</p></li>
<li><p>the rest via helpers like <strong>bpf_skb_store_bytes</strong>(),</p></li>
<li><p><strong>bpf_l3_csum_replace</strong>(), <strong>bpf_l3_csum_replace</strong>()</p></li>
<li><p>and others. This helper is a slow path utility intended for</p></li>
<li><p>replies with control messages. And because it is targeted for</p></li>
<li><p>slow path, the helper itself can afford to be slow: it</p></li>
<li><p>implicitly linearizes, unclones and drops offloads from the</p></li>
<li><p><em>skb</em>.</p></li>
<li></li>
<li><p>A call to this helper is susceptible to change the underlying</p></li>
<li><p>packet buffer. Therefore, at load time, all checks on pointers</p></li>
<li><p>previously done by the verifier are invalidated and must be</p></li>
<li><p>performed again, if the helper is used in combination with</p></li>
<li><p>direct packet access.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_skb_pull_data(struct sk_buff <a href="#id255"><span class="problematic" id="id256">*</span></a>skb, u32 len)</p></li>
<li><p>Description</p></li>
<li><p>Pull in non-linear data in case the <em>skb</em> is non-linear and not</p></li>
<li><p>all of <em>len</em> are part of the linear section. Make <em>len</em> bytes</p></li>
<li><p>from <em>skb</em> readable and writable. If a zero value is passed for</p></li>
<li><p><em>len</em>, then the whole length of the <em>skb</em> is pulled.</p></li>
<li></li>
<li><p>This helper is only needed for reading and writing with direct</p></li>
<li><p>packet access.</p></li>
<li></li>
<li><p>For direct packet access, testing that offsets to access</p></li>
<li><p>are within packet boundaries (test on <em>skb</em><strong>-&gt;data_end</strong>) is</p></li>
<li><p>susceptible to fail if offsets are invalid, or if the requested</p></li>
<li><p>data is in non-linear parts of the <em>skb</em>. On failure the</p></li>
<li><p>program can just bail out, or in the case of a non-linear</p></li>
<li><p>buffer, use a helper to make the data available. The</p></li>
<li><p><strong>bpf_skb_load_bytes</strong>() helper is a first solution to access</p></li>
<li><p>the data. Another one consists in using <strong>bpf_skb_pull_data</strong></p></li>
<li><p>to pull in once the non-linear parts, then retesting and</p></li>
<li><p>eventually access the data.</p></li>
<li></li>
<li><p>At the same time, this also makes sure the <em>skb</em> is uncloned,</p></li>
<li><p>which is a necessary condition for direct write. As this needs</p></li>
<li><p>to be an invariant for the write part only, the verifier</p></li>
<li><p>detects writes and adds a prologue that is calling</p></li>
<li><p><strong>bpf_skb_pull_data()</strong> to effectively unclone the <em>skb</em> from</p></li>
<li><p>the very beginning in case it is indeed cloned.</p></li>
<li></li>
<li><p>A call to this helper is susceptible to change the underlying</p></li>
<li><p>packet buffer. Therefore, at load time, all checks on pointers</p></li>
<li><p>previously done by the verifier are invalidated and must be</p></li>
<li><p>performed again, if the helper is used in combination with</p></li>
<li><p>direct packet access.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>s64 bpf_csum_update(struct sk_buff <a href="#id257"><span class="problematic" id="id258">*</span></a>skb, __wsum csum)</p></li>
<li><p>Description</p></li>
<li><p>Add the checksum <em>csum</em> into <em>skb</em><strong>-&gt;csum</strong> in case the</p></li>
<li><p>driver has supplied a checksum for the entire packet into that</p></li>
<li><p>field. Return an error otherwise. This helper is intended to be</p></li>
<li><p>used in combination with <strong>bpf_csum_diff</strong>(), in particular</p></li>
<li><p>when the checksum needs to be updated after data has been</p></li>
<li><p>written into the packet through direct packet access.</p></li>
<li><p>Return</p></li>
<li><p>The checksum on success, or a negative error code in case of</p></li>
<li><p>failure.</p></li>
<li></li>
<li><p>void bpf_set_hash_invalid(struct sk_buff <a href="#id259"><span class="problematic" id="id260">*</span></a>skb)</p></li>
<li><p>Description</p></li>
<li><p>Invalidate the current <em>skb</em><strong>-&gt;hash</strong>. It can be used after</p></li>
<li><p>mangling on headers through direct packet access, in order to</p></li>
<li><p>indicate that the hash is outdated and to trigger a</p></li>
<li><p>recalculation the next time the kernel tries to access this</p></li>
<li><p>hash or when the <strong>bpf_get_hash_recalc</strong>() helper is called.</p></li>
<li></li>
<li><p>long bpf_get_numa_node_id(void)</p></li>
<li><p>Description</p></li>
<li><p>Return the id of the current NUMA node. The primary use case</p></li>
<li><p>for this helper is the selection of sockets for the local NUMA</p></li>
<li><p>node, when the program is attached to sockets using the</p></li>
<li><p><strong>SO_ATTACH_REUSEPORT_EBPF</strong> option (see also <strong>socket(7)</strong>),</p></li>
<li><p>but the helper is also available to other eBPF program types,</p></li>
<li><p>similarly to <strong>bpf_get_smp_processor_id</strong>().</p></li>
<li><p>Return</p></li>
<li><p>The id of current NUMA node.</p></li>
<li></li>
<li><p>long bpf_skb_change_head(struct sk_buff <a href="#id261"><span class="problematic" id="id262">*</span></a>skb, u32 len, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Grows headroom of packet associated to <em>skb</em> and adjusts the</p></li>
<li><p>offset of the MAC header accordingly, adding <em>len</em> bytes of</p></li>
<li><p>space. It automatically extends and reallocates memory as</p></li>
<li><p>required.</p></li>
<li></li>
<li><p>This helper can be used on a layer 3 <em>skb</em> to push a MAC header</p></li>
<li><p>for redirection into a layer 2 device.</p></li>
<li></li>
<li><p>All values for <em>flags</em> are reserved for future usage, and must</p></li>
<li><p>be left at zero.</p></li>
<li></li>
<li><p>A call to this helper is susceptible to change the underlying</p></li>
<li><p>packet buffer. Therefore, at load time, all checks on pointers</p></li>
<li><p>previously done by the verifier are invalidated and must be</p></li>
<li><p>performed again, if the helper is used in combination with</p></li>
<li><p>direct packet access.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_xdp_adjust_head(struct xdp_buff <a href="#id263"><span class="problematic" id="id264">*</span></a>xdp_md, int delta)</p></li>
<li><p>Description</p></li>
<li><p>Adjust (move) <em>xdp_md</em><strong>-&gt;data</strong> by <em>delta</em> bytes. Note that</p></li>
<li><p>it is possible to use a negative value for <em>delta</em>. This helper</p></li>
<li><p>can be used to prepare the packet for pushing or popping</p></li>
<li><p>headers.</p></li>
<li></li>
<li><p>A call to this helper is susceptible to change the underlying</p></li>
<li><p>packet buffer. Therefore, at load time, all checks on pointers</p></li>
<li><p>previously done by the verifier are invalidated and must be</p></li>
<li><p>performed again, if the helper is used in combination with</p></li>
<li><p>direct packet access.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_probe_read_str(void <a href="#id265"><span class="problematic" id="id266">*</span></a>dst, u32 size, const void <a href="#id267"><span class="problematic" id="id268">*</span></a>unsafe_ptr)</p></li>
<li><p>Description</p></li>
<li><p>Copy a NUL terminated string from an unsafe kernel address</p></li>
<li><p><em>unsafe_ptr</em> to <em>dst</em>. See <strong>bpf_probe_read_kernel_str</strong>() for</p></li>
<li><p>more details.</p></li>
<li></li>
<li><p>Generally, use <strong>bpf_probe_read_user_str</strong>() or</p></li>
<li><p><strong>bpf_probe_read_kernel_str</strong>() instead.</p></li>
<li><p>Return</p></li>
<li><p>On success, the strictly positive length of the string,</p></li>
<li><p>including the trailing NUL character. On error, a negative</p></li>
<li><p>value.</p></li>
<li></li>
<li><p>u64 bpf_get_socket_cookie(struct sk_buff <a href="#id269"><span class="problematic" id="id270">*</span></a>skb)</p></li>
<li><p>Description</p></li>
<li><p>If the <strong>struct sk_buff</strong> pointed by <em>skb</em> has a known socket,</p></li>
<li><p>retrieve the cookie (generated by the kernel) of this socket.</p></li>
<li><p>If no cookie has been set yet, generate a new cookie. Once</p></li>
<li><p>generated, the socket cookie remains stable for the life of the</p></li>
<li><p>socket. This helper can be useful for monitoring per socket</p></li>
<li><p>networking traffic statistics as it provides a global socket</p></li>
<li><p>identifier that can be assumed unique.</p></li>
<li><p>Return</p></li>
<li><p>A 8-byte long unique number on success, or 0 if the socket</p></li>
<li><p>field is missing inside <em>skb</em>.</p></li>
<li></li>
<li><p>u64 bpf_get_socket_cookie(struct bpf_sock_addr <a href="#id271"><span class="problematic" id="id272">*</span></a>ctx)</p></li>
<li><p>Description</p></li>
<li><p>Equivalent to bpf_get_socket_cookie() helper that accepts</p></li>
<li><p><em>skb</em>, but gets socket from <strong>struct bpf_sock_addr</strong> context.</p></li>
<li><p>Return</p></li>
<li><p>A 8-byte long unique number.</p></li>
<li></li>
<li><p>u64 bpf_get_socket_cookie(struct bpf_sock_ops <a href="#id273"><span class="problematic" id="id274">*</span></a>ctx)</p></li>
<li><p>Description</p></li>
<li><p>Equivalent to <strong>bpf_get_socket_cookie</strong>() helper that accepts</p></li>
<li><p><em>skb</em>, but gets socket from <strong>struct bpf_sock_ops</strong> context.</p></li>
<li><p>Return</p></li>
<li><p>A 8-byte long unique number.</p></li>
<li></li>
<li><p>u64 bpf_get_socket_cookie(struct sock <a href="#id275"><span class="problematic" id="id276">*</span></a>sk)</p></li>
<li><p>Description</p></li>
<li><p>Equivalent to <strong>bpf_get_socket_cookie</strong>() helper that accepts</p></li>
<li><p><em>sk</em>, but gets socket from a BTF <strong>struct sock</strong>. This helper</p></li>
<li><p>also works for sleepable programs.</p></li>
<li><p>Return</p></li>
<li><p>A 8-byte long unique number or 0 if <em>sk</em> is NULL.</p></li>
<li></li>
<li><p>u32 bpf_get_socket_uid(struct sk_buff <a href="#id277"><span class="problematic" id="id278">*</span></a>skb)</p></li>
<li><p>Return</p></li>
<li><p>The owner UID of the socket associated to <em>skb</em>. If the socket</p></li>
<li><p>is <strong>NULL</strong>, or if it is not a full socket (i.e. if it is a</p></li>
<li><p>time-wait or a request socket instead), <strong>overflowuid</strong> value</p></li>
<li><p>is returned (note that <strong>overflowuid</strong> might also be the actual</p></li>
<li><p>UID value for the socket).</p></li>
<li></li>
<li><p>long bpf_set_hash(struct sk_buff <a href="#id279"><span class="problematic" id="id280">*</span></a>skb, u32 hash)</p></li>
<li><p>Description</p></li>
<li><p>Set the full hash for <em>skb</em> (set the field <em>skb</em><strong>-&gt;hash</strong>)</p></li>
<li><p>to value <em>hash</em>.</p></li>
<li><p>Return</p></li>
<li><p>0</p></li>
<li></li>
<li><p>long bpf_setsockopt(void <a href="#id281"><span class="problematic" id="id282">*</span></a>bpf_socket, int level, int optname, void <a href="#id283"><span class="problematic" id="id284">*</span></a>optval, int optlen)</p></li>
<li><p>Description</p></li>
<li><p>Emulate a call to <strong>setsockopt()</strong> on the socket associated to</p></li>
<li><p><em>bpf_socket</em>, which must be a full socket. The <em>level</em> at</p></li>
<li><p>which the option resides and the name <em>optname</em> of the option</p></li>
<li><p>must be specified, see <strong>setsockopt(2)</strong> for more information.</p></li>
<li><p>The option value of length <em>optlen</em> is pointed by <em>optval</em>.</p></li>
<li></li>
<li><p><em>bpf_socket</em> should be one of the following:</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>struct bpf_sock_ops</strong> for <strong>BPF_PROG_TYPE_SOCK_OPS</strong>.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p><strong>struct bpf_sock_addr</strong> for <strong>BPF_CGROUP_INET4_CONNECT</strong></p></li>
</ul>
</li>
<li><p>and <strong>BPF_CGROUP_INET6_CONNECT</strong>.</p></li>
<li></li>
<li><p>This helper actually implements a subset of <strong>setsockopt()</strong>.</p></li>
<li><p>It supports the following <em>level</em>s:</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>SOL_SOCKET</strong>, which supports the following <em>optname</em>s:</p></li>
</ul>
</li>
<li><p><strong>SO_RCVBUF</strong>, <strong>SO_SNDBUF</strong>, <strong>SO_MAX_PACING_RATE</strong>,</p></li>
<li><p><strong>SO_PRIORITY</strong>, <strong>SO_RCVLOWAT</strong>, <strong>SO_MARK</strong>,</p></li>
<li><p><strong>SO_BINDTODEVICE</strong>, <strong>SO_KEEPALIVE</strong>.</p></li>
<li><ul class="simple">
<li><p><strong>IPPROTO_TCP</strong>, which supports the following <em>optname</em>s:</p></li>
</ul>
</li>
<li><p><strong>TCP_CONGESTION</strong>, <strong>TCP_BPF_IW</strong>,</p></li>
<li><p><strong>TCP_BPF_SNDCWND_CLAMP</strong>, <strong>TCP_SAVE_SYN</strong>,</p></li>
<li><p><strong>TCP_KEEPIDLE</strong>, <strong>TCP_KEEPINTVL</strong>, <strong>TCP_KEEPCNT</strong>,</p></li>
<li><p><strong>TCP_SYNCNT</strong>, <strong>TCP_USER_TIMEOUT</strong>, <strong>TCP_NOTSENT_LOWAT</strong>.</p></li>
<li><ul class="simple">
<li><p><strong>IPPROTO_IP</strong>, which supports <em>optname</em> <strong>IP_TOS</strong>.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p><strong>IPPROTO_IPV6</strong>, which supports <em>optname</em> <strong>IPV6_TCLASS</strong>.</p></li>
</ul>
</li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_skb_adjust_room(struct sk_buff <a href="#id285"><span class="problematic" id="id286">*</span></a>skb, s32 len_diff, u32 mode, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Grow or shrink the room for data in the packet associated to</p></li>
<li><p><em>skb</em> by <em>len_diff</em>, and according to the selected <em>mode</em>.</p></li>
<li></li>
<li><p>By default, the helper will reset any offloaded checksum</p></li>
<li><p>indicator of the skb to CHECKSUM_NONE. This can be avoided</p></li>
<li><p>by the following flag:</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>BPF_F_ADJ_ROOM_NO_CSUM_RESET</strong>: Do not reset offloaded</p></li>
</ul>
</li>
<li><p>checksum data of the skb to CHECKSUM_NONE.</p></li>
<li></li>
<li><p>There are two supported modes at this time:</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>BPF_ADJ_ROOM_MAC</strong>: Adjust room at the mac layer</p></li>
</ul>
</li>
<li><p>(room space is added or removed below the layer 2 header).</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>BPF_ADJ_ROOM_NET</strong>: Adjust room at the network layer</p></li>
</ul>
</li>
<li><p>(room space is added or removed below the layer 3 header).</p></li>
<li></li>
<li><p>The following flags are supported at this time:</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>BPF_F_ADJ_ROOM_FIXED_GSO</strong>: Do not adjust gso_size.</p></li>
</ul>
</li>
<li><p>Adjusting mss in this way is not allowed for datagrams.</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>BPF_F_ADJ_ROOM_ENCAP_L3_IPV4</strong>,</p></li>
</ul>
</li>
<li><p><strong>BPF_F_ADJ_ROOM_ENCAP_L3_IPV6</strong>:</p></li>
<li><p>Any new space is reserved to hold a tunnel header.</p></li>
<li><p>Configure skb offsets and other fields accordingly.</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>BPF_F_ADJ_ROOM_ENCAP_L4_GRE</strong>,</p></li>
</ul>
</li>
<li><p><strong>BPF_F_ADJ_ROOM_ENCAP_L4_UDP</strong>:</p></li>
<li><p>Use with ENCAP_L3 flags to further specify the tunnel type.</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>BPF_F_ADJ_ROOM_ENCAP_L2</strong>(<em>len</em>):</p></li>
</ul>
</li>
<li><p>Use with ENCAP_L3/L4 flags to further specify the tunnel</p></li>
<li><p>type; <em>len</em> is the length of the inner MAC header.</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>BPF_F_ADJ_ROOM_ENCAP_L2_ETH</strong>:</p></li>
</ul>
</li>
<li><p>Use with BPF_F_ADJ_ROOM_ENCAP_L2 flag to further specify the</p></li>
<li><p>L2 type as Ethernet.</p></li>
<li></li>
<li><p>A call to this helper is susceptible to change the underlying</p></li>
<li><p>packet buffer. Therefore, at load time, all checks on pointers</p></li>
<li><p>previously done by the verifier are invalidated and must be</p></li>
<li><p>performed again, if the helper is used in combination with</p></li>
<li><p>direct packet access.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_redirect_map(struct bpf_map <a href="#id287"><span class="problematic" id="id288">*</span></a>map, u32 key, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Redirect the packet to the endpoint referenced by <em>map</em> at</p></li>
<li><p>index <em>key</em>. Depending on its type, this <em>map</em> can contain</p></li>
<li><p>references to net devices (for forwarding packets through other</p></li>
<li><p>ports), or to CPUs (for redirecting XDP frames to another CPU;</p></li>
<li><p>but this is only implemented for native XDP (with driver</p></li>
<li><p>support) as of this writing).</p></li>
<li></li>
<li><p>The lower two bits of <em>flags</em> are used as the return code if</p></li>
<li><p>the map lookup fails. This is so that the return value can be</p></li>
<li><p>one of the XDP program return codes up to <strong>XDP_TX</strong>, as chosen</p></li>
<li><p>by the caller. The higher bits of <em>flags</em> can be set to</p></li>
<li><p>BPF_F_BROADCAST or BPF_F_EXCLUDE_INGRESS as defined below.</p></li>
<li></li>
<li><p>With BPF_F_BROADCAST the packet will be broadcasted to all the</p></li>
<li><p>interfaces in the map, with BPF_F_EXCLUDE_INGRESS the ingress</p></li>
<li><p>interface will be excluded when do broadcasting.</p></li>
<li></li>
<li><p>See also <strong>bpf_redirect</strong>(), which only supports redirecting</p></li>
<li><p>to an ifindex, but doesn’t require a map to do so.</p></li>
<li><p>Return</p></li>
<li><p><strong>XDP_REDIRECT</strong> on success, or the value of the two lower bits</p></li>
<li><p>of the <em>flags</em> argument on error.</p></li>
<li></li>
<li><p>long bpf_sk_redirect_map(struct sk_buff <a href="#id289"><span class="problematic" id="id290">*</span></a>skb, struct bpf_map <a href="#id291"><span class="problematic" id="id292">*</span></a>map, u32 key, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Redirect the packet to the socket referenced by <em>map</em> (of type</p></li>
<li><p><strong>BPF_MAP_TYPE_SOCKMAP</strong>) at index <em>key</em>. Both ingress and</p></li>
<li><p>egress interfaces can be used for redirection. The</p></li>
<li><p><strong>BPF_F_INGRESS</strong> value in <em>flags</em> is used to make the</p></li>
<li><p>distinction (ingress path is selected if the flag is present,</p></li>
<li><p>egress path otherwise). This is the only flag supported for now.</p></li>
<li><p>Return</p></li>
<li><p><strong>SK_PASS</strong> on success, or <strong>SK_DROP</strong> on error.</p></li>
<li></li>
<li><p>long bpf_sock_map_update(struct bpf_sock_ops <a href="#id293"><span class="problematic" id="id294">*</span></a>skops, struct bpf_map <a href="#id295"><span class="problematic" id="id296">*</span></a>map, void <a href="#id297"><span class="problematic" id="id298">*</span></a>key, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Add an entry to, or update a <em>map</em> referencing sockets. The</p></li>
<li><p><em>skops</em> is used as a new value for the entry associated to</p></li>
<li><p><em>key</em>. <em>flags</em> is one of:</p></li>
<li></li>
<li><p><strong>BPF_NOEXIST</strong></p></li>
<li><p>The entry for <em>key</em> must not exist in the map.</p></li>
<li><p><strong>BPF_EXIST</strong></p></li>
<li><p>The entry for <em>key</em> must already exist in the map.</p></li>
<li><p><strong>BPF_ANY</strong></p></li>
<li><p>No condition on the existence of the entry for <em>key</em>.</p></li>
<li></li>
<li><p>If the <em>map</em> has eBPF programs (parser and verdict), those will</p></li>
<li><p>be inherited by the socket being added. If the socket is</p></li>
<li><p>already attached to eBPF programs, this results in an error.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_xdp_adjust_meta(struct xdp_buff <a href="#id299"><span class="problematic" id="id300">*</span></a>xdp_md, int delta)</p></li>
<li><p>Description</p></li>
<li><p>Adjust the address pointed by <em>xdp_md</em><strong>-&gt;data_meta</strong> by</p></li>
<li><p><em>delta</em> (which can be positive or negative). Note that this</p></li>
<li><p>operation modifies the address stored in <em>xdp_md</em><strong>-&gt;data</strong>,</p></li>
<li><p>so the latter must be loaded only after the helper has been</p></li>
<li><p>called.</p></li>
<li></li>
<li><p>The use of <em>xdp_md</em><strong>-&gt;data_meta</strong> is optional and programs</p></li>
<li><p>are not required to use it. The rationale is that when the</p></li>
<li><p>packet is processed with XDP (e.g. as DoS filter), it is</p></li>
<li><p>possible to push further meta data along with it before passing</p></li>
<li><p>to the stack, and to give the guarantee that an ingress eBPF</p></li>
<li><p>program attached as a TC classifier on the same device can pick</p></li>
<li><p>this up for further post-processing. Since TC works with socket</p></li>
<li><p>buffers, it remains possible to set from XDP the <strong>mark</strong> or</p></li>
<li><p><strong>priority</strong> pointers, or other pointers for the socket buffer.</p></li>
<li><p>Having this scratch space generic and programmable allows for</p></li>
<li><p>more flexibility as the user is free to store whatever meta</p></li>
<li><p>data they need.</p></li>
<li></li>
<li><p>A call to this helper is susceptible to change the underlying</p></li>
<li><p>packet buffer. Therefore, at load time, all checks on pointers</p></li>
<li><p>previously done by the verifier are invalidated and must be</p></li>
<li><p>performed again, if the helper is used in combination with</p></li>
<li><p>direct packet access.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_perf_event_read_value(struct bpf_map <a href="#id301"><span class="problematic" id="id302">*</span></a>map, u64 flags, struct bpf_perf_event_value <a href="#id303"><span class="problematic" id="id304">*</span></a>buf, u32 buf_size)</p></li>
<li><p>Description</p></li>
<li><p>Read the value of a perf event counter, and store it into <em>buf</em></p></li>
<li><p>of size <em>buf_size</em>. This helper relies on a <em>map</em> of type</p></li>
<li><p><strong>BPF_MAP_TYPE_PERF_EVENT_ARRAY</strong>. The nature of the perf event</p></li>
<li><p>counter is selected when <em>map</em> is updated with perf event file</p></li>
<li><p>descriptors. The <em>map</em> is an array whose size is the number of</p></li>
<li><p>available CPUs, and each cell contains a value relative to one</p></li>
<li><p>CPU. The value to retrieve is indicated by <em>flags</em>, that</p></li>
<li><p>contains the index of the CPU to look up, masked with</p></li>
<li><p><strong>BPF_F_INDEX_MASK</strong>. Alternatively, <em>flags</em> can be set to</p></li>
<li><p><strong>BPF_F_CURRENT_CPU</strong> to indicate that the value for the</p></li>
<li><p>current CPU should be retrieved.</p></li>
<li></li>
<li><p>This helper behaves in a way close to</p></li>
<li><p><strong>bpf_perf_event_read</strong>() helper, save that instead of</p></li>
<li><p>just returning the value observed, it fills the <em>buf</em></p></li>
<li><p>structure. This allows for additional data to be retrieved: in</p></li>
<li><p>particular, the enabled and running times (in <em>buf</em></p></li>
<li><p><strong>-&gt;enabled</strong> and <em>buf</em><strong>-&gt;running</strong>, respectively) are</p></li>
<li><p>copied. In general, <strong>bpf_perf_event_read_value</strong>() is</p></li>
<li><p>recommended over <strong>bpf_perf_event_read</strong>(), which has some</p></li>
<li><p>ABI issues and provides fewer functionalities.</p></li>
<li></li>
<li><p>These values are interesting, because hardware PMU (Performance</p></li>
<li><p>Monitoring Unit) counters are limited resources. When there are</p></li>
<li><p>more PMU based perf events opened than available counters,</p></li>
<li><p>kernel will multiplex these events so each event gets certain</p></li>
<li><p>percentage (but not all) of the PMU time. In case that</p></li>
<li><p>multiplexing happens, the number of samples or counter value</p></li>
<li><p>will not reflect the case compared to when no multiplexing</p></li>
<li><p>occurs. This makes comparison between different runs difficult.</p></li>
<li><p>Typically, the counter value should be normalized before</p></li>
<li><p>comparing to other experiments. The usual normalization is done</p></li>
<li><p>as follows.</p></li>
<li></li>
<li></li>
<li></li>
<li><p>normalized_counter = counter * t_enabled / t_running</p></li>
<li></li>
<li><p>Where t_enabled is the time enabled for event and t_running is</p></li>
<li><p>the time running for event since last normalization. The</p></li>
<li><p>enabled and running times are accumulated since the perf event</p></li>
<li><p>open. To achieve scaling factor between two invocations of an</p></li>
<li><p>eBPF program, users can use CPU id as the key (which is</p></li>
<li><p>typical for perf array usage model) to remember the previous</p></li>
<li><p>value and do the calculation inside the eBPF program.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_perf_prog_read_value(struct bpf_perf_event_data <a href="#id305"><span class="problematic" id="id306">*</span></a>ctx, struct bpf_perf_event_value <a href="#id307"><span class="problematic" id="id308">*</span></a>buf, u32 buf_size)</p></li>
<li><p>Description</p></li>
<li><p>For en eBPF program attached to a perf event, retrieve the</p></li>
<li><p>value of the event counter associated to <em>ctx</em> and store it in</p></li>
<li><p>the structure pointed by <em>buf</em> and of size <em>buf_size</em>. Enabled</p></li>
<li><p>and running times are also stored in the structure (see</p></li>
<li><p>description of helper <strong>bpf_perf_event_read_value</strong>() for</p></li>
<li><p>more details).</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_getsockopt(void <a href="#id309"><span class="problematic" id="id310">*</span></a>bpf_socket, int level, int optname, void <a href="#id311"><span class="problematic" id="id312">*</span></a>optval, int optlen)</p></li>
<li><p>Description</p></li>
<li><p>Emulate a call to <strong>getsockopt()</strong> on the socket associated to</p></li>
<li><p><em>bpf_socket</em>, which must be a full socket. The <em>level</em> at</p></li>
<li><p>which the option resides and the name <em>optname</em> of the option</p></li>
<li><p>must be specified, see <strong>getsockopt(2)</strong> for more information.</p></li>
<li><p>The retrieved value is stored in the structure pointed by</p></li>
<li><p><em>opval</em> and of length <em>optlen</em>.</p></li>
<li></li>
<li><p><em>bpf_socket</em> should be one of the following:</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>struct bpf_sock_ops</strong> for <strong>BPF_PROG_TYPE_SOCK_OPS</strong>.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p><strong>struct bpf_sock_addr</strong> for <strong>BPF_CGROUP_INET4_CONNECT</strong></p></li>
</ul>
</li>
<li><p>and <strong>BPF_CGROUP_INET6_CONNECT</strong>.</p></li>
<li></li>
<li><p>This helper actually implements a subset of <strong>getsockopt()</strong>.</p></li>
<li><p>It supports the following <em>level</em>s:</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>IPPROTO_TCP</strong>, which supports <em>optname</em></p></li>
</ul>
</li>
<li><p><strong>TCP_CONGESTION</strong>.</p></li>
<li><ul class="simple">
<li><p><strong>IPPROTO_IP</strong>, which supports <em>optname</em> <strong>IP_TOS</strong>.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p><strong>IPPROTO_IPV6</strong>, which supports <em>optname</em> <strong>IPV6_TCLASS</strong>.</p></li>
</ul>
</li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_override_return(struct pt_regs <a href="#id313"><span class="problematic" id="id314">*</span></a>regs, u64 rc)</p></li>
<li><p>Description</p></li>
<li><p>Used for error injection, this helper uses kprobes to override</p></li>
<li><p>the return value of the probed function, and to set it to <em>rc</em>.</p></li>
<li><p>The first argument is the context <em>regs</em> on which the kprobe</p></li>
<li><p>works.</p></li>
<li></li>
<li><p>This helper works by setting the PC (program counter)</p></li>
<li><p>to an override function which is run in place of the original</p></li>
<li><p>probed function. This means the probed function is not run at</p></li>
<li><p>all. The replacement function just returns with the required</p></li>
<li><p>value.</p></li>
<li></li>
<li><p>This helper has security implications, and thus is subject to</p></li>
<li><p>restrictions. It is only available if the kernel was compiled</p></li>
<li><p>with the <strong>CONFIG_BPF_KPROBE_OVERRIDE</strong> configuration</p></li>
<li><p>option, and in this case it only works on functions tagged with</p></li>
<li><p><strong>ALLOW_ERROR_INJECTION</strong> in the kernel code.</p></li>
<li></li>
<li><p>Also, the helper is only available for the architectures having</p></li>
<li><p>the CONFIG_FUNCTION_ERROR_INJECTION option. As of this writing,</p></li>
<li><p>x86 architecture is the only one to support this feature.</p></li>
<li><p>Return</p></li>
<li><p>0</p></li>
<li></li>
<li><p>long bpf_sock_ops_cb_flags_set(struct bpf_sock_ops <a href="#id315"><span class="problematic" id="id316">*</span></a>bpf_sock, int argval)</p></li>
<li><p>Description</p></li>
<li><p>Attempt to set the value of the <strong>bpf_sock_ops_cb_flags</strong> field</p></li>
<li><p>for the full TCP socket associated to <em>bpf_sock_ops</em> to</p></li>
<li><p><em>argval</em>.</p></li>
<li></li>
<li><p>The primary use of this field is to determine if there should</p></li>
<li><p>be calls to eBPF programs of type</p></li>
<li><p><strong>BPF_PROG_TYPE_SOCK_OPS</strong> at various points in the TCP</p></li>
<li><p>code. A program of the same type can change its value, per</p></li>
<li><p>connection and as necessary, when the connection is</p></li>
<li><p>established. This field is directly accessible for reading, but</p></li>
<li><p>this helper must be used for updates in order to return an</p></li>
<li><p>error if an eBPF program tries to set a callback that is not</p></li>
<li><p>supported in the current kernel.</p></li>
<li></li>
<li><p><em>argval</em> is a flag array which can combine these flags:</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>BPF_SOCK_OPS_RTO_CB_FLAG</strong> (retransmission time out)</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p><strong>BPF_SOCK_OPS_RETRANS_CB_FLAG</strong> (retransmission)</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p><strong>BPF_SOCK_OPS_STATE_CB_FLAG</strong> (TCP state change)</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p><strong>BPF_SOCK_OPS_RTT_CB_FLAG</strong> (every RTT)</p></li>
</ul>
</li>
<li></li>
<li><p>Therefore, this function can be used to clear a callback flag by</p></li>
<li><p>setting the appropriate bit to zero. e.g. to disable the RTO</p></li>
<li><p>callback:</p></li>
<li></li>
<li><p><strong>bpf_sock_ops_cb_flags_set(bpf_sock,</strong></p></li>
<li><p><strong>bpf_sock-&gt;bpf_sock_ops_cb_flags &amp; ~BPF_SOCK_OPS_RTO_CB_FLAG)</strong></p></li>
<li></li>
<li><p>Here are some examples of where one could call such eBPF</p></li>
<li><p>program:</p></li>
<li></li>
<li><ul class="simple">
<li><p>When RTO fires.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p>When a packet is retransmitted.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p>When the connection terminates.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p>When a packet is sent.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p>When a packet is received.</p></li>
</ul>
</li>
<li><p>Return</p></li>
<li><p>Code <strong>-EINVAL</strong> if the socket is not a full TCP socket;</p></li>
<li><p>otherwise, a positive number containing the bits that could not</p></li>
<li><p>be set is returned (which comes down to 0 if all bits were set</p></li>
<li><p>as required).</p></li>
<li></li>
<li><p>long bpf_msg_redirect_map(struct sk_msg_buff <a href="#id317"><span class="problematic" id="id318">*</span></a>msg, struct bpf_map <a href="#id319"><span class="problematic" id="id320">*</span></a>map, u32 key, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>This helper is used in programs implementing policies at the</p></li>
<li><p>socket level. If the message <em>msg</em> is allowed to pass (i.e. if</p></li>
<li><p>the verdict eBPF program returns <strong>SK_PASS</strong>), redirect it to</p></li>
<li><p>the socket referenced by <em>map</em> (of type</p></li>
<li><p><strong>BPF_MAP_TYPE_SOCKMAP</strong>) at index <em>key</em>. Both ingress and</p></li>
<li><p>egress interfaces can be used for redirection. The</p></li>
<li><p><strong>BPF_F_INGRESS</strong> value in <em>flags</em> is used to make the</p></li>
<li><p>distinction (ingress path is selected if the flag is present,</p></li>
<li><p>egress path otherwise). This is the only flag supported for now.</p></li>
<li><p>Return</p></li>
<li><p><strong>SK_PASS</strong> on success, or <strong>SK_DROP</strong> on error.</p></li>
<li></li>
<li><p>long bpf_msg_apply_bytes(struct sk_msg_buff <a href="#id321"><span class="problematic" id="id322">*</span></a>msg, u32 bytes)</p></li>
<li><p>Description</p></li>
<li><p>For socket policies, apply the verdict of the eBPF program to</p></li>
<li><p>the next <em>bytes</em> (number of bytes) of message <em>msg</em>.</p></li>
<li></li>
<li><p>For example, this helper can be used in the following cases:</p></li>
<li></li>
<li><ul class="simple">
<li><p>A single <strong>sendmsg</strong>() or <strong>sendfile</strong>() system call</p></li>
</ul>
</li>
<li><p>contains multiple logical messages that the eBPF program is</p></li>
<li><p>supposed to read and for which it should apply a verdict.</p></li>
<li><ul class="simple">
<li><p>An eBPF program only cares to read the first <em>bytes</em> of a</p></li>
</ul>
</li>
<li><p><em>msg</em>. If the message has a large payload, then setting up</p></li>
<li><p>and calling the eBPF program repeatedly for all bytes, even</p></li>
<li><p>though the verdict is already known, would create unnecessary</p></li>
<li><p>overhead.</p></li>
<li></li>
<li><p>When called from within an eBPF program, the helper sets a</p></li>
<li><p>counter internal to the BPF infrastructure, that is used to</p></li>
<li><p>apply the last verdict to the next <em>bytes</em>. If <em>bytes</em> is</p></li>
<li><p>smaller than the current data being processed from a</p></li>
<li><p><strong>sendmsg</strong>() or <strong>sendfile</strong>() system call, the first</p></li>
<li><p><em>bytes</em> will be sent and the eBPF program will be re-run with</p></li>
<li><p>the pointer for start of data pointing to byte number <em>bytes</em></p></li>
<li><p><strong>+ 1</strong>. If <em>bytes</em> is larger than the current data being</p></li>
<li><p>processed, then the eBPF verdict will be applied to multiple</p></li>
<li><p><strong>sendmsg</strong>() or <strong>sendfile</strong>() calls until <em>bytes</em> are</p></li>
<li><p>consumed.</p></li>
<li></li>
<li><p>Note that if a socket closes with the internal counter holding</p></li>
<li><p>a non-zero value, this is not a problem because data is not</p></li>
<li><p>being buffered for <em>bytes</em> and is sent as it is received.</p></li>
<li><p>Return</p></li>
<li><p>0</p></li>
<li></li>
<li><p>long bpf_msg_cork_bytes(struct sk_msg_buff <a href="#id323"><span class="problematic" id="id324">*</span></a>msg, u32 bytes)</p></li>
<li><p>Description</p></li>
<li><p>For socket policies, prevent the execution of the verdict eBPF</p></li>
<li><p>program for message <em>msg</em> until <em>bytes</em> (byte number) have been</p></li>
<li><p>accumulated.</p></li>
<li></li>
<li><p>This can be used when one needs a specific number of bytes</p></li>
<li><p>before a verdict can be assigned, even if the data spans</p></li>
<li><p>multiple <strong>sendmsg</strong>() or <strong>sendfile</strong>() calls. The extreme</p></li>
<li><p>case would be a user calling <strong>sendmsg</strong>() repeatedly with</p></li>
<li><p>1-byte long message segments. Obviously, this is bad for</p></li>
<li><p>performance, but it is still valid. If the eBPF program needs</p></li>
<li><p><em>bytes</em> bytes to validate a header, this helper can be used to</p></li>
<li><p>prevent the eBPF program to be called again until <em>bytes</em> have</p></li>
<li><p>been accumulated.</p></li>
<li><p>Return</p></li>
<li><p>0</p></li>
<li></li>
<li><p>long bpf_msg_pull_data(struct sk_msg_buff <a href="#id325"><span class="problematic" id="id326">*</span></a>msg, u32 start, u32 end, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>For socket policies, pull in non-linear data from user space</p></li>
<li><p>for <em>msg</em> and set pointers <em>msg</em><strong>-&gt;data</strong> and <em>msg</em></p></li>
<li><p><strong>-&gt;data_end</strong> to <em>start</em> and <em>end</em> bytes offsets into <em>msg</em>,</p></li>
<li><p>respectively.</p></li>
<li></li>
<li><p>If a program of type <strong>BPF_PROG_TYPE_SK_MSG</strong> is run on a</p></li>
<li><p><em>msg</em> it can only parse data that the (<strong>data</strong>, <strong>data_end</strong>)</p></li>
<li><p>pointers have already consumed. For <strong>sendmsg</strong>() hooks this</p></li>
<li><p>is likely the first scatterlist element. But for calls relying</p></li>
<li><p>on the <strong>sendpage</strong> handler (e.g. <strong>sendfile</strong>()) this will</p></li>
<li><p>be the range (<strong>0</strong>, <strong>0</strong>) because the data is shared with</p></li>
<li><p>user space and by default the objective is to avoid allowing</p></li>
<li><p>user space to modify data while (or after) eBPF verdict is</p></li>
<li><p>being decided. This helper can be used to pull in data and to</p></li>
<li><p>set the start and end pointer to given values. Data will be</p></li>
<li><p>copied if necessary (i.e. if data was not linear and if start</p></li>
<li><p>and end pointers do not point to the same chunk).</p></li>
<li></li>
<li><p>A call to this helper is susceptible to change the underlying</p></li>
<li><p>packet buffer. Therefore, at load time, all checks on pointers</p></li>
<li><p>previously done by the verifier are invalidated and must be</p></li>
<li><p>performed again, if the helper is used in combination with</p></li>
<li><p>direct packet access.</p></li>
<li></li>
<li><p>All values for <em>flags</em> are reserved for future usage, and must</p></li>
<li><p>be left at zero.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_bind(struct bpf_sock_addr <a href="#id327"><span class="problematic" id="id328">*</span></a>ctx, struct sockaddr <a href="#id329"><span class="problematic" id="id330">*</span></a>addr, int addr_len)</p></li>
<li><p>Description</p></li>
<li><p>Bind the socket associated to <em>ctx</em> to the address pointed by</p></li>
<li><p><em>addr</em>, of length <em>addr_len</em>. This allows for making outgoing</p></li>
<li><p>connection from the desired IP address, which can be useful for</p></li>
<li><p>example when all processes inside a cgroup should use one</p></li>
<li><p>single IP address on a host that has multiple IP configured.</p></li>
<li></li>
<li><p>This helper works for IPv4 and IPv6, TCP and UDP sockets. The</p></li>
<li><p>domain (<em>addr</em><strong>-&gt;sa_family</strong>) must be <strong>AF_INET</strong> (or</p></li>
<li><p><strong>AF_INET6</strong>). It’s advised to pass zero port (<strong>sin_port</strong></p></li>
<li><p>or <strong>sin6_port</strong>) which triggers IP_BIND_ADDRESS_NO_PORT-like</p></li>
<li><p>behavior and lets the kernel efficiently pick up an unused</p></li>
<li><p>port as long as 4-tuple is unique. Passing non-zero port might</p></li>
<li><p>lead to degraded performance.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_xdp_adjust_tail(struct xdp_buff <a href="#id331"><span class="problematic" id="id332">*</span></a>xdp_md, int delta)</p></li>
<li><p>Description</p></li>
<li><p>Adjust (move) <em>xdp_md</em><strong>-&gt;data_end</strong> by <em>delta</em> bytes. It is</p></li>
<li><p>possible to both shrink and grow the packet tail.</p></li>
<li><p>Shrink done via <em>delta</em> being a negative integer.</p></li>
<li></li>
<li><p>A call to this helper is susceptible to change the underlying</p></li>
<li><p>packet buffer. Therefore, at load time, all checks on pointers</p></li>
<li><p>previously done by the verifier are invalidated and must be</p></li>
<li><p>performed again, if the helper is used in combination with</p></li>
<li><p>direct packet access.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_skb_get_xfrm_state(struct sk_buff <a href="#id333"><span class="problematic" id="id334">*</span></a>skb, u32 index, struct bpf_xfrm_state <a href="#id335"><span class="problematic" id="id336">*</span></a>xfrm_state, u32 size, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Retrieve the XFRM state (IP transform framework, see also</p></li>
<li><p><strong>ip-xfrm(8)</strong>) at <em>index</em> in XFRM “security path” for <em>skb</em>.</p></li>
<li></li>
<li><p>The retrieved value is stored in the <strong>struct bpf_xfrm_state</strong></p></li>
<li><p>pointed by <em>xfrm_state</em> and of length <em>size</em>.</p></li>
<li></li>
<li><p>All values for <em>flags</em> are reserved for future usage, and must</p></li>
<li><p>be left at zero.</p></li>
<li></li>
<li><p>This helper is available only if the kernel was compiled with</p></li>
<li><p><strong>CONFIG_XFRM</strong> configuration option.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_get_stack(void <a href="#id337"><span class="problematic" id="id338">*</span></a>ctx, void <a href="#id339"><span class="problematic" id="id340">*</span></a>buf, u32 size, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Return a user or a kernel stack in bpf program provided buffer.</p></li>
<li><p>To achieve this, the helper needs <em>ctx</em>, which is a pointer</p></li>
<li><p>to the context on which the tracing program is executed.</p></li>
<li><p>To store the stacktrace, the bpf program provides <em>buf</em> with</p></li>
<li><p>a nonnegative <em>size</em>.</p></li>
<li></li>
<li><p>The last argument, <em>flags</em>, holds the number of stack frames to</p></li>
<li><p>skip (from 0 to 255), masked with</p></li>
<li><p><strong>BPF_F_SKIP_FIELD_MASK</strong>. The next bits can be used to set</p></li>
<li><p>the following flags:</p></li>
<li></li>
<li><p><strong>BPF_F_USER_STACK</strong></p></li>
<li><p>Collect a user space stack instead of a kernel stack.</p></li>
<li><p><strong>BPF_F_USER_BUILD_ID</strong></p></li>
<li><p>Collect buildid+offset instead of ips for user stack,</p></li>
<li><p>only valid if <strong>BPF_F_USER_STACK</strong> is also specified.</p></li>
<li></li>
<li><p><strong>bpf_get_stack</strong>() can collect up to</p></li>
<li><p><strong>PERF_MAX_STACK_DEPTH</strong> both kernel and user frames, subject</p></li>
<li><p>to sufficient large buffer size. Note that</p></li>
<li><p>this limit can be controlled with the <strong>sysctl</strong> program, and</p></li>
<li><p>that it should be manually increased in order to profile long</p></li>
<li><p>user stacks (such as stacks for Java programs). To do so, use:</p></li>
<li></li>
<li></li>
<li></li>
<li><p># sysctl kernel.perf_event_max_stack=&lt;new value&gt;</p></li>
<li><p>Return</p></li>
<li><p>A non-negative value equal to or less than <em>size</em> on success,</p></li>
<li><p>or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_skb_load_bytes_relative(const void <a href="#id341"><span class="problematic" id="id342">*</span></a>skb, u32 offset, void <a href="#id343"><span class="problematic" id="id344">*</span></a>to, u32 len, u32 start_header)</p></li>
<li><p>Description</p></li>
<li><p>This helper is similar to <strong>bpf_skb_load_bytes</strong>() in that</p></li>
<li><p>it provides an easy way to load <em>len</em> bytes from <em>offset</em></p></li>
<li><p>from the packet associated to <em>skb</em>, into the buffer pointed</p></li>
<li><p>by <em>to</em>. The difference to <strong>bpf_skb_load_bytes</strong>() is that</p></li>
<li><p>a fifth argument <em>start_header</em> exists in order to select a</p></li>
<li><p>base offset to start from. <em>start_header</em> can be one of:</p></li>
<li></li>
<li><p><strong>BPF_HDR_START_MAC</strong></p></li>
<li><p>Base offset to load data from is <em>skb</em>’s mac header.</p></li>
<li><p><strong>BPF_HDR_START_NET</strong></p></li>
<li><p>Base offset to load data from is <em>skb</em>’s network header.</p></li>
<li></li>
<li><p>In general, “direct packet access” is the preferred method to</p></li>
<li><p>access packet data, however, this helper is in particular useful</p></li>
<li><p>in socket filters where <em>skb</em><strong>-&gt;data</strong> does not always point</p></li>
<li><p>to the start of the mac header and where “direct packet access”</p></li>
<li><p>is not available.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_fib_lookup(void <a href="#id345"><span class="problematic" id="id346">*</span></a>ctx, struct bpf_fib_lookup <a href="#id347"><span class="problematic" id="id348">*</span></a>params, int plen, u32 flags)</p></li>
<li><p>Description</p></li>
<li><p>Do FIB lookup in kernel tables using parameters in <em>params</em>.</p></li>
<li><p>If lookup is successful and result shows packet is to be</p></li>
<li><p>forwarded, the neighbor tables are searched for the nexthop.</p></li>
<li><p>If successful (ie., FIB lookup shows forwarding and nexthop</p></li>
<li><p>is resolved), the nexthop address is returned in ipv4_dst</p></li>
<li><p>or ipv6_dst based on family, smac is set to mac address of</p></li>
<li><p>egress device, dmac is set to nexthop mac address, rt_metric</p></li>
<li><p>is set to metric from route (IPv4/IPv6 only), and ifindex</p></li>
<li><p>is set to the device index of the nexthop from the FIB lookup.</p></li>
<li></li>
<li><p><em>plen</em> argument is the size of the passed in struct.</p></li>
<li><p><em>flags</em> argument can be a combination of one or more of the</p></li>
<li><p>following values:</p></li>
<li></li>
<li><p><strong>BPF_FIB_LOOKUP_DIRECT</strong></p></li>
<li><p>Do a direct table lookup vs full lookup using FIB</p></li>
<li><p>rules.</p></li>
<li><p><strong>BPF_FIB_LOOKUP_OUTPUT</strong></p></li>
<li><p>Perform lookup from an egress perspective (default is</p></li>
<li><p>ingress).</p></li>
<li></li>
<li><p><em>ctx</em> is either <strong>struct xdp_md</strong> for XDP programs or</p></li>
<li><p><strong>struct sk_buff</strong> tc cls_act programs.</p></li>
<li><p>Return</p></li>
<li><ul class="simple">
<li><p>&lt; 0 if any input argument is invalid</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p>0 on success (packet is forwarded, nexthop neighbor exists)</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p>&gt; 0 one of <strong>BPF_FIB_LKUP_RET_</strong> codes explaining why the</p></li>
</ul>
</li>
<li><p>packet is not forwarded or needs assist from full stack</p></li>
<li></li>
<li><p>If lookup fails with BPF_FIB_LKUP_RET_FRAG_NEEDED, then the MTU</p></li>
<li><p>was exceeded and output params-&gt;mtu_result contains the MTU.</p></li>
<li></li>
<li><p>long bpf_sock_hash_update(struct bpf_sock_ops <a href="#id349"><span class="problematic" id="id350">*</span></a>skops, struct bpf_map <a href="#id351"><span class="problematic" id="id352">*</span></a>map, void <a href="#id353"><span class="problematic" id="id354">*</span></a>key, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Add an entry to, or update a sockhash <em>map</em> referencing sockets.</p></li>
<li><p>The <em>skops</em> is used as a new value for the entry associated to</p></li>
<li><p><em>key</em>. <em>flags</em> is one of:</p></li>
<li></li>
<li><p><strong>BPF_NOEXIST</strong></p></li>
<li><p>The entry for <em>key</em> must not exist in the map.</p></li>
<li><p><strong>BPF_EXIST</strong></p></li>
<li><p>The entry for <em>key</em> must already exist in the map.</p></li>
<li><p><strong>BPF_ANY</strong></p></li>
<li><p>No condition on the existence of the entry for <em>key</em>.</p></li>
<li></li>
<li><p>If the <em>map</em> has eBPF programs (parser and verdict), those will</p></li>
<li><p>be inherited by the socket being added. If the socket is</p></li>
<li><p>already attached to eBPF programs, this results in an error.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_msg_redirect_hash(struct sk_msg_buff <a href="#id355"><span class="problematic" id="id356">*</span></a>msg, struct bpf_map <a href="#id357"><span class="problematic" id="id358">*</span></a>map, void <a href="#id359"><span class="problematic" id="id360">*</span></a>key, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>This helper is used in programs implementing policies at the</p></li>
<li><p>socket level. If the message <em>msg</em> is allowed to pass (i.e. if</p></li>
<li><p>the verdict eBPF program returns <strong>SK_PASS</strong>), redirect it to</p></li>
<li><p>the socket referenced by <em>map</em> (of type</p></li>
<li><p><strong>BPF_MAP_TYPE_SOCKHASH</strong>) using hash <em>key</em>. Both ingress and</p></li>
<li><p>egress interfaces can be used for redirection. The</p></li>
<li><p><strong>BPF_F_INGRESS</strong> value in <em>flags</em> is used to make the</p></li>
<li><p>distinction (ingress path is selected if the flag is present,</p></li>
<li><p>egress path otherwise). This is the only flag supported for now.</p></li>
<li><p>Return</p></li>
<li><p><strong>SK_PASS</strong> on success, or <strong>SK_DROP</strong> on error.</p></li>
<li></li>
<li><p>long bpf_sk_redirect_hash(struct sk_buff <a href="#id361"><span class="problematic" id="id362">*</span></a>skb, struct bpf_map <a href="#id363"><span class="problematic" id="id364">*</span></a>map, void <a href="#id365"><span class="problematic" id="id366">*</span></a>key, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>This helper is used in programs implementing policies at the</p></li>
<li><p>skb socket level. If the sk_buff <em>skb</em> is allowed to pass (i.e.</p></li>
<li><p>if the verdict eBPF program returns <strong>SK_PASS</strong>), redirect it</p></li>
<li><p>to the socket referenced by <em>map</em> (of type</p></li>
<li><p><strong>BPF_MAP_TYPE_SOCKHASH</strong>) using hash <em>key</em>. Both ingress and</p></li>
<li><p>egress interfaces can be used for redirection. The</p></li>
<li><p><strong>BPF_F_INGRESS</strong> value in <em>flags</em> is used to make the</p></li>
<li><p>distinction (ingress path is selected if the flag is present,</p></li>
<li><p>egress otherwise). This is the only flag supported for now.</p></li>
<li><p>Return</p></li>
<li><p><strong>SK_PASS</strong> on success, or <strong>SK_DROP</strong> on error.</p></li>
<li></li>
<li><p>long bpf_lwt_push_encap(struct sk_buff <a href="#id367"><span class="problematic" id="id368">*</span></a>skb, u32 type, void <a href="#id369"><span class="problematic" id="id370">*</span></a>hdr, u32 len)</p></li>
<li><p>Description</p></li>
<li><p>Encapsulate the packet associated to <em>skb</em> within a Layer 3</p></li>
<li><p>protocol header. This header is provided in the buffer at</p></li>
<li><p>address <em>hdr</em>, with <em>len</em> its size in bytes. <em>type</em> indicates</p></li>
<li><p>the protocol of the header and can be one of:</p></li>
<li></li>
<li><p><strong>BPF_LWT_ENCAP_SEG6</strong></p></li>
<li><p>IPv6 encapsulation with Segment Routing Header</p></li>
<li><p>(<strong>struct ipv6_sr_hdr</strong>). <em>hdr</em> only contains the SRH,</p></li>
<li><p>the IPv6 header is computed by the kernel.</p></li>
<li><p><strong>BPF_LWT_ENCAP_SEG6_INLINE</strong></p></li>
<li><p>Only works if <em>skb</em> contains an IPv6 packet. Insert a</p></li>
<li><p>Segment Routing Header (<strong>struct ipv6_sr_hdr</strong>) inside</p></li>
<li><p>the IPv6 header.</p></li>
<li><p><strong>BPF_LWT_ENCAP_IP</strong></p></li>
<li><p>IP encapsulation (GRE/GUE/IPIP/etc). The outer header</p></li>
<li><p>must be IPv4 or IPv6, followed by zero or more</p></li>
<li><p>additional headers, up to <strong>LWT_BPF_MAX_HEADROOM</strong></p></li>
<li><p>total bytes in all prepended headers. Please note that</p></li>
<li><p>if <strong>skb_is_gso</strong>(<em>skb</em>) is true, no more than two</p></li>
<li><p>headers can be prepended, and the inner header, if</p></li>
<li><p>present, should be either GRE or UDP/GUE.</p></li>
<li></li>
<li><p><strong>BPF_LWT_ENCAP_SEG6</strong>* types can be called by BPF programs</p></li>
<li><p>of type <strong>BPF_PROG_TYPE_LWT_IN</strong>; <strong>BPF_LWT_ENCAP_IP</strong> type can</p></li>
<li><p>be called by bpf programs of types <strong>BPF_PROG_TYPE_LWT_IN</strong> and</p></li>
<li><p><strong>BPF_PROG_TYPE_LWT_XMIT</strong>.</p></li>
<li></li>
<li><p>A call to this helper is susceptible to change the underlying</p></li>
<li><p>packet buffer. Therefore, at load time, all checks on pointers</p></li>
<li><p>previously done by the verifier are invalidated and must be</p></li>
<li><p>performed again, if the helper is used in combination with</p></li>
<li><p>direct packet access.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_lwt_seg6_store_bytes(struct sk_buff <a href="#id371"><span class="problematic" id="id372">*</span></a>skb, u32 offset, const void <a href="#id373"><span class="problematic" id="id374">*</span></a>from, u32 len)</p></li>
<li><p>Description</p></li>
<li><p>Store <em>len</em> bytes from address <em>from</em> into the packet</p></li>
<li><p>associated to <em>skb</em>, at <em>offset</em>. Only the flags, tag and TLVs</p></li>
<li><p>inside the outermost IPv6 Segment Routing Header can be</p></li>
<li><p>modified through this helper.</p></li>
<li></li>
<li><p>A call to this helper is susceptible to change the underlying</p></li>
<li><p>packet buffer. Therefore, at load time, all checks on pointers</p></li>
<li><p>previously done by the verifier are invalidated and must be</p></li>
<li><p>performed again, if the helper is used in combination with</p></li>
<li><p>direct packet access.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_lwt_seg6_adjust_srh(struct sk_buff <a href="#id375"><span class="problematic" id="id376">*</span></a>skb, u32 offset, s32 delta)</p></li>
<li><p>Description</p></li>
<li><p>Adjust the size allocated to TLVs in the outermost IPv6</p></li>
<li><p>Segment Routing Header contained in the packet associated to</p></li>
<li><p><em>skb</em>, at position <em>offset</em> by <em>delta</em> bytes. Only offsets</p></li>
<li><p>after the segments are accepted. <em>delta</em> can be as well</p></li>
<li><p>positive (growing) as negative (shrinking).</p></li>
<li></li>
<li><p>A call to this helper is susceptible to change the underlying</p></li>
<li><p>packet buffer. Therefore, at load time, all checks on pointers</p></li>
<li><p>previously done by the verifier are invalidated and must be</p></li>
<li><p>performed again, if the helper is used in combination with</p></li>
<li><p>direct packet access.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_lwt_seg6_action(struct sk_buff <a href="#id377"><span class="problematic" id="id378">*</span></a>skb, u32 action, void <a href="#id379"><span class="problematic" id="id380">*</span></a>param, u32 param_len)</p></li>
<li><p>Description</p></li>
<li><p>Apply an IPv6 Segment Routing action of type <em>action</em> to the</p></li>
<li><p>packet associated to <em>skb</em>. Each action takes a parameter</p></li>
<li><p>contained at address <em>param</em>, and of length <em>param_len</em> bytes.</p></li>
<li><p><em>action</em> can be one of:</p></li>
<li></li>
<li><p><strong>SEG6_LOCAL_ACTION_END_X</strong></p></li>
<li><p>End.X action: Endpoint with Layer-3 cross-connect.</p></li>
<li><p>Type of <em>param</em>: <strong>struct in6_addr</strong>.</p></li>
<li><p><strong>SEG6_LOCAL_ACTION_END_T</strong></p></li>
<li><p>End.T action: Endpoint with specific IPv6 table lookup.</p></li>
<li><p>Type of <em>param</em>: <strong>int</strong>.</p></li>
<li><p><strong>SEG6_LOCAL_ACTION_END_B6</strong></p></li>
<li><p>End.B6 action: Endpoint bound to an SRv6 policy.</p></li>
<li><p>Type of <em>param</em>: <strong>struct ipv6_sr_hdr</strong>.</p></li>
<li><p><strong>SEG6_LOCAL_ACTION_END_B6_ENCAP</strong></p></li>
<li><p>End.B6.Encap action: Endpoint bound to an SRv6</p></li>
<li><p>encapsulation policy.</p></li>
<li><p>Type of <em>param</em>: <strong>struct ipv6_sr_hdr</strong>.</p></li>
<li></li>
<li><p>A call to this helper is susceptible to change the underlying</p></li>
<li><p>packet buffer. Therefore, at load time, all checks on pointers</p></li>
<li><p>previously done by the verifier are invalidated and must be</p></li>
<li><p>performed again, if the helper is used in combination with</p></li>
<li><p>direct packet access.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_rc_repeat(void <a href="#id381"><span class="problematic" id="id382">*</span></a>ctx)</p></li>
<li><p>Description</p></li>
<li><p>This helper is used in programs implementing IR decoding, to</p></li>
<li><p>report a successfully decoded repeat key message. This delays</p></li>
<li><p>the generation of a key up event for previously generated</p></li>
<li><p>key down event.</p></li>
<li></li>
<li><p>Some IR protocols like NEC have a special IR message for</p></li>
<li><p>repeating last button, for when a button is held down.</p></li>
<li></li>
<li><p>The <em>ctx</em> should point to the lirc sample as passed into</p></li>
<li><p>the program.</p></li>
<li></li>
<li><p>This helper is only available is the kernel was compiled with</p></li>
<li><p>the <strong>CONFIG_BPF_LIRC_MODE2</strong> configuration option set to</p></li>
<li><p>“<strong>y</strong>”.</p></li>
<li><p>Return</p></li>
<li><p>0</p></li>
<li></li>
<li><p>long bpf_rc_keydown(void <a href="#id383"><span class="problematic" id="id384">*</span></a>ctx, u32 protocol, u64 scancode, u32 toggle)</p></li>
<li><p>Description</p></li>
<li><p>This helper is used in programs implementing IR decoding, to</p></li>
<li><p>report a successfully decoded key press with <em>scancode</em>,</p></li>
<li><p><em>toggle</em> value in the given <em>protocol</em>. The scancode will be</p></li>
<li><p>translated to a keycode using the rc keymap, and reported as</p></li>
<li><p>an input key down event. After a period a key up event is</p></li>
<li><p>generated. This period can be extended by calling either</p></li>
<li><p><strong>bpf_rc_keydown</strong>() again with the same values, or calling</p></li>
<li><p><strong>bpf_rc_repeat</strong>().</p></li>
<li></li>
<li><p>Some protocols include a toggle bit, in case the button was</p></li>
<li><p>released and pressed again between consecutive scancodes.</p></li>
<li></li>
<li><p>The <em>ctx</em> should point to the lirc sample as passed into</p></li>
<li><p>the program.</p></li>
<li></li>
<li><p>The <em>protocol</em> is the decoded protocol number (see</p></li>
<li><p><strong>enum rc_proto</strong> for some predefined values).</p></li>
<li></li>
<li><p>This helper is only available is the kernel was compiled with</p></li>
<li><p>the <strong>CONFIG_BPF_LIRC_MODE2</strong> configuration option set to</p></li>
<li><p>“<strong>y</strong>”.</p></li>
<li><p>Return</p></li>
<li><p>0</p></li>
<li></li>
<li><p>u64 bpf_skb_cgroup_id(struct sk_buff <a href="#id385"><span class="problematic" id="id386">*</span></a>skb)</p></li>
<li><p>Description</p></li>
<li><p>Return the cgroup v2 id of the socket associated with the <em>skb</em>.</p></li>
<li><p>This is roughly similar to the <strong>bpf_get_cgroup_classid</strong>()</p></li>
<li><p>helper for cgroup v1 by providing a tag resp. identifier that</p></li>
<li><p>can be matched on or used for map lookups e.g. to implement</p></li>
<li><p>policy. The cgroup v2 id of a given path in the hierarchy is</p></li>
<li><p>exposed in user space through the f_handle API in order to get</p></li>
<li><p>to the same 64-bit id.</p></li>
<li></li>
<li><p>This helper can be used on TC egress path, but not on ingress,</p></li>
<li><p>and is available only if the kernel was compiled with the</p></li>
<li><p><strong>CONFIG_SOCK_CGROUP_DATA</strong> configuration option.</p></li>
<li><p>Return</p></li>
<li><p>The id is returned or 0 in case the id could not be retrieved.</p></li>
<li></li>
<li><p>u64 bpf_get_current_cgroup_id(void)</p></li>
<li><p>Return</p></li>
<li><p>A 64-bit integer containing the current cgroup id based</p></li>
<li><p>on the cgroup within which the current task is running.</p></li>
<li></li>
<li><p>void <a href="#id387"><span class="problematic" id="id388">*</span></a>bpf_get_local_storage(void <a href="#id389"><span class="problematic" id="id390">*</span></a>map, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Get the pointer to the local storage area.</p></li>
<li><p>The type and the size of the local storage is defined</p></li>
<li><p>by the <em>map</em> argument.</p></li>
<li><p>The <em>flags</em> meaning is specific for each map type,</p></li>
<li><p>and has to be 0 for cgroup local storage.</p></li>
<li></li>
<li><p>Depending on the BPF program type, a local storage area</p></li>
<li><p>can be shared between multiple instances of the BPF program,</p></li>
<li><p>running simultaneously.</p></li>
<li></li>
<li><p>A user should care about the synchronization by himself.</p></li>
<li><p>For example, by using the <strong>BPF_ATOMIC</strong> instructions to alter</p></li>
<li><p>the shared data.</p></li>
<li><p>Return</p></li>
<li><p>A pointer to the local storage area.</p></li>
<li></li>
<li><p>long bpf_sk_select_reuseport(struct sk_reuseport_md <a href="#id391"><span class="problematic" id="id392">*</span></a>reuse, struct bpf_map <a href="#id393"><span class="problematic" id="id394">*</span></a>map, void <a href="#id395"><span class="problematic" id="id396">*</span></a>key, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Select a <strong>SO_REUSEPORT</strong> socket from a</p></li>
<li><p><strong>BPF_MAP_TYPE_REUSEPORT_SOCKARRAY</strong> <em>map</em>.</p></li>
<li><p>It checks the selected socket is matching the incoming</p></li>
<li><p>request in the socket buffer.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>u64 bpf_skb_ancestor_cgroup_id(struct sk_buff <a href="#id397"><span class="problematic" id="id398">*</span></a>skb, int ancestor_level)</p></li>
<li><p>Description</p></li>
<li><p>Return id of cgroup v2 that is ancestor of cgroup associated</p></li>
<li><p>with the <em>skb</em> at the <em>ancestor_level</em>.  The root cgroup is at</p></li>
<li><p><em>ancestor_level</em> zero and each step down the hierarchy</p></li>
<li><p>increments the level. If <em>ancestor_level</em> == level of cgroup</p></li>
<li><p>associated with <em>skb</em>, then return value will be same as that</p></li>
<li><p>of <strong>bpf_skb_cgroup_id</strong>().</p></li>
<li></li>
<li><p>The helper is useful to implement policies based on cgroups</p></li>
<li><p>that are upper in hierarchy than immediate cgroup associated</p></li>
<li><p>with <em>skb</em>.</p></li>
<li></li>
<li><p>The format of returned id and helper limitations are same as in</p></li>
<li><p><strong>bpf_skb_cgroup_id</strong>().</p></li>
<li><p>Return</p></li>
<li><p>The id is returned or 0 in case the id could not be retrieved.</p></li>
<li></li>
<li><p>struct bpf_sock <a href="#id399"><span class="problematic" id="id400">*</span></a>bpf_sk_lookup_tcp(void <a href="#id401"><span class="problematic" id="id402">*</span></a>ctx, struct bpf_sock_tuple <a href="#id403"><span class="problematic" id="id404">*</span></a>tuple, u32 tuple_size, u64 netns, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Look for TCP socket matching <em>tuple</em>, optionally in a child</p></li>
<li><p>network namespace <em>netns</em>. The return value must be checked,</p></li>
<li><p>and if non-<strong>NULL</strong>, released via <strong>bpf_sk_release</strong>().</p></li>
<li></li>
<li><p>The <em>ctx</em> should point to the context of the program, such as</p></li>
<li><p>the skb or socket (depending on the hook in use). This is used</p></li>
<li><p>to determine the base network namespace for the lookup.</p></li>
<li></li>
<li><p><em>tuple_size</em> must be one of:</p></li>
<li></li>
<li><p><strong>sizeof</strong>(<em>tuple</em><strong>-&gt;ipv4</strong>)</p></li>
<li><p>Look for an IPv4 socket.</p></li>
<li><p><strong>sizeof</strong>(<em>tuple</em><strong>-&gt;ipv6</strong>)</p></li>
<li><p>Look for an IPv6 socket.</p></li>
<li></li>
<li><p>If the <em>netns</em> is a negative signed 32-bit integer, then the</p></li>
<li><p>socket lookup table in the netns associated with the <em>ctx</em></p></li>
<li><p>will be used. For the TC hooks, this is the netns of the device</p></li>
<li><p>in the skb. For socket hooks, this is the netns of the socket.</p></li>
<li><p>If <em>netns</em> is any other signed 32-bit value greater than or</p></li>
<li><p>equal to zero then it specifies the ID of the netns relative to</p></li>
<li><p>the netns associated with the <em>ctx</em>. <em>netns</em> values beyond the</p></li>
<li><p>range of 32-bit integers are reserved for future use.</p></li>
<li></li>
<li><p>All values for <em>flags</em> are reserved for future usage, and must</p></li>
<li><p>be left at zero.</p></li>
<li></li>
<li><p>This helper is available only if the kernel was compiled with</p></li>
<li><p><strong>CONFIG_NET</strong> configuration option.</p></li>
<li><p>Return</p></li>
<li><p>Pointer to <strong>struct bpf_sock</strong>, or <strong>NULL</strong> in case of failure.</p></li>
<li><p>For sockets with reuseport option, the <strong>struct bpf_sock</strong></p></li>
<li><p>result is from <em>reuse</em><strong>-&gt;socks</strong>[] using the hash of the</p></li>
<li><p>tuple.</p></li>
<li></li>
<li><p>struct bpf_sock <a href="#id405"><span class="problematic" id="id406">*</span></a>bpf_sk_lookup_udp(void <a href="#id407"><span class="problematic" id="id408">*</span></a>ctx, struct bpf_sock_tuple <a href="#id409"><span class="problematic" id="id410">*</span></a>tuple, u32 tuple_size, u64 netns, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Look for UDP socket matching <em>tuple</em>, optionally in a child</p></li>
<li><p>network namespace <em>netns</em>. The return value must be checked,</p></li>
<li><p>and if non-<strong>NULL</strong>, released via <strong>bpf_sk_release</strong>().</p></li>
<li></li>
<li><p>The <em>ctx</em> should point to the context of the program, such as</p></li>
<li><p>the skb or socket (depending on the hook in use). This is used</p></li>
<li><p>to determine the base network namespace for the lookup.</p></li>
<li></li>
<li><p><em>tuple_size</em> must be one of:</p></li>
<li></li>
<li><p><strong>sizeof</strong>(<em>tuple</em><strong>-&gt;ipv4</strong>)</p></li>
<li><p>Look for an IPv4 socket.</p></li>
<li><p><strong>sizeof</strong>(<em>tuple</em><strong>-&gt;ipv6</strong>)</p></li>
<li><p>Look for an IPv6 socket.</p></li>
<li></li>
<li><p>If the <em>netns</em> is a negative signed 32-bit integer, then the</p></li>
<li><p>socket lookup table in the netns associated with the <em>ctx</em></p></li>
<li><p>will be used. For the TC hooks, this is the netns of the device</p></li>
<li><p>in the skb. For socket hooks, this is the netns of the socket.</p></li>
<li><p>If <em>netns</em> is any other signed 32-bit value greater than or</p></li>
<li><p>equal to zero then it specifies the ID of the netns relative to</p></li>
<li><p>the netns associated with the <em>ctx</em>. <em>netns</em> values beyond the</p></li>
<li><p>range of 32-bit integers are reserved for future use.</p></li>
<li></li>
<li><p>All values for <em>flags</em> are reserved for future usage, and must</p></li>
<li><p>be left at zero.</p></li>
<li></li>
<li><p>This helper is available only if the kernel was compiled with</p></li>
<li><p><strong>CONFIG_NET</strong> configuration option.</p></li>
<li><p>Return</p></li>
<li><p>Pointer to <strong>struct bpf_sock</strong>, or <strong>NULL</strong> in case of failure.</p></li>
<li><p>For sockets with reuseport option, the <strong>struct bpf_sock</strong></p></li>
<li><p>result is from <em>reuse</em><strong>-&gt;socks</strong>[] using the hash of the</p></li>
<li><p>tuple.</p></li>
<li></li>
<li><p>long bpf_sk_release(void <a href="#id411"><span class="problematic" id="id412">*</span></a>sock)</p></li>
<li><p>Description</p></li>
<li><p>Release the reference held by <em>sock</em>. <em>sock</em> must be a</p></li>
<li><p>non-<strong>NULL</strong> pointer that was returned from</p></li>
<li><p><strong>bpf_sk_lookup_xxx</strong>().</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_map_push_elem(struct bpf_map <a href="#id413"><span class="problematic" id="id414">*</span></a>map, const void <a href="#id415"><span class="problematic" id="id416">*</span></a>value, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Push an element <em>value</em> in <em>map</em>. <em>flags</em> is one of:</p></li>
<li></li>
<li><p><strong>BPF_EXIST</strong></p></li>
<li><p>If the queue/stack is full, the oldest element is</p></li>
<li><p>removed to make room for this.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_map_pop_elem(struct bpf_map <a href="#id417"><span class="problematic" id="id418">*</span></a>map, void <a href="#id419"><span class="problematic" id="id420">*</span></a>value)</p></li>
<li><p>Description</p></li>
<li><p>Pop an element from <em>map</em>.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_map_peek_elem(struct bpf_map <a href="#id421"><span class="problematic" id="id422">*</span></a>map, void <a href="#id423"><span class="problematic" id="id424">*</span></a>value)</p></li>
<li><p>Description</p></li>
<li><p>Get an element from <em>map</em> without removing it.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_msg_push_data(struct sk_msg_buff <a href="#id425"><span class="problematic" id="id426">*</span></a>msg, u32 start, u32 len, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>For socket policies, insert <em>len</em> bytes into <em>msg</em> at offset</p></li>
<li><p><em>start</em>.</p></li>
<li></li>
<li><p>If a program of type <strong>BPF_PROG_TYPE_SK_MSG</strong> is run on a</p></li>
<li><p><em>msg</em> it may want to insert metadata or options into the <em>msg</em>.</p></li>
<li><p>This can later be read and used by any of the lower layer BPF</p></li>
<li><p>hooks.</p></li>
<li></li>
<li><p>This helper may fail if under memory pressure (a malloc</p></li>
<li><p>fails) in these cases BPF programs will get an appropriate</p></li>
<li><p>error and BPF programs will need to handle them.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_msg_pop_data(struct sk_msg_buff <a href="#id427"><span class="problematic" id="id428">*</span></a>msg, u32 start, u32 len, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Will remove <em>len</em> bytes from a <em>msg</em> starting at byte <em>start</em>.</p></li>
<li><p>This may result in <strong>ENOMEM</strong> errors under certain situations if</p></li>
<li><p>an allocation and copy are required due to a full ring buffer.</p></li>
<li><p>However, the helper will try to avoid doing the allocation</p></li>
<li><p>if possible. Other errors can occur if input parameters are</p></li>
<li><p>invalid either due to <em>start</em> byte not being valid part of <em>msg</em></p></li>
<li><p>payload and/or <em>pop</em> value being to large.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_rc_pointer_rel(void <a href="#id429"><span class="problematic" id="id430">*</span></a>ctx, s32 rel_x, s32 rel_y)</p></li>
<li><p>Description</p></li>
<li><p>This helper is used in programs implementing IR decoding, to</p></li>
<li><p>report a successfully decoded pointer movement.</p></li>
<li></li>
<li><p>The <em>ctx</em> should point to the lirc sample as passed into</p></li>
<li><p>the program.</p></li>
<li></li>
<li><p>This helper is only available is the kernel was compiled with</p></li>
<li><p>the <strong>CONFIG_BPF_LIRC_MODE2</strong> configuration option set to</p></li>
<li><p>“<strong>y</strong>”.</p></li>
<li><p>Return</p></li>
<li><p>0</p></li>
<li></li>
<li><p>long bpf_spin_lock(struct bpf_spin_lock <a href="#id431"><span class="problematic" id="id432">*</span></a>lock)</p></li>
<li><p>Description</p></li>
<li><p>Acquire a spinlock represented by the pointer <em>lock</em>, which is</p></li>
<li><p>stored as part of a value of a map. Taking the lock allows to</p></li>
<li><p>safely update the rest of the fields in that value. The</p></li>
<li><p>spinlock can (and must) later be released with a call to</p></li>
<li><p><strong>bpf_spin_unlock</strong>(<em>lock</em>).</p></li>
<li></li>
<li><p>Spinlocks in BPF programs come with a number of restrictions</p></li>
<li><p>and constraints:</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>bpf_spin_lock</strong> objects are only allowed inside maps of</p></li>
</ul>
</li>
<li><p>types <strong>BPF_MAP_TYPE_HASH</strong> and <strong>BPF_MAP_TYPE_ARRAY</strong> (this</p></li>
<li><p>list could be extended in the future).</p></li>
<li><ul class="simple">
<li><p>BTF description of the map is mandatory.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p>The BPF program can take ONE lock at a time, since taking two</p></li>
</ul>
</li>
<li><p>or more could cause dead locks.</p></li>
<li><ul class="simple">
<li><p>Only one <strong>struct bpf_spin_lock</strong> is allowed per map element.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p>When the lock is taken, calls (either BPF to BPF or helpers)</p></li>
</ul>
</li>
<li><p>are not allowed.</p></li>
<li><ul class="simple">
<li><p>The <strong>BPF_LD_ABS</strong> and <strong>BPF_LD_IND</strong> instructions are not</p></li>
</ul>
</li>
<li><p>allowed inside a spinlock-ed region.</p></li>
<li><ul class="simple">
<li><p>The BPF program MUST call <strong>bpf_spin_unlock</strong>() to release</p></li>
</ul>
</li>
<li><p>the lock, on all execution paths, before it returns.</p></li>
<li><ul class="simple">
<li><p>The BPF program can access <strong>struct bpf_spin_lock</strong> only via</p></li>
</ul>
</li>
<li><p>the <strong>bpf_spin_lock</strong>() and <strong>bpf_spin_unlock</strong>()</p></li>
<li><p>helpers. Loading or storing data into the <a href="#id433"><span class="problematic" id="id434">**</span></a>struct</p></li>
<li><p>bpf_spin_lock** <em>lock</em><strong>;</strong> field of a map is not allowed.</p></li>
<li><ul class="simple">
<li><p>To use the <strong>bpf_spin_lock</strong>() helper, the BTF description</p></li>
</ul>
</li>
<li><p>of the map value must be a struct and have <a href="#id435"><span class="problematic" id="id436">**</span></a>struct</p></li>
<li><p>bpf_spin_lock** <em>anyname</em><strong>;</strong> field at the top level.</p></li>
<li><p>Nested lock inside another struct is not allowed.</p></li>
<li><ul class="simple">
<li><p>The <strong>struct bpf_spin_lock</strong> <em>lock</em> field in a map value must</p></li>
</ul>
</li>
<li><p>be aligned on a multiple of 4 bytes in that value.</p></li>
<li><ul class="simple">
<li><p>Syscall with command <strong>BPF_MAP_LOOKUP_ELEM</strong> does not copy</p></li>
</ul>
</li>
<li><p>the <strong>bpf_spin_lock</strong> field to user space.</p></li>
<li><ul class="simple">
<li><p>Syscall with command <strong>BPF_MAP_UPDATE_ELEM</strong>, or update from</p></li>
</ul>
</li>
<li><p>a BPF program, do not update the <strong>bpf_spin_lock</strong> field.</p></li>
<li><ul class="simple">
<li><p><strong>bpf_spin_lock</strong> cannot be on the stack or inside a</p></li>
</ul>
</li>
<li><p>networking packet (it can only be inside of a map values).</p></li>
<li><ul class="simple">
<li><p><strong>bpf_spin_lock</strong> is available to root only.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p>Tracing programs and socket filter programs cannot use</p></li>
</ul>
</li>
<li><p><strong>bpf_spin_lock</strong>() due to insufficient preemption checks</p></li>
<li><p>(but this may change in the future).</p></li>
<li><ul class="simple">
<li><p><strong>bpf_spin_lock</strong> is not allowed in inner maps of map-in-map.</p></li>
</ul>
</li>
<li><p>Return</p></li>
<li><p>0</p></li>
<li></li>
<li><p>long bpf_spin_unlock(struct bpf_spin_lock <a href="#id437"><span class="problematic" id="id438">*</span></a>lock)</p></li>
<li><p>Description</p></li>
<li><p>Release the <em>lock</em> previously locked by a call to</p></li>
<li><p><strong>bpf_spin_lock</strong>(<em>lock</em>).</p></li>
<li><p>Return</p></li>
<li><p>0</p></li>
<li></li>
<li><p>struct bpf_sock <a href="#id439"><span class="problematic" id="id440">*</span></a>bpf_sk_fullsock(struct bpf_sock <a href="#id441"><span class="problematic" id="id442">*</span></a>sk)</p></li>
<li><p>Description</p></li>
<li><p>This helper gets a <strong>struct bpf_sock</strong> pointer such</p></li>
<li><p>that all the fields in this <strong>bpf_sock</strong> can be accessed.</p></li>
<li><p>Return</p></li>
<li><p>A <strong>struct bpf_sock</strong> pointer on success, or <strong>NULL</strong> in</p></li>
<li><p>case of failure.</p></li>
<li></li>
<li><p>struct bpf_tcp_sock <a href="#id443"><span class="problematic" id="id444">*</span></a>bpf_tcp_sock(struct bpf_sock <a href="#id445"><span class="problematic" id="id446">*</span></a>sk)</p></li>
<li><p>Description</p></li>
<li><p>This helper gets a <strong>struct bpf_tcp_sock</strong> pointer from a</p></li>
<li><p><strong>struct bpf_sock</strong> pointer.</p></li>
<li><p>Return</p></li>
<li><p>A <strong>struct bpf_tcp_sock</strong> pointer on success, or <strong>NULL</strong> in</p></li>
<li><p>case of failure.</p></li>
<li></li>
<li><p>long bpf_skb_ecn_set_ce(struct sk_buff <a href="#id447"><span class="problematic" id="id448">*</span></a>skb)</p></li>
<li><p>Description</p></li>
<li><p>Set ECN (Explicit Congestion Notification) field of IP header</p></li>
<li><p>to <strong>CE</strong> (Congestion Encountered) if current value is <strong>ECT</strong></p></li>
<li><p>(ECN Capable Transport). Otherwise, do nothing. Works with IPv6</p></li>
<li><p>and IPv4.</p></li>
<li><p>Return</p></li>
<li><p>1 if the <strong>CE</strong> flag is set (either by the current helper call</p></li>
<li><p>or because it was already present), 0 if it is not set.</p></li>
<li></li>
<li><p>struct bpf_sock <a href="#id449"><span class="problematic" id="id450">*</span></a>bpf_get_listener_sock(struct bpf_sock <a href="#id451"><span class="problematic" id="id452">*</span></a>sk)</p></li>
<li><p>Description</p></li>
<li><p>Return a <strong>struct bpf_sock</strong> pointer in <strong>TCP_LISTEN</strong> state.</p></li>
<li><p><strong>bpf_sk_release</strong>() is unnecessary and not allowed.</p></li>
<li><p>Return</p></li>
<li><p>A <strong>struct bpf_sock</strong> pointer on success, or <strong>NULL</strong> in</p></li>
<li><p>case of failure.</p></li>
<li></li>
<li><p>struct bpf_sock <a href="#id453"><span class="problematic" id="id454">*</span></a>bpf_skc_lookup_tcp(void <a href="#id455"><span class="problematic" id="id456">*</span></a>ctx, struct bpf_sock_tuple <a href="#id457"><span class="problematic" id="id458">*</span></a>tuple, u32 tuple_size, u64 netns, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Look for TCP socket matching <em>tuple</em>, optionally in a child</p></li>
<li><p>network namespace <em>netns</em>. The return value must be checked,</p></li>
<li><p>and if non-<strong>NULL</strong>, released via <strong>bpf_sk_release</strong>().</p></li>
<li></li>
<li><p>This function is identical to <strong>bpf_sk_lookup_tcp</strong>(), except</p></li>
<li><p>that it also returns timewait or request sockets. Use</p></li>
<li><p><strong>bpf_sk_fullsock</strong>() or <strong>bpf_tcp_sock</strong>() to access the</p></li>
<li><p>full structure.</p></li>
<li></li>
<li><p>This helper is available only if the kernel was compiled with</p></li>
<li><p><strong>CONFIG_NET</strong> configuration option.</p></li>
<li><p>Return</p></li>
<li><p>Pointer to <strong>struct bpf_sock</strong>, or <strong>NULL</strong> in case of failure.</p></li>
<li><p>For sockets with reuseport option, the <strong>struct bpf_sock</strong></p></li>
<li><p>result is from <em>reuse</em><strong>-&gt;socks</strong>[] using the hash of the</p></li>
<li><p>tuple.</p></li>
<li></li>
<li><p>long bpf_tcp_check_syncookie(void <a href="#id459"><span class="problematic" id="id460">*</span></a>sk, void <a href="#id461"><span class="problematic" id="id462">*</span></a>iph, u32 iph_len, struct tcphdr <a href="#id463"><span class="problematic" id="id464">*</span></a>th, u32 th_len)</p></li>
<li><p>Description</p></li>
<li><p>Check whether <em>iph</em> and <em>th</em> contain a valid SYN cookie ACK for</p></li>
<li><p>the listening socket in <em>sk</em>.</p></li>
<li></li>
<li><p><em>iph</em> points to the start of the IPv4 or IPv6 header, while</p></li>
<li><p><em>iph_len</em> contains <strong>sizeof</strong>(<strong>struct iphdr</strong>) or</p></li>
<li><p><strong>sizeof</strong>(<strong>struct ip6hdr</strong>).</p></li>
<li></li>
<li><p><em>th</em> points to the start of the TCP header, while <em>th_len</em></p></li>
<li><p>contains <strong>sizeof</strong>(<strong>struct tcphdr</strong>).</p></li>
<li><p>Return</p></li>
<li><p>0 if <em>iph</em> and <em>th</em> are a valid SYN cookie ACK, or a negative</p></li>
<li><p>error otherwise.</p></li>
<li></li>
<li><p>long bpf_sysctl_get_name(struct bpf_sysctl <a href="#id465"><span class="problematic" id="id466">*</span></a>ctx, char <a href="#id467"><span class="problematic" id="id468">*</span></a>buf, size_t buf_len, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Get name of sysctl in /proc/sys/ and copy it into provided by</p></li>
<li><p>program buffer <em>buf</em> of size <em>buf_len</em>.</p></li>
<li></li>
<li><p>The buffer is always NUL terminated, unless it’s zero-sized.</p></li>
<li></li>
<li><p>If <em>flags</em> is zero, full name (e.g. “net/ipv4/tcp_mem”) is</p></li>
<li><p>copied. Use <strong>BPF_F_SYSCTL_BASE_NAME</strong> flag to copy base name</p></li>
<li><p>only (e.g. “tcp_mem”).</p></li>
<li><p>Return</p></li>
<li><p>Number of character copied (not including the trailing NUL).</p></li>
<li></li>
<li><p><strong>-E2BIG</strong> if the buffer wasn’t big enough (<em>buf</em> will contain</p></li>
<li><p>truncated name in this case).</p></li>
<li></li>
<li><p>long bpf_sysctl_get_current_value(struct bpf_sysctl <a href="#id469"><span class="problematic" id="id470">*</span></a>ctx, char <a href="#id471"><span class="problematic" id="id472">*</span></a>buf, size_t buf_len)</p></li>
<li><p>Description</p></li>
<li><p>Get current value of sysctl as it is presented in /proc/sys</p></li>
<li><p>(incl. newline, etc), and copy it as a string into provided</p></li>
<li><p>by program buffer <em>buf</em> of size <em>buf_len</em>.</p></li>
<li></li>
<li><p>The whole value is copied, no matter what file position user</p></li>
<li><p>space issued e.g. sys_read at.</p></li>
<li></li>
<li><p>The buffer is always NUL terminated, unless it’s zero-sized.</p></li>
<li><p>Return</p></li>
<li><p>Number of character copied (not including the trailing NUL).</p></li>
<li></li>
<li><p><strong>-E2BIG</strong> if the buffer wasn’t big enough (<em>buf</em> will contain</p></li>
<li><p>truncated name in this case).</p></li>
<li></li>
<li><p><strong>-EINVAL</strong> if current value was unavailable, e.g. because</p></li>
<li><p>sysctl is uninitialized and read returns -EIO for it.</p></li>
<li></li>
<li><p>long bpf_sysctl_get_new_value(struct bpf_sysctl <a href="#id473"><span class="problematic" id="id474">*</span></a>ctx, char <a href="#id475"><span class="problematic" id="id476">*</span></a>buf, size_t buf_len)</p></li>
<li><p>Description</p></li>
<li><p>Get new value being written by user space to sysctl (before</p></li>
<li><p>the actual write happens) and copy it as a string into</p></li>
<li><p>provided by program buffer <em>buf</em> of size <em>buf_len</em>.</p></li>
<li></li>
<li><p>User space may write new value at file position &gt; 0.</p></li>
<li></li>
<li><p>The buffer is always NUL terminated, unless it’s zero-sized.</p></li>
<li><p>Return</p></li>
<li><p>Number of character copied (not including the trailing NUL).</p></li>
<li></li>
<li><p><strong>-E2BIG</strong> if the buffer wasn’t big enough (<em>buf</em> will contain</p></li>
<li><p>truncated name in this case).</p></li>
<li></li>
<li><p><strong>-EINVAL</strong> if sysctl is being read.</p></li>
<li></li>
<li><p>long bpf_sysctl_set_new_value(struct bpf_sysctl <a href="#id477"><span class="problematic" id="id478">*</span></a>ctx, const char <a href="#id479"><span class="problematic" id="id480">*</span></a>buf, size_t buf_len)</p></li>
<li><p>Description</p></li>
<li><p>Override new value being written by user space to sysctl with</p></li>
<li><p>value provided by program in buffer <em>buf</em> of size <em>buf_len</em>.</p></li>
<li></li>
<li><p><em>buf</em> should contain a string in same form as provided by user</p></li>
<li><p>space on sysctl write.</p></li>
<li></li>
<li><p>User space may write new value at file position &gt; 0. To override</p></li>
<li><p>the whole sysctl value file position should be set to zero.</p></li>
<li><p>Return</p></li>
<li><p>0 on success.</p></li>
<li></li>
<li><p><strong>-E2BIG</strong> if the <em>buf_len</em> is too big.</p></li>
<li></li>
<li><p><strong>-EINVAL</strong> if sysctl is being read.</p></li>
<li></li>
<li><p>long bpf_strtol(const char <a href="#id481"><span class="problematic" id="id482">*</span></a>buf, size_t buf_len, u64 flags, long <a href="#id483"><span class="problematic" id="id484">*</span></a>res)</p></li>
<li><p>Description</p></li>
<li><p>Convert the initial part of the string from buffer <em>buf</em> of</p></li>
<li><p>size <em>buf_len</em> to a long integer according to the given base</p></li>
<li><p>and save the result in <em>res</em>.</p></li>
<li></li>
<li><p>The string may begin with an arbitrary amount of white space</p></li>
<li><p>(as determined by <strong>isspace</strong>(3)) followed by a single</p></li>
<li><p>optional ‘<strong>-</strong>‘ sign.</p></li>
<li></li>
<li><p>Five least significant bits of <em>flags</em> encode base, other bits</p></li>
<li><p>are currently unused.</p></li>
<li></li>
<li><p>Base must be either 8, 10, 16 or 0 to detect it automatically</p></li>
<li><p>similar to user space <strong>strtol</strong>(3).</p></li>
<li><p>Return</p></li>
<li><p>Number of characters consumed on success. Must be positive but</p></li>
<li><p>no more than <em>buf_len</em>.</p></li>
<li></li>
<li><p><strong>-EINVAL</strong> if no valid digits were found or unsupported base</p></li>
<li><p>was provided.</p></li>
<li></li>
<li><p><strong>-ERANGE</strong> if resulting value was out of range.</p></li>
<li></li>
<li><p>long bpf_strtoul(const char <a href="#id485"><span class="problematic" id="id486">*</span></a>buf, size_t buf_len, u64 flags, unsigned long <a href="#id487"><span class="problematic" id="id488">*</span></a>res)</p></li>
<li><p>Description</p></li>
<li><p>Convert the initial part of the string from buffer <em>buf</em> of</p></li>
<li><p>size <em>buf_len</em> to an unsigned long integer according to the</p></li>
<li><p>given base and save the result in <em>res</em>.</p></li>
<li></li>
<li><p>The string may begin with an arbitrary amount of white space</p></li>
<li><p>(as determined by <strong>isspace</strong>(3)).</p></li>
<li></li>
<li><p>Five least significant bits of <em>flags</em> encode base, other bits</p></li>
<li><p>are currently unused.</p></li>
<li></li>
<li><p>Base must be either 8, 10, 16 or 0 to detect it automatically</p></li>
<li><p>similar to user space <strong>strtoul</strong>(3).</p></li>
<li><p>Return</p></li>
<li><p>Number of characters consumed on success. Must be positive but</p></li>
<li><p>no more than <em>buf_len</em>.</p></li>
<li></li>
<li><p><strong>-EINVAL</strong> if no valid digits were found or unsupported base</p></li>
<li><p>was provided.</p></li>
<li></li>
<li><p><strong>-ERANGE</strong> if resulting value was out of range.</p></li>
<li></li>
<li><p>void <a href="#id489"><span class="problematic" id="id490">*</span></a>bpf_sk_storage_get(struct bpf_map <a href="#id491"><span class="problematic" id="id492">*</span></a>map, void <a href="#id493"><span class="problematic" id="id494">*</span></a>sk, void <a href="#id495"><span class="problematic" id="id496">*</span></a>value, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Get a bpf-local-storage from a <em>sk</em>.</p></li>
<li></li>
<li><p>Logically, it could be thought of getting the value from</p></li>
<li><p>a <em>map</em> with <em>sk</em> as the <strong>key</strong>.  From this</p></li>
<li><p>perspective,  the usage is not much different from</p></li>
<li><p><strong>bpf_map_lookup_elem</strong>(<em>map</em>, <strong>&amp;</strong><em>sk</em>) except this</p></li>
<li><p>helper enforces the key must be a full socket and the map must</p></li>
<li><p>be a <strong>BPF_MAP_TYPE_SK_STORAGE</strong> also.</p></li>
<li></li>
<li><p>Underneath, the value is stored locally at <em>sk</em> instead of</p></li>
<li><p>the <em>map</em>.  The <em>map</em> is used as the bpf-local-storage</p></li>
<li><p>“type”. The bpf-local-storage “type” (i.e. the <em>map</em>) is</p></li>
<li><p>searched against all bpf-local-storages residing at <em>sk</em>.</p></li>
<li></li>
<li><p><em>sk</em> is a kernel <strong>struct sock</strong> pointer for LSM program.</p></li>
<li><p><em>sk</em> is a <strong>struct bpf_sock</strong> pointer for other program types.</p></li>
<li></li>
<li><p>An optional <em>flags</em> (<strong>BPF_SK_STORAGE_GET_F_CREATE</strong>) can be</p></li>
<li><p>used such that a new bpf-local-storage will be</p></li>
<li><p>created if one does not exist.  <em>value</em> can be used</p></li>
<li><p>together with <strong>BPF_SK_STORAGE_GET_F_CREATE</strong> to specify</p></li>
<li><p>the initial value of a bpf-local-storage.  If <em>value</em> is</p></li>
<li><p><strong>NULL</strong>, the new bpf-local-storage will be zero initialized.</p></li>
<li><p>Return</p></li>
<li><p>A bpf-local-storage pointer is returned on success.</p></li>
<li></li>
<li><p><strong>NULL</strong> if not found or there was an error in adding</p></li>
<li><p>a new bpf-local-storage.</p></li>
<li></li>
<li><p>long bpf_sk_storage_delete(struct bpf_map <a href="#id497"><span class="problematic" id="id498">*</span></a>map, void <a href="#id499"><span class="problematic" id="id500">*</span></a>sk)</p></li>
<li><p>Description</p></li>
<li><p>Delete a bpf-local-storage from a <em>sk</em>.</p></li>
<li><p>Return</p></li>
<li><p>0 on success.</p></li>
<li></li>
<li><p><strong>-ENOENT</strong> if the bpf-local-storage cannot be found.</p></li>
<li><p><strong>-EINVAL</strong> if sk is not a fullsock (e.g. a request_sock).</p></li>
<li></li>
<li><p>long bpf_send_signal(u32 sig)</p></li>
<li><p>Description</p></li>
<li><p>Send signal <em>sig</em> to the process of the current task.</p></li>
<li><p>The signal may be delivered to any of this process’s threads.</p></li>
<li><p>Return</p></li>
<li><p>0 on success or successfully queued.</p></li>
<li></li>
<li><p><strong>-EBUSY</strong> if work queue under nmi is full.</p></li>
<li></li>
<li><p><strong>-EINVAL</strong> if <em>sig</em> is invalid.</p></li>
<li></li>
<li><p><strong>-EPERM</strong> if no permission to send the <em>sig</em>.</p></li>
<li></li>
<li><p><strong>-EAGAIN</strong> if bpf program can try again.</p></li>
<li></li>
<li><p>s64 bpf_tcp_gen_syncookie(void <a href="#id501"><span class="problematic" id="id502">*</span></a>sk, void <a href="#id503"><span class="problematic" id="id504">*</span></a>iph, u32 iph_len, struct tcphdr <a href="#id505"><span class="problematic" id="id506">*</span></a>th, u32 th_len)</p></li>
<li><p>Description</p></li>
<li><p>Try to issue a SYN cookie for the packet with corresponding</p></li>
<li><p>IP/TCP headers, <em>iph</em> and <em>th</em>, on the listening socket in <em>sk</em>.</p></li>
<li></li>
<li><p><em>iph</em> points to the start of the IPv4 or IPv6 header, while</p></li>
<li><p><em>iph_len</em> contains <strong>sizeof</strong>(<strong>struct iphdr</strong>) or</p></li>
<li><p><strong>sizeof</strong>(<strong>struct ip6hdr</strong>).</p></li>
<li></li>
<li><p><em>th</em> points to the start of the TCP header, while <em>th_len</em></p></li>
<li><p>contains the length of the TCP header.</p></li>
<li><p>Return</p></li>
<li><p>On success, lower 32 bits hold the generated SYN cookie in</p></li>
<li><p>followed by 16 bits which hold the MSS value for that cookie,</p></li>
<li><p>and the top 16 bits are unused.</p></li>
<li></li>
<li><p>On failure, the returned value is one of the following:</p></li>
<li></li>
<li><p><strong>-EINVAL</strong> SYN cookie cannot be issued due to error</p></li>
<li></li>
<li><p><strong>-ENOENT</strong> SYN cookie should not be issued (no SYN flood)</p></li>
<li></li>
<li><p><strong>-EOPNOTSUPP</strong> kernel configuration does not enable SYN cookies</p></li>
<li></li>
<li><p><strong>-EPROTONOSUPPORT</strong> IP packet version is not 4 or 6</p></li>
<li></li>
<li><p>long bpf_skb_output(void <a href="#id507"><span class="problematic" id="id508">*</span></a>ctx, struct bpf_map <a href="#id509"><span class="problematic" id="id510">*</span></a>map, u64 flags, void <a href="#id511"><span class="problematic" id="id512">*</span></a>data, u64 size)</p></li>
<li><p>Description</p></li>
<li><p>Write raw <em>data</em> blob into a special BPF perf event held by</p></li>
<li><p><em>map</em> of type <strong>BPF_MAP_TYPE_PERF_EVENT_ARRAY</strong>. This perf</p></li>
<li><p>event must have the following attributes: <strong>PERF_SAMPLE_RAW</strong></p></li>
<li><p>as <strong>sample_type</strong>, <strong>PERF_TYPE_SOFTWARE</strong> as <strong>type</strong>, and</p></li>
<li><p><strong>PERF_COUNT_SW_BPF_OUTPUT</strong> as <strong>config</strong>.</p></li>
<li></li>
<li><p>The <em>flags</em> are used to indicate the index in <em>map</em> for which</p></li>
<li><p>the value must be put, masked with <strong>BPF_F_INDEX_MASK</strong>.</p></li>
<li><p>Alternatively, <em>flags</em> can be set to <strong>BPF_F_CURRENT_CPU</strong></p></li>
<li><p>to indicate that the index of the current CPU core should be</p></li>
<li><p>used.</p></li>
<li></li>
<li><p>The value to write, of <em>size</em>, is passed through eBPF stack and</p></li>
<li><p>pointed by <em>data</em>.</p></li>
<li></li>
<li><p><em>ctx</em> is a pointer to in-kernel struct sk_buff.</p></li>
<li></li>
<li><p>This helper is similar to <strong>bpf_perf_event_output</strong>() but</p></li>
<li><p>restricted to raw_tracepoint bpf programs.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_probe_read_user(void <a href="#id513"><span class="problematic" id="id514">*</span></a>dst, u32 size, const void <a href="#id515"><span class="problematic" id="id516">*</span></a>unsafe_ptr)</p></li>
<li><p>Description</p></li>
<li><p>Safely attempt to read <em>size</em> bytes from user space address</p></li>
<li><p><em>unsafe_ptr</em> and store the data in <em>dst</em>.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_probe_read_kernel(void <a href="#id517"><span class="problematic" id="id518">*</span></a>dst, u32 size, const void <a href="#id519"><span class="problematic" id="id520">*</span></a>unsafe_ptr)</p></li>
<li><p>Description</p></li>
<li><p>Safely attempt to read <em>size</em> bytes from kernel space address</p></li>
<li><p><em>unsafe_ptr</em> and store the data in <em>dst</em>.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_probe_read_user_str(void <a href="#id521"><span class="problematic" id="id522">*</span></a>dst, u32 size, const void <a href="#id523"><span class="problematic" id="id524">*</span></a>unsafe_ptr)</p></li>
<li><p>Description</p></li>
<li><p>Copy a NUL terminated string from an unsafe user address</p></li>
<li><p><em>unsafe_ptr</em> to <em>dst</em>. The <em>size</em> should include the</p></li>
<li><p>terminating NUL byte. In case the string length is smaller than</p></li>
<li><p><em>size</em>, the target is not padded with further NUL bytes. If the</p></li>
<li><p>string length is larger than <em>size</em>, just <em>size</em>-1 bytes are</p></li>
<li><p>copied and the last byte is set to NUL.</p></li>
<li></li>
<li><p>On success, returns the number of bytes that were written,</p></li>
<li><p>including the terminal NUL. This makes this helper useful in</p></li>
<li><p>tracing programs for reading strings, and more importantly to</p></li>
<li><p>get its length at runtime. See the following snippet:</p></li>
<li></li>
<li></li>
<li></li>
<li><p>SEC(“kprobe/sys_open”)</p></li>
<li><p>void bpf_sys_open(struct pt_regs <a href="#id525"><span class="problematic" id="id526">*</span></a>ctx)</p></li>
<li><p>{</p></li>
<li><p>char buf[PATHLEN]; // PATHLEN is defined to 256</p></li>
<li><p>int res = bpf_probe_read_user_str(buf, sizeof(buf),</p></li>
<li><p>ctx-&gt;di);</p></li>
<li></li>
<li><p>// Consume buf, for example push it to</p></li>
<li><p>// userspace via bpf_perf_event_output(); we</p></li>
<li><p>// can use res (the string length) as event</p></li>
<li><p>// size, after checking its boundaries.</p></li>
<li><p>}</p></li>
<li></li>
<li><p>In comparison, using <strong>bpf_probe_read_user</strong>() helper here</p></li>
<li><p>instead to read the string would require to estimate the length</p></li>
<li><p>at compile time, and would often result in copying more memory</p></li>
<li><p>than necessary.</p></li>
<li></li>
<li><p>Another useful use case is when parsing individual process</p></li>
<li><p>arguments or individual environment variables navigating</p></li>
<li><p><em>current</em><strong>-&gt;mm-&gt;arg_start</strong> and <em>current</em></p></li>
<li><p><strong>-&gt;mm-&gt;env_start</strong>: using this helper and the return value,</p></li>
<li><p>one can quickly iterate at the right offset of the memory area.</p></li>
<li><p>Return</p></li>
<li><p>On success, the strictly positive length of the output string,</p></li>
<li><p>including the trailing NUL character. On error, a negative</p></li>
<li><p>value.</p></li>
<li></li>
<li><p>long bpf_probe_read_kernel_str(void <a href="#id527"><span class="problematic" id="id528">*</span></a>dst, u32 size, const void <a href="#id529"><span class="problematic" id="id530">*</span></a>unsafe_ptr)</p></li>
<li><p>Description</p></li>
<li><p>Copy a NUL terminated string from an unsafe kernel address <em>unsafe_ptr</em></p></li>
<li><p>to <em>dst</em>. Same semantics as with <strong>bpf_probe_read_user_str</strong>() apply.</p></li>
<li><p>Return</p></li>
<li><p>On success, the strictly positive length of the string, including</p></li>
<li><p>the trailing NUL character. On error, a negative value.</p></li>
<li></li>
<li><p>long bpf_tcp_send_ack(void <a href="#id531"><span class="problematic" id="id532">*</span></a>tp, u32 rcv_nxt)</p></li>
<li><p>Description</p></li>
<li><p>Send out a tcp-ack. <em>tp</em> is the in-kernel struct <strong>tcp_sock</strong>.</p></li>
<li><p><em>rcv_nxt</em> is the ack_seq to be sent out.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_send_signal_thread(u32 sig)</p></li>
<li><p>Description</p></li>
<li><p>Send signal <em>sig</em> to the thread corresponding to the current task.</p></li>
<li><p>Return</p></li>
<li><p>0 on success or successfully queued.</p></li>
<li></li>
<li><p><strong>-EBUSY</strong> if work queue under nmi is full.</p></li>
<li></li>
<li><p><strong>-EINVAL</strong> if <em>sig</em> is invalid.</p></li>
<li></li>
<li><p><strong>-EPERM</strong> if no permission to send the <em>sig</em>.</p></li>
<li></li>
<li><p><strong>-EAGAIN</strong> if bpf program can try again.</p></li>
<li></li>
<li><p>u64 bpf_jiffies64(void)</p></li>
<li><p>Description</p></li>
<li><p>Obtain the 64bit jiffies</p></li>
<li><p>Return</p></li>
<li><p>The 64 bit jiffies</p></li>
<li></li>
<li><p>long bpf_read_branch_records(struct bpf_perf_event_data <a href="#id533"><span class="problematic" id="id534">*</span></a>ctx, void <a href="#id535"><span class="problematic" id="id536">*</span></a>buf, u32 size, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>For an eBPF program attached to a perf event, retrieve the</p></li>
<li><p>branch records (<strong>struct perf_branch_entry</strong>) associated to <em>ctx</em></p></li>
<li><p>and store it in the buffer pointed by <em>buf</em> up to size</p></li>
<li><p><em>size</em> bytes.</p></li>
<li><p>Return</p></li>
<li><p>On success, number of bytes written to <em>buf</em>. On error, a</p></li>
<li><p>negative value.</p></li>
<li></li>
<li><p>The <em>flags</em> can be set to <strong>BPF_F_GET_BRANCH_RECORDS_SIZE</strong> to</p></li>
<li><p>instead return the number of bytes required to store all the</p></li>
<li><p>branch entries. If this flag is set, <em>buf</em> may be NULL.</p></li>
<li></li>
<li><p><strong>-EINVAL</strong> if arguments invalid or <strong>size</strong> not a multiple</p></li>
<li><p>of <strong>sizeof</strong>(<strong>struct perf_branch_entry</strong>).</p></li>
<li></li>
<li><p><strong>-ENOENT</strong> if architecture does not support branch records.</p></li>
<li></li>
<li><p>long bpf_get_ns_current_pid_tgid(u64 dev, u64 ino, struct bpf_pidns_info <a href="#id537"><span class="problematic" id="id538">*</span></a>nsdata, u32 size)</p></li>
<li><p>Description</p></li>
<li><p>Returns 0 on success, values for <em>pid</em> and <em>tgid</em> as seen from the current</p></li>
<li><p><em>namespace</em> will be returned in <em>nsdata</em>.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or one of the following in case of failure:</p></li>
<li></li>
<li><p><strong>-EINVAL</strong> if dev and inum supplied don’t match dev_t and inode number</p></li>
<li><p>with nsfs of current task, or if dev conversion to dev_t lost high bits.</p></li>
<li></li>
<li><p><strong>-ENOENT</strong> if pidns does not exists for the current task.</p></li>
<li></li>
<li><p>long bpf_xdp_output(void <a href="#id539"><span class="problematic" id="id540">*</span></a>ctx, struct bpf_map <a href="#id541"><span class="problematic" id="id542">*</span></a>map, u64 flags, void <a href="#id543"><span class="problematic" id="id544">*</span></a>data, u64 size)</p></li>
<li><p>Description</p></li>
<li><p>Write raw <em>data</em> blob into a special BPF perf event held by</p></li>
<li><p><em>map</em> of type <strong>BPF_MAP_TYPE_PERF_EVENT_ARRAY</strong>. This perf</p></li>
<li><p>event must have the following attributes: <strong>PERF_SAMPLE_RAW</strong></p></li>
<li><p>as <strong>sample_type</strong>, <strong>PERF_TYPE_SOFTWARE</strong> as <strong>type</strong>, and</p></li>
<li><p><strong>PERF_COUNT_SW_BPF_OUTPUT</strong> as <strong>config</strong>.</p></li>
<li></li>
<li><p>The <em>flags</em> are used to indicate the index in <em>map</em> for which</p></li>
<li><p>the value must be put, masked with <strong>BPF_F_INDEX_MASK</strong>.</p></li>
<li><p>Alternatively, <em>flags</em> can be set to <strong>BPF_F_CURRENT_CPU</strong></p></li>
<li><p>to indicate that the index of the current CPU core should be</p></li>
<li><p>used.</p></li>
<li></li>
<li><p>The value to write, of <em>size</em>, is passed through eBPF stack and</p></li>
<li><p>pointed by <em>data</em>.</p></li>
<li></li>
<li><p><em>ctx</em> is a pointer to in-kernel struct xdp_buff.</p></li>
<li></li>
<li><p>This helper is similar to <strong>bpf_perf_eventoutput</strong>() but</p></li>
<li><p>restricted to raw_tracepoint bpf programs.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>u64 bpf_get_netns_cookie(void <a href="#id545"><span class="problematic" id="id546">*</span></a>ctx)</p></li>
<li><p>Description</p></li>
<li><p>Retrieve the cookie (generated by the kernel) of the network</p></li>
<li><p>namespace the input <em>ctx</em> is associated with. The network</p></li>
<li><p>namespace cookie remains stable for its lifetime and provides</p></li>
<li><p>a global identifier that can be assumed unique. If <em>ctx</em> is</p></li>
<li><p>NULL, then the helper returns the cookie for the initial</p></li>
<li><p>network namespace. The cookie itself is very similar to that</p></li>
<li><p>of <strong>bpf_get_socket_cookie</strong>() helper, but for network</p></li>
<li><p>namespaces instead of sockets.</p></li>
<li><p>Return</p></li>
<li><p>A 8-byte long opaque number.</p></li>
<li></li>
<li><p>u64 bpf_get_current_ancestor_cgroup_id(int ancestor_level)</p></li>
<li><p>Description</p></li>
<li><p>Return id of cgroup v2 that is ancestor of the cgroup associated</p></li>
<li><p>with the current task at the <em>ancestor_level</em>. The root cgroup</p></li>
<li><p>is at <em>ancestor_level</em> zero and each step down the hierarchy</p></li>
<li><p>increments the level. If <em>ancestor_level</em> == level of cgroup</p></li>
<li><p>associated with the current task, then return value will be the</p></li>
<li><p>same as that of <strong>bpf_get_current_cgroup_id</strong>().</p></li>
<li></li>
<li><p>The helper is useful to implement policies based on cgroups</p></li>
<li><p>that are upper in hierarchy than immediate cgroup associated</p></li>
<li><p>with the current task.</p></li>
<li></li>
<li><p>The format of returned id and helper limitations are same as in</p></li>
<li><p><strong>bpf_get_current_cgroup_id</strong>().</p></li>
<li><p>Return</p></li>
<li><p>The id is returned or 0 in case the id could not be retrieved.</p></li>
<li></li>
<li><p>long bpf_sk_assign(struct sk_buff <a href="#id547"><span class="problematic" id="id548">*</span></a>skb, void <a href="#id549"><span class="problematic" id="id550">*</span></a>sk, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Helper is overloaded depending on BPF program type. This</p></li>
<li><p>description applies to <strong>BPF_PROG_TYPE_SCHED_CLS</strong> and</p></li>
<li><p><strong>BPF_PROG_TYPE_SCHED_ACT</strong> programs.</p></li>
<li></li>
<li><p>Assign the <em>sk</em> to the <em>skb</em>. When combined with appropriate</p></li>
<li><p>routing configuration to receive the packet towards the socket,</p></li>
<li><p>will cause <em>skb</em> to be delivered to the specified socket.</p></li>
<li><p>Subsequent redirection of <em>skb</em> via  <strong>bpf_redirect</strong>(),</p></li>
<li><p><strong>bpf_clone_redirect</strong>() or other methods outside of BPF may</p></li>
<li><p>interfere with successful delivery to the socket.</p></li>
<li></li>
<li><p>This operation is only valid from TC ingress path.</p></li>
<li></li>
<li><p>The <em>flags</em> argument must be zero.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure:</p></li>
<li></li>
<li><p><strong>-EINVAL</strong> if specified <em>flags</em> are not supported.</p></li>
<li></li>
<li><p><strong>-ENOENT</strong> if the socket is unavailable for assignment.</p></li>
<li></li>
<li><p><strong>-ENETUNREACH</strong> if the socket is unreachable (wrong netns).</p></li>
<li></li>
<li><p><strong>-EOPNOTSUPP</strong> if the operation is not supported, for example</p></li>
<li><p>a call from outside of TC ingress.</p></li>
<li></li>
<li><p><strong>-ESOCKTNOSUPPORT</strong> if the socket type is not supported</p></li>
<li><p>(reuseport).</p></li>
<li></li>
<li><p>long bpf_sk_assign(struct bpf_sk_lookup <a href="#id551"><span class="problematic" id="id552">*</span></a>ctx, struct bpf_sock <a href="#id553"><span class="problematic" id="id554">*</span></a>sk, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Helper is overloaded depending on BPF program type. This</p></li>
<li><p>description applies to <strong>BPF_PROG_TYPE_SK_LOOKUP</strong> programs.</p></li>
<li></li>
<li><p>Select the <em>sk</em> as a result of a socket lookup.</p></li>
<li></li>
<li><p>For the operation to succeed passed socket must be compatible</p></li>
<li><p>with the packet description provided by the <em>ctx</em> object.</p></li>
<li></li>
<li><p>L4 protocol (<strong>IPPROTO_TCP</strong> or <strong>IPPROTO_UDP</strong>) must</p></li>
<li><p>be an exact match. While IP family (<strong>AF_INET</strong> or</p></li>
<li><p><strong>AF_INET6</strong>) must be compatible, that is IPv6 sockets</p></li>
<li><p>that are not v6-only can be selected for IPv4 packets.</p></li>
<li></li>
<li><p>Only TCP listeners and UDP unconnected sockets can be</p></li>
<li><p>selected. <em>sk</em> can also be NULL to reset any previous</p></li>
<li><p>selection.</p></li>
<li></li>
<li><p><em>flags</em> argument can combination of following values:</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>BPF_SK_LOOKUP_F_REPLACE</strong> to override the previous</p></li>
</ul>
</li>
<li><p>socket selection, potentially done by a BPF program</p></li>
<li><p>that ran before us.</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>BPF_SK_LOOKUP_F_NO_REUSEPORT</strong> to skip</p></li>
</ul>
</li>
<li><p>load-balancing within reuseport group for the socket</p></li>
<li><p>being selected.</p></li>
<li></li>
<li><p>On success <em>ctx-&gt;sk</em> will point to the selected socket.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative errno in case of failure.</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>-EAFNOSUPPORT</strong> if socket family (<em>sk-&gt;family</em>) is</p></li>
</ul>
</li>
<li><p>not compatible with packet family (<em>ctx-&gt;family</em>).</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>-EEXIST</strong> if socket has been already selected,</p></li>
</ul>
</li>
<li><p>potentially by another program, and</p></li>
<li><p><strong>BPF_SK_LOOKUP_F_REPLACE</strong> flag was not specified.</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>-EINVAL</strong> if unsupported flags were specified.</p></li>
</ul>
</li>
<li></li>
<li><ul class="simple">
<li><p><strong>-EPROTOTYPE</strong> if socket L4 protocol</p></li>
</ul>
</li>
<li><p>(<em>sk-&gt;protocol</em>) doesn’t match packet protocol</p></li>
<li><p>(<em>ctx-&gt;protocol</em>).</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>-ESOCKTNOSUPPORT</strong> if socket is not in allowed</p></li>
</ul>
</li>
<li><p>state (TCP listening or UDP unconnected).</p></li>
<li></li>
<li><p>u64 bpf_ktime_get_boot_ns(void)</p></li>
<li><p>Description</p></li>
<li><p>Return the time elapsed since system boot, in nanoseconds.</p></li>
<li><p>Does include the time the system was suspended.</p></li>
<li><p>See: <strong>clock_gettime</strong>(<strong>CLOCK_BOOTTIME</strong>)</p></li>
<li><p>Return</p></li>
<li><p>Current <em>ktime</em>.</p></li>
<li></li>
<li><p>long bpf_seq_printf(struct seq_file <a href="#id555"><span class="problematic" id="id556">*</span></a>m, const char <a href="#id557"><span class="problematic" id="id558">*</span></a>fmt, u32 fmt_size, const void <a href="#id559"><span class="problematic" id="id560">*</span></a>data, u32 data_len)</p></li>
<li><p>Description</p></li>
<li><p><strong>bpf_seq_printf</strong>() uses seq_file <strong>seq_printf</strong>() to print</p></li>
<li><p>out the format string.</p></li>
<li><p>The <em>m</em> represents the seq_file. The <em>fmt</em> and <em>fmt_size</em> are for</p></li>
<li><p>the format string itself. The <em>data</em> and <em>data_len</em> are format string</p></li>
<li><p>arguments. The <em>data</em> are a <strong>u64</strong> array and corresponding format string</p></li>
<li><p>values are stored in the array. For strings and pointers where pointees</p></li>
<li><p>are accessed, only the pointer values are stored in the <em>data</em> array.</p></li>
<li><p>The <em>data_len</em> is the size of <em>data</em> in bytes.</p></li>
<li></li>
<li><p>Formats <strong>%s</strong>, <strong>%p{i,I}{4,6}</strong> requires to read kernel memory.</p></li>
<li><p>Reading kernel memory may fail due to either invalid address or</p></li>
<li><p>valid address but requiring a major memory fault. If reading kernel memory</p></li>
<li><p>fails, the string for <strong>%s</strong> will be an empty string, and the ip</p></li>
<li><p>address for <strong>%p{i,I}{4,6}</strong> will be 0. Not returning error to</p></li>
<li><p>bpf program is consistent with what <strong>bpf_trace_printk</strong>() does for now.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure:</p></li>
<li></li>
<li><p><strong>-EBUSY</strong> if per-CPU memory copy buffer is busy, can try again</p></li>
<li><p>by returning 1 from bpf program.</p></li>
<li></li>
<li><p><strong>-EINVAL</strong> if arguments are invalid, or if <em>fmt</em> is invalid/unsupported.</p></li>
<li></li>
<li><p><strong>-E2BIG</strong> if <em>fmt</em> contains too many format specifiers.</p></li>
<li></li>
<li><p><strong>-EOVERFLOW</strong> if an overflow happened: The same object will be tried again.</p></li>
<li></li>
<li><p>long bpf_seq_write(struct seq_file <a href="#id561"><span class="problematic" id="id562">*</span></a>m, const void <a href="#id563"><span class="problematic" id="id564">*</span></a>data, u32 len)</p></li>
<li><p>Description</p></li>
<li><p><strong>bpf_seq_write</strong>() uses seq_file <strong>seq_write</strong>() to write the data.</p></li>
<li><p>The <em>m</em> represents the seq_file. The <em>data</em> and <em>len</em> represent the</p></li>
<li><p>data to write in bytes.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure:</p></li>
<li></li>
<li><p><strong>-EOVERFLOW</strong> if an overflow happened: The same object will be tried again.</p></li>
<li></li>
<li><p>u64 bpf_sk_cgroup_id(void <a href="#id565"><span class="problematic" id="id566">*</span></a>sk)</p></li>
<li><p>Description</p></li>
<li><p>Return the cgroup v2 id of the socket <em>sk</em>.</p></li>
<li></li>
<li><p><em>sk</em> must be a non-<strong>NULL</strong> pointer to a socket, e.g. one</p></li>
<li><p>returned from <strong>bpf_sk_lookup_xxx</strong>(),</p></li>
<li><p><strong>bpf_sk_fullsock</strong>(), etc. The format of returned id is</p></li>
<li><p>same as in <strong>bpf_skb_cgroup_id</strong>().</p></li>
<li></li>
<li><p>This helper is available only if the kernel was compiled with</p></li>
<li><p>the <strong>CONFIG_SOCK_CGROUP_DATA</strong> configuration option.</p></li>
<li><p>Return</p></li>
<li><p>The id is returned or 0 in case the id could not be retrieved.</p></li>
<li></li>
<li><p>u64 bpf_sk_ancestor_cgroup_id(void <a href="#id567"><span class="problematic" id="id568">*</span></a>sk, int ancestor_level)</p></li>
<li><p>Description</p></li>
<li><p>Return id of cgroup v2 that is ancestor of cgroup associated</p></li>
<li><p>with the <em>sk</em> at the <em>ancestor_level</em>.  The root cgroup is at</p></li>
<li><p><em>ancestor_level</em> zero and each step down the hierarchy</p></li>
<li><p>increments the level. If <em>ancestor_level</em> == level of cgroup</p></li>
<li><p>associated with <em>sk</em>, then return value will be same as that</p></li>
<li><p>of <strong>bpf_sk_cgroup_id</strong>().</p></li>
<li></li>
<li><p>The helper is useful to implement policies based on cgroups</p></li>
<li><p>that are upper in hierarchy than immediate cgroup associated</p></li>
<li><p>with <em>sk</em>.</p></li>
<li></li>
<li><p>The format of returned id and helper limitations are same as in</p></li>
<li><p><strong>bpf_sk_cgroup_id</strong>().</p></li>
<li><p>Return</p></li>
<li><p>The id is returned or 0 in case the id could not be retrieved.</p></li>
<li></li>
<li><p>long bpf_ringbuf_output(void <a href="#id569"><span class="problematic" id="id570">*</span></a>ringbuf, void <a href="#id571"><span class="problematic" id="id572">*</span></a>data, u64 size, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Copy <em>size</em> bytes from <em>data</em> into a ring buffer <em>ringbuf</em>.</p></li>
<li><p>If <strong>BPF_RB_NO_WAKEUP</strong> is specified in <em>flags</em>, no notification</p></li>
<li><p>of new data availability is sent.</p></li>
<li><p>If <strong>BPF_RB_FORCE_WAKEUP</strong> is specified in <em>flags</em>, notification</p></li>
<li><p>of new data availability is sent unconditionally.</p></li>
<li><p>If <strong>0</strong> is specified in <em>flags</em>, an adaptive notification</p></li>
<li><p>of new data availability is sent.</p></li>
<li></li>
<li><p>An adaptive notification is a notification sent whenever the user-space</p></li>
<li><p>process has caught up and consumed all available payloads. In case the user-space</p></li>
<li><p>process is still processing a previous payload, then no notification is needed</p></li>
<li><p>as it will process the newly added payload automatically.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>void <a href="#id573"><span class="problematic" id="id574">*</span></a>bpf_ringbuf_reserve(void <a href="#id575"><span class="problematic" id="id576">*</span></a>ringbuf, u64 size, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Reserve <em>size</em> bytes of payload in a ring buffer <em>ringbuf</em>.</p></li>
<li><p><em>flags</em> must be 0.</p></li>
<li><p>Return</p></li>
<li><p>Valid pointer with <em>size</em> bytes of memory available; NULL,</p></li>
<li><p>otherwise.</p></li>
<li></li>
<li><p>void bpf_ringbuf_submit(void <a href="#id577"><span class="problematic" id="id578">*</span></a>data, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Submit reserved ring buffer sample, pointed to by <em>data</em>.</p></li>
<li><p>If <strong>BPF_RB_NO_WAKEUP</strong> is specified in <em>flags</em>, no notification</p></li>
<li><p>of new data availability is sent.</p></li>
<li><p>If <strong>BPF_RB_FORCE_WAKEUP</strong> is specified in <em>flags</em>, notification</p></li>
<li><p>of new data availability is sent unconditionally.</p></li>
<li><p>If <strong>0</strong> is specified in <em>flags</em>, an adaptive notification</p></li>
<li><p>of new data availability is sent.</p></li>
<li></li>
<li><p>See ‘bpf_ringbuf_output()’ for the definition of adaptive notification.</p></li>
<li><p>Return</p></li>
<li><p>Nothing. Always succeeds.</p></li>
<li></li>
<li><p>void bpf_ringbuf_discard(void <a href="#id579"><span class="problematic" id="id580">*</span></a>data, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Discard reserved ring buffer sample, pointed to by <em>data</em>.</p></li>
<li><p>If <strong>BPF_RB_NO_WAKEUP</strong> is specified in <em>flags</em>, no notification</p></li>
<li><p>of new data availability is sent.</p></li>
<li><p>If <strong>BPF_RB_FORCE_WAKEUP</strong> is specified in <em>flags</em>, notification</p></li>
<li><p>of new data availability is sent unconditionally.</p></li>
<li><p>If <strong>0</strong> is specified in <em>flags</em>, an adaptive notification</p></li>
<li><p>of new data availability is sent.</p></li>
<li></li>
<li><p>See ‘bpf_ringbuf_output()’ for the definition of adaptive notification.</p></li>
<li><p>Return</p></li>
<li><p>Nothing. Always succeeds.</p></li>
<li></li>
<li><p>u64 bpf_ringbuf_query(void <a href="#id581"><span class="problematic" id="id582">*</span></a>ringbuf, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Query various characteristics of provided ring buffer. What</p></li>
<li><p>exactly is queries is determined by <em>flags</em>:</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>BPF_RB_AVAIL_DATA</strong>: Amount of data not yet consumed.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p><strong>BPF_RB_RING_SIZE</strong>: The size of ring buffer.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p><strong>BPF_RB_CONS_POS</strong>: Consumer position (can wrap around).</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p><strong>BPF_RB_PROD_POS</strong>: Producer(s) position (can wrap around).</p></li>
</ul>
</li>
<li></li>
<li><p>Data returned is just a momentary snapshot of actual values</p></li>
<li><p>and could be inaccurate, so this facility should be used to</p></li>
<li><p>power heuristics and for reporting, not to make 100% correct</p></li>
<li><p>calculation.</p></li>
<li><p>Return</p></li>
<li><p>Requested value, or 0, if <em>flags</em> are not recognized.</p></li>
<li></li>
<li><p>long bpf_csum_level(struct sk_buff <a href="#id583"><span class="problematic" id="id584">*</span></a>skb, u64 level)</p></li>
<li><p>Description</p></li>
<li><p>Change the skbs checksum level by one layer up or down, or</p></li>
<li><p>reset it entirely to none in order to have the stack perform</p></li>
<li><p>checksum validation. The level is applicable to the following</p></li>
<li><p>protocols: TCP, UDP, GRE, SCTP, FCOE. For example, a decap of</p></li>
<li><div class="line-block">
<div class="line">ETH | IP | UDP | GUE | IP | TCP | into | ETH | IP | TCP |</div>
</div>
</li>
<li><p>through <strong>bpf_skb_adjust_room</strong>() helper with passing in</p></li>
<li><p><strong>BPF_F_ADJ_ROOM_NO_CSUM_RESET</strong> flag would require one call</p></li>
<li><p>to <strong>bpf_csum_level</strong>() with <strong>BPF_CSUM_LEVEL_DEC</strong> since</p></li>
<li><p>the UDP header is removed. Similarly, an encap of the latter</p></li>
<li><p>into the former could be accompanied by a helper call to</p></li>
<li><p><strong>bpf_csum_level</strong>() with <strong>BPF_CSUM_LEVEL_INC</strong> if the</p></li>
<li><p>skb is still intended to be processed in higher layers of the</p></li>
<li><p>stack instead of just egressing at tc.</p></li>
<li></li>
<li><p>There are three supported level settings at this time:</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>BPF_CSUM_LEVEL_INC</strong>: Increases skb-&gt;csum_level for skbs</p></li>
</ul>
</li>
<li><p>with CHECKSUM_UNNECESSARY.</p></li>
<li><ul class="simple">
<li><p><strong>BPF_CSUM_LEVEL_DEC</strong>: Decreases skb-&gt;csum_level for skbs</p></li>
</ul>
</li>
<li><p>with CHECKSUM_UNNECESSARY.</p></li>
<li><ul class="simple">
<li><p><strong>BPF_CSUM_LEVEL_RESET</strong>: Resets skb-&gt;csum_level to 0 and</p></li>
</ul>
</li>
<li><p>sets CHECKSUM_NONE to force checksum validation by the stack.</p></li>
<li><ul class="simple">
<li><p><strong>BPF_CSUM_LEVEL_QUERY</strong>: No-op, returns the current</p></li>
</ul>
</li>
<li><p>skb-&gt;csum_level.</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure. In the</p></li>
<li><p>case of <strong>BPF_CSUM_LEVEL_QUERY</strong>, the current skb-&gt;csum_level</p></li>
<li><p>is returned or the error code -EACCES in case the skb is not</p></li>
<li><p>subject to CHECKSUM_UNNECESSARY.</p></li>
<li></li>
<li><p>struct tcp6_sock <a href="#id585"><span class="problematic" id="id586">*</span></a>bpf_skc_to_tcp6_sock(void <a href="#id587"><span class="problematic" id="id588">*</span></a>sk)</p></li>
<li><p>Description</p></li>
<li><p>Dynamically cast a <em>sk</em> pointer to a <em>tcp6_sock</em> pointer.</p></li>
<li><p>Return</p></li>
<li><p><em>sk</em> if casting is valid, or <strong>NULL</strong> otherwise.</p></li>
<li></li>
<li><p>struct tcp_sock <a href="#id589"><span class="problematic" id="id590">*</span></a>bpf_skc_to_tcp_sock(void <a href="#id591"><span class="problematic" id="id592">*</span></a>sk)</p></li>
<li><p>Description</p></li>
<li><p>Dynamically cast a <em>sk</em> pointer to a <em>tcp_sock</em> pointer.</p></li>
<li><p>Return</p></li>
<li><p><em>sk</em> if casting is valid, or <strong>NULL</strong> otherwise.</p></li>
<li></li>
<li><p>struct tcp_timewait_sock <a href="#id593"><span class="problematic" id="id594">*</span></a>bpf_skc_to_tcp_timewait_sock(void <a href="#id595"><span class="problematic" id="id596">*</span></a>sk)</p></li>
<li><p>Description</p></li>
<li><p>Dynamically cast a <em>sk</em> pointer to a <em>tcp_timewait_sock</em> pointer.</p></li>
<li><p>Return</p></li>
<li><p><em>sk</em> if casting is valid, or <strong>NULL</strong> otherwise.</p></li>
<li></li>
<li><p>struct tcp_request_sock <a href="#id597"><span class="problematic" id="id598">*</span></a>bpf_skc_to_tcp_request_sock(void <a href="#id599"><span class="problematic" id="id600">*</span></a>sk)</p></li>
<li><p>Description</p></li>
<li><p>Dynamically cast a <em>sk</em> pointer to a <em>tcp_request_sock</em> pointer.</p></li>
<li><p>Return</p></li>
<li><p><em>sk</em> if casting is valid, or <strong>NULL</strong> otherwise.</p></li>
<li></li>
<li><p>struct udp6_sock <a href="#id601"><span class="problematic" id="id602">*</span></a>bpf_skc_to_udp6_sock(void <a href="#id603"><span class="problematic" id="id604">*</span></a>sk)</p></li>
<li><p>Description</p></li>
<li><p>Dynamically cast a <em>sk</em> pointer to a <em>udp6_sock</em> pointer.</p></li>
<li><p>Return</p></li>
<li><p><em>sk</em> if casting is valid, or <strong>NULL</strong> otherwise.</p></li>
<li></li>
<li><p>long bpf_get_task_stack(struct task_struct <a href="#id605"><span class="problematic" id="id606">*</span></a>task, void <a href="#id607"><span class="problematic" id="id608">*</span></a>buf, u32 size, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Return a user or a kernel stack in bpf program provided buffer.</p></li>
<li><p>To achieve this, the helper needs <em>task</em>, which is a valid</p></li>
<li><p>pointer to <strong>struct task_struct</strong>. To store the stacktrace, the</p></li>
<li><p>bpf program provides <em>buf</em> with a nonnegative <em>size</em>.</p></li>
<li></li>
<li><p>The last argument, <em>flags</em>, holds the number of stack frames to</p></li>
<li><p>skip (from 0 to 255), masked with</p></li>
<li><p><strong>BPF_F_SKIP_FIELD_MASK</strong>. The next bits can be used to set</p></li>
<li><p>the following flags:</p></li>
<li></li>
<li><p><strong>BPF_F_USER_STACK</strong></p></li>
<li><p>Collect a user space stack instead of a kernel stack.</p></li>
<li><p><strong>BPF_F_USER_BUILD_ID</strong></p></li>
<li><p>Collect buildid+offset instead of ips for user stack,</p></li>
<li><p>only valid if <strong>BPF_F_USER_STACK</strong> is also specified.</p></li>
<li></li>
<li><p><strong>bpf_get_task_stack</strong>() can collect up to</p></li>
<li><p><strong>PERF_MAX_STACK_DEPTH</strong> both kernel and user frames, subject</p></li>
<li><p>to sufficient large buffer size. Note that</p></li>
<li><p>this limit can be controlled with the <strong>sysctl</strong> program, and</p></li>
<li><p>that it should be manually increased in order to profile long</p></li>
<li><p>user stacks (such as stacks for Java programs). To do so, use:</p></li>
<li></li>
<li></li>
<li></li>
<li><p># sysctl kernel.perf_event_max_stack=&lt;new value&gt;</p></li>
<li><p>Return</p></li>
<li><p>A non-negative value equal to or less than <em>size</em> on success,</p></li>
<li><p>or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_load_hdr_opt(struct bpf_sock_ops <a href="#id609"><span class="problematic" id="id610">*</span></a>skops, void <a href="#id611"><span class="problematic" id="id612">*</span></a>searchby_res, u32 len, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Load header option.  Support reading a particular TCP header</p></li>
<li><p>option for bpf program (<strong>BPF_PROG_TYPE_SOCK_OPS</strong>).</p></li>
<li></li>
<li><p>If <em>flags</em> is 0, it will search the option from the</p></li>
<li><p><em>skops</em><strong>-&gt;skb_data</strong>.  The comment in <strong>struct bpf_sock_ops</strong></p></li>
<li><p>has details on what skb_data contains under different</p></li>
<li><p><em>skops</em><strong>-&gt;op</strong>.</p></li>
<li></li>
<li><p>The first byte of the <em>searchby_res</em> specifies the</p></li>
<li><p>kind that it wants to search.</p></li>
<li></li>
<li><p>If the searching kind is an experimental kind</p></li>
<li><p>(i.e. 253 or 254 according to RFC6994).  It also</p></li>
<li><p>needs to specify the “magic” which is either</p></li>
<li><p>2 bytes or 4 bytes.  It then also needs to</p></li>
<li><p>specify the size of the magic by using</p></li>
<li><p>the 2nd byte which is “kind-length” of a TCP</p></li>
<li><p>header option and the “kind-length” also</p></li>
<li><p>includes the first 2 bytes “kind” and “kind-length”</p></li>
<li><p>itself as a normal TCP header option also does.</p></li>
<li></li>
<li><p>For example, to search experimental kind 254 with</p></li>
<li><p>2 byte magic 0xeB9F, the searchby_res should be</p></li>
<li><p>[ 254, 4, 0xeB, 0x9F, 0, 0, …. 0 ].</p></li>
<li></li>
<li><p>To search for the standard window scale option (3),</p></li>
<li><p>the <em>searchby_res</em> should be [ 3, 0, 0, …. 0 ].</p></li>
<li><p>Note, kind-length must be 0 for regular option.</p></li>
<li></li>
<li><p>Searching for No-Op (0) and End-of-Option-List (1) are</p></li>
<li><p>not supported.</p></li>
<li></li>
<li><p><em>len</em> must be at least 2 bytes which is the minimal size</p></li>
<li><p>of a header option.</p></li>
<li></li>
<li><p>Supported flags:</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>BPF_LOAD_HDR_OPT_TCP_SYN</strong> to search from the</p></li>
</ul>
</li>
<li><p>saved_syn packet or the just-received syn packet.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>&gt; 0 when found, the header option is copied to <em>searchby_res</em>.</p></li>
<li><p>The return value is the total length copied. On failure, a</p></li>
<li><p>negative error code is returned:</p></li>
<li></li>
<li><p><strong>-EINVAL</strong> if a parameter is invalid.</p></li>
<li></li>
<li><p><strong>-ENOMSG</strong> if the option is not found.</p></li>
<li></li>
<li><p><strong>-ENOENT</strong> if no syn packet is available when</p></li>
<li><p><strong>BPF_LOAD_HDR_OPT_TCP_SYN</strong> is used.</p></li>
<li></li>
<li><p><strong>-ENOSPC</strong> if there is not enough space.  Only <em>len</em> number of</p></li>
<li><p>bytes are copied.</p></li>
<li></li>
<li><p><strong>-EFAULT</strong> on failure to parse the header options in the</p></li>
<li><p>packet.</p></li>
<li></li>
<li><p><strong>-EPERM</strong> if the helper cannot be used under the current</p></li>
<li><p><em>skops</em><strong>-&gt;op</strong>.</p></li>
<li></li>
<li><p>long bpf_store_hdr_opt(struct bpf_sock_ops <a href="#id613"><span class="problematic" id="id614">*</span></a>skops, const void <a href="#id615"><span class="problematic" id="id616">*</span></a>from, u32 len, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Store header option.  The data will be copied</p></li>
<li><p>from buffer <em>from</em> with length <em>len</em> to the TCP header.</p></li>
<li></li>
<li><p>The buffer <em>from</em> should have the whole option that</p></li>
<li><p>includes the kind, kind-length, and the actual</p></li>
<li><p>option data.  The <em>len</em> must be at least kind-length</p></li>
<li><p>long.  The kind-length does not have to be 4 byte</p></li>
<li><p>aligned.  The kernel will take care of the padding</p></li>
<li><p>and setting the 4 bytes aligned value to th-&gt;doff.</p></li>
<li></li>
<li><p>This helper will check for duplicated option</p></li>
<li><p>by searching the same option in the outgoing skb.</p></li>
<li></li>
<li><p>This helper can only be called during</p></li>
<li><p><strong>BPF_SOCK_OPS_WRITE_HDR_OPT_CB</strong>.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>0 on success, or negative error in case of failure:</p></li>
<li></li>
<li><p><strong>-EINVAL</strong> If param is invalid.</p></li>
<li></li>
<li><p><strong>-ENOSPC</strong> if there is not enough space in the header.</p></li>
<li><p>Nothing has been written</p></li>
<li></li>
<li><p><strong>-EEXIST</strong> if the option already exists.</p></li>
<li></li>
<li><p><strong>-EFAULT</strong> on failrue to parse the existing header options.</p></li>
<li></li>
<li><p><strong>-EPERM</strong> if the helper cannot be used under the current</p></li>
<li><p><em>skops</em><strong>-&gt;op</strong>.</p></li>
<li></li>
<li><p>long bpf_reserve_hdr_opt(struct bpf_sock_ops <a href="#id617"><span class="problematic" id="id618">*</span></a>skops, u32 len, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Reserve <em>len</em> bytes for the bpf header option.  The</p></li>
<li><p>space will be used by <strong>bpf_store_hdr_opt</strong>() later in</p></li>
<li><p><strong>BPF_SOCK_OPS_WRITE_HDR_OPT_CB</strong>.</p></li>
<li></li>
<li><p>If <strong>bpf_reserve_hdr_opt</strong>() is called multiple times,</p></li>
<li><p>the total number of bytes will be reserved.</p></li>
<li></li>
<li><p>This helper can only be called during</p></li>
<li><p><strong>BPF_SOCK_OPS_HDR_OPT_LEN_CB</strong>.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>0 on success, or negative error in case of failure:</p></li>
<li></li>
<li><p><strong>-EINVAL</strong> if a parameter is invalid.</p></li>
<li></li>
<li><p><strong>-ENOSPC</strong> if there is not enough space in the header.</p></li>
<li></li>
<li><p><strong>-EPERM</strong> if the helper cannot be used under the current</p></li>
<li><p><em>skops</em><strong>-&gt;op</strong>.</p></li>
<li></li>
<li><p>void <a href="#id619"><span class="problematic" id="id620">*</span></a>bpf_inode_storage_get(struct bpf_map <a href="#id621"><span class="problematic" id="id622">*</span></a>map, void <a href="#id623"><span class="problematic" id="id624">*</span></a>inode, void <a href="#id625"><span class="problematic" id="id626">*</span></a>value, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Get a bpf_local_storage from an <em>inode</em>.</p></li>
<li></li>
<li><p>Logically, it could be thought of as getting the value from</p></li>
<li><p>a <em>map</em> with <em>inode</em> as the <strong>key</strong>.  From this</p></li>
<li><p>perspective,  the usage is not much different from</p></li>
<li><p><strong>bpf_map_lookup_elem</strong>(<em>map</em>, <strong>&amp;</strong><em>inode</em>) except this</p></li>
<li><p>helper enforces the key must be an inode and the map must also</p></li>
<li><p>be a <strong>BPF_MAP_TYPE_INODE_STORAGE</strong>.</p></li>
<li></li>
<li><p>Underneath, the value is stored locally at <em>inode</em> instead of</p></li>
<li><p>the <em>map</em>.  The <em>map</em> is used as the bpf-local-storage</p></li>
<li><p>“type”. The bpf-local-storage “type” (i.e. the <em>map</em>) is</p></li>
<li><p>searched against all bpf_local_storage residing at <em>inode</em>.</p></li>
<li></li>
<li><p>An optional <em>flags</em> (<strong>BPF_LOCAL_STORAGE_GET_F_CREATE</strong>) can be</p></li>
<li><p>used such that a new bpf_local_storage will be</p></li>
<li><p>created if one does not exist.  <em>value</em> can be used</p></li>
<li><p>together with <strong>BPF_LOCAL_STORAGE_GET_F_CREATE</strong> to specify</p></li>
<li><p>the initial value of a bpf_local_storage.  If <em>value</em> is</p></li>
<li><p><strong>NULL</strong>, the new bpf_local_storage will be zero initialized.</p></li>
<li><p>Return</p></li>
<li><p>A bpf_local_storage pointer is returned on success.</p></li>
<li></li>
<li><p><strong>NULL</strong> if not found or there was an error in adding</p></li>
<li><p>a new bpf_local_storage.</p></li>
<li></li>
<li><p>int bpf_inode_storage_delete(struct bpf_map <a href="#id627"><span class="problematic" id="id628">*</span></a>map, void <a href="#id629"><span class="problematic" id="id630">*</span></a>inode)</p></li>
<li><p>Description</p></li>
<li><p>Delete a bpf_local_storage from an <em>inode</em>.</p></li>
<li><p>Return</p></li>
<li><p>0 on success.</p></li>
<li></li>
<li><p><strong>-ENOENT</strong> if the bpf_local_storage cannot be found.</p></li>
<li></li>
<li><p>long bpf_d_path(struct path <a href="#id631"><span class="problematic" id="id632">*</span></a>path, char <a href="#id633"><span class="problematic" id="id634">*</span></a>buf, u32 sz)</p></li>
<li><p>Description</p></li>
<li><p>Return full path for given <strong>struct path</strong> object, which</p></li>
<li><p>needs to be the kernel BTF <em>path</em> object. The path is</p></li>
<li><p>returned in the provided buffer <em>buf</em> of size <em>sz</em> and</p></li>
<li><p>is zero terminated.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>On success, the strictly positive length of the string,</p></li>
<li><p>including the trailing NUL character. On error, a negative</p></li>
<li><p>value.</p></li>
<li></li>
<li><p>long bpf_copy_from_user(void <a href="#id635"><span class="problematic" id="id636">*</span></a>dst, u32 size, const void <a href="#id637"><span class="problematic" id="id638">*</span></a>user_ptr)</p></li>
<li><p>Description</p></li>
<li><p>Read <em>size</em> bytes from user space address <em>user_ptr</em> and store</p></li>
<li><p>the data in <em>dst</em>. This is a wrapper of <strong>copy_from_user</strong>().</p></li>
<li><p>Return</p></li>
<li><p>0 on success, or a negative error in case of failure.</p></li>
<li></li>
<li><p>long bpf_snprintf_btf(char <a href="#id639"><span class="problematic" id="id640">*</span></a>str, u32 str_size, struct btf_ptr <a href="#id641"><span class="problematic" id="id642">*</span></a>ptr, u32 btf_ptr_size, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Use BTF to store a string representation of <em>ptr</em>-&gt;ptr in <em>str</em>,</p></li>
<li><p>using <em>ptr</em>-&gt;type_id.  This value should specify the type</p></li>
<li><p>that <em>ptr</em>-&gt;ptr points to. LLVM __builtin_btf_type_id(type, 1)</p></li>
<li><p>can be used to look up vmlinux BTF type ids. Traversing the</p></li>
<li><p>data structure using BTF, the type information and values are</p></li>
<li><p>stored in the first <em>str_size</em> - 1 bytes of <em>str</em>.  Safe copy of</p></li>
<li><p>the pointer data is carried out to avoid kernel crashes during</p></li>
<li><p>operation.  Smaller types can use string space on the stack;</p></li>
<li><p>larger programs can use map data to store the string</p></li>
<li><p>representation.</p></li>
<li></li>
<li><p>The string can be subsequently shared with userspace via</p></li>
<li><p>bpf_perf_event_output() or ring buffer interfaces.</p></li>
<li><p>bpf_trace_printk() is to be avoided as it places too small</p></li>
<li><p>a limit on string size to be useful.</p></li>
<li></li>
<li><p><em>flags</em> is a combination of</p></li>
<li></li>
<li><p><strong>BTF_F_COMPACT</strong></p></li>
<li><p>no formatting around type information</p></li>
<li><p><strong>BTF_F_NONAME</strong></p></li>
<li><p>no struct/union member names/types</p></li>
<li><p><strong>BTF_F_PTR_RAW</strong></p></li>
<li><p>show raw (unobfuscated) pointer values;</p></li>
<li><p>equivalent to printk specifier %px.</p></li>
<li><p><strong>BTF_F_ZERO</strong></p></li>
<li><p>show zero-valued struct/union members; they</p></li>
<li><p>are not displayed by default</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>The number of bytes that were written (or would have been</p></li>
<li><p>written if output had to be truncated due to string size),</p></li>
<li><p>or a negative error in cases of failure.</p></li>
<li></li>
<li><p>long bpf_seq_printf_btf(struct seq_file <a href="#id643"><span class="problematic" id="id644">*</span></a>m, struct btf_ptr <a href="#id645"><span class="problematic" id="id646">*</span></a>ptr, u32 ptr_size, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Use BTF to write to seq_write a string representation of</p></li>
<li><p><em>ptr</em>-&gt;ptr, using <em>ptr</em>-&gt;type_id as per bpf_snprintf_btf().</p></li>
<li><p><em>flags</em> are identical to those used for bpf_snprintf_btf.</p></li>
<li><p>Return</p></li>
<li><p>0 on success or a negative error in case of failure.</p></li>
<li></li>
<li><p>u64 bpf_skb_cgroup_classid(struct sk_buff <a href="#id647"><span class="problematic" id="id648">*</span></a>skb)</p></li>
<li><p>Description</p></li>
<li><p>See <strong>bpf_get_cgroup_classid</strong>() for the main description.</p></li>
<li><p>This helper differs from <strong>bpf_get_cgroup_classid</strong>() in that</p></li>
<li><p>the cgroup v1 net_cls class is retrieved only from the <em>skb</em>’s</p></li>
<li><p>associated socket instead of the current process.</p></li>
<li><p>Return</p></li>
<li><p>The id is returned or 0 in case the id could not be retrieved.</p></li>
<li></li>
<li><p>long bpf_redirect_neigh(u32 ifindex, struct bpf_redir_neigh <a href="#id649"><span class="problematic" id="id650">*</span></a>params, int plen, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Redirect the packet to another net device of index <em>ifindex</em></p></li>
<li><p>and fill in L2 addresses from neighboring subsystem. This helper</p></li>
<li><p>is somewhat similar to <strong>bpf_redirect</strong>(), except that it</p></li>
<li><p>populates L2 addresses as well, meaning, internally, the helper</p></li>
<li><p>relies on the neighbor lookup for the L2 address of the nexthop.</p></li>
<li></li>
<li><p>The helper will perform a FIB lookup based on the skb’s</p></li>
<li><p>networking header to get the address of the next hop, unless</p></li>
<li><p>this is supplied by the caller in the <em>params</em> argument. The</p></li>
<li><p><em>plen</em> argument indicates the len of <em>params</em> and should be set</p></li>
<li><p>to 0 if <em>params</em> is NULL.</p></li>
<li></li>
<li><p>The <em>flags</em> argument is reserved and must be 0. The helper is</p></li>
<li><p>currently only supported for tc BPF program types, and enabled</p></li>
<li><p>for IPv4 and IPv6 protocols.</p></li>
<li><p>Return</p></li>
<li><p>The helper returns <strong>TC_ACT_REDIRECT</strong> on success or</p></li>
<li><p><strong>TC_ACT_SHOT</strong> on error.</p></li>
<li></li>
<li><p>void <a href="#id651"><span class="problematic" id="id652">*</span></a>bpf_per_cpu_ptr(const void <a href="#id653"><span class="problematic" id="id654">*</span></a>percpu_ptr, u32 cpu)</p></li>
<li><p>Description</p></li>
<li><p>Take a pointer to a percpu ksym, <em>percpu_ptr</em>, and return a</p></li>
<li><p>pointer to the percpu kernel variable on <em>cpu</em>. A ksym is an</p></li>
<li><p>extern variable decorated with ‘__ksym’. For ksym, there is a</p></li>
<li><p>global var (either static or global) defined of the same name</p></li>
<li><p>in the kernel. The ksym is percpu if the global var is percpu.</p></li>
<li><p>The returned pointer points to the global percpu var on <em>cpu</em>.</p></li>
<li></li>
<li><p>bpf_per_cpu_ptr() has the same semantic as per_cpu_ptr() in the</p></li>
<li><p>kernel, except that bpf_per_cpu_ptr() may return NULL. This</p></li>
<li><p>happens if <em>cpu</em> is larger than nr_cpu_ids. The caller of</p></li>
<li><p>bpf_per_cpu_ptr() must check the returned value.</p></li>
<li><p>Return</p></li>
<li><p>A pointer pointing to the kernel percpu variable on <em>cpu</em>, or</p></li>
<li><p>NULL, if <em>cpu</em> is invalid.</p></li>
<li></li>
<li><p>void <a href="#id655"><span class="problematic" id="id656">*</span></a>bpf_this_cpu_ptr(const void <a href="#id657"><span class="problematic" id="id658">*</span></a>percpu_ptr)</p></li>
<li><p>Description</p></li>
<li><p>Take a pointer to a percpu ksym, <em>percpu_ptr</em>, and return a</p></li>
<li><p>pointer to the percpu kernel variable on this cpu. See the</p></li>
<li><p>description of ‘ksym’ in <strong>bpf_per_cpu_ptr</strong>().</p></li>
<li></li>
<li><p>bpf_this_cpu_ptr() has the same semantic as this_cpu_ptr() in</p></li>
<li><p>the kernel. Different from <strong>bpf_per_cpu_ptr</strong>(), it would</p></li>
<li><p>never return NULL.</p></li>
<li><p>Return</p></li>
<li><p>A pointer pointing to the kernel percpu variable on this cpu.</p></li>
<li></li>
<li><p>long bpf_redirect_peer(u32 ifindex, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Redirect the packet to another net device of index <em>ifindex</em>.</p></li>
<li><p>This helper is somewhat similar to <strong>bpf_redirect</strong>(), except</p></li>
<li><p>that the redirection happens to the <em>ifindex</em>’ peer device and</p></li>
<li><p>the netns switch takes place from ingress to ingress without</p></li>
<li><p>going through the CPU’s backlog queue.</p></li>
<li></li>
<li><p>The <em>flags</em> argument is reserved and must be 0. The helper is</p></li>
<li><p>currently only supported for tc BPF program types at the ingress</p></li>
<li><p>hook and for veth device types. The peer device must reside in a</p></li>
<li><p>different network namespace.</p></li>
<li><p>Return</p></li>
<li><p>The helper returns <strong>TC_ACT_REDIRECT</strong> on success or</p></li>
<li><p><strong>TC_ACT_SHOT</strong> on error.</p></li>
<li></li>
<li><p>void <a href="#id659"><span class="problematic" id="id660">*</span></a>bpf_task_storage_get(struct bpf_map <a href="#id661"><span class="problematic" id="id662">*</span></a>map, struct task_struct <a href="#id663"><span class="problematic" id="id664">*</span></a>task, void <a href="#id665"><span class="problematic" id="id666">*</span></a>value, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Get a bpf_local_storage from the <em>task</em>.</p></li>
<li></li>
<li><p>Logically, it could be thought of as getting the value from</p></li>
<li><p>a <em>map</em> with <em>task</em> as the <strong>key</strong>.  From this</p></li>
<li><p>perspective,  the usage is not much different from</p></li>
<li><p><strong>bpf_map_lookup_elem</strong>(<em>map</em>, <strong>&amp;</strong><em>task</em>) except this</p></li>
<li><p>helper enforces the key must be an task_struct and the map must also</p></li>
<li><p>be a <strong>BPF_MAP_TYPE_TASK_STORAGE</strong>.</p></li>
<li></li>
<li><p>Underneath, the value is stored locally at <em>task</em> instead of</p></li>
<li><p>the <em>map</em>.  The <em>map</em> is used as the bpf-local-storage</p></li>
<li><p>“type”. The bpf-local-storage “type” (i.e. the <em>map</em>) is</p></li>
<li><p>searched against all bpf_local_storage residing at <em>task</em>.</p></li>
<li></li>
<li><p>An optional <em>flags</em> (<strong>BPF_LOCAL_STORAGE_GET_F_CREATE</strong>) can be</p></li>
<li><p>used such that a new bpf_local_storage will be</p></li>
<li><p>created if one does not exist.  <em>value</em> can be used</p></li>
<li><p>together with <strong>BPF_LOCAL_STORAGE_GET_F_CREATE</strong> to specify</p></li>
<li><p>the initial value of a bpf_local_storage.  If <em>value</em> is</p></li>
<li><p><strong>NULL</strong>, the new bpf_local_storage will be zero initialized.</p></li>
<li><p>Return</p></li>
<li><p>A bpf_local_storage pointer is returned on success.</p></li>
<li></li>
<li><p><strong>NULL</strong> if not found or there was an error in adding</p></li>
<li><p>a new bpf_local_storage.</p></li>
<li></li>
<li><p>long bpf_task_storage_delete(struct bpf_map <a href="#id667"><span class="problematic" id="id668">*</span></a>map, struct task_struct <a href="#id669"><span class="problematic" id="id670">*</span></a>task)</p></li>
<li><p>Description</p></li>
<li><p>Delete a bpf_local_storage from a <em>task</em>.</p></li>
<li><p>Return</p></li>
<li><p>0 on success.</p></li>
<li></li>
<li><p><strong>-ENOENT</strong> if the bpf_local_storage cannot be found.</p></li>
<li></li>
<li><p>struct task_struct <a href="#id671"><span class="problematic" id="id672">*</span></a>bpf_get_current_task_btf(void)</p></li>
<li><p>Description</p></li>
<li><p>Return a BTF pointer to the “current” task.</p></li>
<li><p>This pointer can also be used in helpers that accept an</p></li>
<li><p><em>ARG_PTR_TO_BTF_ID</em> of type <em>task_struct</em>.</p></li>
<li><p>Return</p></li>
<li><p>Pointer to the current task.</p></li>
<li></li>
<li><p>long bpf_bprm_opts_set(struct linux_binprm <a href="#id673"><span class="problematic" id="id674">*</span></a>bprm, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Set or clear certain options on <em>bprm</em>:</p></li>
<li></li>
<li><p><strong>BPF_F_BPRM_SECUREEXEC</strong> Set the secureexec bit</p></li>
<li><p>which sets the <strong>AT_SECURE</strong> auxv for glibc. The bit</p></li>
<li><p>is cleared if the flag is not specified.</p></li>
<li><p>Return</p></li>
<li><p><strong>-EINVAL</strong> if invalid <em>flags</em> are passed, zero otherwise.</p></li>
<li></li>
<li><p>u64 bpf_ktime_get_coarse_ns(void)</p></li>
<li><p>Description</p></li>
<li><p>Return a coarse-grained version of the time elapsed since</p></li>
<li><p>system boot, in nanoseconds. Does not include time the system</p></li>
<li><p>was suspended.</p></li>
<li></li>
<li><p>See: <strong>clock_gettime</strong>(<strong>CLOCK_MONOTONIC_COARSE</strong>)</p></li>
<li><p>Return</p></li>
<li><p>Current <em>ktime</em>.</p></li>
<li></li>
<li><p>long bpf_ima_inode_hash(struct inode <a href="#id675"><span class="problematic" id="id676">*</span></a>inode, void <a href="#id677"><span class="problematic" id="id678">*</span></a>dst, u32 size)</p></li>
<li><p>Description</p></li>
<li><p>Returns the stored IMA hash of the <em>inode</em> (if it’s avaialable).</p></li>
<li><p>If the hash is larger than <em>size</em>, then only <em>size</em></p></li>
<li><p>bytes will be copied to <em>dst</em></p></li>
<li><p>Return</p></li>
<li><p>The <strong>hash_algo</strong> is returned on success,</p></li>
<li><p><strong>-EOPNOTSUP</strong> if IMA is disabled or <strong>-EINVAL</strong> if</p></li>
<li><p>invalid arguments are passed.</p></li>
<li></li>
<li><p>struct socket <a href="#id679"><span class="problematic" id="id680">*</span></a>bpf_sock_from_file(struct file <a href="#id681"><span class="problematic" id="id682">*</span></a>file)</p></li>
<li><p>Description</p></li>
<li><p>If the given file represents a socket, returns the associated</p></li>
<li><p>socket.</p></li>
<li><p>Return</p></li>
<li><p>A pointer to a struct socket on success or NULL if the file is</p></li>
<li><p>not a socket.</p></li>
<li></li>
<li><p>long bpf_check_mtu(void <a href="#id683"><span class="problematic" id="id684">*</span></a>ctx, u32 ifindex, u32 <a href="#id685"><span class="problematic" id="id686">*</span></a>mtu_len, s32 len_diff, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>Check packet size against exceeding MTU of net device (based</p></li>
<li><p>on <em>ifindex</em>).  This helper will likely be used in combination</p></li>
<li><p>with helpers that adjust/change the packet size.</p></li>
<li></li>
<li><p>The argument <em>len_diff</em> can be used for querying with a planned</p></li>
<li><p>size change. This allows to check MTU prior to changing packet</p></li>
<li><p>ctx. Providing an <em>len_diff</em> adjustment that is larger than the</p></li>
<li><p>actual packet size (resulting in negative packet size) will in</p></li>
<li><p>principle not exceed the MTU, why it is not considered a</p></li>
<li><p>failure.  Other BPF-helpers are needed for performing the</p></li>
<li><p>planned size change, why the responsability for catch a negative</p></li>
<li><p>packet size belong in those helpers.</p></li>
<li></li>
<li><p>Specifying <em>ifindex</em> zero means the MTU check is performed</p></li>
<li><p>against the current net device.  This is practical if this isn’t</p></li>
<li><p>used prior to redirect.</p></li>
<li></li>
<li><p>On input <em>mtu_len</em> must be a valid pointer, else verifier will</p></li>
<li><p>reject BPF program.  If the value <em>mtu_len</em> is initialized to</p></li>
<li><p>zero then the ctx packet size is use.  When value <em>mtu_len</em> is</p></li>
<li><p>provided as input this specify the L3 length that the MTU check</p></li>
<li><p>is done against. Remember XDP and TC length operate at L2, but</p></li>
<li><p>this value is L3 as this correlate to MTU and IP-header tot_len</p></li>
<li><p>values which are L3 (similar behavior as bpf_fib_lookup).</p></li>
<li></li>
<li><p>The Linux kernel route table can configure MTUs on a more</p></li>
<li><p>specific per route level, which is not provided by this helper.</p></li>
<li><p>For route level MTU checks use the <strong>bpf_fib_lookup</strong>()</p></li>
<li><p>helper.</p></li>
<li></li>
<li><p><em>ctx</em> is either <strong>struct xdp_md</strong> for XDP programs or</p></li>
<li><p><strong>struct sk_buff</strong> for tc cls_act programs.</p></li>
<li></li>
<li><p>The <em>flags</em> argument can be a combination of one or more of the</p></li>
<li><p>following values:</p></li>
<li></li>
<li><p><strong>BPF_MTU_CHK_SEGS</strong></p></li>
<li><p>This flag will only works for <em>ctx</em> <strong>struct sk_buff</strong>.</p></li>
<li><p>If packet context contains extra packet segment buffers</p></li>
<li><p>(often knows as GSO skb), then MTU check is harder to</p></li>
<li><p>check at this point, because in transmit path it is</p></li>
<li><p>possible for the skb packet to get re-segmented</p></li>
<li><p>(depending on net device features).  This could still be</p></li>
<li><p>a MTU violation, so this flag enables performing MTU</p></li>
<li><p>check against segments, with a different violation</p></li>
<li><p>return code to tell it apart. Check cannot use len_diff.</p></li>
<li></li>
<li><p>On return <em>mtu_len</em> pointer contains the MTU value of the net</p></li>
<li><p>device.  Remember the net device configured MTU is the L3 size,</p></li>
<li><p>which is returned here and XDP and TC length operate at L2.</p></li>
<li><p>Helper take this into account for you, but remember when using</p></li>
<li><p>MTU value in your BPF-code.</p></li>
<li></li>
<li><p>Return</p></li>
<li><ul class="simple">
<li><p>0 on success, and populate MTU value in <em>mtu_len</em> pointer.</p></li>
</ul>
</li>
<li></li>
<li><ul class="simple">
<li><p>&lt; 0 if any input argument is invalid (<em>mtu_len</em> not updated)</p></li>
</ul>
</li>
<li></li>
<li><p>MTU violations return positive values, but also populate MTU</p></li>
<li><p>value in <em>mtu_len</em> pointer, as this can be needed for</p></li>
<li><p>implementing PMTU handing:</p></li>
<li></li>
<li><ul class="simple">
<li><p><strong>BPF_MTU_CHK_RET_FRAG_NEEDED</strong></p></li>
</ul>
</li>
<li><ul class="simple">
<li><p><strong>BPF_MTU_CHK_RET_SEGS_TOOBIG</strong></p></li>
</ul>
</li>
<li></li>
<li><p>long bpf_for_each_map_elem(struct bpf_map <a href="#id687"><span class="problematic" id="id688">*</span></a>map, void <a href="#id689"><span class="problematic" id="id690">*</span></a>callback_fn, void <a href="#id691"><span class="problematic" id="id692">*</span></a>callback_ctx, u64 flags)</p></li>
<li><p>Description</p></li>
<li><p>For each element in <strong>map</strong>, call <strong>callback_fn</strong> function with</p></li>
<li><p><strong>map</strong>, <strong>callback_ctx</strong> and other map-specific parameters.</p></li>
<li><p>The <strong>callback_fn</strong> should be a static function and</p></li>
<li><p>the <strong>callback_ctx</strong> should be a pointer to the stack.</p></li>
<li><p>The <strong>flags</strong> is used to control certain aspects of the helper.</p></li>
<li><p>Currently, the <strong>flags</strong> must be 0.</p></li>
<li></li>
<li><p>The following are a list of supported map types and their</p></li>
<li><p>respective expected callback signatures:</p></li>
<li></li>
<li><p>BPF_MAP_TYPE_HASH, BPF_MAP_TYPE_PERCPU_HASH,</p></li>
<li><p>BPF_MAP_TYPE_LRU_HASH, BPF_MAP_TYPE_LRU_PERCPU_HASH,</p></li>
<li><p>BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY</p></li>
<li></li>
<li><p>long (*callback_fn)(struct bpf_map *map, const void *key, void *value, void *ctx);</p></li>
<li></li>
<li><p>For per_cpu maps, the map_value is the value on the cpu where the</p></li>
<li><p>bpf_prog is running.</p></li>
<li></li>
<li><p>If <strong>callback_fn</strong> return 0, the helper will continue to the next</p></li>
<li><p>element. If return value is 1, the helper will skip the rest of</p></li>
<li><p>elements and return. Other return values are not used now.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>The number of traversed map elements for success, <strong>-EINVAL</strong> for</p></li>
<li><p>invalid <strong>flags</strong>.</p></li>
<li></li>
<li><p>long bpf_snprintf(char <a href="#id693"><span class="problematic" id="id694">*</span></a>str, u32 str_size, const char <a href="#id695"><span class="problematic" id="id696">*</span></a>fmt, u64 <a href="#id697"><span class="problematic" id="id698">*</span></a>data, u32 data_len)</p></li>
<li><p>Description</p></li>
<li><p>Outputs a string into the <strong>str</strong> buffer of size <strong>str_size</strong></p></li>
<li><p>based on a format string stored in a read-only map pointed by</p></li>
<li><p><strong>fmt</strong>.</p></li>
<li></li>
<li><p>Each format specifier in <strong>fmt</strong> corresponds to one u64 element</p></li>
<li><p>in the <strong>data</strong> array. For strings and pointers where pointees</p></li>
<li><p>are accessed, only the pointer values are stored in the <em>data</em></p></li>
<li><p>array. The <em>data_len</em> is the size of <em>data</em> in bytes.</p></li>
<li></li>
<li><p>Formats <strong>%s</strong> and <strong>%p{i,I}{4,6}</strong> require to read kernel</p></li>
<li><p>memory. Reading kernel memory may fail due to either invalid</p></li>
<li><p>address or valid address but requiring a major memory fault. If</p></li>
<li><p>reading kernel memory fails, the string for <strong>%s</strong> will be an</p></li>
<li><p>empty string, and the ip address for <strong>%p{i,I}{4,6}</strong> will be 0.</p></li>
<li><p>Not returning error to bpf program is consistent with what</p></li>
<li><p><strong>bpf_trace_printk</strong>() does for now.</p></li>
<li></li>
<li><p>Return</p></li>
<li><p>The strictly positive length of the formatted string, including</p></li>
<li><p>the trailing zero character. If the return value is greater than</p></li>
<li><p><strong>str_size</strong>, <strong>str</strong> contains a truncated string, guaranteed to</p></li>
<li><p>be zero-terminated except when <strong>str_size</strong> is 0.</p></li>
<li></li>
<li><p>Or <strong>-EBUSY</strong> if the per-CPU memory copy buffer is busy.</p></li>
<li></li>
<li><p>long bpf_sys_bpf(u32 cmd, void <a href="#id699"><span class="problematic" id="id700">*</span></a>attr, u32 attr_size)</p></li>
<li><p>Description</p></li>
<li><p>Execute bpf syscall with given arguments.</p></li>
<li><p>Return</p></li>
<li><p>A syscall result.</p></li>
<li></li>
<li><p>long bpf_btf_find_by_name_kind(char <a href="#id701"><span class="problematic" id="id702">*</span></a>name, int name_sz, u32 kind, int flags)</p></li>
<li><p>Description</p></li>
<li><p>Find BTF type with given name and kind in vmlinux BTF or in module’s BTFs.</p></li>
<li><p>Return</p></li>
<li><p>Returns btf_id and btf_obj_fd in lower and upper 32 bits.</p></li>
<li></li>
<li><p>long bpf_sys_close(u32 fd)</p></li>
<li><p>Description</p></li>
<li><p>Execute close syscall for given FD.</p></li>
<li><p>Return</p></li>
<li><p>A syscall result.</p></li>
</ul>
<p><a href="#id703"><span class="problematic" id="id704">*</span></a>/</p>
</dd>
<dt>#define __BPF_FUNC_MAPPER(FN)           </dt><dd><p>FN(unspec),                     FN(map_lookup_elem),            FN(map_update_elem),            FN(map_delete_elem),            FN(probe_read),                 FN(ktime_get_ns),               FN(trace_printk),               FN(get_prandom_u32),            FN(get_smp_processor_id),       FN(skb_store_bytes),            FN(l3_csum_replace),            FN(l4_csum_replace),            FN(tail_call),                  FN(clone_redirect),             FN(get_current_pid_tgid),       FN(get_current_uid_gid),        FN(get_current_comm),           FN(get_cgroup_classid),         FN(skb_vlan_push),              FN(skb_vlan_pop),               FN(skb_get_tunnel_key),         FN(skb_set_tunnel_key),         FN(perf_event_read),            FN(redirect),                   FN(get_route_realm),            FN(perf_event_output),          FN(skb_load_bytes),             FN(get_stackid),                FN(csum_diff),                  FN(skb_get_tunnel_opt),         FN(skb_set_tunnel_opt),         FN(skb_change_proto),           FN(skb_change_type),            FN(skb_under_cgroup),           FN(get_hash_recalc),            FN(get_current_task),           FN(probe_write_user),           FN(current_task_under_cgroup),  FN(skb_change_tail),            FN(skb_pull_data),              FN(csum_update),                FN(set_hash_invalid),           FN(get_numa_node_id),           FN(skb_change_head),            FN(xdp_adjust_head),            FN(probe_read_str),             FN(get_socket_cookie),          FN(get_socket_uid),             FN(set_hash),                   FN(setsockopt),                 FN(skb_adjust_room),            FN(redirect_map),               FN(sk_redirect_map),            FN(sock_map_update),            FN(xdp_adjust_meta),            FN(perf_event_read_value),      FN(perf_prog_read_value),       FN(getsockopt),                 FN(override_return),            FN(sock_ops_cb_flags_set),      FN(msg_redirect_map),           FN(msg_apply_bytes),            FN(msg_cork_bytes),             FN(msg_pull_data),              FN(bind),                       FN(xdp_adjust_tail),            FN(skb_get_xfrm_state),         FN(get_stack),                  FN(skb_load_bytes_relative),    FN(fib_lookup),                 FN(sock_hash_update),           FN(msg_redirect_hash),          FN(sk_redirect_hash),           FN(lwt_push_encap),             FN(lwt_seg6_store_bytes),       FN(lwt_seg6_adjust_srh),        FN(lwt_seg6_action),            FN(rc_repeat),                  FN(rc_keydown),                 FN(skb_cgroup_id),              FN(get_current_cgroup_id),      FN(get_local_storage),          FN(sk_select_reuseport),        FN(skb_ancestor_cgroup_id),     FN(sk_lookup_tcp),              FN(sk_lookup_udp),              FN(sk_release),                 FN(map_push_elem),              FN(map_pop_elem),               FN(map_peek_elem),              FN(msg_push_data),              FN(msg_pop_data),               FN(rc_pointer_rel),             FN(spin_lock),                  FN(spin_unlock),                FN(sk_fullsock),                FN(tcp_sock),                   FN(skb_ecn_set_ce),             FN(get_listener_sock),          FN(skc_lookup_tcp),             FN(tcp_check_syncookie),        FN(sysctl_get_name),            FN(sysctl_get_current_value),   FN(sysctl_get_new_value),       FN(sysctl_set_new_value),       FN(strtol),                     FN(strtoul),                    FN(sk_storage_get),             FN(sk_storage_delete),          FN(send_signal),                FN(tcp_gen_syncookie),          FN(skb_output),                 FN(probe_read_user),            FN(probe_read_kernel),          FN(probe_read_user_str),        FN(probe_read_kernel_str),      FN(tcp_send_ack),               FN(send_signal_thread),         FN(jiffies64),                  FN(read_branch_records),        FN(get_ns_current_pid_tgid),    FN(xdp_output),                 FN(get_netns_cookie),           FN(get_current_ancestor_cgroup_id),     FN(sk_assign),                  FN(ktime_get_boot_ns),          FN(seq_printf),                 FN(seq_write),                  FN(sk_cgroup_id),               FN(sk_ancestor_cgroup_id),      FN(ringbuf_output),             FN(ringbuf_reserve),            FN(ringbuf_submit),             FN(ringbuf_discard),            FN(ringbuf_query),              FN(csum_level),                 FN(skc_to_tcp6_sock),           FN(skc_to_tcp_sock),            FN(skc_to_tcp_timewait_sock),   FN(skc_to_tcp_request_sock),    FN(skc_to_udp6_sock),           FN(get_task_stack),             FN(load_hdr_opt),               FN(store_hdr_opt),              FN(reserve_hdr_opt),            FN(inode_storage_get),          FN(inode_storage_delete),       FN(d_path),                     FN(copy_from_user),             FN(snprintf_btf),               FN(seq_printf_btf),             FN(skb_cgroup_classid),         FN(redirect_neigh),             FN(per_cpu_ptr),                FN(this_cpu_ptr),               FN(redirect_peer),              FN(task_storage_get),           FN(task_storage_delete),        FN(get_current_task_btf),       FN(bprm_opts_set),              FN(ktime_get_coarse_ns),        FN(ima_inode_hash),             FN(sock_from_file),             FN(check_mtu),                  FN(for_each_map_elem),          FN(snprintf),                   FN(sys_bpf),                    FN(btf_find_by_name_kind),      FN(sys_close),                  /* <a href="#id705"><span class="problematic" id="id706">*</span></a>/</p>
</dd>
<dt>/* integer value in ‘imm’ field of BPF_CALL instruction selects which helper</dt><dd><ul class="simple">
<li><p>function eBPF program intends to call</p></li>
</ul>
<p><a href="#id707"><span class="problematic" id="id708">*</span></a>/</p>
</dd>
</dl>
<p>#define __BPF_ENUM_FN(x) <a href="#id1243"><span class="problematic" id="id1244">BPF_FUNC_</span></a> ## x
enum bpf_func_id {</p>
<blockquote>
<div><p>__BPF_FUNC_MAPPER(__BPF_ENUM_FN)
__BPF_FUNC_MAX_ID,</p>
</div></blockquote>
<p>};</p>
<p>/* All flags used by eBPF helper functions, placed here. <a href="#id709"><span class="problematic" id="id710">*</span></a>/</p>
<p>/* BPF_FUNC_skb_store_bytes flags. <a href="#id711"><span class="problematic" id="id712">*</span></a>/
enum {</p>
<blockquote>
<div><p>BPF_F_RECOMPUTE_CSUM            = (1ULL &lt;&lt; 0),
BPF_F_INVALIDATE_HASH           = (1ULL &lt;&lt; 1),</p>
</div></blockquote>
<p>};</p>
<dl>
<dt>/* BPF_FUNC_l3_csum_replace and BPF_FUNC_l4_csum_replace flags.</dt><dd><ul class="simple">
<li><p>First 4 bits are for passing the header field size.</p></li>
</ul>
<p><a href="#id713"><span class="problematic" id="id714">*</span></a>/</p>
</dd>
<dt>enum {</dt><dd><p>BPF_F_HDR_FIELD_MASK            = 0xfULL,</p>
</dd>
</dl>
<p>};</p>
<p>/* BPF_FUNC_l4_csum_replace flags. <a href="#id715"><span class="problematic" id="id716">*</span></a>/
enum {</p>
<blockquote>
<div><p>BPF_F_PSEUDO_HDR                = (1ULL &lt;&lt; 4),
BPF_F_MARK_MANGLED_0            = (1ULL &lt;&lt; 5),
BPF_F_MARK_ENFORCE              = (1ULL &lt;&lt; 6),</p>
</div></blockquote>
<p>};</p>
<p>/* BPF_FUNC_clone_redirect and BPF_FUNC_redirect flags. <a href="#id717"><span class="problematic" id="id718">*</span></a>/
enum {</p>
<blockquote>
<div><p>BPF_F_INGRESS                   = (1ULL &lt;&lt; 0),</p>
</div></blockquote>
<p>};</p>
<p>/* BPF_FUNC_skb_set_tunnel_key and BPF_FUNC_skb_get_tunnel_key flags. <a href="#id719"><span class="problematic" id="id720">*</span></a>/
enum {</p>
<blockquote>
<div><p>BPF_F_TUNINFO_IPV6              = (1ULL &lt;&lt; 0),</p>
</div></blockquote>
<p>};</p>
<p>/* flags for both BPF_FUNC_get_stackid and BPF_FUNC_get_stack. <a href="#id721"><span class="problematic" id="id722">*</span></a>/
enum {</p>
<blockquote>
<div><p>BPF_F_SKIP_FIELD_MASK           = 0xffULL,
BPF_F_USER_STACK                = (1ULL &lt;&lt; 8),</p>
</div></blockquote>
<dl class="simple">
<dt>/* flags used by BPF_FUNC_get_stackid only. <a href="#id723"><span class="problematic" id="id724">*</span></a>/</dt><dd><p>BPF_F_FAST_STACK_CMP            = (1ULL &lt;&lt; 9),
BPF_F_REUSE_STACKID             = (1ULL &lt;&lt; 10),</p>
</dd>
<dt>/* flags used by BPF_FUNC_get_stack only. <a href="#id725"><span class="problematic" id="id726">*</span></a>/</dt><dd><p>BPF_F_USER_BUILD_ID             = (1ULL &lt;&lt; 11),</p>
</dd>
</dl>
<p>};</p>
<p>/* BPF_FUNC_skb_set_tunnel_key flags. <a href="#id727"><span class="problematic" id="id728">*</span></a>/
enum {</p>
<blockquote>
<div><p>BPF_F_ZERO_CSUM_TX              = (1ULL &lt;&lt; 1),
BPF_F_DONT_FRAGMENT             = (1ULL &lt;&lt; 2),
BPF_F_SEQ_NUMBER                = (1ULL &lt;&lt; 3),</p>
</div></blockquote>
<p>};</p>
<dl>
<dt>/* BPF_FUNC_perf_event_output, BPF_FUNC_perf_event_read and</dt><dd><ul class="simple">
<li><p>BPF_FUNC_perf_event_read_value flags.</p></li>
</ul>
<p><a href="#id729"><span class="problematic" id="id730">*</span></a>/</p>
</dd>
<dt>enum {</dt><dd><p>BPF_F_INDEX_MASK                = 0xffffffffULL,
BPF_F_CURRENT_CPU               = BPF_F_INDEX_MASK,</p>
</dd>
<dt>/* BPF_FUNC_perf_event_output for sk_buff input context. <a href="#id731"><span class="problematic" id="id732">*</span></a>/</dt><dd><p>BPF_F_CTXLEN_MASK               = (0xfffffULL &lt;&lt; 32),</p>
</dd>
</dl>
<p>};</p>
<p>/* Current network namespace <a href="#id733"><span class="problematic" id="id734">*</span></a>/
enum {</p>
<blockquote>
<div><p>BPF_F_CURRENT_NETNS             = (-1L),</p>
</div></blockquote>
<p>};</p>
<p>/* BPF_FUNC_csum_level level values. <a href="#id735"><span class="problematic" id="id736">*</span></a>/
enum {</p>
<blockquote>
<div><p>BPF_CSUM_LEVEL_QUERY,
BPF_CSUM_LEVEL_INC,
BPF_CSUM_LEVEL_DEC,
BPF_CSUM_LEVEL_RESET,</p>
</div></blockquote>
<p>};</p>
<p>/* BPF_FUNC_skb_adjust_room flags. <a href="#id737"><span class="problematic" id="id738">*</span></a>/
enum {</p>
<blockquote>
<div><p>BPF_F_ADJ_ROOM_FIXED_GSO        = (1ULL &lt;&lt; 0),
BPF_F_ADJ_ROOM_ENCAP_L3_IPV4    = (1ULL &lt;&lt; 1),
BPF_F_ADJ_ROOM_ENCAP_L3_IPV6    = (1ULL &lt;&lt; 2),
BPF_F_ADJ_ROOM_ENCAP_L4_GRE     = (1ULL &lt;&lt; 3),
BPF_F_ADJ_ROOM_ENCAP_L4_UDP     = (1ULL &lt;&lt; 4),
BPF_F_ADJ_ROOM_NO_CSUM_RESET    = (1ULL &lt;&lt; 5),
BPF_F_ADJ_ROOM_ENCAP_L2_ETH     = (1ULL &lt;&lt; 6),</p>
</div></blockquote>
<p>};</p>
<dl class="simple">
<dt>enum {</dt><dd><p>BPF_ADJ_ROOM_ENCAP_L2_MASK      = 0xff,
BPF_ADJ_ROOM_ENCAP_L2_SHIFT     = 56,</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>#define BPF_F_ADJ_ROOM_ENCAP_L2(len)    (((__u64)len &amp; </dt><dd><blockquote>
<div><p>BPF_ADJ_ROOM_ENCAP_L2_MASK) </p>
</div></blockquote>
<p>&lt;&lt; BPF_ADJ_ROOM_ENCAP_L2_SHIFT)</p>
</dd>
</dl>
<p>/* BPF_FUNC_sysctl_get_name flags. <a href="#id739"><span class="problematic" id="id740">*</span></a>/
enum {</p>
<blockquote>
<div><p>BPF_F_SYSCTL_BASE_NAME          = (1ULL &lt;&lt; 0),</p>
</div></blockquote>
<p>};</p>
<p>/* BPF_FUNC_&lt;kernel_obj&gt;_storage_get flags <a href="#id741"><span class="problematic" id="id742">*</span></a>/
enum {</p>
<blockquote>
<div><p>BPF_LOCAL_STORAGE_GET_F_CREATE  = (1ULL &lt;&lt; 0),
/* BPF_SK_STORAGE_GET_F_CREATE is only kept for backward compatibility</p>
<blockquote>
<div><ul class="simple">
<li><p>and BPF_LOCAL_STORAGE_GET_F_CREATE must be used instead.</p></li>
</ul>
<p><a href="#id743"><span class="problematic" id="id744">*</span></a>/</p>
</div></blockquote>
<p>BPF_SK_STORAGE_GET_F_CREATE  = BPF_LOCAL_STORAGE_GET_F_CREATE,</p>
</div></blockquote>
<p>};</p>
<p>/* BPF_FUNC_read_branch_records flags. <a href="#id745"><span class="problematic" id="id746">*</span></a>/
enum {</p>
<blockquote>
<div><p>BPF_F_GET_BRANCH_RECORDS_SIZE   = (1ULL &lt;&lt; 0),</p>
</div></blockquote>
<p>};</p>
<dl>
<dt>/* BPF_FUNC_bpf_ringbuf_commit, BPF_FUNC_bpf_ringbuf_discard, and</dt><dd><ul class="simple">
<li><p>BPF_FUNC_bpf_ringbuf_output flags.</p></li>
</ul>
<p><a href="#id747"><span class="problematic" id="id748">*</span></a>/</p>
</dd>
<dt>enum {</dt><dd><p>BPF_RB_NO_WAKEUP                = (1ULL &lt;&lt; 0),
BPF_RB_FORCE_WAKEUP             = (1ULL &lt;&lt; 1),</p>
</dd>
</dl>
<p>};</p>
<p>/* BPF_FUNC_bpf_ringbuf_query flags <a href="#id749"><span class="problematic" id="id750">*</span></a>/
enum {</p>
<blockquote>
<div><p>BPF_RB_AVAIL_DATA = 0,
BPF_RB_RING_SIZE = 1,
BPF_RB_CONS_POS = 2,
BPF_RB_PROD_POS = 3,</p>
</div></blockquote>
<p>};</p>
<p>/* BPF ring buffer constants <a href="#id751"><span class="problematic" id="id752">*</span></a>/
enum {</p>
<blockquote>
<div><p>BPF_RINGBUF_BUSY_BIT            = (1U &lt;&lt; 31),
BPF_RINGBUF_DISCARD_BIT         = (1U &lt;&lt; 30),
BPF_RINGBUF_HDR_SZ              = 8,</p>
</div></blockquote>
<p>};</p>
<p>/* BPF_FUNC_sk_assign flags in bpf_sk_lookup context. <a href="#id753"><span class="problematic" id="id754">*</span></a>/
enum {</p>
<blockquote>
<div><p>BPF_SK_LOOKUP_F_REPLACE         = (1ULL &lt;&lt; 0),
BPF_SK_LOOKUP_F_NO_REUSEPORT    = (1ULL &lt;&lt; 1),</p>
</div></blockquote>
<p>};</p>
<p>/* Mode for BPF_FUNC_skb_adjust_room helper. <a href="#id755"><span class="problematic" id="id756">*</span></a>/
enum bpf_adj_room_mode {</p>
<blockquote>
<div><p>BPF_ADJ_ROOM_NET,
BPF_ADJ_ROOM_MAC,</p>
</div></blockquote>
<p>};</p>
<p>/* Mode for BPF_FUNC_skb_load_bytes_relative helper. <a href="#id757"><span class="problematic" id="id758">*</span></a>/
enum bpf_hdr_start_off {</p>
<blockquote>
<div><p>BPF_HDR_START_MAC,
BPF_HDR_START_NET,</p>
</div></blockquote>
<p>};</p>
<p>/* Encapsulation type for BPF_FUNC_lwt_push_encap helper. <a href="#id759"><span class="problematic" id="id760">*</span></a>/
enum bpf_lwt_encap_mode {</p>
<blockquote>
<div><p>BPF_LWT_ENCAP_SEG6,
BPF_LWT_ENCAP_SEG6_INLINE,
BPF_LWT_ENCAP_IP,</p>
</div></blockquote>
<p>};</p>
<p>/* Flags for bpf_bprm_opts_set helper <a href="#id761"><span class="problematic" id="id762">*</span></a>/
enum {</p>
<blockquote>
<div><p>BPF_F_BPRM_SECUREEXEC   = (1ULL &lt;&lt; 0),</p>
</div></blockquote>
<p>};</p>
<p>/* Flags for bpf_redirect_map helper <a href="#id763"><span class="problematic" id="id764">*</span></a>/
enum {</p>
<blockquote>
<div><p>BPF_F_BROADCAST         = (1ULL &lt;&lt; 3),
BPF_F_EXCLUDE_INGRESS   = (1ULL &lt;&lt; 4),</p>
</div></blockquote>
<p>};</p>
<p>#define __bpf_md_ptr(type, name)        union {                                 </p>
<blockquote>
<div><p>type name;                      __u64 :64;                      </p>
</div></blockquote>
<p>} __attribute__((aligned(8)))</p>
<dl>
<dt>/* user accessible mirror of in-kernel sk_buff.</dt><dd><ul class="simple">
<li><p>new fields can only be added to the end of this structure</p></li>
</ul>
<p><a href="#id765"><span class="problematic" id="id766">*</span></a>/</p>
</dd>
<dt>struct __sk_buff {</dt><dd><p>__u32 len;
__u32 pkt_type;
__u32 mark;
__u32 queue_mapping;
__u32 protocol;
__u32 vlan_present;
__u32 vlan_tci;
__u32 vlan_proto;
__u32 priority;
__u32 ingress_ifindex;
__u32 ifindex;
__u32 tc_index;
__u32 cb[5];
__u32 hash;
__u32 tc_classid;
__u32 data;
__u32 data_end;
__u32 napi_id;</p>
<p>/* Accessed by BPF_PROG_TYPE_sk_skb types from here to … <em>/
__u32 family;
__u32 remote_ip4;       /</em> Stored in network byte order <em>/
__u32 local_ip4;        /</em> Stored in network byte order <em>/
__u32 remote_ip6[4];    /</em> Stored in network byte order <em>/
__u32 local_ip6[4];     /</em> Stored in network byte order <em>/
__u32 remote_port;      /</em> Stored in network byte order <em>/
__u32 local_port;       /</em> stored in host byte order <em>/
/</em> … here. <a href="#id767"><span class="problematic" id="id768">*</span></a>/</p>
<p>__u32 data_meta;
__bpf_md_ptr(struct bpf_flow_keys <a href="#id769"><span class="problematic" id="id770">*</span></a>, flow_keys);
__u64 tstamp;
__u32 wire_len;
__u32 gso_segs;
__bpf_md_ptr(struct bpf_sock <a href="#id771"><span class="problematic" id="id772">*</span></a>, sk);
__u32 gso_size;</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>struct bpf_tunnel_key {</dt><dd><p>__u32 tunnel_id;
union {</p>
<blockquote>
<div><p>__u32 remote_ipv4;
__u32 remote_ipv6[4];</p>
</div></blockquote>
<p>};
__u8 tunnel_tos;
__u8 tunnel_ttl;
__u16 tunnel_ext;       /* Padding, future use. <a href="#id773"><span class="problematic" id="id774">*</span></a>/
__u32 tunnel_label;</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>/* user accessible mirror of in-kernel xfrm_state.</dt><dd><ul class="simple">
<li><p>new fields can only be added to the end of this structure</p></li>
</ul>
<p><a href="#id775"><span class="problematic" id="id776">*</span></a>/</p>
</dd>
<dt>struct bpf_xfrm_state {</dt><dd><p>__u32 reqid;
__u32 spi;      /* Stored in network byte order <em>/
__u16 family;
__u16 ext;      /</em> Padding, future use. <a href="#id777"><span class="problematic" id="id778">*</span></a>/
union {</p>
<blockquote>
<div><p>__u32 remote_ipv4;      /* Stored in network byte order <em>/
__u32 remote_ipv6[4];   /</em> Stored in network byte order <a href="#id779"><span class="problematic" id="id780">*</span></a>/</p>
</div></blockquote>
<p>};</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>/* Generic BPF return codes which all BPF program types may support.</dt><dd><ul class="simple">
<li><p>The values are binary compatible with their TC_ACT_* counter-part to</p></li>
<li><p>provide backwards compatibility with existing SCHED_CLS and SCHED_ACT</p></li>
<li><p>programs.</p></li>
<li></li>
<li><p>XDP is handled seprately, see XDP_*.</p></li>
</ul>
<p><a href="#id781"><span class="problematic" id="id782">*</span></a>/</p>
</dd>
<dt>enum bpf_ret_code {</dt><dd><p>BPF_OK = 0,
/* 1 reserved <em>/
BPF_DROP = 2,
/</em> 3-6 reserved <em>/
BPF_REDIRECT = 7,
/</em> &gt;127 are reserved for prog type specific return codes.</p>
<blockquote>
<div><ul class="simple">
<li></li>
<li><p>BPF_LWT_REROUTE: used by BPF_PROG_TYPE_LWT_IN and</p></li>
<li><p>BPF_PROG_TYPE_LWT_XMIT to indicate that skb had been</p></li>
<li><p>changed and should be routed based on its new L3 header.</p></li>
<li><p>(This is an L3 redirect, as opposed to L2 redirect</p></li>
<li><p>represented by BPF_REDIRECT above).</p></li>
</ul>
<p><a href="#id783"><span class="problematic" id="id784">*</span></a>/</p>
</div></blockquote>
<p>BPF_LWT_REROUTE = 128,</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>struct bpf_sock {</dt><dd><p>__u32 bound_dev_if;
__u32 family;
__u32 type;
__u32 protocol;
__u32 mark;
__u32 priority;
/* IP address also allows 1 and 2 bytes access <em>/
__u32 src_ip4;
__u32 src_ip6[4];
__u32 src_port;         /</em> host byte order <em>/
__u32 dst_port;         /</em> network byte order <a href="#id785"><span class="problematic" id="id786">*</span></a>/
__u32 dst_ip4;
__u32 dst_ip6[4];
__u32 state;
__s32 rx_queue_mapping;</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>struct bpf_tcp_sock {</dt><dd><p>__u32 snd_cwnd;         /* Sending congestion window            <em>/
__u32 srtt_us;          /</em> smoothed round trip time &lt;&lt; 3 in usecs <em>/
__u32 rtt_min;
__u32 snd_ssthresh;     /</em> Slow start size threshold            <em>/
__u32 rcv_nxt;          /</em> What we want to receive next         <em>/
__u32 snd_nxt;          /</em> Next sequence we send                <em>/
__u32 snd_una;          /</em> First byte we want an ack for        <em>/
__u32 mss_cache;        /</em> Cached effective mss, not including SACKS <em>/
__u32 ecn_flags;        /</em> ECN status bits.                     <em>/
__u32 rate_delivered;   /</em> saved rate sample: packets delivered <em>/
__u32 rate_interval_us; /</em> saved rate sample: time elapsed <em>/
__u32 packets_out;      /</em> Packets which are “in flight”        <em>/
__u32 retrans_out;      /</em> Retransmitted packets out            <em>/
__u32 total_retrans;    /</em> Total retransmits for entire connection <em>/
__u32 segs_in;          /</em> RFC4898 tcpEStatsPerfSegsIn</p>
<blockquote>
<div><ul class="simple">
<li><p>total number of segments in.</p></li>
</ul>
<p><a href="#id787"><span class="problematic" id="id788">*</span></a>/</p>
</div></blockquote>
<dl>
<dt>__u32 data_segs_in;     /* RFC4898 tcpEStatsPerfDataSegsIn</dt><dd><ul class="simple">
<li><p>total number of data segments in.</p></li>
</ul>
<p><a href="#id789"><span class="problematic" id="id790">*</span></a>/</p>
</dd>
<dt>__u32 segs_out;         /* RFC4898 tcpEStatsPerfSegsOut</dt><dd><ul class="simple">
<li><p>The total number of segments sent.</p></li>
</ul>
<p><a href="#id791"><span class="problematic" id="id792">*</span></a>/</p>
</dd>
<dt>__u32 data_segs_out;    /* RFC4898 tcpEStatsPerfDataSegsOut</dt><dd><ul class="simple">
<li><p>total number of data segments sent.</p></li>
</ul>
<p><a href="#id793"><span class="problematic" id="id794">*</span></a>/</p>
</dd>
</dl>
<p>__u32 lost_out;         /* Lost packets                 <em>/
__u32 sacked_out;       /</em> SACK’d packets                       <em>/
__u64 bytes_received;   /</em> RFC4898 tcpEStatsAppHCThruOctetsReceived</p>
<blockquote>
<div><ul class="simple">
<li><p>sum(delta(rcv_nxt)), or how many bytes</p></li>
<li><p>were acked.</p></li>
</ul>
<p><a href="#id795"><span class="problematic" id="id796">*</span></a>/</p>
</div></blockquote>
<dl>
<dt>__u64 bytes_acked;      /* RFC4898 tcpEStatsAppHCThruOctetsAcked</dt><dd><ul class="simple">
<li><p>sum(delta(snd_una)), or how many bytes</p></li>
<li><p>were acked.</p></li>
</ul>
<p><a href="#id797"><span class="problematic" id="id798">*</span></a>/</p>
</dd>
<dt>__u32 dsack_dups;       /* RFC4898 tcpEStatsStackDSACKDups</dt><dd><ul class="simple">
<li><p>total number of DSACK blocks received</p></li>
</ul>
<p><a href="#id799"><span class="problematic" id="id800">*</span></a>/</p>
</dd>
</dl>
<p>__u32 delivered;        /* Total data packets delivered incl. rexmits <em>/
__u32 delivered_ce;     /</em> Like the above but only ECE marked packets <em>/
__u32 icsk_retransmits; /</em> Number of unrecovered [RTO] timeouts <a href="#id801"><span class="problematic" id="id802">*</span></a>/</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>struct bpf_sock_tuple {</dt><dd><dl>
<dt>union {</dt><dd><dl class="simple">
<dt>struct {</dt><dd><p>__be32 saddr;
__be32 daddr;
__be16 sport;
__be16 dport;</p>
</dd>
</dl>
<p>} ipv4;
struct {</p>
<blockquote>
<div><p>__be32 saddr[4];
__be32 daddr[4];
__be16 sport;
__be16 dport;</p>
</div></blockquote>
<p>} ipv6;</p>
</dd>
</dl>
<p>};</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>struct bpf_xdp_sock {</dt><dd><p>__u32 queue_id;</p>
</dd>
</dl>
<p>};</p>
<p>#define XDP_PACKET_HEADROOM 256</p>
<dl>
<dt>/* User return codes for XDP prog type.</dt><dd><ul class="simple">
<li><p>A valid XDP program must return one of these defined values. All other</p></li>
<li><p>return codes are reserved for future use. Unknown return codes will</p></li>
<li><p>result in packet drops and a warning via bpf_warn_invalid_xdp_action().</p></li>
</ul>
<p><a href="#id803"><span class="problematic" id="id804">*</span></a>/</p>
</dd>
<dt>enum xdp_action {</dt><dd><p>XDP_ABORTED = 0,
XDP_DROP,
XDP_PASS,
XDP_TX,
XDP_REDIRECT,</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>/* user accessible metadata for XDP packet hook</dt><dd><ul class="simple">
<li><p>new fields must be added to the end of this structure</p></li>
</ul>
<p><a href="#id805"><span class="problematic" id="id806">*</span></a>/</p>
</dd>
<dt>struct xdp_md {</dt><dd><p>__u32 data;
__u32 data_end;
__u32 data_meta;
/* Below access go through struct xdp_rxq_info <em>/
__u32 ingress_ifindex; /</em> rxq-&gt;dev-&gt;ifindex <em>/
__u32 rx_queue_index;  /</em> rxq-&gt;queue_index  <a href="#id807"><span class="problematic" id="id808">*</span></a>/</p>
<p>__u32 egress_ifindex;  /* txq-&gt;dev-&gt;ifindex <a href="#id809"><span class="problematic" id="id810">*</span></a>/</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>/* DEVMAP map-value layout</dt><dd><ul class="simple">
<li></li>
<li><p>The struct data-layout of map-value is a configuration interface.</p></li>
<li><p>New members can only be added to the end of this structure.</p></li>
</ul>
<p><a href="#id811"><span class="problematic" id="id812">*</span></a>/</p>
</dd>
<dt>struct bpf_devmap_val {</dt><dd><p>__u32 ifindex;   /* device index <a href="#id813"><span class="problematic" id="id814">*</span></a>/
union {</p>
<blockquote>
<div><p>int   fd;  /* prog fd on map write <em>/
__u32 id;  /</em> prog id on map read <a href="#id815"><span class="problematic" id="id816">*</span></a>/</p>
</div></blockquote>
<p>} bpf_prog;</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>/* CPUMAP map-value layout</dt><dd><ul class="simple">
<li></li>
<li><p>The struct data-layout of map-value is a configuration interface.</p></li>
<li><p>New members can only be added to the end of this structure.</p></li>
</ul>
<p><a href="#id817"><span class="problematic" id="id818">*</span></a>/</p>
</dd>
<dt>struct bpf_cpumap_val {</dt><dd><p>__u32 qsize;    /* queue size to remote target CPU <a href="#id819"><span class="problematic" id="id820">*</span></a>/
union {</p>
<blockquote>
<div><p>int   fd;       /* prog fd on map write <em>/
__u32 id;       /</em> prog id on map read <a href="#id821"><span class="problematic" id="id822">*</span></a>/</p>
</div></blockquote>
<p>} bpf_prog;</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>enum sk_action {</dt><dd><p>SK_DROP = 0,
SK_PASS,</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>/* user accessible metadata for SK_MSG packet hook, new fields must</dt><dd><ul class="simple">
<li><p>be added to the end of this structure</p></li>
</ul>
<p><a href="#id823"><span class="problematic" id="id824">*</span></a>/</p>
</dd>
<dt>struct sk_msg_md {</dt><dd><p>__bpf_md_ptr(void <a href="#id825"><span class="problematic" id="id826">*</span></a>, data);
__bpf_md_ptr(void <a href="#id827"><span class="problematic" id="id828">*</span></a>, data_end);</p>
<p>__u32 family;
__u32 remote_ip4;       /* Stored in network byte order <em>/
__u32 local_ip4;        /</em> Stored in network byte order <em>/
__u32 remote_ip6[4];    /</em> Stored in network byte order <em>/
__u32 local_ip6[4];     /</em> Stored in network byte order <em>/
__u32 remote_port;      /</em> Stored in network byte order <em>/
__u32 local_port;       /</em> stored in host byte order <em>/
__u32 size;             /</em> Total size of sk_msg <a href="#id829"><span class="problematic" id="id830">*</span></a>/</p>
<p>__bpf_md_ptr(struct bpf_sock <em>, sk); /</em> current socket <a href="#id831"><span class="problematic" id="id832">*</span></a>/</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>struct sk_reuseport_md {</dt><dd><dl>
<dt>/*</dt><dd><ul class="simple">
<li><p>Start of directly accessible data. It begins from</p></li>
<li><p>the tcp/udp header.</p></li>
</ul>
<p><a href="#id833"><span class="problematic" id="id834">*</span></a>/</p>
</dd>
</dl>
<p>__bpf_md_ptr(void <em>, data);
/</em> End of directly accessible data <em>/
__bpf_md_ptr(void *, data_end);
/</em></p>
<blockquote>
<div><ul class="simple">
<li><p>Total length of packet (starting from the tcp/udp header).</p></li>
<li><p>Note that the directly accessible bytes (data_end - data)</p></li>
<li><p>could be less than this “len”.  Those bytes could be</p></li>
<li><p>indirectly read by a helper “bpf_skb_load_bytes()”.</p></li>
</ul>
<p><a href="#id835"><span class="problematic" id="id836">*</span></a>/</p>
</div></blockquote>
<p>__u32 len;
/*</p>
<blockquote>
<div><ul class="simple">
<li><p>Eth protocol in the mac header (network byte order). e.g.</p></li>
<li><p>ETH_P_IP(0x0800) and ETH_P_IPV6(0x86DD)</p></li>
</ul>
<p><a href="#id837"><span class="problematic" id="id838">*</span></a>/</p>
</div></blockquote>
<p>__u32 eth_protocol;
__u32 ip_protocol;      /* IP protocol. e.g. IPPROTO_TCP, IPPROTO_UDP <em>/
__u32 bind_inany;       /</em> Is sock bound to an INANY address? <em>/
__u32 hash;             /</em> A hash of the packet 4 tuples <em>/
/</em> When reuse-&gt;migrating_sk is NULL, it is selecting a sk for the</p>
<blockquote>
<div><ul class="simple">
<li><p>new incoming connection request (e.g. selecting a listen sk for</p></li>
<li><p>the received SYN in the TCP case).  reuse-&gt;sk is one of the sk</p></li>
<li><p>in the reuseport group. The bpf prog can use reuse-&gt;sk to learn</p></li>
<li><p>the local listening ip/port without looking into the skb.</p></li>
<li></li>
<li><p>When reuse-&gt;migrating_sk is not NULL, reuse-&gt;sk is closed and</p></li>
<li><p>reuse-&gt;migrating_sk is the socket that needs to be migrated</p></li>
<li><p>to another listening socket.  migrating_sk could be a fullsock</p></li>
<li><p>sk that is fully established or a reqsk that is in-the-middle</p></li>
<li><p>of 3-way handshake.</p></li>
</ul>
<p><a href="#id839"><span class="problematic" id="id840">*</span></a>/</p>
</div></blockquote>
<p>__bpf_md_ptr(struct bpf_sock <a href="#id841"><span class="problematic" id="id842">*</span></a>, sk);
__bpf_md_ptr(struct bpf_sock <a href="#id843"><span class="problematic" id="id844">*</span></a>, migrating_sk);</p>
</dd>
</dl>
<p>};</p>
<p>#define BPF_TAG_SIZE    8</p>
<dl class="simple">
<dt>struct bpf_prog_info {</dt><dd><p>__u32 type;
__u32 id;
__u8  tag[BPF_TAG_SIZE];
__u32 jited_prog_len;
__u32 xlated_prog_len;
__aligned_u64 jited_prog_insns;
__aligned_u64 xlated_prog_insns;
__u64 load_time;        /* ns since boottime <em>/
__u32 created_by_uid;
__u32 nr_map_ids;
__aligned_u64 map_ids;
char name[BPF_OBJ_NAME_LEN];
__u32 ifindex;
__u32 gpl_compatible:1;
__u32 :31; /</em> alignment pad <a href="#id845"><span class="problematic" id="id846">*</span></a>/
__u64 netns_dev;
__u64 netns_ino;
__u32 nr_jited_ksyms;
__u32 nr_jited_func_lens;
__aligned_u64 jited_ksyms;
__aligned_u64 jited_func_lens;
__u32 btf_id;
__u32 func_info_rec_size;
__aligned_u64 func_info;
__u32 nr_func_info;
__u32 nr_line_info;
__aligned_u64 line_info;
__aligned_u64 jited_line_info;
__u32 nr_jited_line_info;
__u32 line_info_rec_size;
__u32 jited_line_info_rec_size;
__u32 nr_prog_tags;
__aligned_u64 prog_tags;
__u64 run_time_ns;
__u64 run_cnt;
__u64 recursion_misses;</p>
</dd>
</dl>
<p>} __attribute__((aligned(8)));</p>
<dl class="simple">
<dt>struct bpf_map_info {</dt><dd><p>__u32 type;
__u32 id;
__u32 key_size;
__u32 value_size;
__u32 max_entries;
__u32 map_flags;
char  name[BPF_OBJ_NAME_LEN];
__u32 ifindex;
__u32 btf_vmlinux_value_type_id;
__u64 netns_dev;
__u64 netns_ino;
__u32 btf_id;
__u32 btf_key_type_id;
__u32 btf_value_type_id;</p>
</dd>
</dl>
<p>} __attribute__((aligned(8)));</p>
<dl class="simple">
<dt>struct bpf_btf_info {</dt><dd><p>__aligned_u64 btf;
__u32 btf_size;
__u32 id;
__aligned_u64 name;
__u32 name_len;
__u32 kernel_btf;</p>
</dd>
</dl>
<p>} __attribute__((aligned(8)));</p>
<dl>
<dt>struct bpf_link_info {</dt><dd><p>__u32 type;
__u32 id;
__u32 prog_id;
union {</p>
<blockquote>
<div><dl class="simple">
<dt>struct {</dt><dd><p>__aligned_u64 tp_name; /* in/out: tp_name buffer ptr <em>/
__u32 tp_name_len;     /</em> in/out: tp_name buffer len <a href="#id847"><span class="problematic" id="id848">*</span></a>/</p>
</dd>
</dl>
<p>} raw_tracepoint;
struct {</p>
<blockquote>
<div><p>__u32 attach_type;
__u32 target_obj_id; /* prog_id for PROG_EXT, otherwise btf object id <em>/
__u32 target_btf_id; /</em> BTF type id inside the object <a href="#id849"><span class="problematic" id="id850">*</span></a>/</p>
</div></blockquote>
<p>} tracing;
struct {</p>
<blockquote>
<div><p>__u64 cgroup_id;
__u32 attach_type;</p>
</div></blockquote>
<p>} cgroup;
struct {</p>
<blockquote>
<div><p>__aligned_u64 target_name; /* in/out: target_name buffer ptr <em>/
__u32 target_name_len;     /</em> in/out: target_name buffer len <a href="#id851"><span class="problematic" id="id852">*</span></a>/
union {</p>
<blockquote>
<div><dl class="simple">
<dt>struct {</dt><dd><p>__u32 map_id;</p>
</dd>
</dl>
<p>} map;</p>
</div></blockquote>
<p>};</p>
</div></blockquote>
<p>} iter;
struct  {</p>
<blockquote>
<div><p>__u32 netns_ino;
__u32 attach_type;</p>
</div></blockquote>
<p>} netns;
struct {</p>
<blockquote>
<div><p>__u32 ifindex;</p>
</div></blockquote>
<p>} xdp;</p>
</div></blockquote>
<p>};</p>
</dd>
</dl>
<p>} __attribute__((aligned(8)));</p>
<dl>
<dt>/* User bpf_sock_addr struct to access socket fields and sockaddr struct passed</dt><dd><ul class="simple">
<li><p>by user and intended to be used by socket (e.g. to bind to, depends on</p></li>
<li><p>attach type).</p></li>
</ul>
<p><a href="#id853"><span class="problematic" id="id854">*</span></a>/</p>
</dd>
<dt>struct bpf_sock_addr {</dt><dd><p>__u32 user_family;      /* Allows 4-byte read, but no write. <em>/
__u32 user_ip4;         /</em> Allows 1,2,4-byte read and 4-byte write.</p>
<blockquote>
<div><ul class="simple">
<li><p>Stored in network byte order.</p></li>
</ul>
<p><a href="#id855"><span class="problematic" id="id856">*</span></a>/</p>
</div></blockquote>
<dl>
<dt>__u32 user_ip6[4];      /* Allows 1,2,4,8-byte read and 4,8-byte write.</dt><dd><ul class="simple">
<li><p>Stored in network byte order.</p></li>
</ul>
<p><a href="#id857"><span class="problematic" id="id858">*</span></a>/</p>
</dd>
<dt>__u32 user_port;        /* Allows 1,2,4-byte read and 4-byte write.</dt><dd><ul class="simple">
<li><p>Stored in network byte order</p></li>
</ul>
<p><a href="#id859"><span class="problematic" id="id860">*</span></a>/</p>
</dd>
</dl>
<p>__u32 family;           /* Allows 4-byte read, but no write <em>/
__u32 type;             /</em> Allows 4-byte read, but no write <em>/
__u32 protocol;         /</em> Allows 4-byte read, but no write <em>/
__u32 msg_src_ip4;      /</em> Allows 1,2,4-byte read and 4-byte write.</p>
<blockquote>
<div><ul class="simple">
<li><p>Stored in network byte order.</p></li>
</ul>
<p><a href="#id861"><span class="problematic" id="id862">*</span></a>/</p>
</div></blockquote>
<dl>
<dt>__u32 msg_src_ip6[4];   /* Allows 1,2,4,8-byte read and 4,8-byte write.</dt><dd><ul class="simple">
<li><p>Stored in network byte order.</p></li>
</ul>
<p><a href="#id863"><span class="problematic" id="id864">*</span></a>/</p>
</dd>
</dl>
<p>__bpf_md_ptr(struct bpf_sock <a href="#id865"><span class="problematic" id="id866">*</span></a>, sk);</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>/* User bpf_sock_ops struct to access socket values and specify request ops</dt><dd><ul class="simple">
<li><p>and their replies.</p></li>
<li><p>Some of this fields are in network (bigendian) byte order and may need</p></li>
<li><p>to be converted before use (bpf_ntohl() defined in samples/bpf/bpf_endian.h).</p></li>
<li><p>New fields can only be added at the end of this structure</p></li>
</ul>
<p><a href="#id867"><span class="problematic" id="id868">*</span></a>/</p>
</dd>
<dt>struct bpf_sock_ops {</dt><dd><p>__u32 op;
union {</p>
<blockquote>
<div><p>__u32 args[4];          /* Optionally passed to bpf program <em>/
__u32 reply;            /</em> Returned by bpf program          <em>/
__u32 replylong[4];     /</em> Optionally returned by bpf prog  <a href="#id869"><span class="problematic" id="id870">*</span></a>/</p>
</div></blockquote>
<p>};
__u32 family;
__u32 remote_ip4;       /* Stored in network byte order <em>/
__u32 local_ip4;        /</em> Stored in network byte order <em>/
__u32 remote_ip6[4];    /</em> Stored in network byte order <em>/
__u32 local_ip6[4];     /</em> Stored in network byte order <em>/
__u32 remote_port;      /</em> Stored in network byte order <em>/
__u32 local_port;       /</em> stored in host byte order <em>/
__u32 is_fullsock;      /</em> Some TCP fields are only valid if</p>
<blockquote>
<div><ul class="simple">
<li><p>there is a full socket. If not, the</p></li>
<li><p>fields read as zero.</p></li>
</ul>
<p><a href="#id871"><span class="problematic" id="id872">*</span></a>/</p>
</div></blockquote>
<p>__u32 snd_cwnd;
__u32 srtt_us;          /* Averaged RTT &lt;&lt; 3 in usecs <em>/
__u32 bpf_sock_ops_cb_flags; /</em> flags defined in uapi/linux/tcp.h <em>/
__u32 state;
__u32 rtt_min;
__u32 snd_ssthresh;
__u32 rcv_nxt;
__u32 snd_nxt;
__u32 snd_una;
__u32 mss_cache;
__u32 ecn_flags;
__u32 rate_delivered;
__u32 rate_interval_us;
__u32 packets_out;
__u32 retrans_out;
__u32 total_retrans;
__u32 segs_in;
__u32 data_segs_in;
__u32 segs_out;
__u32 data_segs_out;
__u32 lost_out;
__u32 sacked_out;
__u32 sk_txhash;
__u64 bytes_received;
__u64 bytes_acked;
__bpf_md_ptr(struct bpf_sock *, sk);
/</em> [skb_data, skb_data_end) covers the whole TCP header.</p>
<blockquote>
<div><ul class="simple">
<li></li>
<li><p>BPF_SOCK_OPS_PARSE_HDR_OPT_CB: The packet received</p></li>
<li><p>BPF_SOCK_OPS_HDR_OPT_LEN_CB:   Not useful because the</p></li>
<li><p>header has not been written.</p></li>
<li><p>BPF_SOCK_OPS_WRITE_HDR_OPT_CB: The header and options have</p></li>
<li><p>been written so far.</p></li>
<li><p>BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB:  The SYNACK that concludes</p></li>
<li><p>the 3WHS.</p></li>
<li><p>BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB: The ACK that concludes</p></li>
<li><p>the 3WHS.</p></li>
<li></li>
<li><p>bpf_load_hdr_opt() can also be used to read a particular option.</p></li>
</ul>
<p><a href="#id873"><span class="problematic" id="id874">*</span></a>/</p>
</div></blockquote>
<p>__bpf_md_ptr(void <em>, skb_data);
__bpf_md_ptr(void *, skb_data_end);
__u32 skb_len;          /</em> The total length of a packet.</p>
<blockquote>
<div><ul class="simple">
<li><p>It includes the header, options,</p></li>
<li><p>and payload.</p></li>
</ul>
<p><a href="#id875"><span class="problematic" id="id876">*</span></a>/</p>
</div></blockquote>
<dl>
<dt>__u32 skb_tcp_flags;    /* tcp_flags of the header.  It provides</dt><dd><ul class="simple">
<li><p>an easy way to check for tcp_flags</p></li>
<li><p>without parsing skb_data.</p></li>
<li></li>
<li><p>In particular, the skb_tcp_flags</p></li>
<li><p>will still be available in</p></li>
<li><p>BPF_SOCK_OPS_HDR_OPT_LEN even though</p></li>
<li><p>the outgoing header has not</p></li>
<li><p>been written yet.</p></li>
</ul>
<p><a href="#id877"><span class="problematic" id="id878">*</span></a>/</p>
</dd>
</dl>
</dd>
</dl>
<p>};</p>
<p>/* Definitions for bpf_sock_ops_cb_flags <a href="#id879"><span class="problematic" id="id880">*</span></a>/
enum {</p>
<blockquote>
<div><p>BPF_SOCK_OPS_RTO_CB_FLAG        = (1&lt;&lt;0),
BPF_SOCK_OPS_RETRANS_CB_FLAG    = (1&lt;&lt;1),
BPF_SOCK_OPS_STATE_CB_FLAG      = (1&lt;&lt;2),
BPF_SOCK_OPS_RTT_CB_FLAG        = (1&lt;&lt;3),
/* Call bpf for all received TCP headers.  The bpf prog will be</p>
<blockquote>
<div><ul class="simple">
<li><p>called under sock_ops-&gt;op == BPF_SOCK_OPS_PARSE_HDR_OPT_CB</p></li>
<li></li>
<li><p>Please refer to the comment in BPF_SOCK_OPS_PARSE_HDR_OPT_CB</p></li>
<li><p>for the header option related helpers that will be useful</p></li>
<li><p>to the bpf programs.</p></li>
<li></li>
<li><p>It could be used at the client/active side (i.e. connect() side)</p></li>
<li><p>when the server told it that the server was in syncookie</p></li>
<li><p>mode and required the active side to resend the bpf-written</p></li>
<li><p>options.  The active side can keep writing the bpf-options until</p></li>
<li><p>it received a valid packet from the server side to confirm</p></li>
<li><p>the earlier packet (and options) has been received.  The later</p></li>
<li><p>example patch is using it like this at the active side when the</p></li>
<li><p>server is in syncookie mode.</p></li>
<li></li>
<li><p>The bpf prog will usually turn this off in the common cases.</p></li>
</ul>
<p><a href="#id881"><span class="problematic" id="id882">*</span></a>/</p>
</div></blockquote>
<p>BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG  = (1&lt;&lt;4),
/* Call bpf when kernel has received a header option that</p>
<blockquote>
<div><ul class="simple">
<li><p>the kernel cannot handle.  The bpf prog will be called under</p></li>
<li><p>sock_ops-&gt;op == BPF_SOCK_OPS_PARSE_HDR_OPT_CB.</p></li>
<li></li>
<li><p>Please refer to the comment in BPF_SOCK_OPS_PARSE_HDR_OPT_CB</p></li>
<li><p>for the header option related helpers that will be useful</p></li>
<li><p>to the bpf programs.</p></li>
</ul>
<p><a href="#id883"><span class="problematic" id="id884">*</span></a>/</p>
</div></blockquote>
<p>BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG = (1&lt;&lt;5),
/* Call bpf when the kernel is writing header options for the</p>
<blockquote>
<div><ul class="simple">
<li><p>outgoing packet.  The bpf prog will first be called</p></li>
<li><p>to reserve space in a skb under</p></li>
<li><p>sock_ops-&gt;op == BPF_SOCK_OPS_HDR_OPT_LEN_CB.  Then</p></li>
<li><p>the bpf prog will be called to write the header option(s)</p></li>
<li><p>under sock_ops-&gt;op == BPF_SOCK_OPS_WRITE_HDR_OPT_CB.</p></li>
<li></li>
<li><p>Please refer to the comment in BPF_SOCK_OPS_HDR_OPT_LEN_CB</p></li>
<li><p>and BPF_SOCK_OPS_WRITE_HDR_OPT_CB for the header option</p></li>
<li><p>related helpers that will be useful to the bpf programs.</p></li>
<li></li>
<li><p>The kernel gets its chance to reserve space and write</p></li>
<li><p>options first before the BPF program does.</p></li>
</ul>
<p><a href="#id885"><span class="problematic" id="id886">*</span></a>/</p>
</div></blockquote>
<p>BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG = (1&lt;&lt;6),</p>
</div></blockquote>
<dl class="simple">
<dt>/* Mask of all currently supported cb flags <a href="#id887"><span class="problematic" id="id888">*</span></a>/</dt><dd><p>BPF_SOCK_OPS_ALL_CB_FLAGS       = 0x7F,</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>/* List of known BPF sock_ops operators.</dt><dd><ul class="simple">
<li><p>New entries can only be added at the end</p></li>
</ul>
<p><a href="#id889"><span class="problematic" id="id890">*</span></a>/</p>
</dd>
<dt>enum {</dt><dd><p>BPF_SOCK_OPS_VOID,
BPF_SOCK_OPS_TIMEOUT_INIT,      /* Should return SYN-RTO value to use or</p>
<blockquote>
<div><ul class="simple">
<li><p>-1 if default value should be used</p></li>
</ul>
<p><a href="#id891"><span class="problematic" id="id892">*</span></a>/</p>
</div></blockquote>
<dl>
<dt>BPF_SOCK_OPS_RWND_INIT,         /* Should return initial advertized</dt><dd><ul class="simple">
<li><p>window (in packets) or -1 if default</p></li>
<li><p>value should be used</p></li>
</ul>
<p><a href="#id893"><span class="problematic" id="id894">*</span></a>/</p>
</dd>
<dt>BPF_SOCK_OPS_TCP_CONNECT_CB,    /* Calls BPF program right before an</dt><dd><ul class="simple">
<li><p>active connection is initialized</p></li>
</ul>
<p><a href="#id895"><span class="problematic" id="id896">*</span></a>/</p>
</dd>
<dt>BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB,     /* Calls BPF program when an</dt><dd><ul class="simple">
<li><p>active connection is</p></li>
<li><p>established</p></li>
</ul>
<p><a href="#id897"><span class="problematic" id="id898">*</span></a>/</p>
</dd>
<dt>BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB,    /* Calls BPF program when a</dt><dd><ul class="simple">
<li><p>passive connection is</p></li>
<li><p>established</p></li>
</ul>
<p><a href="#id899"><span class="problematic" id="id900">*</span></a>/</p>
</dd>
<dt>BPF_SOCK_OPS_NEEDS_ECN,         /* If connection’s congestion control</dt><dd><ul class="simple">
<li><p>needs ECN</p></li>
</ul>
<p><a href="#id901"><span class="problematic" id="id902">*</span></a>/</p>
</dd>
<dt>BPF_SOCK_OPS_BASE_RTT,          /* Get base RTT. The correct value is</dt><dd><ul class="simple">
<li><p>based on the path and may be</p></li>
<li><p>dependent on the congestion control</p></li>
<li><p>algorithm. In general it indicates</p></li>
<li><p>a congestion threshold. RTTs above</p></li>
<li><p>this indicate congestion</p></li>
</ul>
<p><a href="#id903"><span class="problematic" id="id904">*</span></a>/</p>
</dd>
<dt>BPF_SOCK_OPS_RTO_CB,            /* Called when an RTO has triggered.</dt><dd><ul class="simple">
<li><p>Arg1: value of icsk_retransmits</p></li>
<li><p>Arg2: value of icsk_rto</p></li>
<li><p>Arg3: whether RTO has expired</p></li>
</ul>
<p><a href="#id905"><span class="problematic" id="id906">*</span></a>/</p>
</dd>
<dt>BPF_SOCK_OPS_RETRANS_CB,        /* Called when skb is retransmitted.</dt><dd><ul class="simple">
<li><p>Arg1: sequence number of 1st byte</p></li>
<li><p>Arg2: # segments</p></li>
<li><p>Arg3: return value of</p></li>
<li><p>tcp_transmit_skb (0 =&gt; success)</p></li>
</ul>
<p><a href="#id907"><span class="problematic" id="id908">*</span></a>/</p>
</dd>
<dt>BPF_SOCK_OPS_STATE_CB,          /* Called when TCP changes state.</dt><dd><ul class="simple">
<li><p>Arg1: old_state</p></li>
<li><p>Arg2: new_state</p></li>
</ul>
<p><a href="#id909"><span class="problematic" id="id910">*</span></a>/</p>
</dd>
<dt>BPF_SOCK_OPS_TCP_LISTEN_CB,     /* Called on listen(2), right after</dt><dd><ul class="simple">
<li><p>socket transition to LISTEN state.</p></li>
</ul>
<p><a href="#id911"><span class="problematic" id="id912">*</span></a>/</p>
</dd>
<dt>BPF_SOCK_OPS_RTT_CB,            /* Called on every RTT.</dt><dd><p><a href="#id913"><span class="problematic" id="id914">*</span></a>/</p>
</dd>
<dt>BPF_SOCK_OPS_PARSE_HDR_OPT_CB,  /* Parse the header option.</dt><dd><ul class="simple">
<li><p>It will be called to handle</p></li>
<li><p>the packets received at</p></li>
<li><p>an already established</p></li>
<li><p>connection.</p></li>
<li></li>
<li><p>sock_ops-&gt;skb_data:</p></li>
<li><p>Referring to the received skb.</p></li>
<li><p>It covers the TCP header only.</p></li>
<li></li>
<li><p>bpf_load_hdr_opt() can also</p></li>
<li><p>be used to search for a</p></li>
<li><p>particular option.</p></li>
</ul>
<p><a href="#id915"><span class="problematic" id="id916">*</span></a>/</p>
</dd>
<dt>BPF_SOCK_OPS_HDR_OPT_LEN_CB,    /* Reserve space for writing the</dt><dd><ul class="simple">
<li><p>header option later in</p></li>
<li><p>BPF_SOCK_OPS_WRITE_HDR_OPT_CB.</p></li>
<li><p>Arg1: bool want_cookie. (in</p></li>
<li><p>writing SYNACK only)</p></li>
<li></li>
<li><p>sock_ops-&gt;skb_data:</p></li>
<li><p>Not available because no header has</p></li>
<li><p>been written yet.</p></li>
<li></li>
<li><p>sock_ops-&gt;skb_tcp_flags:</p></li>
<li><p>The tcp_flags of the</p></li>
<li><p>outgoing skb. (e.g. SYN, ACK, FIN).</p></li>
<li></li>
<li><p>bpf_reserve_hdr_opt() should</p></li>
<li><p>be used to reserve space.</p></li>
</ul>
<p><a href="#id917"><span class="problematic" id="id918">*</span></a>/</p>
</dd>
<dt>BPF_SOCK_OPS_WRITE_HDR_OPT_CB,  /* Write the header options</dt><dd><ul class="simple">
<li><p>Arg1: bool want_cookie. (in</p></li>
<li><p>writing SYNACK only)</p></li>
<li></li>
<li><p>sock_ops-&gt;skb_data:</p></li>
<li><p>Referring to the outgoing skb.</p></li>
<li><p>It covers the TCP header</p></li>
<li><p>that has already been written</p></li>
<li><p>by the kernel and the</p></li>
<li><p>earlier bpf-progs.</p></li>
<li></li>
<li><p>sock_ops-&gt;skb_tcp_flags:</p></li>
<li><p>The tcp_flags of the outgoing</p></li>
<li><p>skb. (e.g. SYN, ACK, FIN).</p></li>
<li></li>
<li><p>bpf_store_hdr_opt() should</p></li>
<li><p>be used to write the</p></li>
<li><p>option.</p></li>
<li></li>
<li><p>bpf_load_hdr_opt() can also</p></li>
<li><p>be used to search for a</p></li>
<li><p>particular option that</p></li>
<li><p>has already been written</p></li>
<li><p>by the kernel or the</p></li>
<li><p>earlier bpf-progs.</p></li>
</ul>
<p><a href="#id919"><span class="problematic" id="id920">*</span></a>/</p>
</dd>
</dl>
</dd>
</dl>
<p>};</p>
<dl>
<dt>/* List of TCP states. There is a build check in net/ipv4/tcp.c to detect</dt><dd><ul class="simple">
<li><p>changes between the TCP and BPF versions. Ideally this should never happen.</p></li>
<li><p>If it does, we need to add code to convert them before calling</p></li>
<li><p>the BPF sock_ops function.</p></li>
</ul>
<p><a href="#id921"><span class="problematic" id="id922">*</span></a>/</p>
</dd>
<dt>enum {</dt><dd><p>BPF_TCP_ESTABLISHED = 1,
BPF_TCP_SYN_SENT,
BPF_TCP_SYN_RECV,
BPF_TCP_FIN_WAIT1,
BPF_TCP_FIN_WAIT2,
BPF_TCP_TIME_WAIT,
BPF_TCP_CLOSE,
BPF_TCP_CLOSE_WAIT,
BPF_TCP_LAST_ACK,
BPF_TCP_LISTEN,
BPF_TCP_CLOSING,        /* Now a valid state <a href="#id923"><span class="problematic" id="id924">*</span></a>/
BPF_TCP_NEW_SYN_RECV,</p>
<p>BPF_TCP_MAX_STATES      /* Leave at the end! <a href="#id925"><span class="problematic" id="id926">*</span></a>/</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>enum {</dt><dd><p>TCP_BPF_IW              = 1001, /* Set TCP initial congestion window <em>/
TCP_BPF_SNDCWND_CLAMP   = 1002, /</em> Set sndcwnd_clamp <em>/
TCP_BPF_DELACK_MAX      = 1003, /</em> Max delay ack in usecs <em>/
TCP_BPF_RTO_MIN         = 1004, /</em> Min delay ack in usecs <em>/
/</em> Copy the SYN pkt to optval</p>
<blockquote>
<div><ul class="simple">
<li></li>
<li><p>BPF_PROG_TYPE_SOCK_OPS only.  It is similar to the</p></li>
<li><p>bpf_getsockopt(TCP_SAVED_SYN) but it does not limit</p></li>
<li><p>to only getting from the saved_syn.  It can either get the</p></li>
<li><p>syn packet from:</p></li>
<li></li>
<li><ol class="arabic simple">
<li><p>the just-received SYN packet (only available when writing the</p></li>
</ol>
</li>
<li><p>SYNACK).  It will be useful when it is not necessary to</p></li>
<li><p>save the SYN packet for latter use.  It is also the only way</p></li>
<li><p>to get the SYN during syncookie mode because the syn</p></li>
<li><p>packet cannot be saved during syncookie.</p></li>
<li></li>
<li><p>OR</p></li>
<li></li>
<li><ol class="arabic simple" start="2">
<li><p>the earlier saved syn which was done by</p></li>
</ol>
</li>
<li><p>bpf_setsockopt(TCP_SAVE_SYN).</p></li>
<li></li>
<li><p>The bpf_getsockopt(TCP_BPF_SYN*) option will hide where the</p></li>
<li><p>SYN packet is obtained.</p></li>
<li></li>
<li><p>If the bpf-prog does not need the IP[46] header,  the</p></li>
<li><p>bpf-prog can avoid parsing the IP header by using</p></li>
<li><p>TCP_BPF_SYN.  Otherwise, the bpf-prog can get both</p></li>
<li><p>IP[46] and TCP header by using TCP_BPF_SYN_IP.</p></li>
<li></li>
<li><p>&gt;0: Total number of bytes copied</p></li>
<li><p>-ENOSPC: Not enough space in optval. Only optlen number of</p></li>
<li><p>bytes is copied.</p></li>
<li><p>-ENOENT: The SYN skb is not available now and the earlier SYN pkt</p></li>
<li><p>is not saved by setsockopt(TCP_SAVE_SYN).</p></li>
</ul>
<p><a href="#id927"><span class="problematic" id="id928">*</span></a>/</p>
</div></blockquote>
<p>TCP_BPF_SYN             = 1005, /* Copy the TCP header <em>/
TCP_BPF_SYN_IP          = 1006, /</em> Copy the IP[46] and TCP header <em>/
TCP_BPF_SYN_MAC         = 1007, /</em> Copy the MAC, IP[46], and TCP header <a href="#id929"><span class="problematic" id="id930">*</span></a>/</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>enum {</dt><dd><p>BPF_LOAD_HDR_OPT_TCP_SYN = (1ULL &lt;&lt; 0),</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>/* args[0] value during BPF_SOCK_OPS_HDR_OPT_LEN_CB and</dt><dd><ul class="simple">
<li><p>BPF_SOCK_OPS_WRITE_HDR_OPT_CB.</p></li>
</ul>
<p><a href="#id931"><span class="problematic" id="id932">*</span></a>/</p>
</dd>
<dt>enum {</dt><dd><dl>
<dt>BPF_WRITE_HDR_TCP_CURRENT_MSS = 1,      /* Kernel is finding the</dt><dd><ul class="simple">
<li><p>total option spaces</p></li>
<li><p>required for an established</p></li>
<li><p>sk in order to calculate the</p></li>
<li><p>MSS.  No skb is actually</p></li>
<li><p>sent.</p></li>
</ul>
<p><a href="#id933"><span class="problematic" id="id934">*</span></a>/</p>
</dd>
<dt>BPF_WRITE_HDR_TCP_SYNACK_COOKIE = 2,    /* Kernel is in syncookie mode</dt><dd><ul class="simple">
<li><p>when sending a SYN.</p></li>
</ul>
<p><a href="#id935"><span class="problematic" id="id936">*</span></a>/</p>
</dd>
</dl>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>struct bpf_perf_event_value {</dt><dd><p>__u64 counter;
__u64 enabled;
__u64 running;</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>enum {</dt><dd><p>BPF_DEVCG_ACC_MKNOD     = (1ULL &lt;&lt; 0),
BPF_DEVCG_ACC_READ      = (1ULL &lt;&lt; 1),
BPF_DEVCG_ACC_WRITE     = (1ULL &lt;&lt; 2),</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>enum {</dt><dd><p>BPF_DEVCG_DEV_BLOCK     = (1ULL &lt;&lt; 0),
BPF_DEVCG_DEV_CHAR      = (1ULL &lt;&lt; 1),</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>struct bpf_cgroup_dev_ctx {</dt><dd><p>/* access_type encoded as (BPF_DEVCG_ACC_* &lt;&lt; 16) | BPF_DEVCG_DEV_* <a href="#id937"><span class="problematic" id="id938">*</span></a>/
__u32 access_type;
__u32 major;
__u32 minor;</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>struct bpf_raw_tracepoint_args {</dt><dd><p>__u64 args[0];</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>/* DIRECT:  Skip the FIB rules and go to FIB table associated with device</dt><dd><ul class="simple">
<li><p>OUTPUT:  Do lookup from egress perspective; default is ingress</p></li>
</ul>
<p><a href="#id939"><span class="problematic" id="id940">*</span></a>/</p>
</dd>
<dt>enum {</dt><dd><p>BPF_FIB_LOOKUP_DIRECT  = (1U &lt;&lt; 0),
BPF_FIB_LOOKUP_OUTPUT  = (1U &lt;&lt; 1),</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>enum {</dt><dd><p>BPF_FIB_LKUP_RET_SUCCESS,      /* lookup successful <em>/
BPF_FIB_LKUP_RET_BLACKHOLE,    /</em> dest is blackholed; can be dropped <em>/
BPF_FIB_LKUP_RET_UNREACHABLE,  /</em> dest is unreachable; can be dropped <em>/
BPF_FIB_LKUP_RET_PROHIBIT,     /</em> dest not allowed; can be dropped <em>/
BPF_FIB_LKUP_RET_NOT_FWDED,    /</em> packet is not forwarded <em>/
BPF_FIB_LKUP_RET_FWD_DISABLED, /</em> fwding is not enabled on ingress <em>/
BPF_FIB_LKUP_RET_UNSUPP_LWT,   /</em> fwd requires encapsulation <em>/
BPF_FIB_LKUP_RET_NO_NEIGH,     /</em> no neighbor entry for nh <em>/
BPF_FIB_LKUP_RET_FRAG_NEEDED,  /</em> fragmentation required to fwd <a href="#id941"><span class="problematic" id="id942">*</span></a>/</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>struct bpf_fib_lookup {</dt><dd><dl>
<dt>/* input:  network family for lookup (AF_INET, AF_INET6)</dt><dd><ul class="simple">
<li><p>output: network family of egress nexthop</p></li>
</ul>
<p><a href="#id943"><span class="problematic" id="id944">*</span></a>/</p>
</dd>
</dl>
<p>__u8    family;</p>
<p>/* set if lookup is to consider L4 data - e.g., FIB rules <a href="#id945"><span class="problematic" id="id946">*</span></a>/
__u8    l4_protocol;
__be16  sport;
__be16  dport;</p>
<dl>
<dt>union { /* used for MTU check <a href="#id947"><span class="problematic" id="id948">*</span></a>/</dt><dd><p>/* input to lookup <em>/
__u16   tot_len; /</em> L3 length from network hdr (iph-&gt;tot_len) <a href="#id949"><span class="problematic" id="id950">*</span></a>/</p>
<p>/* output: MTU value <a href="#id951"><span class="problematic" id="id952">*</span></a>/
__u16   mtu_result;</p>
</dd>
</dl>
<p>};
/* input: L3 device index for lookup</p>
<blockquote>
<div><ul class="simple">
<li><p>output: device index from FIB lookup</p></li>
</ul>
<p><a href="#id953"><span class="problematic" id="id954">*</span></a>/</p>
</div></blockquote>
<p>__u32   ifindex;</p>
<dl>
<dt>union {</dt><dd><p>/* inputs to lookup <em>/
__u8    tos;            /</em> AF_INET  <em>/
__be32  flowinfo;       /</em> AF_INET6, flow_label + priority <a href="#id955"><span class="problematic" id="id956">*</span></a>/</p>
<p>/* output: metric of fib result (IPv4/IPv6 only) <a href="#id957"><span class="problematic" id="id958">*</span></a>/
__u32   rt_metric;</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>union {</dt><dd><p>__be32          ipv4_src;
__u32           ipv6_src[4];  /* in6_addr; network order <a href="#id959"><span class="problematic" id="id960">*</span></a>/</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>/* input to bpf_fib_lookup, ipv{4,6}_dst is destination address in</dt><dd><ul class="simple">
<li><p>network header. output: bpf_fib_lookup sets to gateway address</p></li>
<li><p>if FIB lookup returns gateway route</p></li>
</ul>
<p><a href="#id961"><span class="problematic" id="id962">*</span></a>/</p>
</dd>
<dt>union {</dt><dd><p>__be32          ipv4_dst;
__u32           ipv6_dst[4];  /* in6_addr; network order <a href="#id963"><span class="problematic" id="id964">*</span></a>/</p>
</dd>
</dl>
<p>};</p>
<p>/* output <em>/
__be16  h_vlan_proto;
__be16  h_vlan_TCI;
__u8    smac[6];     /</em> ETH_ALEN <em>/
__u8    dmac[6];     /</em> ETH_ALEN <a href="#id965"><span class="problematic" id="id966">*</span></a>/</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>struct bpf_redir_neigh {</dt><dd><p>/* network family for lookup (AF_INET, AF_INET6) <em>/
__u32 nh_family;
/</em> network address of nexthop; skips fib lookup to find gateway <a href="#id967"><span class="problematic" id="id968">*</span></a>/
union {</p>
<blockquote>
<div><p>__be32          ipv4_nh;
__u32           ipv6_nh[4];  /* in6_addr; network order <a href="#id969"><span class="problematic" id="id970">*</span></a>/</p>
</div></blockquote>
<p>};</p>
</dd>
</dl>
<p>};</p>
<p>/* bpf_check_mtu flags*/
enum  bpf_check_mtu_flags {</p>
<blockquote>
<div><p>BPF_MTU_CHK_SEGS  = (1U &lt;&lt; 0),</p>
</div></blockquote>
<p>};</p>
<dl class="simple">
<dt>enum bpf_check_mtu_ret {</dt><dd><p>BPF_MTU_CHK_RET_SUCCESS,      /* check and lookup successful <em>/
BPF_MTU_CHK_RET_FRAG_NEEDED,  /</em> fragmentation required to fwd <em>/
BPF_MTU_CHK_RET_SEGS_TOOBIG,  /</em> GSO re-segmentation needed to fwd <a href="#id971"><span class="problematic" id="id972">*</span></a>/</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>enum bpf_task_fd_type {</dt><dd><p>BPF_FD_TYPE_RAW_TRACEPOINT,     /* tp name <em>/
BPF_FD_TYPE_TRACEPOINT,         /</em> tp name <em>/
BPF_FD_TYPE_KPROBE,             /</em> (symbol + offset) or addr <em>/
BPF_FD_TYPE_KRETPROBE,          /</em> (symbol + offset) or addr <em>/
BPF_FD_TYPE_UPROBE,             /</em> filename + offset <em>/
BPF_FD_TYPE_URETPROBE,          /</em> filename + offset <a href="#id973"><span class="problematic" id="id974">*</span></a>/</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>enum {</dt><dd><p>BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG             = (1U &lt;&lt; 0),
BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL         = (1U &lt;&lt; 1),
BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP              = (1U &lt;&lt; 2),</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>struct bpf_flow_keys {</dt><dd><p>__u16   nhoff;
__u16   thoff;
__u16   addr_proto;                     /* ETH_P_* of valid addrs <a href="#id975"><span class="problematic" id="id976">*</span></a>/
__u8    is_frag;
__u8    is_first_frag;
__u8    is_encap;
__u8    ip_proto;
__be16  n_proto;
__be16  sport;
__be16  dport;
union {</p>
<blockquote>
<div><dl class="simple">
<dt>struct {</dt><dd><p>__be32  ipv4_src;
__be32  ipv4_dst;</p>
</dd>
</dl>
<p>};
struct {</p>
<blockquote>
<div><p>__u32   ipv6_src[4];    /* in6_addr; network order <em>/
__u32   ipv6_dst[4];    /</em> in6_addr; network order <a href="#id977"><span class="problematic" id="id978">*</span></a>/</p>
</div></blockquote>
<p>};</p>
</div></blockquote>
<p>};
__u32   flags;
__be32  flow_label;</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>struct bpf_func_info {</dt><dd><p>__u32   insn_off;
__u32   type_id;</p>
</dd>
</dl>
<p>};</p>
<p>#define BPF_LINE_INFO_LINE_NUM(line_col)        ((line_col) &gt;&gt; 10)
#define BPF_LINE_INFO_LINE_COL(line_col)        ((line_col) &amp; 0x3ff)</p>
<dl class="simple">
<dt>struct bpf_line_info {</dt><dd><p>__u32   insn_off;
__u32   file_name_off;
__u32   line_off;
__u32   line_col;</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>struct bpf_spin_lock {</dt><dd><p>__u32   val;</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>struct bpf_sysctl {</dt><dd><dl>
<dt>__u32   write;          /* Sysctl is being read (= 0) or written (= 1).</dt><dd><ul class="simple">
<li><p>Allows 1,2,4-byte read, but no write.</p></li>
</ul>
<p><a href="#id979"><span class="problematic" id="id980">*</span></a>/</p>
</dd>
<dt>__u32   file_pos;       /* Sysctl file position to read from, write to.</dt><dd><ul class="simple">
<li><p>Allows 1,2,4-byte read an 4-byte write.</p></li>
</ul>
<p><a href="#id981"><span class="problematic" id="id982">*</span></a>/</p>
</dd>
</dl>
</dd>
</dl>
<p>};</p>
<dl>
<dt>struct bpf_sockopt {</dt><dd><p>__bpf_md_ptr(struct bpf_sock <a href="#id983"><span class="problematic" id="id984">*</span></a>, sk);
__bpf_md_ptr(void <a href="#id985"><span class="problematic" id="id986">*</span></a>, optval);
__bpf_md_ptr(void <a href="#id987"><span class="problematic" id="id988">*</span></a>, optval_end);</p>
<p>__s32   level;
__s32   optname;
__s32   optlen;
__s32   retval;</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>struct bpf_pidns_info {</dt><dd><p>__u32 pid;
__u32 tgid;</p>
</dd>
</dl>
<p>};</p>
<p>/* User accessible data for SK_LOOKUP programs. Add new fields at the end. <a href="#id989"><span class="problematic" id="id990">*</span></a>/
struct bpf_sk_lookup {</p>
<blockquote>
<div><dl class="simple">
<dt>union {</dt><dd><p>__bpf_md_ptr(struct bpf_sock <em>, sk); /</em> Selected socket <em>/
__u64 cookie; /</em> Non-zero if socket was selected in PROG_TEST_RUN <a href="#id991"><span class="problematic" id="id992">*</span></a>/</p>
</dd>
</dl>
<p>};</p>
<p>__u32 family;           /* Protocol family (AF_INET, AF_INET6) <em>/
__u32 protocol;         /</em> IP protocol (IPPROTO_TCP, IPPROTO_UDP) <em>/
__u32 remote_ip4;       /</em> Network byte order <em>/
__u32 remote_ip6[4];    /</em> Network byte order <em>/
__u32 remote_port;      /</em> Network byte order <em>/
__u32 local_ip4;        /</em> Network byte order <em>/
__u32 local_ip6[4];     /</em> Network byte order <em>/
__u32 local_port;       /</em> Host byte order <a href="#id993"><span class="problematic" id="id994">*</span></a>/</p>
</div></blockquote>
<p>};</p>
<dl>
<dt>/*</dt><dd><ul class="simple">
<li><p>struct btf_ptr is used for typed pointer representation; the</p></li>
<li><p>type id is used to render the pointer data as the appropriate type</p></li>
<li><p>via the bpf_snprintf_btf() helper described above.  A flags field -</p></li>
<li><p>potentially to specify additional details about the BTF pointer</p></li>
<li><p>(rather than its mode of display) - is included for future use.</p></li>
<li><p>Display flags - BTF_F_* - are passed to bpf_snprintf_btf separately.</p></li>
</ul>
<p><a href="#id995"><span class="problematic" id="id996">*</span></a>/</p>
</dd>
<dt>struct btf_ptr {</dt><dd><p>void <em>ptr;
__u32 type_id;
__u32 flags;            /</em> BTF ptr flags; unused at present. <a href="#id997"><span class="problematic" id="id998">*</span></a>/</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>/*</dt><dd><ul class="simple">
<li><p>Flags to control bpf_snprintf_btf() behaviour.</p></li>
<li><ul>
<li><p>BTF_F_COMPACT: no formatting around type information</p></li>
</ul>
</li>
<li><ul>
<li><p>BTF_F_NONAME: no struct/union member names/types</p></li>
</ul>
</li>
<li><ul>
<li><p>BTF_F_PTR_RAW: show raw (unobfuscated) pointer values;</p></li>
</ul>
</li>
<li><p>equivalent to %px.</p></li>
<li><ul>
<li><p>BTF_F_ZERO: show zero-valued struct/union members; they</p></li>
</ul>
</li>
<li><p>are not displayed by default</p></li>
</ul>
<p><a href="#id999"><span class="problematic" id="id1000">*</span></a>/</p>
</dd>
<dt>enum {</dt><dd><p>BTF_F_COMPACT   =       (1ULL &lt;&lt; 0),
BTF_F_NONAME    =       (1ULL &lt;&lt; 1),
BTF_F_PTR_RAW   =       (1ULL &lt;&lt; 2),
BTF_F_ZERO      =       (1ULL &lt;&lt; 3),</p>
</dd>
</dl>
<p>};</p>
</div>
<div class="section" id="libbpf">
<h2>libbpf总结<a class="headerlink" href="#libbpf" title="Permalink to this headline">¶</a></h2>
<p>提供bpf系统调用封装（libbpf)</p>
<p>bpf/libbpf.h
bpf/bpf.h</p>
<p>bpf.c:通用eBPF ELF操作</p>
<dl class="simple">
<dt>static inline int sys_bpf(enum bpf_cmd cmd, union bpf_attr <a href="#id1001"><span class="problematic" id="id1002">*</span></a>attr,</dt><dd><p>unsigned int size)</p>
</dd>
</dl>
<dl class="simple">
<dt>{</dt><dd><p>return syscall(__NR_bpf, cmd, attr, size);</p>
</dd>
</dl>
<p>}</p>
<p>static inline int sys_bpf_prog_load(union bpf_attr <a href="#id1003"><span class="problematic" id="id1004">*</span></a>attr, unsigned int size)
{</p>
<blockquote>
<div><p>int retries = 5;
int fd;</p>
<dl class="simple">
<dt>do {</dt><dd><p>fd = sys_bpf(BPF_PROG_LOAD, attr, size);</p>
</dd>
</dl>
<p>} while (fd &lt; 0 &amp;&amp; errno == EAGAIN &amp;&amp; retries– &gt; 0);</p>
<p>return fd;</p>
</div></blockquote>
<p>}</p>
<p>int bpf_create_map_xattr(const struct bpf_create_map_attr <a href="#id1005"><span class="problematic" id="id1006">*</span></a>create_attr)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int fd;</p>
<p>memset(&amp;attr, ‘0’, sizeof(attr));</p>
<p>attr.map_type = create_attr-&gt;map_type;
attr.key_size = create_attr-&gt;key_size;
attr.value_size = create_attr-&gt;value_size;
attr.max_entries = create_attr-&gt;max_entries;
attr.map_flags = create_attr-&gt;map_flags;
if (create_attr-&gt;name)</p>
<blockquote>
<div><dl class="simple">
<dt>memcpy(attr.map_name, create_attr-&gt;name,</dt><dd><p>min(strlen(create_attr-&gt;name), BPF_OBJ_NAME_LEN - 1));</p>
</dd>
</dl>
</div></blockquote>
<p>attr.numa_node = create_attr-&gt;numa_node;
attr.btf_fd = create_attr-&gt;btf_fd;
attr.btf_key_type_id = create_attr-&gt;btf_key_type_id;
attr.btf_value_type_id = create_attr-&gt;btf_value_type_id;
attr.map_ifindex = create_attr-&gt;map_ifindex;
if (attr.map_type == BPF_MAP_TYPE_STRUCT_OPS)</p>
<blockquote>
<div><dl class="simple">
<dt>attr.btf_vmlinux_value_type_id =</dt><dd><p>create_attr-&gt;btf_vmlinux_value_type_id;</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>else</dt><dd><p>attr.inner_map_fd = create_attr-&gt;inner_map_fd;</p>
</dd>
</dl>
<p>fd = sys_bpf(BPF_MAP_CREATE, &amp;attr, sizeof(attr));
return libbpf_err_errno(fd);</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>int bpf_create_map_node(enum bpf_map_type map_type, const char <a href="#id1007"><span class="problematic" id="id1008">*</span></a>name,</dt><dd><p>int key_size, int value_size, int max_entries,
__u32 map_flags, int node)</p>
</dd>
</dl>
<dl>
<dt>{</dt><dd><p>struct bpf_create_map_attr map_attr = {};</p>
<p>map_attr.name = name;
map_attr.map_type = map_type;
map_attr.map_flags = map_flags;
map_attr.key_size = key_size;
map_attr.value_size = value_size;
map_attr.max_entries = max_entries;
if (node &gt;= 0) {</p>
<blockquote>
<div><p>map_attr.numa_node = node;
map_attr.map_flags <a href="#id1009"><span class="problematic" id="id1010">|</span></a>= BPF_F_NUMA_NODE;</p>
</div></blockquote>
<p>}</p>
<p>return bpf_create_map_xattr(&amp;map_attr);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>int bpf_create_map(enum bpf_map_type map_type, int key_size,</dt><dd><p>int value_size, int max_entries, __u32 map_flags)</p>
</dd>
</dl>
<dl>
<dt>{</dt><dd><p>struct bpf_create_map_attr map_attr = {};</p>
<p>map_attr.map_type = map_type;
map_attr.map_flags = map_flags;
map_attr.key_size = key_size;
map_attr.value_size = value_size;
map_attr.max_entries = max_entries;</p>
<p>return bpf_create_map_xattr(&amp;map_attr);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>int bpf_create_map_name(enum bpf_map_type map_type, const char <a href="#id1011"><span class="problematic" id="id1012">*</span></a>name,</dt><dd><p>int key_size, int value_size, int max_entries,
__u32 map_flags)</p>
</dd>
</dl>
<dl>
<dt>{</dt><dd><p>struct bpf_create_map_attr map_attr = {};</p>
<p>map_attr.name = name;
map_attr.map_type = map_type;
map_attr.map_flags = map_flags;
map_attr.key_size = key_size;
map_attr.value_size = value_size;
map_attr.max_entries = max_entries;</p>
<p>return bpf_create_map_xattr(&amp;map_attr);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>int bpf_create_map_in_map_node(enum bpf_map_type map_type, const char <a href="#id1013"><span class="problematic" id="id1014">*</span></a>name,</dt><dd><p>int key_size, int inner_map_fd, int max_entries,
__u32 map_flags, int node)</p>
</dd>
</dl>
<dl>
<dt>{</dt><dd><p>union bpf_attr attr;
int fd;</p>
<p>memset(&amp;attr, ‘0’, sizeof(attr));</p>
<p>attr.map_type = map_type;
attr.key_size = key_size;
attr.value_size = 4;
attr.inner_map_fd = inner_map_fd;
attr.max_entries = max_entries;
attr.map_flags = map_flags;
if (name)</p>
<blockquote>
<div><dl class="simple">
<dt>memcpy(attr.map_name, name,</dt><dd><p>min(strlen(name), BPF_OBJ_NAME_LEN - 1));</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>if (node &gt;= 0) {</dt><dd><p>attr.map_flags <a href="#id1015"><span class="problematic" id="id1016">|</span></a>= BPF_F_NUMA_NODE;
attr.numa_node = node;</p>
</dd>
</dl>
<p>}</p>
<p>fd = sys_bpf(BPF_MAP_CREATE, &amp;attr, sizeof(attr));
return libbpf_err_errno(fd);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>int bpf_create_map_in_map(enum bpf_map_type map_type, const char <a href="#id1017"><span class="problematic" id="id1018">*</span></a>name,</dt><dd><p>int key_size, int inner_map_fd, int max_entries,
__u32 map_flags)</p>
</dd>
</dl>
<dl class="simple">
<dt>{</dt><dd><dl class="simple">
<dt>return bpf_create_map_in_map_node(map_type, name, key_size,</dt><dd><p>inner_map_fd, max_entries, map_flags,
-1);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>static void *
alloc_zero_tailing_info(const void <a href="#id1019"><span class="problematic" id="id1020">*</span></a>orecord, __u32 cnt,</p>
<blockquote>
<div><p>__u32 actual_rec_size, __u32 expected_rec_size)</p>
</div></blockquote>
<dl>
<dt>{</dt><dd><p>__u64 info_len = (__u64)actual_rec_size * cnt;
void <a href="#id1021"><span class="problematic" id="id1022">*</span></a>info, <a href="#id1023"><span class="problematic" id="id1024">*</span></a>nrecord;
int i;</p>
<p>info = malloc(info_len);
if (!info)</p>
<blockquote>
<div><p>return NULL;</p>
</div></blockquote>
<p>/* zero out bytes kernel does not understand <a href="#id1025"><span class="problematic" id="id1026">*</span></a>/
nrecord = info;
for (i = 0; i &lt; cnt; i++) {</p>
<blockquote>
<div><p>memcpy(nrecord, orecord, expected_rec_size);
memset(nrecord + expected_rec_size, 0,</p>
<blockquote>
<div><p>actual_rec_size - expected_rec_size);</p>
</div></blockquote>
<p>orecord += actual_rec_size;
nrecord += actual_rec_size;</p>
</div></blockquote>
<p>}</p>
<p>return info;</p>
</dd>
</dl>
<p>}</p>
<p>int libbpf__bpf_prog_load(const struct bpf_prog_load_params <a href="#id1027"><span class="problematic" id="id1028">*</span></a>load_attr)
{</p>
<blockquote>
<div><p>void <a href="#id1029"><span class="problematic" id="id1030">*</span></a>finfo = NULL, <a href="#id1031"><span class="problematic" id="id1032">*</span></a>linfo = NULL;
union bpf_attr attr;
int fd;</p>
<dl class="simple">
<dt>if (!load_attr-&gt;log_buf != !load_attr-&gt;log_buf_sz)</dt><dd><p>return libbpf_err(-EINVAL);</p>
</dd>
<dt>if (load_attr-&gt;log_level &gt; (4 | 2 | 1) || (load_attr-&gt;log_level &amp;&amp; !load_attr-&gt;log_buf))</dt><dd><p>return libbpf_err(-EINVAL);</p>
</dd>
</dl>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.prog_type = load_attr-&gt;prog_type;
attr.expected_attach_type = load_attr-&gt;expected_attach_type;</p>
<dl class="simple">
<dt>if (load_attr-&gt;attach_prog_fd)</dt><dd><p>attr.attach_prog_fd = load_attr-&gt;attach_prog_fd;</p>
</dd>
<dt>else</dt><dd><p>attr.attach_btf_obj_fd = load_attr-&gt;attach_btf_obj_fd;</p>
</dd>
</dl>
<p>attr.attach_btf_id = load_attr-&gt;attach_btf_id;</p>
<p>attr.prog_ifindex = load_attr-&gt;prog_ifindex;
attr.kern_version = load_attr-&gt;kern_version;</p>
<p>attr.insn_cnt = (__u32)load_attr-&gt;insn_cnt;
attr.insns = ptr_to_u64(load_attr-&gt;insns);
attr.license = ptr_to_u64(load_attr-&gt;license);</p>
<p>attr.log_level = load_attr-&gt;log_level;
if (attr.log_level) {</p>
<blockquote>
<div><p>attr.log_buf = ptr_to_u64(load_attr-&gt;log_buf);
attr.log_size = load_attr-&gt;log_buf_sz;</p>
</div></blockquote>
<p>}</p>
<p>attr.prog_btf_fd = load_attr-&gt;prog_btf_fd;
attr.prog_flags = load_attr-&gt;prog_flags;</p>
<p>attr.func_info_rec_size = load_attr-&gt;func_info_rec_size;
attr.func_info_cnt = load_attr-&gt;func_info_cnt;
attr.func_info = ptr_to_u64(load_attr-&gt;func_info);</p>
<p>attr.line_info_rec_size = load_attr-&gt;line_info_rec_size;
attr.line_info_cnt = load_attr-&gt;line_info_cnt;
attr.line_info = ptr_to_u64(load_attr-&gt;line_info);</p>
<dl class="simple">
<dt>if (load_attr-&gt;name)</dt><dd><dl class="simple">
<dt>memcpy(attr.prog_name, load_attr-&gt;name,</dt><dd><p>min(strlen(load_attr-&gt;name), (size_t)BPF_OBJ_NAME_LEN - 1));</p>
</dd>
</dl>
</dd>
</dl>
<p>fd = sys_bpf_prog_load(&amp;attr, sizeof(attr));
if (fd &gt;= 0)</p>
<blockquote>
<div><p>return fd;</p>
</div></blockquote>
<dl>
<dt>/* After bpf_prog_load, the kernel may modify certain attributes</dt><dd><ul class="simple">
<li><p>to give user space a hint how to deal with loading failure.</p></li>
<li><p>Check to see whether we can make some changes and load again.</p></li>
</ul>
<p><a href="#id1033"><span class="problematic" id="id1034">*</span></a>/</p>
</dd>
<dt>while (errno == E2BIG &amp;&amp; (!finfo || !linfo)) {</dt><dd><dl>
<dt>if (!finfo &amp;&amp; attr.func_info_cnt &amp;&amp;</dt><dd><dl>
<dt>attr.func_info_rec_size &lt; load_attr-&gt;func_info_rec_size) {</dt><dd><p>/* try with corrected func info records <a href="#id1035"><span class="problematic" id="id1036">*</span></a>/
finfo = alloc_zero_tailing_info(load_attr-&gt;func_info,</p>
<blockquote>
<div><p>load_attr-&gt;func_info_cnt,
load_attr-&gt;func_info_rec_size,
attr.func_info_rec_size);</p>
</div></blockquote>
<dl class="simple">
<dt>if (!finfo) {</dt><dd><p>errno = E2BIG;
goto done;</p>
</dd>
</dl>
<p>}</p>
<p>attr.func_info = ptr_to_u64(finfo);
attr.func_info_rec_size = load_attr-&gt;func_info_rec_size;</p>
</dd>
</dl>
</dd>
<dt>} else if (!linfo &amp;&amp; attr.line_info_cnt &amp;&amp;</dt><dd><blockquote>
<div><p>attr.line_info_rec_size &lt;
load_attr-&gt;line_info_rec_size) {</p>
</div></blockquote>
<dl class="simple">
<dt>linfo = alloc_zero_tailing_info(load_attr-&gt;line_info,</dt><dd><p>load_attr-&gt;line_info_cnt,
load_attr-&gt;line_info_rec_size,
attr.line_info_rec_size);</p>
</dd>
<dt>if (!linfo) {</dt><dd><p>errno = E2BIG;
goto done;</p>
</dd>
</dl>
<p>}</p>
<p>attr.line_info = ptr_to_u64(linfo);
attr.line_info_rec_size = load_attr-&gt;line_info_rec_size;</p>
</dd>
<dt>} else {</dt><dd><p>break;</p>
</dd>
</dl>
<p>}</p>
<p>fd = sys_bpf_prog_load(&amp;attr, sizeof(attr));
if (fd &gt;= 0)</p>
<blockquote>
<div><p>goto done;</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (load_attr-&gt;log_level || !load_attr-&gt;log_buf)</dt><dd><p>goto done;</p>
</dd>
</dl>
<p>/* Try again with log <a href="#id1037"><span class="problematic" id="id1038">*</span></a>/
attr.log_buf = ptr_to_u64(load_attr-&gt;log_buf);
attr.log_size = load_attr-&gt;log_buf_sz;
attr.log_level = 1;
load_attr-&gt;log_buf[0] = 0;</p>
<p>fd = sys_bpf_prog_load(&amp;attr, sizeof(attr));</p>
</div></blockquote>
<dl class="simple">
<dt>done:</dt><dd><p>/* free() doesn’t affect errno, so we don’t need to restore it <a href="#id1039"><span class="problematic" id="id1040">*</span></a>/
free(finfo);
free(linfo);
return libbpf_err_errno(fd);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>int bpf_load_program_xattr(const struct bpf_load_program_attr <a href="#id1041"><span class="problematic" id="id1042">*</span></a>load_attr,</dt><dd><p>char <a href="#id1043"><span class="problematic" id="id1044">*</span></a>log_buf, size_t log_buf_sz)</p>
</dd>
</dl>
<dl>
<dt>{</dt><dd><p>struct bpf_prog_load_params p = {};</p>
<dl class="simple">
<dt>if (!load_attr || !log_buf != !log_buf_sz)</dt><dd><p>return libbpf_err(-EINVAL);</p>
</dd>
</dl>
<p>p.prog_type = load_attr-&gt;prog_type;
p.expected_attach_type = load_attr-&gt;expected_attach_type;
switch (p.prog_type) {
case BPF_PROG_TYPE_STRUCT_OPS:
case BPF_PROG_TYPE_LSM:</p>
<blockquote>
<div><p>p.attach_btf_id = load_attr-&gt;attach_btf_id;
break;</p>
</div></blockquote>
<p>case BPF_PROG_TYPE_TRACING:
case BPF_PROG_TYPE_EXT:</p>
<blockquote>
<div><p>p.attach_btf_id = load_attr-&gt;attach_btf_id;
p.attach_prog_fd = load_attr-&gt;attach_prog_fd;
break;</p>
</div></blockquote>
<dl class="simple">
<dt>default:</dt><dd><p>p.prog_ifindex = load_attr-&gt;prog_ifindex;
p.kern_version = load_attr-&gt;kern_version;</p>
</dd>
</dl>
<p>}
p.insn_cnt = load_attr-&gt;insns_cnt;
p.insns = load_attr-&gt;insns;
p.license = load_attr-&gt;license;
p.log_level = load_attr-&gt;log_level;
p.log_buf = log_buf;
p.log_buf_sz = log_buf_sz;
p.prog_btf_fd = load_attr-&gt;prog_btf_fd;
p.func_info_rec_size = load_attr-&gt;func_info_rec_size;
p.func_info_cnt = load_attr-&gt;func_info_cnt;
p.func_info = load_attr-&gt;func_info;
p.line_info_rec_size = load_attr-&gt;line_info_rec_size;
p.line_info_cnt = load_attr-&gt;line_info_cnt;
p.line_info = load_attr-&gt;line_info;
p.name = load_attr-&gt;name;
p.prog_flags = load_attr-&gt;prog_flags;</p>
<p>return libbpf__bpf_prog_load(&amp;p);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>int bpf_load_program(enum bpf_prog_type type, const struct bpf_insn <a href="#id1045"><span class="problematic" id="id1046">*</span></a>insns,</dt><dd><p>size_t insns_cnt, const char <a href="#id1047"><span class="problematic" id="id1048">*</span></a>license,
__u32 kern_version, char <a href="#id1049"><span class="problematic" id="id1050">*</span></a>log_buf,
size_t log_buf_sz)</p>
</dd>
</dl>
<dl>
<dt>{</dt><dd><p>struct bpf_load_program_attr load_attr;</p>
<p>memset(&amp;load_attr, 0, sizeof(struct bpf_load_program_attr));
load_attr.prog_type = type;
load_attr.expected_attach_type = 0;
load_attr.name = NULL;
load_attr.insns = insns;
load_attr.insns_cnt = insns_cnt;
load_attr.license = license;
load_attr.kern_version = kern_version;</p>
<p>return bpf_load_program_xattr(&amp;load_attr, log_buf, log_buf_sz);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>int bpf_verify_program(enum bpf_prog_type type, const struct bpf_insn <a href="#id1051"><span class="problematic" id="id1052">*</span></a>insns,</dt><dd><p>size_t insns_cnt, __u32 prog_flags, const char <a href="#id1053"><span class="problematic" id="id1054">*</span></a>license,
__u32 kern_version, char <a href="#id1055"><span class="problematic" id="id1056">*</span></a>log_buf, size_t log_buf_sz,
int log_level)</p>
</dd>
</dl>
<dl>
<dt>{</dt><dd><p>union bpf_attr attr;
int fd;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.prog_type = type;
attr.insn_cnt = (__u32)insns_cnt;
attr.insns = ptr_to_u64(insns);
attr.license = ptr_to_u64(license);
attr.log_buf = ptr_to_u64(log_buf);
attr.log_size = log_buf_sz;
attr.log_level = log_level;
log_buf[0] = 0;
attr.kern_version = kern_version;
attr.prog_flags = prog_flags;</p>
<p>fd = sys_bpf_prog_load(&amp;attr, sizeof(attr));
return libbpf_err_errno(fd);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>int bpf_map_update_elem(int fd, const void <a href="#id1057"><span class="problematic" id="id1058">*</span></a>key, const void <a href="#id1059"><span class="problematic" id="id1060">*</span></a>value,</dt><dd><p>__u64 flags)</p>
</dd>
</dl>
<dl>
<dt>{</dt><dd><p>union bpf_attr attr;
int ret;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.map_fd = fd;
attr.key = ptr_to_u64(key);
attr.value = ptr_to_u64(value);
attr.flags = flags;</p>
<p>ret = sys_bpf(BPF_MAP_UPDATE_ELEM, &amp;attr, sizeof(attr));
return libbpf_err_errno(ret);</p>
</dd>
</dl>
<p>}</p>
<p>int bpf_map_lookup_elem(int fd, const void <a href="#id1061"><span class="problematic" id="id1062">*</span></a>key, void <a href="#id1063"><span class="problematic" id="id1064">*</span></a>value)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int ret;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.map_fd = fd;
attr.key = ptr_to_u64(key);
attr.value = ptr_to_u64(value);</p>
<p>ret = sys_bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr, sizeof(attr));
return libbpf_err_errno(ret);</p>
</div></blockquote>
<p>}</p>
<p>int bpf_map_lookup_elem_flags(int fd, const void <a href="#id1065"><span class="problematic" id="id1066">*</span></a>key, void <a href="#id1067"><span class="problematic" id="id1068">*</span></a>value, __u64 flags)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int ret;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.map_fd = fd;
attr.key = ptr_to_u64(key);
attr.value = ptr_to_u64(value);
attr.flags = flags;</p>
<p>ret = sys_bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr, sizeof(attr));
return libbpf_err_errno(ret);</p>
</div></blockquote>
<p>}</p>
<p>int bpf_map_lookup_and_delete_elem(int fd, const void <a href="#id1069"><span class="problematic" id="id1070">*</span></a>key, void <a href="#id1071"><span class="problematic" id="id1072">*</span></a>value)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int ret;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.map_fd = fd;
attr.key = ptr_to_u64(key);
attr.value = ptr_to_u64(value);</p>
<p>ret = sys_bpf(BPF_MAP_LOOKUP_AND_DELETE_ELEM, &amp;attr, sizeof(attr));
return libbpf_err_errno(ret);</p>
</div></blockquote>
<p>}</p>
<p>int bpf_map_lookup_and_delete_elem_flags(int fd, const void <a href="#id1073"><span class="problematic" id="id1074">*</span></a>key, void <a href="#id1075"><span class="problematic" id="id1076">*</span></a>value, __u64 flags)
{</p>
<blockquote>
<div><p>union bpf_attr attr;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.map_fd = fd;
attr.key = ptr_to_u64(key);
attr.value = ptr_to_u64(value);
attr.flags = flags;</p>
<p>return sys_bpf(BPF_MAP_LOOKUP_AND_DELETE_ELEM, &amp;attr, sizeof(attr));</p>
</div></blockquote>
<p>}</p>
<p>int bpf_map_delete_elem(int fd, const void <a href="#id1077"><span class="problematic" id="id1078">*</span></a>key)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int ret;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.map_fd = fd;
attr.key = ptr_to_u64(key);</p>
<p>ret = sys_bpf(BPF_MAP_DELETE_ELEM, &amp;attr, sizeof(attr));
return libbpf_err_errno(ret);</p>
</div></blockquote>
<p>}</p>
<p>int bpf_map_get_next_key(int fd, const void <a href="#id1079"><span class="problematic" id="id1080">*</span></a>key, void <a href="#id1081"><span class="problematic" id="id1082">*</span></a>next_key)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int ret;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.map_fd = fd;
attr.key = ptr_to_u64(key);
attr.next_key = ptr_to_u64(next_key);</p>
<p>ret = sys_bpf(BPF_MAP_GET_NEXT_KEY, &amp;attr, sizeof(attr));
return libbpf_err_errno(ret);</p>
</div></blockquote>
<p>}</p>
<p>int bpf_map_freeze(int fd)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int ret;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.map_fd = fd;</p>
<p>ret = sys_bpf(BPF_MAP_FREEZE, &amp;attr, sizeof(attr));
return libbpf_err_errno(ret);</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>static int bpf_map_batch_common(int cmd, int fd, void  <a href="#id1083"><span class="problematic" id="id1084">*</span></a>in_batch,</dt><dd><p>void <a href="#id1085"><span class="problematic" id="id1086">*</span></a>out_batch, void <a href="#id1087"><span class="problematic" id="id1088">*</span></a>keys, void <a href="#id1089"><span class="problematic" id="id1090">*</span></a>values,
__u32 <a href="#id1091"><span class="problematic" id="id1092">*</span></a>count,
const struct bpf_map_batch_opts <a href="#id1093"><span class="problematic" id="id1094">*</span></a>opts)</p>
</dd>
</dl>
<dl>
<dt>{</dt><dd><p>union bpf_attr attr;
int ret;</p>
<dl class="simple">
<dt>if (!OPTS_VALID(opts, bpf_map_batch_opts))</dt><dd><p>return libbpf_err(-EINVAL);</p>
</dd>
</dl>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.batch.map_fd = fd;
attr.batch.in_batch = ptr_to_u64(in_batch);
attr.batch.out_batch = ptr_to_u64(out_batch);
attr.batch.keys = ptr_to_u64(keys);
attr.batch.values = ptr_to_u64(values);
attr.batch.count = <a href="#id1095"><span class="problematic" id="id1096">*</span></a>count;
attr.batch.elem_flags  = OPTS_GET(opts, elem_flags, 0);
attr.batch.flags = OPTS_GET(opts, flags, 0);</p>
<p>ret = sys_bpf(cmd, &amp;attr, sizeof(attr));
<a href="#id1097"><span class="problematic" id="id1098">*</span></a>count = attr.batch.count;</p>
<p>return libbpf_err_errno(ret);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>int bpf_map_delete_batch(int fd, void <a href="#id1099"><span class="problematic" id="id1100">*</span></a>keys, __u32 <a href="#id1101"><span class="problematic" id="id1102">*</span></a>count,</dt><dd><p>const struct bpf_map_batch_opts <a href="#id1103"><span class="problematic" id="id1104">*</span></a>opts)</p>
</dd>
</dl>
<dl class="simple">
<dt>{</dt><dd><dl class="simple">
<dt>return bpf_map_batch_common(BPF_MAP_DELETE_BATCH, fd, NULL,</dt><dd><p>NULL, keys, NULL, count, opts);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>int bpf_map_lookup_batch(int fd, void <a href="#id1105"><span class="problematic" id="id1106">*</span></a>in_batch, void <a href="#id1107"><span class="problematic" id="id1108">*</span></a>out_batch, void <a href="#id1109"><span class="problematic" id="id1110">*</span></a>keys,</dt><dd><p>void <a href="#id1111"><span class="problematic" id="id1112">*</span></a>values, __u32 <a href="#id1113"><span class="problematic" id="id1114">*</span></a>count,
const struct bpf_map_batch_opts <a href="#id1115"><span class="problematic" id="id1116">*</span></a>opts)</p>
</dd>
</dl>
<dl class="simple">
<dt>{</dt><dd><dl class="simple">
<dt>return bpf_map_batch_common(BPF_MAP_LOOKUP_BATCH, fd, in_batch,</dt><dd><p>out_batch, keys, values, count, opts);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>int bpf_map_lookup_and_delete_batch(int fd, void <a href="#id1117"><span class="problematic" id="id1118">*</span></a>in_batch, void <a href="#id1119"><span class="problematic" id="id1120">*</span></a>out_batch,</dt><dd><p>void <a href="#id1121"><span class="problematic" id="id1122">*</span></a>keys, void <a href="#id1123"><span class="problematic" id="id1124">*</span></a>values, __u32 <a href="#id1125"><span class="problematic" id="id1126">*</span></a>count,
const struct bpf_map_batch_opts <a href="#id1127"><span class="problematic" id="id1128">*</span></a>opts)</p>
</dd>
</dl>
<dl class="simple">
<dt>{</dt><dd><dl class="simple">
<dt>return bpf_map_batch_common(BPF_MAP_LOOKUP_AND_DELETE_BATCH,</dt><dd><p>fd, in_batch, out_batch, keys, values,
count, opts);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>int bpf_map_update_batch(int fd, void <a href="#id1129"><span class="problematic" id="id1130">*</span></a>keys, void <a href="#id1131"><span class="problematic" id="id1132">*</span></a>values, __u32 <a href="#id1133"><span class="problematic" id="id1134">*</span></a>count,</dt><dd><p>const struct bpf_map_batch_opts <a href="#id1135"><span class="problematic" id="id1136">*</span></a>opts)</p>
</dd>
</dl>
<dl class="simple">
<dt>{</dt><dd><dl class="simple">
<dt>return bpf_map_batch_common(BPF_MAP_UPDATE_BATCH, fd, NULL, NULL,</dt><dd><p>keys, values, count, opts);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>int bpf_obj_pin(int fd, const char <a href="#id1137"><span class="problematic" id="id1138">*</span></a>pathname)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int ret;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.pathname = ptr_to_u64((void <a href="#id1139"><span class="problematic" id="id1140">*</span></a>)pathname);
attr.bpf_fd = fd;</p>
<p>ret = sys_bpf(BPF_OBJ_PIN, &amp;attr, sizeof(attr));
return libbpf_err_errno(ret);</p>
</div></blockquote>
<p>}</p>
<p>int bpf_obj_get(const char <a href="#id1141"><span class="problematic" id="id1142">*</span></a>pathname)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int fd;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.pathname = ptr_to_u64((void <a href="#id1143"><span class="problematic" id="id1144">*</span></a>)pathname);</p>
<p>fd = sys_bpf(BPF_OBJ_GET, &amp;attr, sizeof(attr));
return libbpf_err_errno(fd);</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>int bpf_prog_attach(int prog_fd, int target_fd, enum bpf_attach_type type,</dt><dd><p>unsigned int flags)</p>
</dd>
</dl>
<dl>
<dt>{</dt><dd><dl class="simple">
<dt>DECLARE_LIBBPF_OPTS(bpf_prog_attach_opts, opts,</dt><dd><p>.flags = flags,</p>
</dd>
</dl>
<p>);</p>
<p>return bpf_prog_attach_xattr(prog_fd, target_fd, type, &amp;opts);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>int bpf_prog_attach_xattr(int prog_fd, int target_fd,</dt><dd><p>enum bpf_attach_type type,
const struct bpf_prog_attach_opts <a href="#id1145"><span class="problematic" id="id1146">*</span></a>opts)</p>
</dd>
</dl>
<dl>
<dt>{</dt><dd><p>union bpf_attr attr;
int ret;</p>
<dl class="simple">
<dt>if (!OPTS_VALID(opts, bpf_prog_attach_opts))</dt><dd><p>return libbpf_err(-EINVAL);</p>
</dd>
</dl>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.target_fd     = target_fd;
attr.attach_bpf_fd = prog_fd;
attr.attach_type   = type;
attr.attach_flags  = OPTS_GET(opts, flags, 0);
attr.replace_bpf_fd = OPTS_GET(opts, replace_prog_fd, 0);</p>
<p>ret = sys_bpf(BPF_PROG_ATTACH, &amp;attr, sizeof(attr));
return libbpf_err_errno(ret);</p>
</dd>
</dl>
<p>}</p>
<p>int bpf_prog_detach(int target_fd, enum bpf_attach_type type)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int ret;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.target_fd   = target_fd;
attr.attach_type = type;</p>
<p>ret = sys_bpf(BPF_PROG_DETACH, &amp;attr, sizeof(attr));
return libbpf_err_errno(ret);</p>
</div></blockquote>
<p>}</p>
<p>int bpf_prog_detach2(int prog_fd, int target_fd, enum bpf_attach_type type)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int ret;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.target_fd   = target_fd;
attr.attach_bpf_fd = prog_fd;
attr.attach_type = type;</p>
<p>ret = sys_bpf(BPF_PROG_DETACH, &amp;attr, sizeof(attr));
return libbpf_err_errno(ret);</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>int bpf_link_create(int prog_fd, int target_fd,</dt><dd><p>enum bpf_attach_type attach_type,
const struct bpf_link_create_opts <a href="#id1147"><span class="problematic" id="id1148">*</span></a>opts)</p>
</dd>
</dl>
<dl>
<dt>{</dt><dd><p>__u32 target_btf_id, iter_info_len;
union bpf_attr attr;
int fd;</p>
<dl class="simple">
<dt>if (!OPTS_VALID(opts, bpf_link_create_opts))</dt><dd><p>return libbpf_err(-EINVAL);</p>
</dd>
</dl>
<p>iter_info_len = OPTS_GET(opts, iter_info_len, 0);
target_btf_id = OPTS_GET(opts, target_btf_id, 0);</p>
<p>/* validate we don’t have unexpected combinations of non-zero fields <a href="#id1149"><span class="problematic" id="id1150">*</span></a>/
if (iter_info_len || target_btf_id) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (iter_info_len &amp;&amp; target_btf_id)</dt><dd><p>return libbpf_err(-EINVAL);</p>
</dd>
<dt>if (!OPTS_ZEROED(opts, target_btf_id))</dt><dd><p>return libbpf_err(-EINVAL);</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.link_create.prog_fd = prog_fd;
attr.link_create.target_fd = target_fd;
attr.link_create.attach_type = attach_type;
attr.link_create.flags = OPTS_GET(opts, flags, 0);</p>
<dl class="simple">
<dt>if (target_btf_id) {</dt><dd><p>attr.link_create.target_btf_id = target_btf_id;
goto proceed;</p>
</dd>
</dl>
<p>}</p>
<p>switch (attach_type) {
case BPF_TRACE_ITER:</p>
<blockquote>
<div><p>attr.link_create.iter_info = ptr_to_u64(OPTS_GET(opts, iter_info, (void <a href="#id1151"><span class="problematic" id="id1152">*</span></a>)0));
attr.link_create.iter_info_len = iter_info_len;
break;</p>
</div></blockquote>
<dl>
<dt>case BPF_PERF_EVENT:</dt><dd><p>attr.link_create.perf_event.bpf_cookie = OPTS_GET(opts, perf_event.bpf_cookie, 0);
if (!OPTS_ZEROED(opts, perf_event))</p>
<blockquote>
<div><p>return libbpf_err(-EINVAL);</p>
</div></blockquote>
<p>break;</p>
</dd>
<dt>default:</dt><dd><dl class="simple">
<dt>if (!OPTS_ZEROED(opts, flags))</dt><dd><p>return libbpf_err(-EINVAL);</p>
</dd>
</dl>
<p>break;</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>proceed:</dt><dd><p>fd = sys_bpf(BPF_LINK_CREATE, &amp;attr, sizeof(attr));
return libbpf_err_errno(fd);</p>
</dd>
</dl>
<p>}</p>
<p>int bpf_link_detach(int link_fd)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int ret;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.link_detach.link_fd = link_fd;</p>
<p>ret = sys_bpf(BPF_LINK_DETACH, &amp;attr, sizeof(attr));
return libbpf_err_errno(ret);</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>int bpf_link_update(int link_fd, int new_prog_fd,</dt><dd><p>const struct bpf_link_update_opts <a href="#id1153"><span class="problematic" id="id1154">*</span></a>opts)</p>
</dd>
</dl>
<dl>
<dt>{</dt><dd><p>union bpf_attr attr;
int ret;</p>
<dl class="simple">
<dt>if (!OPTS_VALID(opts, bpf_link_update_opts))</dt><dd><p>return libbpf_err(-EINVAL);</p>
</dd>
</dl>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.link_update.link_fd = link_fd;
attr.link_update.new_prog_fd = new_prog_fd;
attr.link_update.flags = OPTS_GET(opts, flags, 0);
attr.link_update.old_prog_fd = OPTS_GET(opts, old_prog_fd, 0);</p>
<p>ret = sys_bpf(BPF_LINK_UPDATE, &amp;attr, sizeof(attr));
return libbpf_err_errno(ret);</p>
</dd>
</dl>
<p>}</p>
<p>int bpf_iter_create(int link_fd)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int fd;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.iter_create.link_fd = link_fd;</p>
<p>fd = sys_bpf(BPF_ITER_CREATE, &amp;attr, sizeof(attr));
return libbpf_err_errno(fd);</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>int bpf_prog_query(int target_fd, enum bpf_attach_type type, __u32 query_flags,</dt><dd><p>__u32 <a href="#id1155"><span class="problematic" id="id1156">*</span></a>attach_flags, __u32 <a href="#id1157"><span class="problematic" id="id1158">*</span></a>prog_ids, __u32 <a href="#id1159"><span class="problematic" id="id1160">*</span></a>prog_cnt)</p>
</dd>
</dl>
<dl>
<dt>{</dt><dd><p>union bpf_attr attr;
int ret;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.query.target_fd    = target_fd;
attr.query.attach_type  = type;
attr.query.query_flags  = query_flags;
attr.query.prog_cnt     = <a href="#id1161"><span class="problematic" id="id1162">*</span></a>prog_cnt;
attr.query.prog_ids     = ptr_to_u64(prog_ids);</p>
<p>ret = sys_bpf(BPF_PROG_QUERY, &amp;attr, sizeof(attr));</p>
<dl class="simple">
<dt>if (attach_flags)</dt><dd><p><a href="#id1163"><span class="problematic" id="id1164">*</span></a>attach_flags = attr.query.attach_flags;</p>
</dd>
</dl>
<p><a href="#id1165"><span class="problematic" id="id1166">*</span></a>prog_cnt = attr.query.prog_cnt;</p>
<p>return libbpf_err_errno(ret);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>int bpf_prog_test_run(int prog_fd, int repeat, void <a href="#id1167"><span class="problematic" id="id1168">*</span></a>data, __u32 size,</dt><dd><p>void <a href="#id1169"><span class="problematic" id="id1170">*</span></a>data_out, __u32 <a href="#id1171"><span class="problematic" id="id1172">*</span></a>size_out, __u32 <a href="#id1173"><span class="problematic" id="id1174">*</span></a>retval,
__u32 <a href="#id1175"><span class="problematic" id="id1176">*</span></a>duration)</p>
</dd>
</dl>
<dl>
<dt>{</dt><dd><p>union bpf_attr attr;
int ret;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.test.prog_fd = prog_fd;
attr.test.data_in = ptr_to_u64(data);
attr.test.data_out = ptr_to_u64(data_out);
attr.test.data_size_in = size;
attr.test.repeat = repeat;</p>
<p>ret = sys_bpf(BPF_PROG_TEST_RUN, &amp;attr, sizeof(attr));</p>
<dl class="simple">
<dt>if (size_out)</dt><dd><p><a href="#id1177"><span class="problematic" id="id1178">*</span></a>size_out = attr.test.data_size_out;</p>
</dd>
<dt>if (retval)</dt><dd><p><a href="#id1179"><span class="problematic" id="id1180">*</span></a>retval = attr.test.retval;</p>
</dd>
<dt>if (duration)</dt><dd><p><a href="#id1181"><span class="problematic" id="id1182">*</span></a>duration = attr.test.duration;</p>
</dd>
</dl>
<p>return libbpf_err_errno(ret);</p>
</dd>
</dl>
<p>}</p>
<p>int bpf_prog_test_run_xattr(struct bpf_prog_test_run_attr <a href="#id1183"><span class="problematic" id="id1184">*</span></a>test_attr)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int ret;</p>
<dl class="simple">
<dt>if (!test_attr-&gt;data_out &amp;&amp; test_attr-&gt;data_size_out &gt; 0)</dt><dd><p>return libbpf_err(-EINVAL);</p>
</dd>
</dl>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.test.prog_fd = test_attr-&gt;prog_fd;
attr.test.data_in = ptr_to_u64(test_attr-&gt;data_in);
attr.test.data_out = ptr_to_u64(test_attr-&gt;data_out);
attr.test.data_size_in = test_attr-&gt;data_size_in;
attr.test.data_size_out = test_attr-&gt;data_size_out;
attr.test.ctx_in = ptr_to_u64(test_attr-&gt;ctx_in);
attr.test.ctx_out = ptr_to_u64(test_attr-&gt;ctx_out);
attr.test.ctx_size_in = test_attr-&gt;ctx_size_in;
attr.test.ctx_size_out = test_attr-&gt;ctx_size_out;
attr.test.repeat = test_attr-&gt;repeat;</p>
<p>ret = sys_bpf(BPF_PROG_TEST_RUN, &amp;attr, sizeof(attr));</p>
<p>test_attr-&gt;data_size_out = attr.test.data_size_out;
test_attr-&gt;ctx_size_out = attr.test.ctx_size_out;
test_attr-&gt;retval = attr.test.retval;
test_attr-&gt;duration = attr.test.duration;</p>
<p>return libbpf_err_errno(ret);</p>
</div></blockquote>
<p>}</p>
<p>int bpf_prog_test_run_opts(int prog_fd, struct bpf_test_run_opts <a href="#id1185"><span class="problematic" id="id1186">*</span></a>opts)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int ret;</p>
<dl class="simple">
<dt>if (!OPTS_VALID(opts, bpf_test_run_opts))</dt><dd><p>return libbpf_err(-EINVAL);</p>
</dd>
</dl>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.test.prog_fd = prog_fd;
attr.test.cpu = OPTS_GET(opts, cpu, 0);
attr.test.flags = OPTS_GET(opts, flags, 0);
attr.test.repeat = OPTS_GET(opts, repeat, 0);
attr.test.duration = OPTS_GET(opts, duration, 0);
attr.test.ctx_size_in = OPTS_GET(opts, ctx_size_in, 0);
attr.test.ctx_size_out = OPTS_GET(opts, ctx_size_out, 0);
attr.test.data_size_in = OPTS_GET(opts, data_size_in, 0);
attr.test.data_size_out = OPTS_GET(opts, data_size_out, 0);
attr.test.ctx_in = ptr_to_u64(OPTS_GET(opts, ctx_in, NULL));
attr.test.ctx_out = ptr_to_u64(OPTS_GET(opts, ctx_out, NULL));
attr.test.data_in = ptr_to_u64(OPTS_GET(opts, data_in, NULL));
attr.test.data_out = ptr_to_u64(OPTS_GET(opts, data_out, NULL));</p>
<p>ret = sys_bpf(BPF_PROG_TEST_RUN, &amp;attr, sizeof(attr));</p>
<p>OPTS_SET(opts, data_size_out, attr.test.data_size_out);
OPTS_SET(opts, ctx_size_out, attr.test.ctx_size_out);
OPTS_SET(opts, duration, attr.test.duration);
OPTS_SET(opts, retval, attr.test.retval);</p>
<p>return libbpf_err_errno(ret);</p>
</div></blockquote>
<p>}</p>
<p>static int bpf_obj_get_next_id(__u32 start_id, __u32 <a href="#id1187"><span class="problematic" id="id1188">*</span></a>next_id, int cmd)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int err;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.start_id = start_id;</p>
<p>err = sys_bpf(cmd, &amp;attr, sizeof(attr));
if (!err)</p>
<blockquote>
<div><p><a href="#id1189"><span class="problematic" id="id1190">*</span></a>next_id = attr.next_id;</p>
</div></blockquote>
<p>return libbpf_err_errno(err);</p>
</div></blockquote>
<p>}</p>
<p>int bpf_prog_get_next_id(__u32 start_id, __u32 <a href="#id1191"><span class="problematic" id="id1192">*</span></a>next_id)
{</p>
<blockquote>
<div><p>return bpf_obj_get_next_id(start_id, next_id, BPF_PROG_GET_NEXT_ID);</p>
</div></blockquote>
<p>}</p>
<p>int bpf_map_get_next_id(__u32 start_id, __u32 <a href="#id1193"><span class="problematic" id="id1194">*</span></a>next_id)
{</p>
<blockquote>
<div><p>return bpf_obj_get_next_id(start_id, next_id, BPF_MAP_GET_NEXT_ID);</p>
</div></blockquote>
<p>}</p>
<p>int bpf_btf_get_next_id(__u32 start_id, __u32 <a href="#id1195"><span class="problematic" id="id1196">*</span></a>next_id)
{</p>
<blockquote>
<div><p>return bpf_obj_get_next_id(start_id, next_id, BPF_BTF_GET_NEXT_ID);</p>
</div></blockquote>
<p>}</p>
<p>int bpf_link_get_next_id(__u32 start_id, __u32 <a href="#id1197"><span class="problematic" id="id1198">*</span></a>next_id)
{</p>
<blockquote>
<div><p>return bpf_obj_get_next_id(start_id, next_id, BPF_LINK_GET_NEXT_ID);</p>
</div></blockquote>
<p>}</p>
<p>int bpf_prog_get_fd_by_id(__u32 id)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int fd;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.prog_id = id;</p>
<p>fd = sys_bpf(BPF_PROG_GET_FD_BY_ID, &amp;attr, sizeof(attr));
return libbpf_err_errno(fd);</p>
</div></blockquote>
<p>}</p>
<p>int bpf_map_get_fd_by_id(__u32 id)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int fd;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.map_id = id;</p>
<p>fd = sys_bpf(BPF_MAP_GET_FD_BY_ID, &amp;attr, sizeof(attr));
return libbpf_err_errno(fd);</p>
</div></blockquote>
<p>}</p>
<p>int bpf_btf_get_fd_by_id(__u32 id)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int fd;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.btf_id = id;</p>
<p>fd = sys_bpf(BPF_BTF_GET_FD_BY_ID, &amp;attr, sizeof(attr));
return libbpf_err_errno(fd);</p>
</div></blockquote>
<p>}</p>
<p>int bpf_link_get_fd_by_id(__u32 id)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int fd;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.link_id = id;</p>
<p>fd = sys_bpf(BPF_LINK_GET_FD_BY_ID, &amp;attr, sizeof(attr));
return libbpf_err_errno(fd);</p>
</div></blockquote>
<p>}</p>
<p>int bpf_obj_get_info_by_fd(int bpf_fd, void <a href="#id1199"><span class="problematic" id="id1200">*</span></a>info, __u32 <a href="#id1201"><span class="problematic" id="id1202">*</span></a>info_len)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int err;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.info.bpf_fd = bpf_fd;
attr.info.info_len = <a href="#id1203"><span class="problematic" id="id1204">*</span></a>info_len;
attr.info.info = ptr_to_u64(info);</p>
<p>err = sys_bpf(BPF_OBJ_GET_INFO_BY_FD, &amp;attr, sizeof(attr));</p>
<dl class="simple">
<dt>if (!err)</dt><dd><p><a href="#id1205"><span class="problematic" id="id1206">*</span></a>info_len = attr.info.info_len;</p>
</dd>
</dl>
<p>return libbpf_err_errno(err);</p>
</div></blockquote>
<p>}</p>
<p>int bpf_raw_tracepoint_open(const char <a href="#id1207"><span class="problematic" id="id1208">*</span></a>name, int prog_fd)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int fd;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.raw_tracepoint.name = ptr_to_u64(name);
attr.raw_tracepoint.prog_fd = prog_fd;</p>
<p>fd = sys_bpf(BPF_RAW_TRACEPOINT_OPEN, &amp;attr, sizeof(attr));
return libbpf_err_errno(fd);</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>int bpf_load_btf(const void <a href="#id1209"><span class="problematic" id="id1210">*</span></a>btf, __u32 btf_size, char <a href="#id1211"><span class="problematic" id="id1212">*</span></a>log_buf, __u32 log_buf_size,</dt><dd><p>bool do_log)</p>
</dd>
</dl>
<dl>
<dt>{</dt><dd><p>union bpf_attr attr = {};
int fd;</p>
<p>attr.btf = ptr_to_u64(btf);
attr.btf_size = btf_size;</p>
</dd>
<dt>retry:</dt><dd><dl class="simple">
<dt>if (do_log &amp;&amp; log_buf &amp;&amp; log_buf_size) {</dt><dd><p>attr.btf_log_level = 1;
attr.btf_log_size = log_buf_size;
attr.btf_log_buf = ptr_to_u64(log_buf);</p>
</dd>
</dl>
<p>}</p>
<p>fd = sys_bpf(BPF_BTF_LOAD, &amp;attr, sizeof(attr));</p>
<dl class="simple">
<dt>if (fd &lt; 0 &amp;&amp; !do_log &amp;&amp; log_buf &amp;&amp; log_buf_size) {</dt><dd><p>do_log = true;
goto retry;</p>
</dd>
</dl>
<p>}</p>
<p>return libbpf_err_errno(fd);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>int bpf_task_fd_query(int pid, int fd, __u32 flags, char <a href="#id1213"><span class="problematic" id="id1214">*</span></a>buf, __u32 <a href="#id1215"><span class="problematic" id="id1216">*</span></a>buf_len,</dt><dd><p>__u32 <a href="#id1217"><span class="problematic" id="id1218">*</span></a>prog_id, __u32 <a href="#id1219"><span class="problematic" id="id1220">*</span></a>fd_type, __u64 <a href="#id1221"><span class="problematic" id="id1222">*</span></a>probe_offset,
__u64 <a href="#id1223"><span class="problematic" id="id1224">*</span></a>probe_addr)</p>
</dd>
</dl>
<dl>
<dt>{</dt><dd><p>union bpf_attr attr = {};
int err;</p>
<p>attr.task_fd_query.pid = pid;
attr.task_fd_query.fd = fd;
attr.task_fd_query.flags = flags;
attr.task_fd_query.buf = ptr_to_u64(buf);
attr.task_fd_query.buf_len = <a href="#id1225"><span class="problematic" id="id1226">*</span></a>buf_len;</p>
<p>err = sys_bpf(BPF_TASK_FD_QUERY, &amp;attr, sizeof(attr));</p>
<p><a href="#id1227"><span class="problematic" id="id1228">*</span></a>buf_len = attr.task_fd_query.buf_len;
<a href="#id1229"><span class="problematic" id="id1230">*</span></a>prog_id = attr.task_fd_query.prog_id;
<a href="#id1231"><span class="problematic" id="id1232">*</span></a>fd_type = attr.task_fd_query.fd_type;
<a href="#id1233"><span class="problematic" id="id1234">*</span></a>probe_offset = attr.task_fd_query.probe_offset;
<a href="#id1235"><span class="problematic" id="id1236">*</span></a>probe_addr = attr.task_fd_query.probe_addr;</p>
<p>return libbpf_err_errno(err);</p>
</dd>
</dl>
<p>}</p>
<p>int bpf_enable_stats(enum bpf_stats_type type)
{</p>
<blockquote>
<div><p>union bpf_attr attr;
int fd;</p>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.enable_stats.type = type;</p>
<p>fd = sys_bpf(BPF_ENABLE_STATS, &amp;attr, sizeof(attr));
return libbpf_err_errno(fd);</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>int bpf_prog_bind_map(int prog_fd, int map_fd,</dt><dd><p>const struct bpf_prog_bind_opts <a href="#id1237"><span class="problematic" id="id1238">*</span></a>opts)</p>
</dd>
</dl>
<dl>
<dt>{</dt><dd><p>union bpf_attr attr;
int ret;</p>
<dl class="simple">
<dt>if (!OPTS_VALID(opts, bpf_prog_bind_opts))</dt><dd><p>return libbpf_err(-EINVAL);</p>
</dd>
</dl>
<p>memset(&amp;attr, 0, sizeof(attr));
attr.prog_bind_map.prog_fd = prog_fd;
attr.prog_bind_map.map_fd = map_fd;
attr.prog_bind_map.flags = OPTS_GET(opts, flags, 0);</p>
<p>ret = sys_bpf(BPF_PROG_BIND_MAP, &amp;attr, sizeof(attr));
return libbpf_err_errno(ret);</p>
</dd>
</dl>
<p>}</p>
</div>
<div class="section" id="bpf">
<h2>bpf系统调用分析<a class="headerlink" href="#bpf" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="ebpf">
<h2>ebpf运行机制<a class="headerlink" href="#ebpf" title="Permalink to this headline">¶</a></h2>
<p>BPF JIT编译器</p>
</div>
<div class="section" id="bpfilter">
<h2>bpfilter分析总结<a class="headerlink" href="#bpfilter" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Rachel.Sun.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>