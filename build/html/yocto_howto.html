<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>yocto概念 &mdash; Rachel&#39;s E-book 1.0 documentation</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Rachel's E-book
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="os_base/index.html">linux 操作系统概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="lk_devel/index.html">linux 内核开发基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="x86_kernel_base.html">linux X86内核基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="lk_code/index.html">linux 内核基础代码分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="pm.html">电源管理框架</a></li>
<li class="toctree-l1"><a class="reference internal" href="cpu.html">cpu管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="driver.html">设备驱动</a></li>
<li class="toctree-l1"><a class="reference internal" href="ps.html">进程管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="mem.html">内存管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="fs.html">文件系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="sec.html">linux 内核安全</a></li>
<li class="toctree-l1"><a class="reference internal" href="yocto_kernel.html">yocto uboot与内核模块、内核开发总结</a></li>
<li class="toctree-l1"><a class="reference internal" href="uboot.html">uboot理解</a></li>
<li class="toctree-l1"><a class="reference internal" href="dot.html">dot画图</a></li>
<li class="toctree-l1"><a class="reference internal" href="bpf_helper.html">BPF-HELPERS</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Rachel's E-book</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>yocto概念</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/yocto_howto.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="yocto">
<h1>yocto概念<a class="headerlink" href="#yocto" title="Permalink to this headline">¶</a></h1>
<p>Yocto 项目快速构建
欢迎！
这个简短的文档将引导您完成使用 Yocto 项目构建典型图像的过程。该文档还介绍了如何为特定硬件配置构建。您将使用 Yocto Project 构建一个名为 Poky 的参考嵌入式操作系统。</p>
<p>笔记</p>
<p>本文中的示例假设您使用的是运行最近的 Ubuntu Linux 发行版的本机 Linux 系统。如果您要使用 Yocto Project 构建映像（构建主机）的机器不是本机 Linux 系统，您仍然可以通过使用 CROss PlatformS (CROPS) 并设置 Poky 容器来执行这些步骤。有关详细信息，请参阅 Yocto 项目开发任务手册中的 设置使用 CROss PlatformS (CROPS) 部分。</p>
<p>您可以使用 Windows Subsystem For Linux v2 来设置使用 Windows 10 的构建主机。</p>
<p>笔记</p>
<p>Yocto 项目与 WSLv1 不兼容，它与 WSLv2 兼容但未得到官方支持或验证，如果您仍然决定使用 WSL，请升级到 WSLv2。</p>
<p>有关详细信息，请参阅 Yocto 项目开发任务手册中的设置以使用适用于 Linux 的 Windows 子系统 (WSLv2)部分。</p>
<p>如果您想了解有关 Yocto 项目的更多概念或背景信息，请参阅Yocto 项目概述和概念手册。</p>
<p>兼容的 Linux 发行版
确保您的构建主机满足以下要求：</p>
<p>50 GB 可用磁盘空间</p>
<p>运行受支持的 Linux 发行版（即 Fedora、openSUSE、CentOS、Debian 或 Ubuntu 的最新版本）。有关支持 Yocto 项目的 Linux 发行版列表，请参阅 Yocto 项目参考手册中的 支持的 Linux 发行版 部分。有关准备构建主机的详细信息，请参阅 Yocto 项目开发任务手册中的 准备构建主机 部分。</p>
<p>Git 1.8.3.1 或更高版本</p>
<p>焦油 1.28 或更高版本</p>
<p>Python 3.6.0 或更高版本。</p>
<p>gcc 5.0 或更高版本。</p>
<p>如果您的构建主机不满足这三个列出的版本要求中的任何一个，您可以采取措施准备系统，以便您仍然可以使用 Yocto 项目。有关信息，请参阅 Yocto 项目参考手册中的所需 Git、tar、Python 和 gcc 版本部分。</p>
<p>构建主机包
您必须在构建主机上安装必要的主机包。以下命令基于 Ubuntu 发行版安装主机包：</p>
<p>$ sudo apt install gawk wget git diffstat unzip texinfo gcc build-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping python3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint3 xterm python3-subunit mesa-common-dev zstd liblz4-tool
笔记</p>
<p>有关所有受支持的 Linux 发行版的主机包要求，请参阅Yocto 项目参考手册中的构建主机所需的包 部分。</p>
<p>使用 Git 克隆 Poky
完成机器的设置说明后，您需要在构建主机上获取 Poky 存储库的副本。使用以下命令克隆 Poky 存储库。</p>
<p>$ git clone git://git.yoctoproject.org/poky
Cloning into ‘poky’…
remote: Counting
objects: 432160, done. remote: Compressing objects: 100%
(102056/102056), done. remote: Total 432160 (delta 323116), reused
432037 (delta 323000) Receiving objects: 100% (432160/432160), 153.81 MiB | 8.54 MiB/s, done.
Resolving deltas: 100% (323116/323116), done.
Checking connectivity… done.
转至Releases wiki 页面honister，并选择与最新稳定版本或长期支持版本相对应的版本代号（例如）。</p>
<p>然后移动到poky目录并查看现有分支：</p>
<p>$ cd poky
$ git branch -a
.
.
.
remotes/origin/HEAD -&gt; origin/master
remotes/origin/dunfell
remotes/origin/dunfell-next
.
.
.
remotes/origin/gatesgarth
remotes/origin/gatesgarth-next
.
.
.
remotes/origin/master
remotes/origin/master-next
.
.
.
对于此示例，请查看honister基于 Honister版本的分支：</p>
<p>$ git checkout -t origin/honister -b my-honister
Branch ‘my-honister’ set up to track remote branch ‘honister’ from ‘origin’.
Switched to a new branch ‘my-honister’
前面的 Git checkout 命令创建了一个名为 my-honister. 该分支中可供您使用的文件与honister 发布分支中存储库的文件完全匹配。</p>
<p>请注意，您可以定期在同一目录中键入以下命令，以使本地文件与发布分支保持同步：</p>
<p>$ git pull
有关访问 Yocto Project 相关存储库的更多选项和信息，请参阅 Yocto 项目开发任务手册中的 定位 Yocto 项目源文件 部分。</p>
<p>建立你的形象
使用以下步骤构建您的映像。构建过程从源代码创建一个完整的 Linux 发行版，包括工具链。</p>
<p>笔记</p>
<p>如果您在防火墙后面工作并且您的构建主机没有为代理设置，您可能会在获取源代码时遇到构建过程的问题（例如，获取器失败或 Git 失败）。</p>
<p>如果您不知道您的代理设置，请咨询您的本地网络基础设施资源并获取该信息。检查您的网络浏览器设置也是一个很好的起点。最后，您可以在 Yocto 项目 Wiki的“在网络代理后面工作”页面找到更多信息。</p>
<p>初始化构建环境：在poky 目录中，运行oe-init-build-env 环境设置脚本以在您的构建主机上定义 Yocto Project 的构建环境。</p>
<p>$ cd poky
$ source oe-init-build-env
You had no conf/local.conf file. This configuration file has therefore been
created for you with some default values. You may wish to edit it to, for
example, select a different MACHINE (target hardware). See conf/local.conf
for more information as common configuration options are commented.</p>
<p>You had no conf/bblayers.conf file. This configuration file has therefore
been created for you with some default values. To add additional metadata
layers into your configuration please add entries to conf/bblayers.conf.</p>
<p>The Yocto Project has extensive documentation about OE including a reference
manual which can be found at:</p>
<blockquote>
<div><p><a class="reference external" href="https://docs.yoctoproject.org">https://docs.yoctoproject.org</a></p>
</div></blockquote>
<dl class="simple">
<dt>For more information about OpenEmbedded see their website:</dt><dd><p><a class="reference external" href="https://www.openembedded.org/">https://www.openembedded.org/</a></p>
</dd>
</dl>
<p>### Shell environment set up for builds. ###</p>
<p>You can now run ‘bitbake &lt;target&gt;’</p>
<dl class="simple">
<dt>Common targets are:</dt><dd><p>core-image-minimal
core-image-full-cmdline
core-image-sato
core-image-weston
meta-toolchain
meta-ide-support</p>
</dd>
</dl>
<p>You can also run generated QEMU images with a command like ‘runqemu qemux86-64’</p>
<dl class="simple">
<dt>Other commonly useful commands are:</dt><dd><ul class="simple">
<li><p>‘devtool’ and ‘recipetool’ handle common recipe tasks</p></li>
<li><p>‘bitbake-layers’ handles common layer tasks</p></li>
<li><p>‘oe-pkgdata-util’ handles common target package tasks</p></li>
</ul>
</dd>
</dl>
<p>除其他外，该脚本创建了Build Directory， build在这种情况下，它位于Source Directory中。脚本运行后，您的当前工​​作目录将设置为构建目录。稍后，当构建完成时，构建目录包含构建期间创建的所有文件。</p>
<p>检查您的本地配置文件：当您设置构建环境时，名为的本地配置文件在构建目录的子目录中local.conf可用。conf对于此示例，默认设置为针对qemux86适合仿真的目标构建。使用的包管理器设置为 RPM 包管理器。</p>
<p>提示</p>
<p>您可以通过使用共享状态缓存 镜像和启用Hash Equivalence显着加快构建速度并防止提取器失败。这样，您可以使用预构建的工件而不是构建它们。仅当您的网络和您使用的服务器下载这些工件的速度快于您构建它们的速度时，这才是相关的。</p>
<p>要使用此类镜像，请在Build Directorylocal.conf中取消注释 文件中的以下行：</p>
<p>BB_SIGNATURE_HANDLER = “OEEquivHash”
BB_HASHSERVE = “auto”
BB_HASHSERVE_UPSTREAM = “typhoon.yocto.io:8687”
SSTATE_MIRRORS ?= “file://.* https://sstate.yoctoproject.org/3.4.2/PATH;downloadfilename=PATH”
以上设置假设使用 Yocto Project 3.4.2。如果您使用的是开发版本，请按如下方式设置SSTATE_MIRRORS ：</p>
<p>SSTATE_MIRRORS ?= “<a class="reference external" href="file://.*">file://.*</a> <a class="reference external" href="https://sstate.yoctoproject.org/dev/PATH;downloadfilename=PATH">https://sstate.yoctoproject.org/dev/PATH;downloadfilename=PATH</a>”
开始构建：继续使用以下命令为目标构建 OS 映像，core-image-sato在此示例中为：</p>
<p>$ bitbake core-image-sato
有关使用该bitbake命令的信息，请参阅 Yocto 项目概述和概念手册中 的BitBake部分，或参阅 BitBake 用户手册中的 BitBake 命令 。</p>
<p>使用 QEMU 模拟您的图像：构建此特定图像后，您可以启动 QEMU，它是 Yocto 项目附带的快速 EMUlator：</p>
<p>$ runqemu qemux86-64
如果您想了解有关运行 QEMU 的更多信息，请参阅 Yocto 项目开发任务手册中的 使用 Quick EMUlator (QEMU)章节。</p>
<p>退出 QEMU：通过单击关机图标或 Ctrl-C在调用 QEMU 的 QEMU 脚本窗口中键入退出 QEMU。</p>
<p>为特定硬件定制您的构建
到目前为止，您所做的只是快速构建了一个仅适用于仿真的图像。本节向您展示如何通过将硬件层添加到 Yocto 项目开发环境中来自定义特定硬件的构建。</p>
<p>通常，层是包含相关指令集和配置的存储库，这些指令和配置告诉 Yocto 项目要做什么。将相关元数据隔离到功能特定的层有助于模块化开发，并使层元数据的重用变得更容易。</p>
<p>笔记</p>
<p>按照惯例，图层名称以字符串“meta-”开头。</p>
<p>按照以下步骤添加硬件层：</p>
<p>查找层：许多硬件层可用。Yocto Project Source Repositories有许多硬件层。此示例添加了 meta-altera硬件层。</p>
<p>克隆层：使用 Git 在您的机器上制作层的本地副本。您可以将副本放在之前创建的 Poky 存储库副本的顶层：</p>
<p>$ cd poky
$ git clone <a class="reference external" href="https://github.com/kraj/meta-altera.git">https://github.com/kraj/meta-altera.git</a>
Cloning into ‘meta-altera’…
remote: Counting objects: 25170, done.
remote: Compressing objects: 100% (350/350), done.
remote: Total 25170 (delta 645), reused 719 (delta 538), pack-reused 24219
Receiving objects: 100% (25170/25170), 41.02 MiB | 1.64 MiB/s, done.
Resolving deltas: 100% (13385/13385), done.
Checking connectivity… done.
硬件层现在在构建主机上的 Poky 参考存储库中的其他层旁边可用，meta-altera并且包含支持 Intel 拥有的 Altera 硬件所需的所有元数据。</p>
<p>笔记</p>
<p>建议层在每个 Yocto 项目版本中都有一个分支。请确保签出支持您正在使用的 Yocto 项目版本的层分支。</p>
<p>将配置更改为为特定机器构建：文件中的 MACHINE变量 local.conf指定构建的机器。对于此示例，将MACHINE变量设置为cyclone5。使用这些配置： https ://github.com/kraj/meta-altera/blob/master/conf/machine/cyclone5.conf 。</p>
<p>笔记</p>
<p>有关配置构建的更多信息，请参阅前面的“检查您的本地配置文件”步骤。</p>
<p>将您的层添加到层配置文件：在构建期间使用层之前，您必须将其添加到您的bblayers.conf 文件中，该文件位于 构建目录 conf 目录中。</p>
<p>使用命令将层添加到配置文件中：bitbake-layers add-layer</p>
<p>$ cd poky/build
$ bitbake-layers add-layer ../meta-altera
NOTE: Starting bitbake server…
Parsing recipes: 100% <a href="#id129"><span class="problematic" id="id130">|##################################################################|</span></a> Time: 0:00:32
Parsing of 918 .bb files complete (0 cached, 918 parsed). 1401 targets,
123 skipped, 0 masked, 0 errors.
您可以在使用 bitbake-layers 脚本添加图层部分中找到有关添加图层的更多信息 。</p>
<p>完成这些步骤已将该meta-altera层添加到您的 Yocto Project 开发环境中，并将其配置为为 cyclone5机器构建。</p>
<p>笔记</p>
<p>前面的步骤仅用于演示目的。如果您要尝试为cyclone5机器构建映像，您应该阅读 Altera README。</p>
<p>创建您自己的通用层
也许您有需要隔离的应用程序或特定行为集。您可以使用该命令创建自己的通用层 。该工具通过设置具有 配置文件的子目录、包含 配方、许可文件和.bitbake-layers create-layerlayer.confrecipes-exampleexample.bbREADME</p>
<p>以下命令运行该工具以创建 meta-mylayer在poky目录中命名的层：</p>
<p>$ cd poky
$ bitbake-layers create-layer meta-mylayer
NOTE: Starting bitbake server…
Add your new layer with ‘bitbake-layers add-layer meta-mylayer’
有关图层以及如何创建图层的更多信息，请参阅 Yocto 项目开发任务手册中的使用 bitbake-layers 脚本创建通用图层 部分。</p>
<p>下一步要去哪里
既然您已经体验过使用 Yocto 项目，您可能会问自己“现在怎么办？”。Yocto 项目有许多信息来源，包括网站、wiki 页面和用户手册：</p>
<p>网站： Yocto项目网站提供背景信息、最新版本、突发新闻、完整的开发文档，以及可以访问的丰富的 Yocto 项目开发社区。</p>
<p>开发者截屏视频： Yocto项目入门 - 新的开发者截屏教程 提供了一个 30 分钟的视频，专为不熟悉 Yocto 项目但熟悉 Linux 构建主机的用户制作。虽然此截屏视频有些过时，但介绍性和基本概念对初学者很有用。</p>
<p>Yocto 项目概述和概念手册： Yocto 项目概述和概念手册是开始了解 Yocto 项目的好地方。本手册向您介绍 Yocto 项目及其开发环境。该手册还提供了 Yocto 项目各个方面的概念信息。</p>
<p>Yocto 项目 Wiki：Yocto 项目 Wiki 提供了有关在升级 Yocto 项目、发布信息、项目规划和 QA 信息时下一步要去哪里的更多信息。</p>
<p>Yocto Project 邮件列表：相关邮件列表为讨论、补丁提交和公告提供了一个论坛。有几个按主题分组的邮件列表。有关 Yocto 项目邮件列表的完整列表，请参阅 Yocto 项目参考手册中的邮件列表部分。</p>
<p>链接和其他文档的综合列表： Yocto 项目参考手册中的 链接和相关文档 部分提供了所有相关链接和其他用户文档的综合列表。</p>
<p>笔记</p>
<p>在进一步阅读之前，请确保您已查看 软件概述页面，该页面提供了此处引用的许多术语的定义。另外，要知道这里的一些信息现在没有意义，但是当您开始开发时，这些信息是您想要随时掌握的信息。这些是使用 Yocto Project 的最著名方法，并且会定期更新。</p>
<p>使用 Yocto 项目相当容易，直到出现问题。如果不了解构建过程的工作原理，您会发现自己正在尝试排除“黑匣子”的故障。以下是新用户在开始使用 Yocto Project 进行第一次构建之前希望他们知道的一些项目。如有其他建议，请随时与我们联系。</p>
<p>使用 Git，而不是 tarball 下载： 如果您使用 git，由于 git 的工作方式，软件将自动更新错误更新。如果您改为下载 tarball，则需要对自己的更新负责。</p>
<p>了解图层索引： 所有图层都可以在图层索引中找到。已申请 Yocto Project Compatible 状态（结构连续性保证和测试）的层可以在Yocto Project Compatible 索引中找到. 一般先检查Compatible layer index，如果没有找到需要的layer，检查general layer index。图层索引是来自 Open Embedded Project 的原始工件。因此，该索引没有 Yocto Project 在 Yocto Project Compatible 层列表上提供的策展和测试，但后者的条目较少。要知道，当您开始在层索引中搜索时，并非所有层都具有相同级别的成熟度、验证或可用性。搜索也不会优先显示显示的结果。没有简单的方法可以帮助您完成选择适合您需求的最佳层的过程。因此，通常需要反复试验、检查邮件列表或通过协作室与其他开发人员合作，这些都可以帮助您做出正确的选择。</p>
<p>尽可能使用芯片供应商提供的现有 BSP 层： 英特尔、TI、NXP 和其他公司都有关于哪些 BSP 层与他们的芯片一起使用的信息。这些层具有诸如“meta-intel”或“meta-ti”之类的名称。尽量不要从头开始构建图层。如果您确实有定制芯片，请使用这些层之一作为指南或模板，并熟悉 Yocto 项目板支持包开发人员指南。</p>
<p>不要把所有东西都放在一个层： 使用不同的层在你的构建中逻辑分离信息。例如，您可以有一个 BSP 层、一个 GUI 层、一个发行版配置、中间件或一个应用程序（例如“元文件系统”、“元python”、“元英特尔”等）。将整个构建放入一层会限制并使未来的定制和重用变得复杂。另一方面，将信息分层，有助于简化未来的定制和重用。</p>
<p>切勿修改 POKY 层。绝不。曾经。当您更新到下一个版本时，您将丢失所有工作。所有的。</p>
<p>不要被文档搜索结果所迷惑： Yocto Project 文档一直在更新。不幸的是，当您使用 Google 搜索 Yocto Project 概念或术语时，Google 会始终搜索和检索旧版本的 Yocto Project 手册。例如，使用 Google 搜索特定主题可能会“命中”几个版本的 Yocto 项目手册。为确保您使用的是最新的 Yocto Project 文档，请使用其任何页面顶部的下拉菜单。</p>
<p>许多开发人员 通过在整个页面中进行搜索来查看一体化“超级”手册中的概念或术语。本手册是 Yocto Project 手册核心集的串联。因此，在本手册中使用 Ctrl-F 进行简单的字符串搜索会产生所需术语或概念的所有“命中”。找到您感兴趣的区域后，您可以根据需要显示实际的手册。也可以使用菜单或左侧导航窗格中的搜索栏。</p>
<p>了解构建系统如何工作的基本概念： 工作流程： 了解 Yocto Project 工作流程很重要，因为它可以帮助您查明问题发生在哪里以及构建是如何中断的。工作流程分为以下步骤：</p>
<p>Fetch——获取源代码</p>
<p>提取 - 解压缩源</p>
<p>补丁 - 应用补丁以修复错误和新功能</p>
<p>配置 - 设置您的环境规范</p>
<p>构建——编译和链接</p>
<p>安装 - 将文件复制到目标目录</p>
<p>包 - 用于安装的捆绑文件</p>
<p>在“获取”期间，可能无法找到代码。在“提取”期间，可能存在无效的 zip 或类似的东西。换句话说，工作流特定部分的功能可以让您了解可能出现的问题。</p>
<p>yp-how-it-works-new-diagram.png</p>
<p>知道您可以生成依赖关系图并学习如何去做： 依赖关系图显示配方、任务和目标之间的依赖关系。您可以使用 BitBake 的“-g”选项来生成此图。当您开始构建并且构建中断时，您可能会看到您不知道或不知道构建系统为何包含它们的包。依赖图可以澄清这种混淆。您可以在 BitBake 用户手册的生成依赖图部分了解更多关于依赖图以及如何生成它们的信息 。</p>
<p>以下是您在 tmp/work 中解码“神奇”文件夹名称的方法： 构建系统获取、解包、预处理和构建。如果出现问题，构建系统会直接向您报告构建产生的临时（构建/tmp）文件和包所在的文件夹的路径。有关此过程的详细示例，请参见示例。不幸的是，这个例子是在 Yocto Project 的早​​期版本中。</p>
<p>当您执行构建时，您可以使用“-u”BitBake 命令行选项将用户界面查看器指定到依赖关系图中（例如，knotty、ncurses 或 taskexp），以帮助您更好地理解构建依赖关系。</p>
<p>您可以构建的不仅仅是图像： 您可以为特定包（包括 devshell）甚至单个配方构建和运行特定任务。当开发人员第一次开始使用 Yocto 项目时， Yocto 项目快速构建中的说明显示了如何创建映像，然后运行或刷新该映像。但是，您实际上可以只构建一个配方。因此，如果某些依赖项或配方不起作用，您只需说“bitbake foo”，其中“foo”是特定配方的名称。随着您使用 Yocto 项目变得更加先进，并且如果构建失败，确保 fetch 本身按预期工作会很有用。以下是一些有价值的链接：使用开发 Shell获取有关如何使用 devshell 构建和运行特定任务的信息。此外，该SDK 手册展示了如何构建特定的配方。</p>
<p>一个模棱两可的定义：包与配方： 配方包含构建系统用于创建包的指令。Recipes 和 Packages 是前端和构建过程结果之间的区别。</p>
<p>如前所述，构建系统采用配方并根据配方的说明创建包。生成的包与配方正在构建的一件事相关，但是是构建的不同部分（包）（即主包、doc 包、调试符号包、单独的实用程序包等）。构建系统将包分开，这样您就不需要安装不需要或不需要的包，这是有利的，因为在为嵌入式和物联网开发时，您正在为小型设备构建。</p>
<p>您将想要了解并了解根文件系统中打包的内容。</p>
<p>创建您自己的图像配方： 有多种方法可以创建您自己的图像配方。我们建议您创建自己的图像配方，而不是附加现有配方。编写图像配方是微不足道和容易的。同样，不要尝试附加到现有的图像配方。创建您自己的并从一开始就做好。</p>
<p>最后，这里列出了作为系统开发人员所需的基本技能。您必须能够：</p>
<p>处理公司代理人</p>
<p>将包添加到图像</p>
<p>了解配方和包装之间的区别</p>
<p>自己构建一个包以及为什么它很有用</p>
<p>找出配方创建的包</p>
<p>找出包中有哪些文件</p>
<p>找出图像中的文件</p>
<p>将 ssh 服务器添加到图像（启用将文件传输到目标）</p>
<p>了解食谱的解剖结构</p>
<p>知道如何创建和使用图层</p>
<p>查找食谱（使用OpenEmbedded 层索引）</p>
<p>了解机器和发行版设置之间的区别</p>
<p>为您的硬件找到并使用正确的 BSP（机器）</p>
<p>查找发行版功能的示例并知道在哪里设置它们</p>
<p>了解任务管道并执行单个任务</p>
<p>了解 devtool 以及它如何简化您的工作流程</p>
<p>通过共享下载和共享状态缓存提高构建速度</p>
<p>生成和理解依赖图</p>
<p>生成和理解 bitbake 环境</p>
<p>为应用程序开发构建可扩展的 SDK</p>
<p>根据您对 Yocto 项目的主要兴趣，您可以考虑以下任何阅读内容：</p>
<p>查看 Yocto 项目开发任务手册：本手册包含分组的程序信息，可帮助您进行设置、使用层、自定义图像、编写新配方、使用库和使用 QEMU。这些信息是基于任务的，并且涵盖了 Yocto 项目的范围。请参阅Yocto 项目开发任务手册。</p>
<p>查看 Yocto 项目应用程序开发和可扩展软件开发工具包 (eSDK) 手册：本手册描述了如何使用标准 SDK 和可扩展 SDK，它们主要用于应用程序开发。使用可扩展 SDK还提供了使用 devtool 的示例工作流。有关更多信息，请参阅 SDK 工作流程中的使用 devtool部分 。</p>
<p>了解内核开发：如果您想了解如何使用内核并了解 Yocto Linux 内核，请参阅Yocto Project Linux 内核开发手册。本手册提供有关如何修补内核、修改内核配方和配置内核的信息。</p>
<p>了解板级支持包 (BSP)：如果您想了解 BSP，请参阅Yocto 项目板级支持包开发人员指南。本手册还提供了一个示例 BSP 创建工作流程。请参阅板级支持包 (BSP) - 开发人员指南部分。</p>
<p>了解 Toaster：Toaster 是 Yocto 项目的 OpenEmbedded 构建系统的 Web 界面。如果您对使用这种类型的界面创建图像感兴趣，请参阅Toaster 用户手册。</p>
<p>提供 Yocto Project 参考手册：与 Yocto Project 手册集的其余部分不同，本手册包含适合参考的材料，而不是程序。您可以获取构建详细信息、详细了解 Yocto Project 开发环境的各个部分如何协同工作、有关各种技术细节的信息、迁移到较新 Yocto Project 版本的指南、有关目录结构、类和任务的参考资料。Yocto 项目参考手册还包含一个相当全面的Yocto 项目中使用的变量词汇表。</p>
<p>过渡到用于系统开发的自定义环境</p>
<p>笔记</p>
<p>所以您已经完成了Yocto Project 快速构建并浏览了文档What I wish I’d known about Yocto Project，后者包含从其他用户那里学到的重要信息。你准备充分。但是现在，当您开始自己的项目时，要做什么并不那么简单。而且，文档令人生畏。我们已经整理了一些提示来帮助您入门。</p>
<p>列出将成为您项目一部分的处理器、目标板、技术和功能。您将找到包含支持这些内容的配方和其他元数据的图层，并将它们添加到您的配置中。（见#3）</p>
<p>设置您的董事会支持。即使您使用的是定制硬件，从使用与定制硬件相同的处理器或至少相同架构的现有目标板开始可能会更容易。知道该板在项目中已经有一个正常工作的板支持包 (BSP) 可以让您更轻松地熟悉项目概念。</p>
<p>为您的目标寻找并获得最佳 BSP。使用Yocto Project 精选层索引甚至OpenEmbedded 层索引来查找和获取最适合您的目标板的 BSP。Yocto 项目层索引 BSP 会定期进行验证。获得您的第一个 BSP 的最佳地点是您的芯片制造商或电路板供应商——他们可以为您指出他们最合格的努力。一般来说，英特尔芯片使用 meta-intel，德州仪器使用 meta-ti，依此类推。选择一个已使用您下载的相同 Yocto Project 版本进行测试的 BSP。请注意，最新版本可能不会立即支持某些 BSP，但最终会支持。</p>
<p>您可能希望从 Poky 提供的构建规范（参考嵌入式发行版）开始，然后将新选择的层添加到其中。这是有关添加层的信息。</p>
<p>根据您选择的层，对您的配置进行必要的更改。例如，您选择了一种机器类型并添加到相应的 BSP 层中。然后，您需要更改配置文件 (build/local.conf) 中MACHINE变量的值以指向相同的机器类型。您可能还需要更改其他特定于图层的设置。每个层都有一个README文档，您可以查看该文档以了解此类使用信息。</p>
<p>为您创建的任何自定义配方和元数据添加一个新层。使用Yocto Project 2.4+ 版本的工具。如果您使用的是 2.4 之前的 Yocto Project 版本，请使用该 工具。该工具还提供了许多其他有用的与图层相关的命令。请参阅 使用 bitbake-layers 脚本创建通用层部分。bitbake-layers create-layeryocto-layer createbitbake-layers</p>
<p>为您要使用的 BSP 创建您自己的层。除非您有一个非常特殊的设备，否则您需要从头开始创建整个 BSP 并不常见。即使您使用现有的 BSP，也请为 BSP 创建自己的层。例如，给定一台基于 x86 的 64 位机器，复制 conf/intel-corei7-64 定义并给机器起一个相关名称（考虑板名称，而不是产品名称）。确保层配置依赖于 meta-intel 层（或者至少 meta-intel 保留在您的 bblayers.conf 中）。现在您可以将自定义 BSP 设置放入您的层中，并且可以将其重新用于不同的应用程序。</p>
<p>编写您自己的配方以构建尚未以配方形式提供的其他软件支持。创建自己的配方对于要在设备上运行的自定义应用程序软件尤其重要。编写新食谱是一个改进的过程。首先让构建过程的每个步骤都从获取到打包开始。接下来，在您的目标上运行该软件并根据需要进一步改进。有关更多信息，请参阅Yocto 项目开发任务手册中的编写新配方。</p>
<p>现在您已准备好创建图像配方。有很多方法可以做到这一点。但是，强烈建议您拥有自己的图像配方 - 不要尝试附加到现有的图像配方。图像配方创建起来很简单，您通常希望完全自定义它们的内容。</p>
<p>建立你的形象并完善它。使用您对工作流程的了解来确定可能发生问题的位置，添加缺失的内容并修复任何损坏的内容 。</p>
<p>考虑创建您自己的发行版。当您达到一定程度的自定义时，请考虑创建您自己的发行版，而不是使用默认的参考发行版。</p>
<p>分发设置定义了打包后端（例如 rpm 或其他）以及包源和可能的更新解决方案。您将在继承自 Poky 的新层中创建自己的发行版，但覆盖您的发行版需要更改的内容。如果您发现除了路径和其他典型的本地设置之外，您还向 local.conf 文件添加了很多配置，那么是时候考虑创建自己的发行版了。</p>
<p>如果需要，您可以在其他层中添加可以自定义分布的产品规格。您还可以添加特定于产品的其他功能。但是要更新分布而不是单个产品，您可以通过该层更新分布特征。</p>
<p>恭喜！你一路走好。 欢迎来到 Yocto 项目社区。</p>
<p>wiki:https://wiki.yoctoprojet.org</p>
<hr class="docutils" />
<p>V3.5
概述
“””””
Yocto 项目是一个开源协作项目，可帮助开发人员创建基于 Linux 的定制系统，这些系统专为嵌入式产品而设计，无论产品的硬件架构如何。Yocto Project 提供了一个灵活的工具集和开发环境，允许世界各地的嵌入式设备开发人员通过共享技术、软件堆栈、配置和用于创建这些定制 Linux 映像的最佳实践进行协作。</p>
<p>全球数以千计的开发人员发现 Yocto Project 在系统和应用程序开发、归档和管理优势以及用于速度、占用空间和内存利用率的自定义方面都具有优势。该项目是交付嵌入式软件堆栈的标准。该项目允许为多个硬件平台以及可以维护和扩展的软件堆栈进行软件定制和构建交换。</p>
<p>key-dev-elements.png</p>
<p>有关 Yocto 项目的更多介绍性信息，您可能会对 Drew Moseley 的这篇文章和这个简短的介绍性视频感兴趣。:<a class="reference external" href="https://www.embedded.com/why-the-yocto-project-for-my-iot-project/">https://www.embedded.com/why-the-yocto-project-for-my-iot-project/</a></p>
<div class="section" id="id1">
<h2>特点<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>以下是 Yocto 项目的特点和优势：</p>
<p>在整个行业中广泛采用：许多半导体、操作系统、软件和服务供应商在其产品和服务中采用并支持 Yocto 项目。要查看 Yocto 项目社区和参与 Yocto 项目的公司，请参阅 Yocto 项目主页上的“社区”和“生态系统”选项卡。</p>
<p>架构不可知论： Yocto 项目支持 Intel、ARM、MIPS、AMD、PPC 和其他架构。大多数 ODM、OSV 和芯片供应商创建和提供支持其硬件的 BSP。如果您有定制芯片，则可以创建支持该架构的 BSP。</p>
<p>除了广泛的架构支持之外，Yocto 项目还完全支持由 Quick EMUlator (QEMU) 模拟的各种设备。</p>
<p>图像和代码轻松传输： Yocto Project 输出可以轻松地在架构之间移动，而无需迁移到新的开发环境。此外，如果您使用 Yocto 项目创建映像或应用程序，但发现自己无法支持它，风河、Mentor Graphics、Timesys 和 ENEA 等商业 Linux 供应商可以接受它并提供持续支持。这些供应商提供使用 Yocto 项目构建的产品。</p>
<p>灵活性：公司以多种不同方式使用 Yocto 项目。一个例子是创建一个内部 Linux 发行版作为公司可以跨多个产品组使用的代码库。通过定制和分层，项目组可以利用基础 Linux 发行版来创建满足其产品需求的发行版。</p>
<p>受限嵌入式和物联网设备的理想选择：与完整的 Linux 发行版不同，您可以使用 Yocto 项目来准确创建嵌入式设备所需的内容。您只需添加设备绝对需要的功能支持或软件包。对于具有显示硬件的设备，您可以使用 X11、Wayland、GTK+、Qt、Clutter 和 SDL（以及其他）等可用系统组件来创建丰富的用户体验。对于没有显示器的设备或您想要使用替代 UI 框架的设备，您可以选择不构建这些组件。</p>
<p>全面的工具链功能：支持架构的工具链满足大多数用例。但是，如果您的硬件支持不属于标准工具链的功能，您可以通过指定平台特定的调整参数轻松自定义该工具链。而且，如果您需要使用第三方工具链，Yocto 项目中内置的机制允许这样做。</p>
<p>机制规则优于策略：关注机制而不是策略可确保您可以根据设计需求自由设置策略，而不是采用某些系统软件提供商强制执行的决策。</p>
<p>使用层模型： Yocto Project层基础设施 将相关功能分组到单独的包中。您可以根据需要将这些分组功能逐步添加到您的项目中。使用层来隔离和分组功能可以降低项目的复杂性和冗余，让您可以轻松扩展系统、进行自定义并保持功能井井有条。</p>
<p>支持部分构建：您可以根据需要构建和重建单个包。Yocto Project 通过其 共享状态缓存(sstate) 方案实现了这一点。能够单独构建和调试组件简化了项目开发。</p>
<p>根据严格的时间表发布：主要发布以 六个月为周期 ，预计在 10 月和 4 月发布。最近的两个版本支持点版本以解决常见的漏洞和暴露。这种可预测性对于基于 Yocto 项目的项目至关重要，并允许开发团队计划活动。</p>
<p>丰富的个人和组织生态系统：对于开源项目来说，社区的价值非常重要。支持论坛、专业知识和继续推动 Yocto 项目向前发展的活跃开发人员随时可用。</p>
<p>二进制可重现性： Yocto 项目允许您非常具体地了解依赖关系并实现非常高的二进制重现性百分比（例如 99.8% core-image-minimal）。当发行版没有具体说明拉入哪些包以及以什么顺序支持依赖项时，其他构建系统可以任意包含包。</p>
<p>许可证清单： Yocto 项目提供许可证清单 供需要跟踪开源许可证使用情况的人员（例如法律团队）进行审查。</p>
</div>
<div class="section" id="id2">
<h2>Yocto 项目层模型<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Yocto 项目的“层模型”是一种用于嵌入式和物联网 Linux 创建的开发模型，它将 Yocto 项目与其他简单的构建系统区分开来。层模型同时支持协作和定制。层是包含相关指令集的存储库，这些指令告诉OpenEmbedded 构建系统 要做什么。您可以协作、共享和重用图层。</p>
<p>图层可以随时包含对先前说明或设置的更改。这种强大的覆盖功能允许您自定义以前提供的协作或社区层以满足您的产品需求。</p>
<p>您在构建中使用不同的层在逻辑上分离信息。例如，您可以拥有 BSP、GUI、发行版配置、中间件或应用程序层。将整个构建放入一层会限制并使未来的定制和重用变得复杂。另一方面，将信息分层，有助于简化未来的定制和重用。在处理单个项目时，您可能会发现将所有内容都放在一个层中很诱人。但是，元数据越模块化，就越容易应对未来的变化。</p>
<p>笔记</p>
<p>尽可能使用芯片供应商提供的板级支持包 (BSP) 层。</p>
<p>熟悉 Yocto Project 策划层索引 或OpenEmbedded 层索引。后者包含更多层，但它们的普遍验证较少。</p>
<p>层支持包含技术、硬件组件和软件组件。Yocto 项目兼容 指定提供了有助于强大生态系统的最低标准化水平。“YP Compatible”应用于适当的产品和软件组件，例如 BSP、其他 OE 兼容层和相关的开源项目，允许生产者使用 Yocto Project 徽章和品牌资产。</p>
<p>为了说明如何使用层来保持模块化，请考虑机器定制。这些类型的定制通常驻留在一个特殊的层，而不是一个通用层，称为 BSP 层。此外，例如，机器定制应该与支持新 GUI 环境的配方和元数据隔离开来。这种情况为您提供了几层：一层用于机器配置，一层用于 GUI 环境。然而，重要的是要理解，BSP 层仍然可以对 GUI 环境层中的配方进行特定于机器的添加，而不会因这些特定于机器的更改而污染 GUI 层本身。您可以通过作为 BitBake 附加 ( .bbappend) 文件的配方来完成此操作，本节稍后将对此进行介绍。</p>
<p>笔记</p>
<p>有关 BSP 层结构的一般信息，请参阅 Yocto Project Board Support Package Developer’s Guide。</p>
<p>源目录 包含开箱即用的通用层和 BSP 层。您可以通过名称轻松识别源目录中随 Yocto 项目发布的层。层通常具有以字符串开头的名称meta-。</p>
<p>笔记</p>
<p>层名称不要求以前缀 开头 meta-，但它是 Yocto Project 社区中普遍接受的标准。</p>
<p>例如，如果您要检查存储库的树视图 ，poky您将看到几个层：meta、 meta-skeleton、meta-selftest、meta-poky和 meta-yocto-bsp。这些存储库中的每一个都代表一个不同的层。</p>
<p>有关如何创建层的过程，请参阅 Yocto 项目开发任务手册中的“理解和创建层”部分。</p>
</div>
<div class="section" id="id3">
<h2>开发工具<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>以下工具可帮助您使用 Yocto 项目开发图像和应用程序：</p>
<ul class="simple">
<li><p>CROPS： CROPS是一个利用Docker Containers的开源跨平台开发框架 。CROPS 提供了一个易于管理、可扩展的环境，允许您为 Windows、Linux 和 Mac OS X 主机上的各种架构构建二进制文件。</p></li>
<li><p>devtool：此命令行工具作为可扩展 SDK (eSDK) 的一部分提供，是它的基石。您可以devtool 用来帮助在 eSDK 中构建、测试和打包软件。您可以使用该工具选择性地将您构建的内容集成到由 OpenEmbedded 构建系统构建的映像中。</p></li>
</ul>
<p>该devtool命令使用了许多允许您添加、修改和升级配方的子命令。与 OpenEmbedded 构建系统一样，“recipes”表示 devtool. 当您使用 时，会自动创建一个配方。使用 时，将使用指定的现有配方以确定从何处获取源代码以及如何修补它。在这两种情况下，都会设置一个环境，以便在您构建配方时使用您控制的源代码树，以便您可以根据需要对源代码进行更改。默认情况下，新配方和源代码都进入 eSDK 下的“工作区”目录。该命令更新现有配方，以便您可以为一组更新的源文件构建它。devtool adddevtool modifydevtool upgrade</p>
<p>您可以在“在 SDK 工作流程中使用 devtool ”部分中阅读devtoolYocto 项目应用程序开发和可扩展软件开发工具包 (eSDK) 手册中的工作流程。</p>
<ul class="simple">
<li><p>可扩展软件开发工具包 (eSDK)： eSDK 提供了针对特定图像内容定制的交叉开发工具链和库。eSDK 可以轻松地将新应用程序和库添加到映像、修改现有组件的源代码、测试目标硬件上的更改以及集成到 OpenEmbedded 构建系统的其余部分。eSDK 为您提供工具链体验，并辅以devtool为 Yocto 项目环境量身定制的强大命令集。</p></li>
</ul>
<p>有关 eSDK 的信息，请参阅Yocto 项目应用程序开发和可扩展软件开发工具包 (eSDK)手册。</p>
<ul class="simple">
<li><p>Toaster： Toaster 是 Yocto Project OpenEmbedded 构建系统的 Web 界面。Toaster 允许您配置、运行和查看有关构建的信息。有关烤面包机的信息，请参阅 烤面包机用户手册。</p></li>
</ul>
</div>
<div class="section" id="id4">
<h2>生产工具<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>以下是帮助使用 Yocto 项目进行生产相关活动的工具：</p>
<ul class="simple">
<li><p>自动升级助手：此实用程序与 OpenEmbedded 构建系统 （BitBake 和 OE-Core）结合使用时，会自动为基于上游发布的新版本配方的配方生成升级。 有关如何设置它，请参阅 使用自动升级帮助程序 (AUH) 。</p></li>
<li><p>配方报告系统：配方报告系统跟踪可用于 Yocto 项目的配方版本。该系统的主要目的是帮助您管理您维护的配方并提供项目的动态概览。配方报告系统建立在OpenEmbedded Layer Index之上，这是一个索引 OpenEmbedded-Core 层的网站。</p></li>
<li><p>Patchwork： Patchwork 是最初由 OzLabs启动的项目的一个分支。该项目是一个基于网络的跟踪系统，旨在简化将贡献引入项目的过程。Yocto 项目使用 Patchwork 作为组织工具来处理补丁，每个版本的补丁数量为数千。</p></li>
<li><p>AutoBuilder： AutoBuilder 是一个自动化构建测试和质量保证 (QA) 的项目。通过使用公共 AutoBuilder，任何人都可以确定 Poky 当前开发分支的状态。</p></li>
</ul>
<p>笔记</p>
<p>AutoBuilder 基于 buildbot。</p>
<p>Yocto 项目的一个目标是通过一个自动化测试和 QA 程序的项目来引领开源行业。在此过程中，该项目鼓励开发社区发布 QA 和测试计划，公开展示 QA 和测试计划，并鼓励开发自动化和测试和 QA 程序的工具，以造福于开发社区。</p>
<p>您可以在此处了解有关 Yocto Project Autobuilder 使用的 AutoBuilder 的更多信息。</p>
<ul class="simple">
<li><p>交叉预链接：与在运行时执行此操作相比，预链接是预先计算动态链接器生成的加载地址和链接表的过程。提前执行此操作会在启动应用程序时提高性能，并减少许多应用程序共享的库的内存使用量。</p></li>
</ul>
<p>从历史上看，交叉预链接是预链接的一种变体，它是由Jakub Jelínek几年前构想的。预链接和交叉预链接都维护在同一个存储库中，尽管在不同的分支上。通过提供模拟运行时动态链接器（即glibc衍生ld.so模拟），交叉预链接项目扩展了预链接软件预链接 sysroot 环境的能力。此外，交叉预链接软件能够在 sysroot 风格的环境中工作。</p>
<p>动态链接器根据映射地址、库使用和库函数冲突等多种因素确定标准加载地址计算。预链接工具使用来自动态链接器的此信息来确定共享库和动态链接的可执行和可链接格式 (ELF) 二进制文件的唯一加载地址。预链接工具使用预先计算的信息修改这些 ELF 二进制文件。结果是更快的加载并且通常更低的内存消耗，因为更多的库代码可以从共享的写时复制 (COW) 页面中重用。</p>
<p>由于依赖于目标设备的动态链接器，原上游预链接项目仅支持在终端目标设备上运行预链接。在开发交叉编译系统时，此限制会导致问题。交叉预链接添加了一个在主机上运行的合成动态加载程序，因此允许交叉预链接，而不必在读写目标文件系统上运行。</p>
<ul class="simple">
<li><p>伪：伪是 Yocto 项目的 fakeroot实现，用于在看似具有 root 权限的环境中运行命令。</p></li>
</ul>
<p>在构建期间，可能需要执行需要系统管理员权限的操作。例如，可能需要定义文件所有权或权限。Pseudo 是一种可以直接使用或通过环境变量使用的工具 LD_PRELOAD。即使没有系统管理员权限，任何一种方法都允许这些操作成功。</p>
<p>感谢 Pseudo，Yocto 项目永远不需要 root 权限来为您的目标系统构建映像。</p>
<p>您可以在“ Fakeroot and Pseudo ”部分阅读更多关于 Pseudo 的信息。</p>
<div class="section" id="id5">
<h3>2.3.3开放式嵌入式构建系统组件<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>以下是与OpenEmbedded Build System相关的组件：</p>
<ul class="simple">
<li><p>BitBake： BitBake 是 Yocto 项目的核心组件，被 OpenEmbedded 构建系统用于构建镜像。虽然 BitBake 是构建系统的关键，但 BitBake 与 Yocto 项目分开维护。</p></li>
</ul>
<p>BitBake 是一个通用的任务执行引擎，它允许 shell 和 Python 任务在复杂的任务间依赖约束下高效并行运行。简而言之，BitBake 是一个构建引擎，它通过以特定格式编写的配方来执行一系列任务。</p>
<p>您可以在BitBake 用户手册中了解有关 BitBake 的更多信息。</p>
<ul class="simple">
<li><p>OpenEmbedded-Core： OpenEmbedded-Core (OE-Core) 是 OpenEmbedded 派生系统（包括 Yocto 项目）使用的元数据的公共层（即配方、类和相关文件）。Yocto 项目和 OpenEmbedded 项目都维护 OpenEmbedded-Core。您可以在 Yocto Project Source Repositories中找到 OE-Core 元数据。</p></li>
</ul>
<p>从历史上看，Yocto 项目在整个 Yocto 项目源存储库参考系统 (Poky) 中集成了 OE-Core 元数据。在 Yocto 项目 1.0 版之后，Yocto 项目和 OpenEmbedded 同意一起工作并共享一组共同的核心元数据 (OE-Core)，其中包含以前在 Poky 中发现的大部分功能。这种合作实现了 OpenEmbedded 长期以来的目标，即拥有更严格控制和质量保证的核心。与许多不同的工具相比，结果也非常符合 Yocto 项目的目标，即实现较少数量的全功能工具。</p>
<p>共享一组核心元数据导致 Poky 作为 OE-Core 之上的集成层。你可以在这张 图中看到。Yocto 项目结合了各种组件，例如 BitBake、OE-Core、脚本“胶水”和构建系统的文档。</p>
</div>
</div>
<div class="section" id="poky">
<h2>参考分布（Poky）<a class="headerlink" href="#poky" title="Permalink to this headline">¶</a></h2>
<p>Poky 是 Yocto 项目的参考发行版。它包含 OpenEmbedded 构建系统 （BitBake 和 OE-Core）以及一组元数据，可帮助您开始构建自己的发行版。参见“什么是 Yocto 项目？”部分的插图展示了 Poky 及其与 Yocto 项目其他部分的关系。</p>
<p>要使用 Yocto Project 工具和组件，您可以下载 ( clone) Poky 并使用它来引导您自己的发行版。</p>
<p>笔记:Poky 不包含二进制文件。这是一个如何从源代码构建您自己的自定义 Linux 发行版的工作示例。</p>
<p>您可以在“参考嵌入式发行版（Poky） ”部分阅读更多关于 Poky 的信息。</p>
</div>
<div class="section" id="id6">
<h2>2.3.5成品目标包<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>以下是与已完成目标的包相关的组件：</p>
<ul class="simple">
<li><p>Matchbox： Matchbox 是 X Window 系统的开源基础环境，可在非桌面嵌入式平台上运行，例如手持设备、机顶盒、信息亭以及任何其他屏幕空间、输入机制或系统资源受限的平台.</p></li>
</ul>
<p>Matchbox 包含许多可互换和可选的应用程序，您可以针对特定的非桌面平台进行定制，以增强在受限环境中的可用性。</p>
<p>您可以在 Yocto Project Source Repositories中找到 Matchbox 源。</p>
<ul class="simple">
<li><p>Opkg： Open PacKaGe管理（opkg）是一个基于itsy包（ipkg）管理系统的轻量级包管理系统。Opkg 是用 C 语言编写的，在操作上类似于 Advanced Package Tool (APT) 和 Debian Package (dpkg)。</p></li>
</ul>
<p>Opkg 旨在用于嵌入式 Linux 设备，并在OpenEmbedded和 OpenWrt项目以及 Yocto 项目中以这种方式使用。</p>
<p>笔记</p>
<p>opkg 尽其所能保持与 ipkg 的向后兼容性，并符合 Debian 政策手册中有关控制文件的子集。</p>
<p>您可以在 Yocto Project Source Repositories中找到 opkg 源。</p>
</div>
<div class="section" id="id7">
<h2>2.3.6归档组件<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>Build Appliance 是一个虚拟机映像，使您能够使用非 Linux 开发系统通过 Yocto 项目构建和引导自定义嵌入式 Linux 映像。</p>
<p>从历史上看，Build Appliance 是您可以在非 Linux 原生系统上使用 Yocto 项目的三种方法中的第二种。</p>
<p>Hob： Hob，现在已弃用并且不再可用，因为 Yocto 项目的 2.1 版本为 Yocto 项目提供了一个基本的、基于 GUI 的界面。烤面包机已完全取代滚刀。</p>
<p>Build Appliance：在 Hob 之后，Build Appliance 可用。从来没有建议您将 Build Appliance 用作 Yocto 项目的日常生产开发环境。作为在 Yocto Project 环境中尝试开发的一种方式，Build Appliance 非常有用。</p>
<p>CROPS：现在可用于在非 Linux 原生系统上使用 Yocto 项目进行开发的最终和最佳解决方案是使用 CROPS。</p>
</div>
<div class="section" id="id8">
<h2>2.4开发方式<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>Yocto Project 开发环境通常涉及 构建主机和目标硬件。您使用构建主机来构建映像和开发应用程序，同时使用目标硬件来执行部署的软件。</p>
<p>本节介绍您在设置构建主机时的选择或开发方法。根据您的特定工作流程偏好和构建主机运行的操作系统类型，您有多种选择。</p>
<p>笔记:有关 Yocto 项目开发环境的更多详细信息，请参阅“ Yocto 项目开发环境”一章。</p>
<ul class="simple">
<li><p>本机 Linux 主机：到目前为止，构建主机的最佳选择。运行 Linux 作为其本机操作系统的系统允许您直接使用 BitBake工具开发软件。您可以从受支持的 Linux 发行版中的常规 shell 完成开发的所有方面。</p></li>
</ul>
<p>有关如何在运行 Linux 作为其本机操作系统的系统上设置构建主机的信息，请参阅 Yocto 项目开发任务手册中的“设置本机 Linux 主机”部分。</p>
<ul class="simple">
<li><p>CROss PlatformS (CROPS)：通常，您使用 利用 Docker Containers的CROPS来设置不运行 Linux（例如 Microsoft Windows 或 macOS）的构建主机。</p></li>
</ul>
<p>笔记:但是，您可以在基于 Linux 的系统上使用 CROPS。</p>
<p>CROPS 是一个开源的跨平台开发框架，它提供了一个易于管理、可扩展的环境，用于构建针对 Windows、macOS 或 Linux 主机上的各种架构的二进制文件。使用 CROPS 设置构建主机后，您可以准备一个 shell 环境来模拟在本机运行 Linux 的系统上使用的 shell。</p>
<p>有关如何使用 CROPS 设置构建主机的信息，请参阅 Yocto 项目开发任务手册中的“设置以使用 CROss PlatformS (CROPS) ”部分。</p>
<ul class="simple">
<li><p>适用于 Linux 的 Windows 子系统 (WSLv2)：您可以使用适用于 Linux v2 的 Windows 子系统来设置使用 Windows 10 的构建主机。</p></li>
</ul>
<p>笔记</p>
<p>Yocto 项目与 WSLv1 不兼容，它与 WSLv2 兼容但未得到官方支持或验证，如果您仍然决定使用 WSL，请升级到 WSLv2。</p>
<p>适用于 Linux 的 Windows 子系统允许 Windows 10 在轻量级虚拟机 (VM) 内运行真正的 Linux 内核。</p>
<p>有关如何使用 WSLv2 设置构建主机的信息，请参阅 Yocto 项目开发任务手册中的“设置以使用 Linux 的 Windows 子系统 (WSLv2) ”部分。</p>
<ul class="simple">
<li><p>Toaster：无论您的 Build Host 正在运行什么，您都可以使用 Toaster 通过 Yocto Project 开发软件。Toaster 是 Yocto 项目的OpenEmbedded 构建系统的 Web 界面。该界面允许您配置和运行您的构建。有关构建的信息被收集并存储在数据库中。您可以使用 Toaster 在多个远程构建服务器上配置和启动构建。</p></li>
</ul>
<p>有关和如何使用烤面包机的信息，请参阅 烤面包机用户手册。</p>
</div>
<div class="section" id="id9">
<h2>poky<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>“Poky”的发音是 Pock -ee，是 Yocto 项目的参考发行版或参考操作系统套件的名称。Poky 包含 OpenEmbedded 构建系统（BitBake和 OpenEmbedded-Core (OE-Core)）以及一组 元数据，可帮助您开始构建自己的发行版。换句话说，Poky 是典型嵌入式系统所需功能的基本规范，也是 Yocto 项目中允许您将分发构建成可用二进制映像的组件的基本规范。</p>
<p>Poky 是 BitBake、OpenEmbedded-Core meta（meta-poky可meta-yocto-bsp在 您可以在Source Repositories中查看构成 Poky 存储库的这些项目 。</p>
<p>笔记:如果您对 poky Git 存储库的所有内容感兴趣，请参阅 Yocto 项目参考手册中的“顶级核心组件”部分。</p>
<p>下图说明了 Poky 的一般组成部分：</p>
<p>poky-reference-distribution.png</p>
<ul class="simple">
<li><p>BitBake 是一个任务执行器和调度器，是 OpenEmbedded 构建系统的核心。</p></li>
<li><p>meta-poky，这是 Poky 特定的元数据。</p></li>
<li><p>meta-yocto-bsp，它们是 Yocto 项目特定的板级支持包 (BSP)。</p></li>
<li><p>OpenEmbedded-Core (OE-Core) 元数据，包括共享配置、全局变量定义、共享类、打包和配方。类定义了构建逻辑的封装和继承。配方是要构建的软件和图像的逻辑单元。</p></li>
<li><p>文档，其中包含用于制作用户手册集的 Yocto 项目源文件。</p></li>
</ul>
<p>笔记:虽然 Poky 是一个“完整的”分发规范，并且经过了测试和 QA，但您不能以当前形式将其用作“开箱即用”的产品。</p>
<p>要使用 Yocto Project 工具，您可以使用 Git 克隆（下载）Poky 存储库，然后使用参考分发的本地副本来引导您自己的分发。
笔记:Poky 不包含二进制文件。这是一个如何从源代码构建您自己的自定义 Linux 发行版的工作示例。</p>
<p>Poky 在其自己的版本下有一个定期的、完善的、六个月的发布周期。主要发布与 Yocto 项目的主要发布（点发布）同时发生，通常在春季和秋季。有关 Yocto 项目发布时间表和节奏的更多信息，请参阅 Yocto 项目参考手册中的“ Yocto 项目发布和稳定发布流程”一章。</p>
<p>关于 Poky 作为“默认配置”的说法很多。默认配置提供起始映像占用空间。您可以使用开箱即用的 Poky 创建图像，范围从 shell 可访问的最小图像一直到使用基于 GNOME 移动和嵌入式 (GMAE) 的参考用户界面（称为 Sato）的符合 Linux 标准基础的图像。</p>
<p>Poky 最强大的特性之一是构建的每个方面都由元数据控制。您可以通过添加扩展功能的元数据层 &lt;overview-manual/yp-intro:the yocto project layer model&gt;来使用元数据来扩充这些基本图像类型 。例如，这些层可以为图像类型提供额外的软件堆栈，为额外的硬件添加板级支持包 (BSP)，甚至创建新的图像类型。</p>
<p>元数据被松散地分组到配置文件或包配方中。配方是 BitBake 用于设置变量或定义其他构建时任务的不可执行元数据的集合。配方包含配方描述、配方版本、包的许可证和上游源存储库等字段。配方还可能表明构建过程使用 autotools、make、distutils 或任何其他构建过程，在这种情况下，基本功能可以由它从 OE-Core 层的类定义中继承的类定义./meta/classes。在配方中，您还可以定义其他任务以及任务先决条件。通过 BitBake 的配方语法还支持:prepend和:append运算符作为扩展任务功能的一种方法。这些运算符将代码注入到任务的开头或结尾。有关这些 BitBake 运算符的信息，请参阅BitBake 用户手册中的“附加和前置（覆盖样式语法） ”部分。</p>
<blockquote>
<div></div></blockquote>
<p>OpenEmbedded Build System使用“工作流程”来完成镜像和 SDK 的生成。下图概述了该工作流程：
YP-flow-diagram.png</p>
<p>以下是“工作流程”的简要概述：</p>
<ol class="arabic simple">
<li><p>开发人员指定架构、策略、补丁和配置细节。</p></li>
<li><p>构建系统从指定位置获取并下载源代码。构建系统支持标准方法，如 tarball 或源代码存储库系统，如 Git。</p></li>
<li><p>下载源代码后，构建系统会将源代码提取到本地工作区，在该工作区应用补丁并运行配置和编译软件的常用步骤。</p></li>
<li><p>然后，构建系统将软件安装到临时暂存区域，您选择的二进制包格式（DEB、RPM 或 IPK）用于汇总软件。</p></li>
<li><p>不同的 QA 和健全性检查贯穿整个构建过程。</p></li>
<li><p>创建二进制文件后，构建系统会生成一个二进制包提要，用于创建最终的根文件映像。</p></li>
<li><p>构建系统生成文件系统映像和定制的可扩展 SDK (eSDK)，用于并行开发应用程序。</p></li>
</ol>
<p>有关此工作流程的详细信息，请参阅“ OpenEmbedded 构建系统概念”部分。</p>
</div>
<div class="section" id="id10">
<h2>一些基本术语<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>它有助于在学习 Yocto 项目时理解一些基本的基本术语。虽然在 Yocto 项目参考手册的“ Yocto 项目术语”部分中有一个术语列表，但该部分提供了一些有助于入门的术语的定义：</p>
<ul class="simple">
<li><p>配置文件：保存全局变量定义、用户定义变量和硬件配置信息的文件。这些文件告诉OpenEmbedded 构建系统 要构建什么以及将什么放入映像中以支持特定平台。</p></li>
<li><p>可扩展软件开发工具包 (eSDK)：适用于应用程序开发人员的自定义 SDK。此 eSDK 允许开发人员将他们的库和编程更改合并回映像中，以使其他应用程序开发人员可以使用他们的代码。有关 eSDK 的信息，请参阅Yocto 项目应用程序开发和可扩展软件开发工具包 (eSDK)手册。</p></li>
<li><p>层：相关配方的集合。层允许您整合相关的元数据来自定义您的构建。层还隔离了为多个架构构建时使用的信息。层在覆盖先前规范的能力方面是分层的。您可以包含来自 Yocto 项目的任意数量的可用层，并通过在它们之后添加您自己的层来自定义构建。您可以在图层索引中搜索 Yocto 项目中使用的图层。</p></li>
</ul>
<p>有关层的更多详细信息，请参阅 Yocto 项目开发任务手册中的“理解和创建层”部分。有关 BSP 层的具体讨论，请参阅 Yocto 项目板支持包 (BSP) 开发人员指南中的“ BSP 层”部分。</p>
<ul class="simple">
<li><p>元数据： Yocto 项目的一个关键元素是用于构建 Linux 发行版的元数据，它包含在 OpenEmbedded 构建系统在构建映像时解析的文件中。通常，元数据包括配方、配置文件和其他涉及构建指令本身的信息，以及用于控制构建内容和构建效果的数据。元数据还包括用于指示所使用的软件版本、从何处获得它们的命令和数据，以及用于修复错误或定制软件以用于软件本身的更改或添加（补丁或辅助文件）特定情况。OpenEmbedded-Core 是一组重要的经过验证的元数据。</p></li>
<li><p>OpenEmbedded 构建系统：术语“BitBake”和“构建系统”有时用于 OpenEmbedded 构建系统。BitBake 是一个任务调度器和执行引擎，它解析指令（即配方）和配置数据。在一个解析阶段之后，BitBake 创建一个依赖树来排序编译，调度包含代码的编译，最后执行指定自定义 Linux 镜像的构建（分发）。BitBake 类似于该make工具。建过程中，构建系统跟踪依赖关系并执行每个包的本机或交叉编译。作为交叉构建设置的第一步，框架尝试创建适合目标平台的交叉编译器工具链（即可扩展 SDK）。</p></li>
<li><p>OpenEmbedded-Core (OE-Core)： OE-Core 是由基础配方、类和相关文件组成的元数据，这些元数据在许多不同的 OpenEmbedded 派生系统（包括 Yocto 项目）中通用。OE-Core 是由 OpenEmbedded 社区开发的原始存储库的精选子集，已被缩减为一个更小、核心的一组不断验证的配方。结果是一套严格控制和质量保证的核心配方。您可以在metaYocto Project Source Repositories的目录中看到元数据。</p></li>
<li><p>包：在 Yocto 项目的上下文中，该术语指的是由 BitBake 生成的配方的打包输出（即“烘焙配方”）。包通常是从配方源生成的编译二进制文件。你通过 BitBake 运行它来“烘焙”一些东西。</p></li>
</ul>
<p>值得注意的是，“包”一词通常具有微妙的含义。例如，在 Yocto 项目参考手册中的“构建主机所需的包”部分中提到的包是已编译的二进制文件，在安装时，它们会向您的主机 Linux 发行版添加功能。</p>
<p>另一点值得注意的是，历史上在 Yocto 项目中，配方被称为包 - 因此，存在几个看似错误命名的 BitBake 变量（例如 PR、 PV和 PE）。</p>
<ul>
<li><p>Poky： Poky 是一个参考嵌入式发行版和参考测试配置。Poky 提供以下功能：</p>
<blockquote>
<div><ul class="simple">
<li><p>用于说明如何自定义发行版的基本功能发行版。</p></li>
<li><p>一种测试 Yocto 项目组件的方法（即 Poky 用于验证 Yocto 项目）。</p></li>
<li><p>您可以通过它下载 Yocto 项目的车辆。</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>Poky 不是产品级发行版。相反，这是一个很好的定制起点。</p>
<p>笔记:Poky 是 OE-Core 之上的集成层。</p>
<ul class="simple">
<li><p>配方：最常见的元数据形式。配方包含用于构建包的设置和任务列表（即指令），然后用于构建二进制映像。配方描述了您从哪里获得源代码以及应用哪些补丁。配方描述了库或其他配方的依赖关系以及配置和编译选项。相关配方合并为一个层。</p></li>
</ul>
<div class="section" id="id11">
<h3>yocto开发环境<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="id12">
<h2>开发主机<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p>开发主机或构建主机是使用 Yocto 项目的关键。因为 Yocto 项目的目标是开发在嵌入式硬件上运行的图像或应用程序，所以这些图像和应用程序的开发通常发生在不打算运行软件的系统上——开发主机。</p>
<p>您需要设置一个开发主机才能将其与 Yocto 项目一起使用。大多数人发现最好有一个本机Linux机器功能作为开发主机。但是，可以使用不运行 Linux 作为其操作系统的系统作为您的开发主机。当您拥有基于 Mac 或 Windows 的系统时，您可以使用 CROPS 将其设置为开发主机 ，它利用 了Docker 容器。一旦您采取了设置 CROPS 机器的步骤，您就可以有效地访问类似于您在使用基于 Linux 的开发主机时看到的 shell 环境。有关使用 CROPS 设置系统所需的步骤，请参阅 Yocto 项目开发任务手册中的“设置以使用 CROss PlatformS (CROPS) ”部分。</p>
<p>如果您的开发主机将是一个运行 Linux 发行版的系统，您仍必须采取措施准备系统以用于 Yocto 项目。您需要确保系统上的 Linux 发行版是支持 Yocto 项目的发行版。您还需要确保安装了允许使用 Yocto 项目进行开发的正确主机包集。有关设置运行 Linux 的开发主机所需的步骤，请参阅 Yocto 项目开发任务手册中的“设置本机 Linux 主机”部分。</p>
<p>一旦您的开发主机设置为使用 Yocto 项目，在 Yocto 项目环境中有几种工作方式：</p>
<ul class="simple">
<li><p>命令行、BitBake 和 Shell： Yocto 项目中的传统开发涉及在开发主机上的 shell 的命令行环境中使用OpenEmbedded 构建系统，该系统使用 BitBake。您可以从作为本机 Linux 机器的主机或从已设置 CROPS 的主机完成此操作。无论哪种方式，您都可以使用 Linux 发行版和 Yocto 项目提供的组件和工具在基于 shell 的环境中创建、修改和构建映像和应用程序。</p></li>
</ul>
<p>有关构建过程的一般流程，请参阅 Yocto 项目开发任务手册中的“构建简单映像”部分。</p>
<ul class="simple">
<li><p>板级支持包 (BSP) 开发：BSP的开发涉及使用 Yocto 项目创建和测试层，以便轻松开发针对特定硬件的图像和应用程序。要开发 BSP，除了设置开发主机中描述的内容之外，您还需要采取一些额外的步骤。</p></li>
</ul>
<p>Yocto Project Board Support Package Developer’s Guide提供了与BSP 相关的开发信息。有关开发主机准备的详细信息，请参阅 Yocto 项目板支持包 (BSP) 开发人员指南中的“准备您的构建主机以使用 BSP 层”部分。</p>
<ul class="simple">
<li><p>内核开发：如果您打算使用 Yocto 项目开发内核，您可能会使用devtool. 工作流使用devtool通过减少迭代周期时间使内核开发更快。</p></li>
</ul>
<p>Yocto Project Linux Kernel Development Manual提供了与内核相关的开发信息。有关开发主机准备的详细信息，请参阅 Yocto Project Linux 内核开发手册中的“准备构建主机以在内核上工作”部分。</p>
<ul class="simple">
<li><p>使用 Toaster：另一种 Yocto Project 开发方法涉及一个有效地将 Yocto Project 置于后台的界面是 Toaster。Toaster 为 OpenEmbedded 构建系统提供了一个接口。该界面使您能够配置和运行您的构建。有关构建的信息被收集并存储在数据库中。您可以使用 Toaster 在多个远程构建服务器上配置和启动构建。</p></li>
</ul>
<p>有关向您展示如何设置开发主机以使用 Toaster 以及如何使用 Toaster 的步骤，请参阅 Toaster 用户手册。</p>
<div class="section" id="id13">
<h3>Yocto 项目源代码库<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>Yocto 项目团队在https://git.yoctoproject.org/cgit/cgit.cgi/维护所有 Yocto 项目文件的完整源存储库。这个基于 Web 的源代码浏览器按功能分类，例如 IDE Plugins、Matchbox、Poky、Yocto Linux Kernel 等。在界面中，您可以单击“名称”列中的任何特定项目，并在页面底部查看您需要为该特定项目克隆 Git 存储库的 URL。拥有Source Directory的本地 Git 存储库，通常称为“poky”，允许您进行更改、贡献历史，并最终增强 Yocto 项目的工具、董事会支持包等。</p>
<p>对于任何支持的 Yocto Project 版本，您还可以访问 Yocto Project 网站并从“SOFTWARE”菜单中选择“DOWNLOADS”项，并获取poky 存储库的已发布 tarball、任何受支持的 BSP tarball 或 Yocto Project 工具。解压缩这些 tarball 可为您提供已发布文件的快照。</p>
<p>笔记</p>
<ul class="simple">
<li><p>设置 Yocto 项目 源目录和支持的 BSP 文件（例如，meta-intel）的推荐方法是使用 Git 创建上游存储库的本地副本。</p></li>
<li><p>确保始终为选定的 BSP 存储库和源目录（即poky）存储库在匹配的分支中工作。例如，如果您已签出 的“honister”分支poky并且要使用meta-intel，请务必签出 的“honister”分支meta-intel。</p></li>
</ul>
<p>总之，在这里您可以获取开发所需的项目文件：</p>
<ul class="simple">
<li><p>源存储库：该区域包含 IDE 插件、Matchbox、Poky、Poky 支持、工具、Yocto Linux 内核和 Yocto 元数据层。您可以为每个区域创建 Git 存储库的本地副本。</p></li>
</ul>
<p>source-repos.png
有关如何查看和访问这些上游 Git 存储库的步骤，请参阅 Yocto 项目开发任务手册中的“访问源存储库”部分。</p>
<ul class="simple">
<li><p>/releases 的索引：这是发布的索引，例如 Poky、Pseudo、交叉开发工具链的安装程序、杂项支持以及所有以图像或 tarball 形式发布的 Yocto Project 版本。下载和提取这些文件不会生成 Git 存储库的本地副本，而是生成特定版本或映像的快照。</p></li>
</ul>
<p>index-downloads.png</p>
<ul class="simple">
<li><p>Yocto 项目网站 的“下载”页面：Yocto 项目网站包括一个“下载”页面，可通过“软件”菜单访问，允许您以 tarball 格式下载任何 Yocto 项目版本、工具和板级支持包 (BSP)。压缩包类似于 /releases:区域的索引中的压缩包。</p></li>
</ul>
<p>…</p>
</div>
</div>
<div class="section" id="git-yocto">
<h2>Git 工作流和 Yocto 项目<a class="headerlink" href="#git-yocto" title="Permalink to this headline">¶</a></h2>
<p>使用 Yocto 项目进行开发可能需要使用 Git。Git 是一个免费的开源分布式版本控制系统，用作许多协作设计环境的一部分。本节提供使用 Yocto 项目和 Git 的工作流概念。特别是，这些信息涵盖了描述协作开发环境中的角色和操作的基本实践。</p>
<p>笔记</p>
<p>如果您熟悉这种类型的开发环境，您可能不想阅读本节。</p>
<p>Yocto 项目文件使用 Git 在“分支”中维护，其 Git 历史记录跟踪每一次更改，其结构为所有不同的功能提供分支。虽然没有必要使用 Git，但很多开源项目都会这样做。</p>
<p>对于 Yocto 项目，一个称为“维护者”的关键个人负责给定 Git 存储库的开发分支的完整性。开发分支是“上游”存储库，从中发生项目的最终或最新构建。维护者负责接受来自其他开发人员的更改，并负责组织底层分支结构以反映发布策略等。</p>
<p>笔记</p>
<p>有关找出谁负责（维护） Yocto 项目中的特定代码区域的信息，请参阅 Yocto 项目开发任务手册的“向 Yocto 项目提交更改”部分。</p>
<p>Yocto Project pokyGit 存储库还有一个上游贡献 Git 存储库，名为poky-contrib. 您可以使用“Poky 支持”区域中组织的源存储库的 Web 界面查看此存储库中的所有分支 。这些分支保存由 Yocto 项目开发团队和为项目做出贡献的社区成员提交或提交的项目更改（提交）。维护者确定更改是否有资格从“contrib”分支移动到 Git 存储库的“master”分支。</p>
<p>开发人员（包括贡献的社区成员）创建和维护上游分支的克隆存储库。克隆的存储库是其开发平台的本地存储库，用于开发更改。当开发人员对特定功能或更改感到满意时，他们会将更改“推送”到适当的“contrib”存储库。</p>
<p>开发人员负责使他们的本地存储库与他们正在处理的任何上游分支保持最新。他们还负责解决多人同时处理的文件中可能出现的任何冲突。所有这些工作都在开发主机上本地完成，然后将任何内容推送到“贡献”区域并在维护者级别进行检查。</p>
<p>有一种正式的方法，开发人员提交更改并将它们推送到“contrib”区域，然后请求维护人员将它们包含到上游分支中。此过程称为“提交补丁”或“提交更改”。有关提交补丁和更改的信息，请参阅Yocto 项目开发任务手册中的“向 Yocto 项目提交更改”部分。</p>
<p>总之，对 Git 存储库的开发分支的更改有一个单一的入口点，由项目的维护者控制。一组开发人员独立开发、测试和提交对“贡献”区域的更改，以供维护人员检查。然后维护者选择哪些更改将成为项目的永久部分。</p>
<p>git-workflow.svg</p>
<p>虽然每个开发环境都是独一无二的，但有一些最佳实践或方法可以帮助开发顺利进行。以下列表描述了其中一些做法。有关 Git 工作流的更多信息，请参阅Git Community Book中的工作流主题。</p>
<ul class="simple">
<li><p>进行小更改：与将许多不同的更改捆绑到单个提交中相比，最好保持提交的更改很小。这种做法不仅使事情易于管理，而且还允许维护者更容易地包含或拒绝更改。</p></li>
<li><p>进行完全更改：让存储库处于允许您仍然成功构建项目的状态也是一种很好的做法。换句话说，不要提交功能的一半，然后将另一半添加为单独的稍后提交。每个提交都应该将您从一个可构建的项目状态带到另一个可构建的状态。</p></li>
<li><p>自由使用分支：在开发主机上的工作 Git 存储库中创建、使用和删除本地分支非常容易。您可以随意命名这些分支。为他们提供与您正在处理的特定功能或更改相关联的名称会很有帮助。完成功能或更改并将其合并到本地开发分支后，只需丢弃临时分支即可。</p></li>
<li><p>合并更改：该命令允许您从一个分支中获取更改并将它们折叠到另一个分支中。当多个开发人员可能正在开发同一功能的不同部分时，此过程特别有用。合并更改还会自动识别由于两个不同的开发人员更改相同的代码行而可能发生的任何冲突或“冲突”。git merge</p></li>
<li><p>管理分支：因为分支易于使用，您应该使用一个系统，其中分支指示不同级别的代码准备就绪。例如，您可以在其中开发一个“工作”分支，一个测试代码或更改的“测试”分支，一个准备提交更改的“阶段”分支，等等。随着项目的开发，您可以跨分支合并代码以反映开发的不断增长的稳定状态。</p></li>
<li><p>使用推拉：推拉工作流基于开发人员将本地提交“推送”到远程存储库的概念，该远程存储库通常是一个贡献存储库。此工作流程还基于开发人员将项目的已知状态“拉”到他们的本地开发存储库中。该工作流程允许您轻松地将其他开发人员提交的更改从上游存储库拉到您的工作区域，确保您拥有要开发的最新软件。Yocto 项目有两个名为的脚本 create-pull-request，send-pull-request它们随版本一起发布以促进此工作流程。您可以在Source Directoryscripts的文件夹中 找到这些脚本。有关如何使用这些脚本的信息，请参阅“Yocto 项目开发任务手册中的使用脚本向上游推送更改并请求拉取”部分。</p></li>
<li><p>补丁工作流程：此工作流程允许您通过电子邮件通知维护人员您有更改（或补丁），您希望考虑将其用于 Git 存储库的开发分支。要发送此类更改，请格式化补丁，然后使用 Git 命令和. 有关如何使用这些脚本的信息，请参阅 Yocto 项目开发任务手册中的“提交对 Yocto 项目的更改”部分。git format-patchgit send-email</p></li>
</ul>
</div>
<div class="section" id="git">
<h2>git<a class="headerlink" href="#git" title="Permalink to this headline">¶</a></h2>
<p>Yocto 项目广泛使用 Git，这是一个免费的开源分布式版本控制系统。Git支持分布式开发、非线性开发，可以处理大型项目。如果您打算使用 Yocto 项目进行开发，最好对 Git 如何跟踪项目以及如何使用 Git 有一些基本的了解。本节简要概述了 Git 的工作原理，并为您提供了一些基本 Git 命令的摘要。</p>
<p>笔记</p>
<p>有关 Git 的更多信息，请参阅 <a class="reference external" href="https://git-scm.com/documentation">https://git-scm.com/documentation</a>。</p>
<p>如果您需要下载 Git，建议您通过发行版的“软件商店”将 Git 添加到系统中（例如，对于 Ubuntu，使用 Ubuntu 软件功能）。对于 Git 下载页面，请参见https://git-scm.com/download。</p>
</div>
<div class="section" id="id14">
<h2>许可<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h2>
<p>由于开源项目对公众开放，因此它们具有不同的许可结构。开源和自由软件的许可证演变都有一段有趣的历史。如果您对这段历史感兴趣，可以在这里找到基本信息：</p>
<p>开源许可证历史</p>
<p>自由软件许可证历史</p>
<p>一般来说，Yocto 项目在麻省理工学院 (MIT) 许可下获得广泛许可。MIT 许可允许在专有软件中重复使用软件，只要许可证与该软件一起分发。MIT 还与 GNU 通用公共许可证 (GPL) 兼容。Yocto 项目的补丁遵循上游许可方案。您可以在此处找到有关 MIT 许可证的 信息。您可以在此处找到有关 GNU GPL 的 信息。</p>
<p>当您使用 Yocto 项目构建映像时，构建过程使用已知的许可证列表来确保合规性。您可以在位于的源目录中 找到此列表meta/files/common-licenses。构建完成后，在构建过程中找到和使用的所有许可证的列表都保存在 构建目录中 tmp/deploy/licenses。</p>
<p>如果模块需要不在基本列表中的许可证，则构建过程会在构建过程中生成警告。这些工具使开发人员更容易确定其交付的产品必须遵守的许可证。但是，即使使用这些工具，仍然需要由开发人员来解决潜在的许可问题。</p>
<p>构建过程使用的基本许可证列表是软件包数据交换 (SPDX) 列表和开源计划 (OSI) 项目的组合。SPDX Group是 Linux 基金会的一个工作组，负责维护用于传达与软件包相关的组件、许可证和版权的标准格式规范。 OSI是一家致力于开源定义以及审查和批准符合开源定义 (OSD) 的许可证的公司。</p>
<p>您可以在源目录meta/files/common-licenses的目录中 找到 Yocto 项目使用的组合 SPDX 和 OSI 许可证的列表。</p>
<p>有关可以帮助您在使用 Yocto 项目创建的产品的生命周期内保持对各种开源许可的合规性的信息，请参阅Yocto 项目开发任务手册中的“在产品的生命周期内保持开源许可合规性”部分。</p>
<div class="section" id="id15">
<h3>yocto项目概念描述<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>4.1 Yocto 项目组件
BitBake任务执行器与各种类型的配置文件一起构成了 OpenEmbedded -Core (OE-Core)。本节通过描述它们的使用以及它们如何交互来概述这些组件。</p>
<p>BitBake 处理数据文件的解析和执行。数据本身有多种类型：</p>
<p>食谱：提供有关特定软件的详细信息。</p>
<p>类数据：抽象公共构建信息（例如如何构建 Linux 内核）。</p>
<p>配置数据：定义特定于机器的设置、策略决策等。配置数据充当将所有内容绑定在一起的粘合剂。</p>
<p>BitBake 知道如何将多个数据源组合在一起，并将每个数据源称为一个层。有关层的信息，请参阅 Yocto 项目开发任务手册的“理解和创建层”部分。</p>
<p>以下是这些核心组件的一些简要细节。有关这些组件在构建期间如何交互的更多信息，请参阅“ OpenEmbedded 构建系统概念”部分。</p>
<p>4.1.1比特烘焙
BitBake 是OpenEmbedded 构建系统的核心工具， 负责解析元数据，从中生成任务列表，然后执行这些任务。</p>
<p>本节简要介绍 BitBake。如果您想了解有关 BitBake 的更多信息，请参阅BitBake 用户手册。</p>
<p>要查看 BitBake 支持的选项列表，请使用以下任一命令：</p>
<p>$ bitbake -h
$ bitbake –help
BitBake 最常见的用法是，其中 是您要构建的配方的名称（称为“目标”）。目标通常等同于配方文件名的第一部分（例如，名为 的配方的“foo” ）。因此，要处理配方文件，您可以键入以下内容：bitbake recipenamerecipenamefoo_1.3.0-r0.bbmatchbox-desktop_1.2.3.bb</p>
<p>$ bitbake matchbox-desktop
matchbox-desktop可能存在几个不同的版本。BitBake 选择分发配置选择的那个。您可以在 BitBake 用户手册的“首选项”部分中获得有关 BitBake 如何在不同目标版本和提供程序之间进行选择的更多详细信息。</p>
<p>BitBake 还尝试首先执行任何相关任务。例如，在构建之前matchbox-desktop，BitBake 将构建一个交叉编译器，glibc如果它们尚未构建。</p>
<p>要考虑的一个有用的 BitBake 选项是-kor–continue 选项。此选项指示 BitBake 尝试并尽可能长时间地继续处理作业，即使在遇到错误后也是如此。发生错误时，失败的目标和依赖它的目标都无法重新制作。但是，当您使用此选项时，仍然可以处理其他依赖项。</p>
<p>4.1.2食谱
带有.bb后缀的文件是“recipes”文件。通常，配方包含有关单个软件的信息。此信息包括下载未更改源的位置、要应用于该源的任何源补丁（如果需要）、要应用的特殊配置选项、如何编译源文件以及如何打包编译的输出。</p>
<p>术语“包装”有时用于指代食谱。但是，由于“包”一词用于 OpenEmbedded 构建系统的打包输出（即.ipk文件.deb），因此本文档在提及配方时避免使用“包”一词。</p>
<p>4.1.3类
类文件 ( .bbclass) 包含有助于在配方文件之间共享的信息。一个例子是 autotools类，它包含 Autotools 使用的任何应用程序的通用设置。Yocto 项目参考手册中的“类”一章提供了关于类以及如何使用它们的详细信息。</p>
<p>4.1.4配置
配置文件 ( .conf) 定义了管理 OpenEmbedded 构建过程的各种配置变量。这些文件分为几个区域，这些区域定义了机器配置选项、分发配置选项、编译器调整选项、通用配置选项和用户配置选项 conf/local.conf，这些选项位于Build Directory中。</p>
<p>4.2层
层是包含相关元数据（即指令集）的存储库，这些元数据告诉 OpenEmbedded 构建系统如何构建目标。Yocto 项目层模型 促进了 Yocto 项目开发环境中的协作、共享、定制和重用。为您的项目分层逻辑分离信息。例如，您可以使用一个层来保存特定硬件的所有配置。隔离特定于硬件的配置允许您通过使用不同的层来共享其他元数据，其中元数据可能在多个硬件中是通用的。</p>
<p>Yocto Project 开发环境中有许多层在工作。Yocto Project Curated Layer Index 和OpenEmbedded Layer Index都包含您可以使用或利用的层。</p>
<p>按照惯例，Yocto 项目中的层遵循特定的形式。符合已知结构允许 BitBake 在构建期间对在何处查找元数据类型做出假设。您可以在 Yocto 项目开发任务手册的“理解和创建层”部分找到bitbake-layers用于创建适用于 Yocto 项目的层的程序并了解工具（即）。</p>
<p>4.3 OpenEmbedded 构建系统概念
本节更详细地了解OpenEmbedded 构建系统使用的构建过程，它是特定于 Yocto 项目的构建系统。构建系统的核心是任务执行器 BitBake。</p>
<p>下图表示构建的高级工作流程。本节的其余部分将扩展构成工作流的基本输入、输出、过程和元数据逻辑块。</p>
<p>YP-flow-diagram.png</p>
<p>一般来说，构建的工作流程由几个功能区域组成：</p>
<ul class="simple">
<li><p>用户配置：可用于控制构建过程的元数据。</p></li>
<li><p>元数据层：提供软件、机器和发行版元数据的各种层。</p></li>
<li><p>源文件：上游版本、本地项目和 SCM。</p></li>
<li><p>构建系统：由BitBake控制的进程 。本部分扩展了 BitBake 如何获取源、应用补丁、完成编译、分析输出以生成包、创建和测试包、生成图像以及生成交叉开发工具。</p></li>
<li><p>包源：包含输出包（RPM、DEB 或 IPK）的目录，随后用于构建由构建系统生成的图像或软件开发工具包 (SDK)。如果启用了运行时包管理，也可以使用 Web 服务器或其他方式复制和共享这些提要，以便在运行时扩展或更新设备上的现有图像。</p></li>
<li><p>图像：工作流产生的图像。</p></li>
<li><p>应用程序开发 SDK：与图像一起生成或与 BitBake 单独生成的交叉开发工具。</p></li>
</ul>
</div>
</div>
<div class="section" id="id16">
<h2>4.3.1用户配置<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h2>
<p>用户配置有助于定义构建。通过用户配置，您可以告诉 BitBake 您正在为其构建映像的目标架构、下载源的存储位置以及其他构建属性。</p>
<p>下图显示了一般工作流程图的“用户配置”框的扩展表示：</p>
<p>user-configuration.png</p>
<p>BitBake 需要一些基本配置文件才能完成构建。这些文件是*.conf文件。最少需要的文件作为示例文件驻留在Source Directorybuild/conf的目录中 。为简单起见，本节将源目录称为“Poky 目录”。</p>
<p>当您克隆Poky Git 存储库或下载并解压 Yocto 项目版本时，您可以将源目录设置为您想要的任何名称。对于本次讨论，克隆的存储库使用默认名称poky。</p>
<p>笔记</p>
<p>Poky 存储库主要是现有存储库的聚合。它不是规范的上游来源。</p>
<p>meta-pokyPoky 内部的层包含一个包含conf示例配置文件的目录。当您获取oe-init-build-env（构建环境脚本）时，这些示例文件用作创建实际配置文件的基础 。</p>
<p>如果构建环境脚本尚不存在，则获取构建环境脚本会创建一个 构建目录。BitBake 在构建期间使用构建目录进行所有工作。Build Directory 有一个conf目录，其中包含您的默认版本local.conf和bblayers.conf 配置文件。仅当您获取构建环境设置脚本时构建目录中尚不存在版本时，才会创建这些默认配置文件。</p>
<p>因为 Poky 存储库基本上是现有存储库的聚合，所以一些用户可能熟悉 在单独的OpenEmbedded-Core (OE-Core)和 BitBake 存储库而不是单个 Poky 存储库的上下文中运行oe-init-build-env脚本 . 本讨论假设脚本是在 Poky 的克隆或解包版本中执行的。</p>
<p>根据脚本的来源，调用不同的子脚本来设置构建目录（Yocto 或 OpenEmbedded）。具体来说，scripts/oe-setup-builddirpoky 目录中的脚本设置构建目录，并使用适合 Yocto 项目开发环境的配置文件为目录（如果需要）播种。</p>
<p>笔记:scripts/oe-setup-builddir 脚本使用该 $TEMPLATECONF 变量来确定要定位哪些示例配置文件。</p>
<p>该local.conf文件提供了许多定义构建环境的基本变量。这是一些列表。local.conf要查看构建环境脚本创建 的文件中的默认配置，请查看层 中的local.conf.samplemeta-poky：</p>
<ul class="simple">
<li><p>目标机器选择：由 MACHINE变量控制。</p></li>
<li><p>下载目录：由 DL_DIR变量控制。</p></li>
<li><p>共享状态目录：由 SSTATE_DIR变量控制。</p></li>
<li><p>构建输出：由 TMPDIR变量控制。</p></li>
<li><p>分发策略：由 DISTRO变量控制。</p></li>
<li><p>打包格式：由 PACKAGE_CLASSES 变量控制。</p></li>
<li><p>SDK 目标架构：由 SDKMACHINE变量控制。</p></li>
<li><p>额外图像包：由 EXTRA_IMAGE_FEATURES 变量控制。</p></li>
</ul>
<p>笔记</p>
<p>在 conf/local.conf 文件中设置的配置也可以在 conf/site.conf 和 conf/auto.conf 配置文件中进行设置。</p>
<p>该bblayers.conf文件告诉 BitBake 在构建过程中您想要考虑哪些层。默认情况下，此文件中列出的层包括构建系统最少需要的层。但是，您必须手动添加已创建的任何自定义图层。您可以在 Yocto 项目开发任务手册的“启用您的层”部分中找到有关使用该bblayers.conf文件的更多信息。</p>
<p>这些文件不是由环境初始化脚本创建的site.conf。auto.conf如果你想要这个site.conf文件，你需要自己创建它。该auto.conf文件通常由自动构建器创建：</p>
<p>site.conf：可以使用conf/site.conf配置文件来配置多个构建目录。例如，假设您有多个构建环境并且它们共享一些共同的特性。您可以在此处设置这些默认构建属性。一个很好的例子可能是通过 PACKAGE_CLASSES 变量使用的打包格式。</p>
<p>使用该文件的一个有用方案conf/site.conf是扩展BBPATH变量以包含conf/site.conf. 然后，当 BitBake 使用BBPATH查找元数据时，它会找到该conf/site.conf文件并应用您在该文件中找到的常用配置。要覆盖特定构建目录中的配置，请更改该构建目录conf/local.conf 文件中的类似配置。</p>
<p>auto.conf：该文件通常由自动构建器创建和写入。放入文件中的设置通常与您在文件中找到的conf/local.conf相同conf/site.conf 。</p>
<p>您可以编辑所有配置文件以进一步定义任何特定的构建环境。该过程由图中的“用户配置编辑”框表示。</p>
<p>当您使用命令启动构建时，BitBake 会整理配置以最终定义您的构建环境。了解 OpenEmbedded 构建系统以特定顺序读取配置文件很重要：、和. 并且，构建系统应用了 BitBake 用户手册的“语法和运算符”一章中描述的正常赋值语句规则。由于文件是按特定顺序解析的，因此同一变量的变量分配可能会受到影响。例如，如果文件和设置 variable1 为不同的值，因为构建系统在解析 之后， variable1 被分配来自 文件的值。bitbake targetsite.confauto.conflocal.confauto.conflocal.conflocal.confauto.conflocal.conf</p>
<p>4.3.2元数据、机器配置和策略配置
上一节描述了定义 BitBake 全局行为的用户配置。本节仔细研究构建系统用于进一步控制构建的层。这些层为软件、机器和策略提供元数据。</p>
<p>一般来说，有三种类型的层输入。您可以在一般工作流程图 &lt;overview-manual/concepts:openembedded build systemconcepts&gt;中的“用户配置”框下方看到它们：</p>
<ul class="simple">
<li><p>元数据（.bb + 补丁）：包含用户提供的配方文件、补丁和附加文件的软件层。软件层的一个很好的例子可能是 OpenEmbedded Layer Index 中的 meta - qt5 层。该层适用于流行的Qt 跨平台应用程序开发框架 5.0 版，适用于桌面、嵌入式和移动设备。</p></li>
<li><p>机器 BSP 配置：提供特定机器配置的板支持包 (BSP) 层（即下图中的“BSP 层”）。这种类型的信息特定于特定的目标体系结构。参考分布 (Poky)中BSP 层的一个很好的例子 是 meta-yocto-bsp 层。</p></li>
<li><p>策略配置：分发层（即下图中的“分发层”）为为特定分发构建的图像或 SDK 提供顶级或通用策略。例如，在 Poky Reference Distribution 中，发行层是 meta-poky 层。在发行版层中有一个conf/distro目录，其中包含发行版配置文件（例如 poky.conf ，其中包含 Poky 发行版的许多策略配置。</p></li>
</ul>
<p>下图显示了一般工作流程图中这三层的扩展表示：</p>
<p>layer-input.png</p>
<p>通常，所有层都具有相似的结构。如果要分发层，它们都包含一个许可文件（例如COPYING.MIT），一个README作为良好实践的文件，特别是如果要分发层，一个配置目录和配方目录。您可以在 Yocto 项目开发任务手册中的“创建您自己的层”部分了解与 Yocto 项目一起使用的层的一般结构。有关图层和可以从中绘制的许多图层的一般性讨论，请参阅本手册前面的“图层”和“ Yocto 项目图层模型”部分。</p>
<p>如果您浏览了前面的链接，您会发现一些区域存在许多与 Yocto 项目一起使用的层。源存储库还显示了分类在“Yocto 元数据层”下的层。</p>
<p>笔记</p>
<p>Yocto 项目源存储库中有一些图层在 OpenEmbedded 图层索引中找不到。这样的层要么被弃用，要么在本质上是实验性的。</p>
<p>BitBake 使用该conf/bblayers.conf文件（它是用户配置的一部分）来查找它应该使用哪些层作为构建的一部分。</p>
<p>4.3.2.1发行层
分发层为您的分发提供策略配置。最佳实践要求您将这些类型的配置隔离到它们自己的层中。您提供的设置 conf/distro/distro.conf会覆盖 BitBake 在您conf/local.conf的构建目录中的文件中找到的类似设置。</p>
<p>以下列表为您通常在分布层中找到的内容提供了一些解释和参考：</p>
<ul class="simple">
<li><p>类：类文件 ( .bbclass) 包含可以在发行版中的配方之间共享的通用功能。当您的食谱继承一个类时，它们会采用该类的设置和功能。您可以在 Yocto 参考手册的“类”一章中阅读更多关于类文件的信息。</p></li>
<li><p>conf：此区域包含层 ( conf/layer.conf)、分布 ( conf/distro/distro.conf) 和任何分布范围的包含文件的配置文件。</p></li>
<li><p>recipes- :* 影响整个发行版的通用功能的配方和附加文件。该区域可能包括配方和附加文件，以添加特定于发行版的配置、初始化脚本、自定义图像配方等。recipes-<em>目录的示例是recipes-core和 recipes-extra。目录中的层次结构和内容recipes-</em> 可能会有所不同。通常，这些目录包含配方文件 ( <a href="#id17"><span class="problematic" id="id18">*</span></a>.bb)、配方附加文件 ( <a href="#id19"><span class="problematic" id="id20">*</span></a>.bbappend)、特定于发行版的配置文件目录等。</p></li>
</ul>
<p>BSP 层
BSP 层提供针对特定硬件的机器配置。此层中的所有内容都特定于您为其构建映像或 SDK 的机器。为 BSP 层定义了一个共同的结构或形式。您可以在Yocto Project Board Support Package Developer’s Guide中了解有关此结构的更多信息 。</p>
<p>笔记</p>
<p>为了使 BSP 层被认为与 Yocto 项目兼容，它必须满足一些结构要求。</p>
<p>BSP 层的配置目录包含机器的配置文件 ( conf/machine/machine.conf)，当然还有层 ( conf/layer.conf)。</p>
<p>该层的其余部分按功能专用于特定配方： recipes-bsp、recipes-core、recipes-graphics、 recipes-kernel等等。可以有多种形式因素、图形支持系统等的元数据。</p>
<p>笔记</p>
<p>虽然该图显示了几个 recipes-* 目录，但并非所有这些目录都出现在所有 BSP 层中。</p>
<p>4.3.2.3软件层
软件层为构建期间使用的其他软件包提供元数据。该层不包括特定于发行版或机器的元数据，这些元数据位于各自的层中。</p>
<p>该层包含您的项目需要的任何配方、附加文件和补丁。</p>
<p>4.3.3来源
为了让 OpenEmbedded 构建系统创建映像或任何目标，它必须能够访问源文件。一般工作流程图 使用“上游项目发布”、“本地项目”和“SCM（可选）”框表示源文件。该图表示镜子，它也起到定位源文件的作用，带有“源材料”框。</p>
<p>最终组织源文件的方法是项目的一项功能。例如，对于已发布的软件，项目倾向于使用 tarball 或其他归档文件，这些文件可以捕获发布状态，以保证它是静态表示的。另一方面，对于本质上更具动态性或实验性的项目，项目可能会将源文件保存在由源代码控制管理器 (SCM)（例如 Git）控制的存储库中。从存储库中提取源代码允许您控制存储库（修订版）中要构建软件的点。两者的组合也是可能的。</p>
<p>BitBake 使用SRC_URI 变量指向源文件，而不管它们的位置。每个配方必须有一个指向源的SRC_URI变量。</p>
<p>DL_DIR变量指向另一个在源文件来源方面起重要作用的区域 。这个区域是一个缓存，可以保存以前下载的源。您还可以指示 OpenEmbedded 构建系统从 Git 存储库创建 tarball，这不是默认行为，并 使用 BB_GENERATE_MIRROR_TARBALLS 变量将它们存储在DL_DIR中。</p>
<p>明智地使用DL_DIR目录可以节省构建系统在查找文件时跨 Internet 的麻烦。使用下载目录的一个好方法是让DL_DIR指向构建目录之外的区域。这样做可以让您在需要时安全地删除构建目录，而不必担心删除任何下载的源文件。</p>
<p>本节的其余部分提供了对源文件和镜像的更深入了解。下面是对一般工作流图的源文件区域的更详细的查看：</p>
<p>source-input.png</p>
<p>4.3.3.1上游项目发布
上游项目版本以存档文件的形式存在于任何地方（例如 tarball 或 zip 文件）。这些文件对应于各个配方。例如，该图使用了 BusyBox、Qt 和 Dbus 各自的特定版本。存档文件可以用于可以使用配方构建的任何已发布产品。</p>
<p>4.3.3.2本地项目
本地项目是用户提供的自定义软件。这些位驻留在项目本地的某个地方——可能是用户签入项目的目录（例如，包含组使用的开发源树的本地目录）。</p>
<p>包含本地项目的规范方法是使用externalsrc 类来包含该本地项目。您可以使用local.conf 或配方的附加文件来覆盖或设置配方以指向磁盘上的本地目录以拉入整个源代码树。</p>
<p>4.3.3.3源代码控制管理器（可选）
构建系统可以从中获取源文件的另一个地方是 Fetchers使用各种源代码控制管理器 (SCM)，例如 Git 或 Subversion。在这种情况下，将克隆或签出存储库。BitBake 中的 do_fetch任务使用SRC_URI 变量和参数的前缀来确定正确的 fetcher 模块。</p>
<p>笔记</p>
<p>有关如何让 OpenEmbedded 构建系统为 Git 存储库生成 tarball 并将它们放置在 DL_DIR 目录中的信息，请参阅 Yocto 项目参考手册中的BB_GENERATE_MIRROR_TARBALLS 变量。</p>
<p>获取存储库时，BitBake 使用 SRCREV变量来确定要构建的特定版本。</p>
<p>4.3.3.4源镜像
镜子有两种：前置镜子和普通镜子。PREMIRRORS 和 MIRRORS变量分别指向这些变量。BitBake 在向上游查找任何源文件之前检查预镜像。当您的共享目录不是由 DL_DIR变量定义的目录时，预镜像是合适的。预镜像通常指向您组织的本地共享目录。</p>
<p>常规镜像可以是 Internet 上的任何站点，如果主站点由于某种原因无法运行，则用作源代码的替代位置。</p>
<p>4.3.4包源
当 OpenEmbedded 构建系统生成图像或 SDK 时，它会从位于 Build Directory中的包源区域获取包。常规工作流程图在 右上角显示了此包提要区域。</p>
<p>本节看起来更接近于构建系统使用的包源区域。以下是该地区的更详细介绍：</p>
<p>package-feeds.png</p>
<p>包提要是构建过程中的一个中间步骤。OpenEmbedded 构建系统提供类来生成不同的包类型，您可以通过 PACKAGE_CLASSES 变量指定启用哪些类。在将包放入包提要之前，构建过程通过insane 类生成的输出质量保证检查来验证它们。</p>
<p>包提要区域位于构建目录中。构建系统用于临时存储包的目录由变量和正在使用的特定包管理器的组合决定。请参阅插图中的“Package Feeds”框并记下该区域右侧的信息。特别是，以下定义了包文件的保存位置：</p>
<ul class="simple">
<li><p>DEPLOY_DIR：定义为 tmp/deploy在构建目录中。</p></li>
<li><p>DEPLOY_DIR_*：取决于使用的包管理器，包类型子文件夹。给定 RPM、IPK 或 DEB 打包和 tarball 创建，分别使用 DEPLOY_DIR_RPM、 DEPLOY_DIR_IPK、 DEPLOY_DIR_DEB或 DEPLOY_DIR_TAR变量。</p></li>
<li><p>PACKAGE_ARCH：定义特定于体系结构的子文件夹。例如，软件包可用于 i586 或 qemux86 架构。</p></li>
</ul>
<p>BitBake 使用 do_package_write_* 任务来生成包并将它们放入包保存区域（例如do_package_write_ipk对于 IPK 包）。有关更多信息，请参阅 Yocto 项目参考手册中的“ do_package_write_deb ”、“ do_package_write_ipk ”、“ do_package_write_rpm ”和“ do_package_write_tar ”部分。例如，考虑使用 IPK 打包管理器并且 i586 和 qemux86 都支持包体系结构的场景。i586 架构的 build/tmp/deploy/ipk/i586包放在 .qemux86 架构的包放在build/tmp/deploy/ipk/qemux86.</p>
<p>4.3.5 BitBake 工具
OpenEmbedded 构建系统使用 BitBake生成图像和软件开发工具包 (SDK)。从一般的工作流程图中可以看出，BitBake 区域由几个功能区域组成。本节将仔细研究这些领域中的每一个。</p>
<p>笔记</p>
<p>BitBake 工具的文档单独提供。有关 BitBake 的参考资料，请参阅 BitBake 用户手册。</p>
<p>4.3.5.1源码获取
构建配方的第一阶段是获取和解压缩源代码：</p>
<p>source-fetching.png</p>
<p>do_fetch和 do_unpack任务获取源文件并将它们解压到 Build Directory中。</p>
<p>笔记</p>
<p>对于作为配方的 SRC_URI 语句一部分的每个本地文件（例如 <a class="reference external" href="file://">file://</a> ），OpenEmbedded 构建系统获取配方文件的校验和并将校验和插入到 do_fetch 任务的签名中。如果任何本地文件被修改，do_fetch 任务和所有依赖它的任务都会重新执行。</p>
<p>默认情况下，一切都在构建目录中完成，该目录具有定义的结构。有关构建目录的其他一般信息，请参阅 Yocto 项目参考手册中的“ build/ ”部分。</p>
<p>每个配方在构建目录中都有一个区域，解压的源代码所在的位置。S变量指向该区域以获取配方的解压缩源代码。任何给定配方的目录名称由几个不同的变量定义。上图和以下列表描述了构建目录的层次结构：</p>
<ul class="simple">
<li><p>TMPDIR：OpenEmbedded 构建系统在构建期间执行所有工作的基本目录。默认的基本目录是tmp目录。</p></li>
<li><p>PACKAGE_ARCH：构建的包或包的体系结构。根据一个或多个包的最终目的地（即机器架构、构建主机、SDK 或特定机器）， PACKAGE_ARCH 会有所不同。有关详细信息，请参阅变量的描述。</p></li>
<li><p>TARGET_OS：目标设备的操作系统。一个典型的值是“linux”（例如“qemux86-poky-linux”）。</p></li>
<li><p>PN：用于构建包的配方的名称。这个变量可以有多种含义。但是，在输入文件的上下文中使用时， PN表示配方的名称。</p></li>
<li><dl class="simple">
<dt>WORKDIR：OpenEmbedded 构建系统构建配方的位置（即创建包的工作）。</dt><dd><ul>
<li><p>PV：用于构建包的配方版本。</p></li>
<li><p>PR：用于构建包的配方的修订版。</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>S：包含给定配方的解压缩源文件。</dt><dd><ul>
<li><p>BPN：用于构建包的配方的名称。BPN变量是PN变量的但删除了常见的前缀和后缀。</p></li>
<li><p>PV：用于构建包的配方版本。</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>笔记:在上图中，请注意有两个示例层次结构：一个基于包体系结构（即PACKAGE_ARCH），一个基于机器（即MACHINE）。底层结构相同。区别在于 OpenEmbedded 构建系统使用什么作为构建目标（例如通用架构、构建主机、SDK 或特定机器）。</p>
<div class="section" id="id21">
<h3>打补丁<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h3>
<p>获取并解压缩源代码后，BitBake 会定位补丁文件并将其应用于源文件：</p>
<p>patching.png</p>
<p>do_patch任务使用配方的SRC_URI语句和FILESPATH变量来定位适用的补丁文件。</p>
<p>补丁文件的默认处理假定文件具有 <em>.patch或</em>.diff文件类型。您可以使用SRC_URI参数来更改构建系统识别补丁文件的方式。有关更多信息，请参阅 do_patch任务。</p>
<p>BitBake 按照查找补丁的顺序为单个配方查找并应用多个补丁。FILESPATH变量定义了构建系统用来搜索补丁文件的默认目录集。一旦找到，补丁就会应用于配方的源文件，这些文件位于 S目录中。</p>
<p>有关如何创建源目录的更多信息，请参阅“ Source Fetching ”部分。有关如何创建补丁以及构建系统如何处理补丁的更多信息，请参阅 Yocto 项目开发任务手册中的“补丁代码”部分。您还可以查看Yocto 项目应用程序开发和可扩展软件开发工具包 (SDK) 手册中的“使用 devtool modify 修改现有组件的源代码”部分和“使用传统内核开发修补内核”部分Yocto Project Linux 内核开发手册。</p>
<p>4.3.5.3配置、编译和暂存
源代码修补后，BitBake 执行配置和编译源代码的任务。编译完成后，将文件复制到保存区域（暂存）以准备打包：</p>
<p>configuration-compile-autoreconf.png</p>
<p>构建过程中的此步骤包括以下任务：</p>
<ul class="simple">
<li><p>do_prepare_recipe_sysroot：此任务在 ${WORKDIR}中设置两个 sysroot （即recipe-sysroot和recipe-sysroot-native），以便在打包阶段 sysroot 可以包含包含 任务的配方所依赖的配方的do_populate_sysroot任务的内容。目标和本地二进制文件都存在 sysroot，它们在主机系统上运行。</p></li>
<li><p>do_configure：此任务通过启用和禁用正在构建的软件的任何构建时间和配置选项来配置源。配置可以来自配方本身，也可以来自继承的类。此外，软件本身可能会根据所构建的目标进行自我配置。</p></li>
</ul>
<p>do_configure任务处理的配置 特定于配方构建的源代码的配置。</p>
<p>如果您使用的是 autotools类，则可以使用 EXTRA_OECONF或 PACKAGECONFIG_CONFARGS 变量添加其他配置选项。有关此变量如何在该类中工作的信息，请参阅 此处的autotools类 。</p>
<ul class="simple">
<li><p>do_compile：一旦配置任务得到满足，BitBake 使用 do_compile任务编译源代码。编译发生在B变量指向的目录中 。意识到 B目录默认情况下与 S目录相同。</p></li>
<li><p>do_install：编译完成后，BitBake 执行 do_install任务。此任务从B目录复制文件并将它们放置在D 变量指向的保存区域中。稍后使用此保存目录中的文件进行打包。</p></li>
</ul>
</div>
</div>
<div class="section" id="id22">
<h2>包拆分<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h2>
<p>在配置、编译和暂存源代码后，构建系统会分析结果并将输出拆分为包：</p>
<p>analysis-for-package-splitting.png</p>
<p>do_package和 do_packagedata任务结合起来 分析在 D目录中找到的文件，并根据可用的包和文件将它们拆分为子集。分析涉及以下以及其他项目：拆分调试符号、查看包之间的共享库依赖关系以及查看包关系。</p>
<p>该do_packagedata任务基于分析创建包元数据，以便构建系统可以生成最终包。do_populate_sysroot任务将 do_install任务 安装的文件子集暂存（复制） 到相应的 sysroot 中。分析和包拆分过程的工作、分阶段和中间结果使用几个领域：</p>
<ul class="simple">
<li><p>PKGDpackage ：包被拆分为单独包之前的目标目录（即</p></li>
<li><p>PKGDESTWORK ： 任务用来保存包元数据的临时工作区（即pkgdata）do_package</p></li>
<li><p>PKGDEST：包被拆分后的父目录（即packages-split）。</p></li>
<li><p>PKGDATA_DIR：一个共享的全局状态目录，保存在打包过程中生成的打包元数据。打包过程将元数据从 PKGDESTWORK复制到PKGDATA_DIR区域，在该区域全局可用。</p></li>
<li><p>STAGING_DIR_HOST：构建组件以运行的系统的 sysroot 路径（即recipe-sysroot）。</p></li>
<li><p>STAGING_DIR_NATIVE：为构建主机构建组件时使用的 sysroot 的路径（即recipe-sysroot-native）。</p></li>
<li><p>STAGING_DIR_TARGET：当构建为在系统上执行的组件并为另一台机器（例如跨加拿大食谱）生成代码时使用的 sysroot 路径。</p></li>
</ul>
<p>FILES变量定义进入 PACKAGES中每个包的文件。如果您想了解有关如何完成此操作的详细信息，可以查看 package.bbclass。</p>
<p>根据正在创建的包的类型（RPM、DEB 或 IPK）， do_package_write_* 任务会创建实际的包并将它们放置在 Package Feed 区域，即${TMPDIR}/deploy. 您可以查看“ Package Feeds ”部分以获取有关构建过程的该部分的更多详细信息。</p>
<blockquote>
<div><p>4.3.5.5镜像生成</p>
</div></blockquote>
<p>一旦包被拆分并存储在 Package Feeds 区域中，构建系统就会使用 BitBake 生成根文件系统映像：</p>
<p>image-generation.png</p>
<p>图像生成过程由几个阶段组成，取决于几个任务和变量。do_rootfs 任务为图像创建根文件系统（文件和目录结构）。此任务使用几个关键变量来帮助创建要实际安装的软件包列表：</p>
<ul class="simple">
<li><p>IMAGE_INSTALL：列出要从 Package Feeds 区域安装的基本软件包集。</p></li>
<li><p>PACKAGE_EXCLUDE：指定不应安装到映像中的包。</p></li>
<li><p>IMAGE_FEATURES：指定要包含在图像中的特征。这些功能中的大多数都映射到其他安装包。</p></li>
<li><p>PACKAGE_CLASSES：指定要使用的包后端（例如 RPM、DEB 或 IPK），因此有助于确定在包源区域内定位包的位置。</p></li>
<li><p>IMAGE_LINGUAS：确定安装附加语言支持包的语言。</p></li>
<li><p>PACKAGE_INSTALL：传递给包管理器以安装到映像中的包的最终列表。</p></li>
<li><p>IMAGE_ROOTFS 指向正在构建的文件系统的位置，并且 PACKAGE_INSTALL变量提供了要安装的包的最终列表，因此创建了根文件系统。</p></li>
</ul>
<p>软件包安装受软件包管理器（例如 dnf/rpm、opkg 或 apt/dpkg）控制，无论是否为目标启用了软件包管理。在该过程结束时，如果没有为目标启用包管理，则包管理器的数据文件将从根文件系统中删除。作为包安装最后阶段的一部分，作为包一部分的安装后脚本将运行。首次引导目标系统时，任何未能在构建主机上运行的脚本都会在目标上运行。如果您使用的是 只读根文件系统，则所有安装后脚本都必须在包安装阶段在构建主机上成功，因为目标上的根文件系统是只读的。</p>
<p>任务的最后阶段do_rootfs处理后处理。后处理包括清单文件的创建和优化。</p>
<p>清单文件 ( .manifest) 与根文件系统映像位于同一目录中。此文件逐行列出已安装的软件包。清单文件对于 testimage类很有用，例如，确定是否运行特定测试。有关其他信息，请参阅 IMAGE_MANIFEST 变量。</p>
<p>优化跨映像运行的进程包括mklibs、 和任何其他由ROOTFS_POSTPROCESS_COMMAND 变量prelink定义的后处理命令 。该过程优化了库的大小，而该过程优化了共享库的动态链接以减少可执行文件的启动时间。mklibsprelink</p>
<p>构建根文件系统后，通过do_image 任务开始对图像进行处理。构建系统运行由IMAGE_PREPROCESS_COMMAND 变量定义的任何预处理命令 。此变量指定在构建系统创建最终图像输出文件之前要调用的函数列表。</p>
<p>构建系统根据IMAGE_FSTYPES变量do_image_*中指定的图像类型根据需要动态创建任务 。该过程将所有内容变成一个图像文件或一组图像文件，并且可以压缩根文件系统图像以减小图像的整体大小。用于根文件系统的格式取决于 IMAGE_FSTYPES变量。压缩取决于格式是否支持压缩。</p>
<p>例如，在创建特定图像类型时动态创建的任务将采用以下形式：</p>
<p>do_image_type
因此，如果IMAGE_FSTYPES指定的类型为ext4，则动态生成的任务如下：</p>
<p>do_image_ext4
图像创建涉及的最后一个任务是 do_image_complete 任务。此任务通过应用通过IMAGE_POSTPROCESS_COMMAND 变量定义的任何图像后处理来完成图像 。该变量指定构建系统创建最终图像输出文件后要调用的函数列表。</p>
<p>笔记</p>
<p>整个图像生成过程在 Pseudo 下运行。在 Pseudo 下运行可确保根文件系统中的文件具有正确的所有权。</p>
<p>4.3.5.6 SDK 生成
OpenEmbedded 构建系统使用 BitBake 为标准 SDK 和可扩展 SDK (eSDK) 生成软件开发工具包 (SDK) 安装程序脚本：</p>
<p>sdk-generation.png</p>
<p>笔记：有关交叉开发工具链生成的更多信息，请参阅“交叉开发工具链生成”部分。有关使用 do_populate_sdk 任务构建交叉开发工具链时获得的优势的信息，请参阅 Yocto 项目应用程序开发和可扩展软件开发工具包 (eSDK) 手册中的“构建 SDK 安装程序”部分。</p>
<p>与图像生成一样，SDK 脚本过程由多个阶段组成，并且依赖于许多变量。do_populate_sdk 和 do_populate_sdk_ext任务使用这些关键变量来帮助创建要 实际安装的软件包列表。有关图中列出的变量的信息，请参阅“应用程序开发 SDK ”部分。</p>
<p>该do_populate_sdk任务有助于创建标准 SDK 并处理两个部分：目标部分和主机部分。目标部分是为目标硬件构建的部分，包括库和头文件。主机部分是在 SDKMACHINE上运行的 SDK 部分。</p>
<p>该do_populate_sdk_ext任务有助于创建可扩展的 SDK，并且处理主机和目标部分的方式与处理标准 SDK 的对应部分不同。对于可扩展 SDK，任务封装了构建系统，其中包括 SDK 所需的一切（主机和目标）。</p>
<p>无论构建的 SDK 类型如何，任务都会执行一些清理，然后创建交叉开发环境设置脚本和任何所需的配置文件。最终输出的是跨开发工具链安装脚本（.sh文件），其中包含环境设置脚本。</p>
<p>4.3.5.7戳文件和任务的重新运行
对于每个成功完成的任务，BitBake 都会将一个戳文件写入STAMPS_DIR 目录。戳记文件的文件名的开头由STAMP变量确定，名称的结尾由任务名称和当前输入校验和组成。</p>
<p>笔记</p>
<p>此命名方案假定 BB_SIGNATURE_HANDLER 是“OEBasicHash”，这在当前的 OpenEmbedded 中几乎总是如此。</p>
<p>为了确定是否需要重新运行任务，BitBake 会检查该任务是否存在具有匹配输入校验和的标记文件。在这种情况下，假定任务的输出存在并且仍然有效。否则，将重新运行该任务。</p>
<p>笔记</p>
<p>标记机制比“ Setscene 任务和共享状态”一节中描述的共享状态（sstate）缓存机制更通用。BitBake 避免重新运行任何具有有效标记文件的任务，而不仅仅是可以通过 sstate 缓存加速的任务。</p>
<p>但是，您应该意识到标记文件仅用作某些工作已完成的标记，并且这些文件不记录任务输出。实际的任务输出通常在 TMPDIR中的某个地方（例如，在某些配方的WORKDIR中）。sstate 缓存机制添加的是一种缓存任务输出的方法，然后可以在构建机器之间共享。</p>
<p>由于STAMPS_DIR通常是TMPDIR的子目录，因此删除 TMPDIR也将删除STAMPS_DIR，这意味着将正确地重新运行任务以重新填充TMPDIR。</p>
<p>如果您希望某些任务始终被视为“过时”，您可以使用nostamp varflag 对其进行标记。如果某个其他任务依赖于这样的任务，那么该任务也将始终被认为是过时的，这可能不是您想要的。</p>
<p>有关如何查看任务签名信息的详细信息，请参阅 Yocto 项目开发任务手册中的“查看任务变量依赖关系”部分。</p>
<p>4.3.5.8 Setscene 任务和共享状态
到目前为止的任务描述假定 BitBake 需要构建所有内容并且不存在可用的预构建对象。如果预建对象可用，BitBake 确实支持跳过任务。这些对象通常以共享状态 (sstate) 缓存的形式提供。</p>
<p>笔记</p>
<p>有关影响 sstate 的变量的信息，请参阅 SSTATE_DIR 和 SSTATE_MIRRORS 变量。</p>
<p>场景任务（即）的想法是任务do_taskname_setscene的一个版本，BitBake 可以跳到最终结果，并根据需要简单地将一组文件放置到特定位置，而不是构建一些东西。在某些情况下，有一个 setscene 任务变体是有意义的（例如，在 do_package_write_* 任务中生成包文件）。在其他情况下，它没有意义（例如 do_patch任务或 do_unpack任务），因为所涉及的工作将等于或大于底层任务。</p>
<p>在构建系统中，具有场景变体的常见任务是 do_package、 do_package_write_*、 do_deploy、 do_packagedata和 do_populate_sysroot。请注意，这些任务代表了大多数以最终结果为输出的任务。</p>
<p>构建系统了解这些任务与其他先前任务之间的关系。例如，如果 BitBake 为某事运行 ，那么运行、、、 、和任务do_populate_sysroot_setscene中的任何一个都没有意义。但是，如果 需要运行，BitBake 需要运行那些其他任务。do_fetchdo_unpackdo_patchdo_configuredo_compiledo_installdo_package</p>
<p>如果所有内容都可以来自 sstate 缓存，则变得更加复杂，因为根本不需要某些对象。例如，如果没有要编译或修补的内容，则不需要编译器或本机工具，例如 quilt。如果do_package_write_*包可从 sstate 获得，BitBake 不需要do_package任务数据。</p>
<p>为了处理所有这些复杂性，BitBake 分两个阶段运行。首先是“场景”阶段。在这个阶段，BitBake 首先检查 sstate 缓存是否有它计划构建的任何目标。BitBake 会快速检查对象是否存在，而不是进行完整下载。如果什么都不存在，则第二阶段（即场景阶段）完成并继续进行主要构建。</p>
<p>如果在 sstate 缓存中找到对象，则构建系统从用户指定的最终目标向后工作。例如，如果正在构建映像，则构建系统首先查找该映像所需的包以及构建映像所需的工具。如果这些可用，则不需要编译器。因此，甚至没有下载编译器。如果发现某些内容不可用，或者下载或设置场景任务失败，则构建系统会尝试从缓存中安装依赖项，例如编译器。</p>
<p>sstate 缓存中对象的可用性由BB_HASHCHECK_FUNCTION 变量指定的函数处理，并返回可用对象的列表。BB_SETSCENE_DEPVALID变量指定 的函数是确定是否需要遵循给定依赖关系以及是否需要传递给定关系的函数。该函数返回 True 或 False 值。</p>
<p>4.3.6图像
构建系统生成的映像是根文件系统的压缩形式，可以在目标设备上启动。您可以从一般工作流程图中看到，BitBake 输出部分由图像组成。本节仔细研究此输出：</p>
<p>images.png</p>
<p>笔记：有关Yocto项目提供的示例图像列表，请参阅Yocto项目参考手册中的“图像”章节。</p>
<p>如图所示，构建过程将图像写入文件夹 内 的构建目录tmp/deploy/images/machine/。此文件夹包含预期在目标设备上加载的任何文件。deploy_dir变量指向目录，而 deploy_dir_image变量指向 包含当前配置的图像的相应目录。deploy</p>
<ul class="simple">
<li><p>kernel-image：内核二进制文件。KERNEL_IMAGETYPE 变量确定内核映像文件的 命名方案。根据此变量，文件可以以各种命名字符串开头。机器目录可以包含机器的deploy/images/多个图像文件。</p></li>
<li><p>root-filesystem-image：目标设备（例如文件）的根文件 <em>.ext3系统</em>.bz2。IMAGE_FSTYPES 变量 确定根文件系统映像类型。deploy/images/机器目录可以包含机器的多个根文件系统。</p></li>
<li><p>kernel-modules：包含为内核构建的所有模块的压缩包。内核模块 tarball 用于遗留目的，可以通过将 MODULE_TARBALL_DEPLOY 变量设置为“0”来抑制。deploy/images/机器目录可以包含机器的多个内核模块压缩包。</p></li>
<li><p>引导加载程序：如果适用于目标机器，则支持映像的引导加载程序。deploy/images/机器目录可以包含机器的多个引导加载程序。</p></li>
<li><p>symlinks：deploy/images/机器文件夹包含一个符号链接，指向每台机器最近构建的文件。这些链接对于需要获取每个文件的最新版本的外部脚本可能很有用。</p></li>
</ul>
<p>4.3.7应用开发SDK
在里面一般工作流程图中，标记为“应用程序开发 SDK”的输出代表一个 SDK。SDK 生成过程会有所不同，具体取决于您构建的是可扩展 SDK（例如imagename）还是标准 SDK（例如imagename）。本节仔细研究此输出：bitbake -c populate_sdk_extbitbake -c populate_sdk</p>
<p>sdk.png</p>
<p>此输出的具体形式是一组文件，其中包括自解压 SDK 安装程序 ( <a href="#id23"><span class="problematic" id="id24">*</span></a>.sh)、主机和目标清单文件以及用于 SDK 测试的文件。当 SDK 安装程序文件运行时，它会安装 SDK。SDK 由一个交叉开发工具链、一组库和头文件以及一个 SDK 环境设置脚本组成。运行此安装程序实质上会设置您的交叉开发环境。您可以将跨工具链视为“主机”部分，因为它运行在 SDK 机器上。您可以将库和头文件视为“目标”部分，因为它们是为目标硬件构建的。添加了环境设置脚本，以便您可以在使用工具之前初始化环境。</p>
<p>笔记</p>
<ul class="simple">
<li><p>Yocto 项目支持多种方法，您可以通过这些方法设置此交叉开发环境。这些方法包括下载预构建的 SDK 安装程序或构建和安装您自己的 SDK 安装程序。</p></li>
<li><p>有关 Yocto Project 开发环境中交叉开发工具链的背景信息，请参阅“交叉开发工具链生成”部分。</p></li>
<li><p>有关设置交叉开发环境的信息，请参阅Yocto 项目应用程序开发和可扩展软件开发工具包 (eSDK)手册。</p></li>
</ul>
<p>如上图所示，SDK 的所有输出文件都会写入Build Directorydeploy/sdk中的文件夹。根据 SDK 的类型，有几个变量可以配置这些文件。以下是与可扩展 SDK 相关的变量：</p>
<ul class="simple">
<li><p>DEPLOY_DIR：指向deploy目录。</p></li>
<li><p>SDK_EXT_TYPE：控制是否将共享状态工件复制到可扩展 SDK 中。默认情况下，所有必需的共享状态工件都会复制到 SDK 中。</p></li>
<li><p>SDK_INCLUDE_PKGDATA：指定 packagedata 是否包含在“世界”目标中所有配方的可扩展 SDK 中。</p></li>
<li><p>SDK_INCLUDE_TOOLCHAIN：指定构建可扩展 SDK 时是否包含工具链。</p></li>
<li><p>SDK_LOCAL_CONF_WHITELIST：允许从构建系统配置到可扩展 SDK 配置的变量列表。</p></li>
<li><p>SDK_LOCAL_CONF_BLACKLIST：不允许从构建系统配置进入可扩展 SDK 配置的变量列表。</p></li>
<li><p>SDK_INHERIT_BLACKLIST ：要从可扩展 SDK 配置中的全局INHERIT值中删除的类列表</p></li>
</ul>
<p>下一个列表显示了与标准 SDK 关联的变量：</p>
<ul class="simple">
<li><p>DEPLOY_DIR：指向deploy目录。</p></li>
<li><p>SDKMACHINE：指定运行交叉开发工具以为目标硬件创建包的机器的体系结构。</p></li>
<li><p>SDKIMAGE_FEATURES：列出要包含在 SDK 的“目标”部分中的功能。</p></li>
<li><p>TOOLCHAIN_HOST_TASK：列出组成 SDK 的主机部分的包（即在SDKMACHINE上运行的部分）。当您用于 创建 SDK 时，会应用一组默认包。此变量允许您添加更多包。bitbake -c populate_sdk imagename</p></li>
<li><p>TOOLCHAIN_TARGET_TASK：列出组成 SDK 目标部分的包（即为目标硬件构建的部分）。</p></li>
<li><p>SDKPATH：定义安装脚本提供的默认 SDK 安装路径。</p></li>
<li><p>SDK_HOST_MANIFEST：列出构成 SDK 主机部分的所有已安装包。该变量在可扩展 SDK 开发中也扮演着次要角色。但是，它主要用于标准 SDK。</p></li>
<li><p>SDK_TARGET_MANIFEST：列出构成 SDK 目标部分的所有已安装包。该变量在可扩展 SDK 开发中也扮演着次要角色。但是，它主要用于标准 SDK。</p></li>
</ul>
<p>4.4交叉开发工具链生成
在创建交叉开发工具链时，Yocto 项目为您完成了大部分工作。本节提供有关如何创建和使用交叉开发工具链的一些技术背景。有关工具链的更多信息，您还可以查看Yocto 项目应用程序开发和可扩展软件开发工具包 (eSDK)手册。</p>
<p>在 Yocto Project 开发环境中，交叉开发工具链用于构建在目标硬件上运行的镜像和应用程序。只需几个命令，OpenEmbedded 构建系统就可以为您创建这些必要的工具链。</p>
<p>下图显示了关于工具链构建和使用的高级构建环境。</p>
<p>cross-development-toolchains.png</p>
<p>大部分工作发生在构建主机上。这是用于构建图像的机器，通常在 Yocto 项目环境中工作。当您运行 BitBake来创建映像时，OpenEmbedded 构建系统使用主机gcc编译器来引导名为gcc-cross. 编译器是 BitBake在gcc-cross创建目标图像时用来编译源文件的工具。您可以gcc-cross简单地将其视为仅在 BitBake 内部使用的自动生成的交叉编译器。</p>
<p>笔记</p>
<p>可扩展 SDK 不使用gcc-cross-canadian ，因为此 SDK 提供了 OpenEmbedded 构建系统的副本，并且其中包含gcc-cross.</p>
<p>引导标准工具链时发生的事件链：</p>
<p>binutils-cross -&gt; linux-libc-headers -&gt; gcc-cross -&gt; libgcc-initial -&gt; glibc -&gt; libgcc -&gt; gcc-runtime
- gcc: 编译器，GNU 编译器集合 (GCC)。</p>
<ul class="simple">
<li><p>binutils-crossgcc-cross：运行引导操作阶段和为 C 库构建头文件所需的二进制实用程序。</p></li>
<li><p>linux-libc-headers：交叉编译器和 C 库构建所需的头文件。</p></li>
<li><p>libgcc-initial：引导所需的 gcc 支持库的初始版本glibc。</p></li>
<li><p>libgcc：gcc 支持库的最终版本，只有在有 C 库可以链接时才能构建。</p></li>
<li><p>glibc: GNU C 库。</p></li>
<li><p>gcc-cross：交叉编译器引导过程的最后阶段。此阶段生成 BitBake 在为目标设备构建映像时使用的实际交叉编译器。这个工具是一个“原生”工具（即它被设计为在构建主机上运行）。</p></li>
<li><p>gcc-runtime：工具链引导过程产生的运行时库。此工具生成一个二进制文件，其中包含目标设备所需的运行时库。</p></li>
</ul>
<p>您可以使用 OpenEmbedded 构建系统为用于开发应用程序的可重定位 SDK 构建安装程序。当您运行安装程序时，它会安装工具链，其中包含开发工具（例如 、gcc-cross-canadian和binutils-cross-canadian其他nativesdk-<a href="#id25"><span class="problematic" id="id26">*</span></a>工具），这些工具是 SDK 原生的工具（即SDK_ARCH原生的），您需要交叉编译和测试您的软件. 该图显示了用于轻松构建此工具链的命令。这个交叉开发工具链是为在 SDKMACHINE上执行而构建的，它可能与构建主机是同一台机器，也可能不是同一台机器。</p>
<p>笔记</p>
<p>如果 Yocto 项目支持您的目标架构，您可以利用 Yocto 项目附带的预构建映像，并且已经包含交叉开发工具链安装程序。</p>
<p>这是可重定位工具链的引导过程：</p>
<p>gcc -&gt; binutils-crosssdk -&gt; gcc-crosssdk-initial -&gt; linux-libc-headers -&gt; glibc-initial -&gt; nativesdk-glibc -&gt; gcc-crosssdk -&gt; gcc-cross-canadian
- gcc：构建主机的 GNU 编译器集合 (GCC)。</p>
<ul class="simple">
<li><p>binutils-crosssdkgcc-crosssdk-initial：运行引导操作阶段所需的最低限度的二进制实用程序。</p></li>
<li><p>gcc-crosssdk-initial：创建交叉编译器的引导过程的早期阶段。这个阶段构建了足够多的 gcc-crosssdk支持部分，以便引导过程的最后阶段可以生成完成的交叉编译器。该工具是在构建主机上运行的“本机”二进制文件。</p></li>
<li><p>linux-libc-headers: 交叉编译器需要的头文件。</p></li>
<li><p>glibc-initial：需要引导的嵌入式 GLIBC 的初始版本nativesdk-glibc。</p></li>
<li><p>nativesdk-glibc：嵌入式 GLIBC 需要引导 gcc-crosssdk.</p></li>
<li><p>gcc-crosssdk：可重定位交叉编译器的引导过程的最后阶段。这gcc-crosssdk是一个临时编译器，永远不会离开构建主机。它的目的是帮助引导过程创建最终的gcc-cross-canadian 编译器，它是可重定位的。这个工具也是一个“原生”包（即它被设计为在构建主机上运行）。</p></li>
<li><p>gcc-cross-canadian: 最终的可重定位交叉编译器。在SDKMACHINE上运行时，此工具会生成在目标设备上运行的可执行代码。每个架构只生成一个跨加拿大编译器，因为它们可以使用通过编译命令传递给编译器的配置针对不同的处理器优化。这避免了对多个编译器的需求，从而减少了工具链的大小。</p></li>
</ul>
<p>笔记：有关在构建交叉开发工具链安装程序时获得的优势的信息，请参阅 Yocto 项目应用程序开发和可扩展软件开发工具包 (eSDK) 手册中的“构建 SDK 安装程序”附录。</p>
<p>4.5共享状态缓存
按照设计，OpenEmbedded 构建系统从头开始构建所有内容，除非BitBake可以确定不需要重新构建部件。从根本上说，从头开始构建很有吸引力，因为这意味着所有部分都是全新构建的，并且不存在可能导致问题的陈旧数据。当开发人员遇到问题时，他们通常会默认从头开始构建，因此他们从一开始就有一个已知的状态。</p>
<p>从头开始构建图像对该过程来说既是优点也是缺点。如上一段所述，从头开始构建可确保一切都是最新的并从已知状态开始。但是，从头开始构建也需要更长的时间，因为它通常意味着重建不一定需要重建的东西。</p>
<p>Yocto 项目实现了支持增量构建的共享状态代码。共享状态代码的实现回答了以下问题，这些问题是 OpenEmbedded 增量构建支持系统中的基本障碍：</p>
<ul class="simple">
<li><p>系统的哪些部分发生了变化，哪些部分没有改变？</p></li>
<li><p>如何删除和替换已更改的软件？</p></li>
<li><p>无需从头开始重新构建的预构建组件在可用时如何使用？</p></li>
</ul>
<p>对于第一个问题，构建系统通过创建任务输入的校验和（或签名）来检测给定任务的“输入”变化。如果校验和改变，系统假定输入已经改变并且需要重新运行任务。对于第二个问题，共享状态 (sstate) 代码跟踪哪些任务将哪些输出添加到构建过程。这意味着可以删除、升级或以其他方式操纵给定任务的输出。第三个问题由第二个问题的解决方案部分解决，假设构建系统可以从远程位置获取 sstate 对象并在它们被认为有效时安装它们。</p>
<p>笔记</p>
<ul class="simple">
<li><p>构建系统不维护 PR信息作为共享状态包的一部分。因此，有一些考虑因素会影响维护共享状态提要。有关构建系统如何使用包以及如何跟踪递增PR 信息的信息，请参阅 Yocto 项目开发任务手册中的“自动递增包版本号”部分。</p></li>
<li><p>支持增量构建的构建系统中的代码很复杂。有关帮助您解决与共享状态代码相关的问题的技术，请参阅Yocto 项目开发中的“查看用于创建共享状态任务的输入签名的元数据”和“使共享状态无效以强制任务运行”部分任务手册。</p></li>
</ul>
<p>本节的其余部分详细介绍了整体增量构建架构、校验和（签名）和共享状态。</p>
<p>4.5.1整体架构
在确定需要构建系统的哪些部分时，BitBake 基于每个任务而不是每个配方工作。您可能想知道为什么使用基于每个任务的基础优于基于每个食谱的基础。为了帮助解释，请考虑启用 IPK 打包后端，然后切换到 DEB。在这种情况下， do_install和 do_package任务输出仍然有效。但是，使用按配方的方法，构建将不包括.deb文件。因此，您必须使整个构建无效并重新运行它。重新运行所有内容并不是最好的解决方案。此外，在这种情况下，必须“教授”很多关于特定任务的核心。这种方法不能很好地扩展，并且不允许用户在不触及打包暂存核心的情况下轻松地在层中添加新任务或作为外部配方。</p>
<p>4.5.2校验和（签名）
共享状态代码使用校验和（它是任务输入的唯一签名）来确定是否需要再次运行任务。因为触发重新运行的是任务输入的变化，所以流程需要检测给定任务的所有输入。对于 shell 任务，这变得相当容易，因为构建过程会为每个任务生成一个“运行”的 shell 脚本，并且可以创建一个校验和，让您很好地了解任务的数据何时发生变化。</p>
<p>使问题复杂化的是，有些东西不应该包含在校验和中。首先，有给定任务的实际特定构建路径 - WORKDIR。工作目录是否更改并不重要，因为它不应该影响目标包的输出。此外，构建过程的目标是使本地或跨包可重定位。</p>
<p>笔记</p>
<p>本机和交叉包都在构建主机上运行。但是，跨包会为目标架构生成输出。</p>
<p>因此校验和需要排除WORKDIR。排除工作目录的简单方法是将WORKDIR设置为某个固定值并为“运行”脚本创建校验和。</p>
<p>另一个问题是“运行”脚本包含可能会或可能不会被调用的函数。增量构建解决方案包含计算 shell 函数之间依赖关系的代码。此代码用于将“运行”脚本修剪到最小集，从而缓解此问题并使“运行”脚本更具可读性作为奖励。</p>
<p>到目前为止，有针对 shell 脚本的解决方案。Python 任务呢？即使这些任务更加困难，同样的方法也适用。该过程需要弄清楚 Python 函数访问哪些变量以及它调用了哪些函数。同样，增量构建解决方案包含的代码首先确定变量和函数依赖关系，然后为用作任务输入的数据创建校验和。</p>
<p>与WORKDIR案例一样，可能存在应忽略依赖关系的情况。对于这些情况，您可以使用如下行指示构建过程忽略依赖项：</p>
<p>PACKAGE_ARCHS[vardepsexclude] = “MACHINE”
此示例确保PACKAGE_ARCHS变量不依赖于MACHINE的值，即使它确实引用了它。</p>
<p>同样，在某些情况下，您需要添加 BitBake 无法找到的依赖项。您可以通过使用如下行来完成此操作：</p>
<p>PACKAGE_ARCHS[vardeps] = “MACHINE”
此示例显式添加MACHINE变量作为PACKAGE_ARCHS的依赖项。</p>
<p>例如，考虑一个内嵌 Python 的情况，其中 BitBake 无法找出依赖关系。在调试模式下运行时（即使用 -DDD），BitBake 会在发现无法确定依赖关系的内容时生成输出。Yocto 项目团队目前还没有设法详细介绍这些依赖关系，并且意识到需要解决这种情况。</p>
<p>到目前为止，本节的讨论仅限于对任务的直接输入。基于直接输入的信息在代码中称为“basehash”。但是，任务的间接输入问题仍然存在 - 项目已经构建并存在于 Build Directory中。特定任务的校验和（或签名）需要添加特定任务所依赖的所有任务的哈希值。选择要添加的依赖项是一项策略决策。但是，效果是生成一个校验和，它结合了 basehash 和任务依赖项的哈希值。</p>
<p>在代码级别，有多种方式可以影响基本哈希和相关任务哈希。在 BitBake 配置文件中，您可以为 BitBake 提供一些额外的信息来帮助它构建 basehash。以下语句有效地导致全局变量依赖排除列表（即从未包含在任何校验和中的变量）：</p>
<dl class="simple">
<dt>BB_HASHBASE_WHITELIST ?= “TMPDIR FILE PATH PWD BB_TASKHASH BBPATH DL_DIR \</dt><dd><p>SSTATE_DIR THISDIR FILESEXTRAPATHS FILE_DIRNAME HOME LOGNAME SHELL TERM \
USER FILESPATH STAGING_DIR_HOST STAGING_DIR_TARGET COREBASE PRSERV_HOST \
PRSERV_DUMPDIR PRSERV_DUMPFILE PRSERV_LOCKDOWN PARALLEL_MAKE \
CCACHE_DIR EXTERNAL_TOOLCHAIN CCACHE CCACHE_DISABLE LICENSE_PATH SDKPKGSUFFIX”</p>
</dd>
</dl>
<p>前面的示例不包括WORKDIR，因为该变量实际上构造为TMPDIR中的路径，其中包含在上面。</p>
<p>决定通过依赖链包含哪些依赖任务的哈希的规则更复杂，通常使用 Python 函数完成。中的代码 meta/lib/oe/sstatesig.py显示了这方面的两个示例，还说明了如果需要，您可以如何将自己的策略插入系统。该文件定义了 OpenEmbedded-Core (OE-Core)使用的两个基本签名生成器：“OEBasic”和“OEBasicHash”。默认情况下，BitBake 中启用了一个虚拟的“noop”签名处理程序。这意味着行为与以前的版本没有变化。OE-Core 通过文件中的这个设置默认使用“OEBasicHash”签名处理程序bitbake.conf：</p>
<p>BB_SIGNATURE_HANDLER ?= “OEBasicHash”
“OEBasicHash” BB_SIGNATURE_HANDLER与“OEBasic”版本相同，但将任务哈希添加到戳文件中。这会导致任何会更改任务哈希的元数据更改，从而自动导致任务再次运行。这消除了增加 PR值的需要，并且对元数据的更改会自动在整个构建中产生涟漪效应。</p>
<p>还值得注意的是，这些签名生成器的最终结果是使某些依赖项和哈希信息可用于构建。这些信息包括：</p>
<p>BB_BASEHASH:task-taskname：配方中每个任务的基本哈希值。</p>
<p>BB_BASEHASH_文件名任务名:：每个依赖任务的基本哈希。</p>
<p>BB_TASKHASH：当前运行任务的哈希值。</p>
<p>4.5.3共享状态
如上一节所述，校验和和依赖关系解决了支持共享状态的一半问题。问题的另一半是能够在构建期间使用校验和信息，并且能够重用或重建特定组件。</p>
<p>sstate类是如何“捕获”给定任务的快照的相对通用的实现。这个想法是构建过程不关心任务输出的来源。输出可以是新构建的，也可以从某个地方下载和解压缩。换句话说，构建过程不需要担心它的起源。</p>
<p>存在两种类型的输出。一种类型只是在WORKDIR中创建一个目录。一个很好的例子是 do_install或 do_package的输出。当一组数据合并到一个共享目录树（如 sysroot）中时，会出现另一种类型的输出。</p>
<p>Yocto 项目团队试图将实现的细节隐藏在sstate类中。从用户的角度来看，向任务添加共享状态包装就像 从部署类中获取的do_deploy示例一样简单：</p>
<p>DEPLOYDIR = “${WORKDIR}/deploy-${PN}”
SSTATETASKS += “do_deploy”
do_deploy[sstate-inputdirs] = “${DEPLOYDIR}”
do_deploy[sstate-outputdirs] = “${DEPLOY_DIR_IMAGE}”</p>
<dl class="simple">
<dt>python do_deploy_setscene () {</dt><dd><p>sstate_setscene(d)</p>
</dd>
</dl>
<p>}
addtask do_deploy_setscene
do_deploy[dirs] = “${DEPLOYDIR} ${B}”
do_deploy[stamp-extra-info] = “${MACHINE_ARCH}”
以下列表解释了前面的示例：</p>
<p>添加“do_deploy”以在do_deploy任务之前和之后 SSTATETASKS添加一些所需的与sstate相关的处理，这些处理在 sstate类中实现。</p>
<p>声明 在正常运行时（即不使用 sstate 缓存时）放置其输出。此输出成为共享状态缓存的输入。do_deploy[sstate-inputdirs] = “${DEPLOYDIR}”do_deploy${DEPLOYDIR}</p>
<p>该行将共享状态缓存的内容复制到 .do_deploy[sstate-outputdirs] = “${DEPLOY_DIR_IMAGE}”${DEPLOY_DIR_IMAGE}</p>
<p>笔记</p>
<p>如果do_deploy尚未在共享状态缓存中，或者其输入校验和（签名）与输出缓存时相比已更改，则运行任务以填充共享状态缓存，然后将共享状态缓存的内容复制到 ${ DEPLOY_DIR_IMAGE }。如果 do_deployis 在共享状态缓存中并且其签名表明缓存的输出仍然有效（即，如果没有相关的任务输入发生变化），则共享状态缓存的内容直接由任务复制到 ${ DEPLOY_DIR_IMAGE } do_deploy_setscene，跳过do_deploy任务。</p>
<p>以下任务定义是使先前设置生效所需的粘合逻辑：</p>
<dl class="simple">
<dt>python do_deploy_setscene () {</dt><dd><p>sstate_setscene(d)</p>
</dd>
</dl>
<p>}
addtask do_deploy_setscene
sstate_setscene()do_deploy如果可能，将上面的标志作为输入并通过共享状态缓存加速任务。如果任务被加速，则sstate_setscene()返回 True。否则，它返回 False，并且正常的do_deploy任务运行。有关详细信息，请参阅 BitBake 用户手册中的“ Setscene ”部分。</p>
<p>该行在 任务运行之前创建and ，还将当前工作目录设置为。有关详细信息，请参阅 BitBake 用户手册中的“变量标志”部分。do_deploy[dirs] = “${DEPLOYDIR} ${B}”${DEPLOYDIR}${B}do_deploydo_deploy${B}</p>
<p>笔记</p>
<p>在 和 相同的情况下sstate-inputdirs，sstate-outputdirs您可以使用sstate-plaindirs. 例如，要保留任务的 ${ PKGD } 和 ${ PKGDEST } 输出do_package ，请使用以下命令：</p>
<p>do_package[sstate-plaindirs] = “${PKGD} ${PKGDEST}”
该行将额外的元数据附加到戳文件。在这种情况下，元数据使任务特定于机器的架构。有关标志的更多信息，请参阅BitBake 用户手册中的 “任务列表”部分。do_deploy[stamp-extra-info] = “${MACHINE_ARCH}”stamp-extra-info</p>
<p>sstate-inputdirs也sstate-outputdirs可以与多个目录一起使用。例如，以下声明 PKGDESTWORK和SHLIBWORK作为共享状态输入目录，它填充共享状态缓存，以及PKGDATA_DIR和 SHLIBSDIR作为相应的共享状态输出目录：</p>
<p>do_package[sstate-inputdirs] = “${PKGDESTWORK} ${SHLIBSWORKDIR}”
do_package[sstate-outputdirs] = “${PKGDATA_DIR} ${SHLIBSDIR}”
这些方法还包括在操作共享状态目录结构时获取锁定文件的能力，用于文件添加或删除敏感的情况：</p>
<p>do_package[sstate-lockfile] = “${PACKAGELOCK}”
在幕后，共享状态代码通过在 SSTATE_DIR和 SSTATE_MIRRORS中查找共享状态文件来工作。这是一个例子：</p>
<dl class="simple">
<dt>SSTATE_MIRRORS ?= “</dt><dd><p><a class="reference external" href="file://.*">file://.*</a> <a class="reference external" href="https://someserver.tld/share/sstate/PATH;downloadfilename=PATH">https://someserver.tld/share/sstate/PATH;downloadfilename=PATH</a> <a class="reference external" href="file://.*">file://.*</a> <a class="reference external" href="file:///some/local/dir/sstate/PATH">file:///some/local/dir/sstate/PATH</a>”</p>
</dd>
</dl>
<p>笔记</p>
<p>共享状态目录 ( SSTATE_DIR ) 被组织成两个字符的子目录，其中子目录名称基于哈希的前两个字符。如果镜像的共享状态目录结构与SSTATE_DIR具有相同的结构，则必须将“PATH”指定为 URI 的一部分，以使构建系统能够映射到适当的子目录。</p>
<p>共享状态包的有效性可以通过查看文件名来检测，因为文件名包含本节前面所述的任务校验和（或签名）。如果找到有效的共享状态包，构建过程将下载它并使用它来加速任务。</p>
<p>构建过程将*_setscene任务用于任务加速阶段。BitBake 在主要执行代码之前经历这个阶段，并尝试加速它可以找到共享状态包的任何任务。如果任务的共享状态包可用，则使用共享状态包。这意味着任务和它所依赖的任何任务都不会被执行。</p>
<p>作为一个真实世界的例子，目标是在构建基于 IPK 的图像时，只有 do_package_write_ipk 任务会获取和提取它们的共享状态包。由于没有使用 sysroot，它永远不会被提取。这是基于任务的方法优于基于配方的方法的另一个原因，后者必须安装每个任务的输出。</p>
<p>4.5.4哈希等价
上面的部分解释了 BitBake 如何跳过已经在共享状态缓存中找到输出的任务的执行。</p>
<p>在构建过程中，尽管任务的输入值发生了变化，但任务的输出/结果可能经常发生变化。一个示例可能是某些输入 C 代码中的空白更改。用项目术语来说，这就是我们定义为“等价”的东西。</p>
<p>为了跟踪这种等价性，BitBake 必须为每个任务管理三个哈希：</p>
<p>之前解释过的任务哈希：根据配方元数据、任务代码和来自其依赖项的任务哈希值计算。当进行更改时，这些任务哈希因此被修改，导致任务重新执行。因此，依赖于该任务的任务的任务哈希也被修改，导致整个依赖链重新执行。</p>
<p>输出哈希，从共享状态任务的输出计算的新哈希，任务将其结果输出保存到共享状态 tarball。将任务哈希和其输出散列之间的映射报告给新的哈希等价服务器。该映射由服务器存储在数据库中以供将来参考。</p>
<p>unihash是一个新的哈希，最初设置为任务的任务哈希。这用于跟踪任务输出的唯一性，我们将解释它的价值是如何保持的。</p>
<p>启用 Hash Equivalence 后，BitBake 使用其依赖项的 unihash 而非其任务哈希来计算每个任务的任务哈希。</p>
<p>现在，想象一下，由于其代码或元数据的变化，或由于其依赖项的变化，因此修改了共享状态任务。由于这会修改其任务哈希，因此此任务将需要重新执行。因此，它的输出哈希将再次计算。</p>
<p>然后，将报告新任务哈希和其输出散列之间的新映射到哈希等价服务器。服务器将让 BitBake 知道此输出哈希是否与先前报告的输出哈希相同，用于不同的任务哈希。</p>
<p>如果输出哈希已知，则Bitbake将更新任务的Unihash以匹配生成的原始任务哈希值。多亏了这一点，依赖任务将保留先前记录的任务哈希，BitBake 将能够从共享状态缓存中检索它们的输出，而不是重新执行它们。同样，进一步下游任务的输出也可以从 Shared Shate 中检索。</p>
<p>如果输出哈希未知，将在哈希等效服务器上创建一个新条目，将任务哈希与该输出匹配。根据更改，仍然具有新的任务哈希仍然需要重新执行任务，仍然需要重新执行。更改会传播到依赖的任务。</p>
<p>为了总结，当启用哈希等价时，比特班Run队列中的一个任务的更改不必传播到依赖于此任务的输出的所有下游任务，导致此类任务完全重建，因此继续下一个依赖任务。相反，当此任务的输出与之前记录的输出保持一致时，BitBake 可以安全地从共享状态缓存中检索所有下游任务输出。</p>
<p>笔记</p>
<p>拥有可重现的构建是任务输出哈希稳定性的关键因素。因此，Hash Equivalence 的有效性很大程度上取决于它。</p>
<p>这适用于多种场景：</p>
<p>对配方的“微不足道”更改不会影响其生成的输出，例如空格更改、对未使用代码路径的修改或变量排序。</p>
<p>共享库更新，例如修复安全漏洞。当然，应该重新构建使用这样一个库的程序，但它们的新二进制文件应该保持相同。由于它们的库依赖项的哈希值发生了变化，相应的任务应该具有不同的输出哈希值，但是由于它们的输出相同，哈希等效将停止沿依赖项链的传播。</p>
<p>本机工具更新。尽管应该重建依赖的任务，但它们很可能会生成相同的输出并被标记为等效。</p>
<p>这个机制在 Poky 中默认启用，由三个变量控制：</p>
<p>BB_HASHSERVE，指定要使用的本地或远程哈希等效服务器。</p>
<p>BB_HASHSERVE_UPSTREAM时，允许将本地服务器连接到上游服务器。BB_HASHSERVE = “auto”</p>
<p>BB_SIGNATURE_HANDLER，必须设置为OEEquivHash.</p>
<p>因此，Poky 中的默认配置对应如下设置：</p>
<p>BB_HASHSERVE = “auto”
BB_SIGNATURE_HANDLER = “OEEquivHash”
除了启动本地服务器，另一种可能性是依赖网络上的 Hash Equivalence 服务器，通过设置：</p>
<p>BB_HASHSERVE = “&lt;HOSTNAME&gt;:&lt;PORT&gt;”
笔记</p>
<p>共享哈希等价服务器需要与共享状态缓存一起维护。否则，服务器可能会报告仅存在于特定客户端上的共享状态哈希。</p>
<p>因此，我们建议将一个 Hash Equivalence 服务器设置为与给定的共享状态缓存对应，并以只读模式启动此服务器，这样它就不会存储客户端本地共享状态缓存的等效项。</p>
<p>有关启动 Hash Equivalence 服务器的详细信息，请参阅BB_HASHSERVE参考。</p>
<p>请参阅 Joshua Watt 在 ELC 2020 上的Hash Equivalence and Reproducible Builds演示视频， 以非常综合地介绍 Yocto 项目中的 Hash Equivalence 实现。</p>
<p>4.6自动添加运行时依赖
OpenEmbedded 构建系统会自动在包之间添加常见类型的运行时依赖项，这意味着您无需使用 RDEPENDS显式声明包。有三种自动机制（shlibdeps、pcdeps和depchains）分别处理共享库、包配置 (pkg-config) 模块 -dev和-dbg包。对于其他类型的运行时依赖项，您必须手动声明依赖项。</p>
<p>shlibdeps：在每个recipe的 do_package任务期间，recipe安装的所有共享库都被定位。对于每个共享库，包含共享库的包被注册为提供共享库。更具体地说，该包被注册为提供库的 soname。生成的共享库到包映射 由 do_packagedata 任务全局保存在PKGDATA_DIR中。</p>
<p>同时，检查配方安装的所有可执行文件和共享库，以查看它们链接的共享库。对于找到的每个共享库依赖项，查询PKGDATA_DIR以查看某个包（可能来自不同的配方）是否包含共享库。如果找到这样的包，则将运行时依赖项从依赖于共享库的包添加到包含该库的包中。</p>
<p>自动添加的运行时依赖项还包括版本限制。此版本限制指定至少必须使用提供共享库的包的当前版本，就好像“package (&gt;= version)”已添加到RDEPENDS中一样。如果需要，这会在安装依赖于库的包时强制升级包含共享库的包。</p>
<p>如果您想避免将包注册为提供特定共享库（例如，因为该库仅供内部使用），则将该库添加到 包配方中的PRIVATE_LIBS 。</p>
<p>pcdeps：在do_package每个recipe的任务期间，recipe安装的所有pkg-config模块（<a href="#id27"><span class="problematic" id="id28">*</span></a>.pc文件）都被定位。对于每个模块，包含该模块的包被注册为提供该模块。生成的模块到包映射由 任务全局保存在PKGDATA_DIR中。do_packagedata</p>
<p>同时，检查配方安装的所有 pkg​​-config 模块以查看它们依赖的其他 pkg-config 模块。如果一个模块包含指定另一个模块的“Requires:”行，则该模块被视为依赖于另一个模块。对于每个模块依赖项，查询PKGDATA_DIR以查看某个包是否包含该模块。如果找到这样的包，则将运行时依赖从依赖于该模块的包添加到包含该模块的包中。</p>
<p>笔记</p>
<p>pcdeps 机制最常推断 -dev 包之间的依赖关系。</p>
<p>depchains：如果一个包foo依赖于一个包bar，那么foo-dev和foo-dbg也分别依赖于 bar-dev和bar-dbg。以-dev 包为例，bar-dev包可能会提供所需的头文件和共享库符号链接foo-dev，这表明包之间需要依赖关系。</p>
<p>添加的依赖项采用RRECOMMENDSdepchains的形式 。</p>
<p>笔记</p>
<p>默认情况下，foo-dev还具有RDEPENDS样式的依赖 项foo，因为RDEPENDS:${PN}-dev（在 bitbake.conf 中设置）的默认值包括“${PN}”。</p>
<p>确保依赖链永远不会被破坏，-dev并且 -dbg总是默认生成包，即使包是空的。有关详细信息，请参阅 ALLOW_EMPTY变量。</p>
<p>该任务通过使用deptaskdo_package声明依赖于DEPENDSdo_packagedata中每个配方的任务 ，这保证了只要正确设置了 DEPENDS，所需的共享库/模块到包的映射信息将在需要时可用。[]</p>
<p>4.7假根和伪
当允许执行通常为 root 用户保留的某些操作（例如 do_install、 do_package_write*、 do_rootfs和 do_image*）时，某些任务更容易实现。例如，该do_install任务受益于能够将已安装文件的 UID 和 GID 设置为任意值。</p>
<p>允许任务执行仅限 root 操作的一种方法是要求BitBake以 root 身份运行。但是，这种方法比较麻烦并且存在安全问题。实际使用的方法是在“假”根环境中运行受益于根特权的任务。在此环境中，任务及其子进程认为它们以 root 用户身份运行，并看到文件系统的内部一致视图。只要生成最终输出（例如包或图像）不需要 root 权限，一些较早的步骤在假的 root 环境中运行这一事实不会导致问题。</p>
<p>在假根环境中运行任务的能力被称为“ fakeroot ”，它源自为任务请求假根环境的 BitBake 关键字/变量标志。</p>
<p>在OpenEmbedded Build System中，实现 fakeroot 的程序称为Pseudo。伪通过使用环境变量覆盖系统调用LD_PRELOAD，从而导致以 root 身份运行的错觉。为了跟踪需要 root 权限的操作产生的“虚假”文件所有权和权限，Pseudo 使用 SQLite 3 数据库。该数据库存储在 ${WORKDIR}/pseudo/files.db 中，用于各个配方。将数据库存储在文件中而不是内存中，可以在任务和构建之间提供持久性，而这不是使用 fakeroot 完成的。</p>
<p>笔记</p>
<p>如果您添加自己的任务来操作与 fakeroot 任务相同的文件或目录，那么该任务也需要在 fakeroot 下运行。否则，该任务无法运行仅限 root 的操作，并且无法看到其他任务设置的虚假文件所有权和权限。您还需要添加对 的依赖项 virtual/fakeroot-native:do_populate_sysroot，提供以下内容：</p>
<dl class="simple">
<dt>fakeroot do_mytask () {</dt><dd><p>…</p>
</dd>
</dl>
<p>}
do_mytask[depends] += “virtual/fakeroot-native:do_populate_sysroot”
有关详细信息，请参阅 FAKEROOT*变量。你也可以参考“ Why Not Fakeroot? ” 有关 Fakeroot 和 Pseudo 的背景信息的文章。</p>
</div>
</div>
<div class="section" id="youcto">
<h1>youcto项目参考手册<a class="headerlink" href="#youcto" title="Permalink to this headline">¶</a></h1>
<p>2 Yocto 项目条款
以下是 Yocto Project 开发环境的新用户可能会发现有用的术语和定义列表。虽然其中一些术语是通用的，但该列表包括它们以防万一：</p>
<p>附加文件
将构建信息附加到配方文件的文件。附加文件称为 BitBake 附加文件和.bbappend文件。OpenEmbedded 构建系统期望每个附加文件都有一个相应的配方 ( .bb) 文件。此外，附加文件和相应的配方文件必须使用相同的根文件名。文件名只能在使用的文件类型后缀上有所不同（例如formfactor_0.0.bb和 formfactor_0.0.bbappend）。</p>
<p>附加文件中的信息扩展或覆盖了类似名称的配方文件中的信息。有关正在使用的附加文件的示例，请参阅Yocto 项目开发任务手册中的“使用您的图层附加其他图层元数据”部分。</p>
<p>命名附加文件时，可以使用“ %”通配符来匹配配方名称。例如，假设您有一个名为如下的附加文件：</p>
<p>busybox_1.21.%.bbappend
该附加文件将匹配任何busybox_1.21.x.bb版本的配方。因此，附加文件将匹配以下任何配方名称：</p>
<p>busybox_1.21.1.bb
busybox_1.21.2.bb
busybox_1.21.3.bb
busybox_1.21.10.bb
busybox_1.21.25.bb
笔记</p>
<p>“%”字符的使用受到限制，因为它只能直接在附加文件名的 .bbappend 部分前面使用。您不能在名称的任何其他位置使用通配符。</p>
<p>BitBake
OpenEmbedded 构建系统用来构建镜像的任务执行器和调度器。有关 BitBake 的更多信息，请参阅BitBake 用户手册。</p>
<p>板级支持包 (BSP)
为特定硬件配置提供支持的一组驱动程序、定义和其他组件。有关 BSP 的更多信息，请参阅Yocto 项目板支持包开发人员指南。</p>
<p>构建目录
该术语是指 OpenEmbedded 构建系统用于构建的区域。source当您在源目录（即oe-init-build-env）中找到设置环境脚本时，将创建该区域。TOPDIR变量指向构建目录。</p>
<p>创建构建目录时，您有很大的灵活性。以下是显示如何创建目录的一些示例。这些示例假设您的源目录名为poky：</p>
<p>在您的源目录中创建构建目录，并让构建目录的名称默认为build：</p>
<p>$ cd poky
$ source oe-init-build-env
在您的主目录中创建构建目录并具体命名test-builds：</p>
<p>$ source poky/oe-init-build-env test-builds
提供目录路径并专门命名构建目录。路径名中的任何中间文件夹都必须存在。下一个示例创建一个 YP-26.0.2在现有目录中命名的构建目录mybuilds：</p>
<p>$ source poky/oe-init-build-env mybuilds/YP-26.0.2
笔记</p>
<p>默认情况下，构建目录包含TMPDIR，这是构建系统用于其工作的临时目录。TMPDIR不能在 NFS 下。因此，默认情况下，构建目录不能位于 NFS 下。但是，如果您需要构建目录位于 NFS 下，您可以通过在文件中设置TMPDIRlocal.conf来设置它以使用本地驱动器。这样做可以有效地将TMPDIR与TOPDIR（构建目录）分开。</p>
<p>构建主机
用于在 Yocto 项目开发环境中构建图像的系统。构建系统有时被称为开发主机。</p>
<p>课程
提供逻辑封装和继承的文件，以便可以定义一次常用模式，然后在多个配方中轻松使用。有关 Yocto Project 类的参考信息，请参阅“类”一章。类文件以 .bbclass文件扩展名结尾。</p>
<p>配置文件
保存全局变量定义、用户定义变量和硬件配置信息的文件。这些文件告诉 OpenEmbedded 构建系统要构建什么以及将什么放入映像中以支持特定平台。</p>
<p>配置文件以.conf文件扩展名结尾。构建目录中的 conf/local.conf配置文件 包含影响每个构建的用户定义变量。配置文件仅定义yocto“发行版”配置变量， 仅在使用此策略时使用。机器配置文件位于整个 源目录中，为特定硬件定义变量，并且仅在为该目标构建时使用（例如， 配置文件为德州仪器 ARM Cortex-A8 开发板定义变量）。meta-poky/conf/distro/poky.confmachine/beaglebone.conf</p>
<p>容器层
一个灵活的定义，通常指的是单个 Git 签出，其中包含多个（通常相关的）子层，这些子层可以独立地包含在您的项目bblayers.conf文件中。</p>
<p>在某些情况下，例如使用OpeneMbedded的 Meta-OpeneMbedded 图层，顶级meta-openembedded/目录本身并不是一个实际的图层，因此您永远不会在bblayers.conf文件中将其列入; 相反，您可以包含任意数量的层子目录，例如 meta-openembedded/meta-oe、 meta-openembedded/meta-python 等。</p>
<p>另一方面，一些容器层（例如 meta-security）有一个顶层目录，它本身就是一个实际层，以及各种子层，这两个层都可以包含在您的 bblayers.conf文件中。</p>
<p>在任何一种情况下，短语“容器层”仅用于描述包含多个有效 OpenEmbedded 层的目录结构。</p>
<p>交叉开发工具链
一般来说，交叉开发工具链是软件开发工具和实用程序的集合，它们在一个架构上运行，允许您为不同的或目标架构开发软件。这些工具链包含特定于目标架构的交叉编译器、链接器和调试器。</p>
<p>Yocto 项目支持两种不同的交叉开发工具链：</p>
<p>在为目标架构构建映像时，仅由 BitBake 使用和在其中使用的工具链。</p>
<p>开发人员在开发将在目标设备上运行的应用程序时在 Bi​​tBake 之外使用的可重定位工具链。</p>
<p>这些工具链的创建既简单又自动化。有关工具链概念的信息，它们适用于Yocto项目，请参阅Yocto项目概述和概念手册中的“跨开发工具链生成”部分。您还可以在Yocto 项目应用程序开发和可扩展软件开发工具包 (eSDK)手册中找到有关使用可重定位工具链的更多信息。</p>
<p>可扩展软件开发工具包 (eSDK)
为应用程序开发人员定制的 SDK。此 eSDK 允许开发人员将他们的库和编程更改合并回映像中，以使其他应用程序开发人员可以使用他们的代码。</p>
<p>有关 eSDK 的信息，请参阅Yocto 项目应用程序开发和可扩展软件开发工具包 (eSDK)手册。</p>
<p>图片
图像是给定配方和相关元数据的集合的 BitBake 构建过程的工件。图像是在特定硬件或 QEMU 上运行并用于特定用例的二进制输出。有关 Yocto 项目提供的受支持图像类型的列表，请参阅“图像”一章。</p>
<p>层
相关食谱的集合。层允许您整合相关的元数据来自定义您的构建。层还隔离了为多个架构构建时使用的信息。层在覆盖先前规范的能力方面是分层的。您可以包含来自 Yocto 项目的任意数量的可用层，并通过在它们之后添加层来自定义构建。您可以在图层索引中搜索 Yocto 项目中使用的图层。</p>
<p>有关层的介绍性信息，请参阅 Yocto 项目概述和概念手册中的“ Yocto 项目层模型”部分。有关层的更多详细信息，请参阅 Yocto 项目开发任务手册中的“理解和创建层”部分。有关 BSP 层的具体讨论，请参阅 Yocto 项目板支持包 (BSP) 开发人员指南中的“ BSP 层”部分。</p>
<p>元数据
Yocto 项目的一个关键元素是用于构建 Linux 发行版的元数据，它包含在OpenEmbedded 构建系统 在构建映像时解析的文件中。通常，元数据包括配方、配置文件和其他涉及构建指令本身的信息，以及用于控制构建内容和构建效果的数据。元数据还包括用于指示所使用的软件版本、从何处获得它们的命令和数据，以及用于修复错误或定制软件以用于软件本身的更改或添加（补丁或辅助文件）特定情况。OpenEmbedded-Core 是一组重要的经过验证的元数据。</p>
<p>在内核（“内核元数据”）的上下文中，该术语指的是 yocto-kernel-cache Git 存储库中包含的内核配置片段和功能。</p>
<p>OpenEmbedded-Core (OE-Core)
OE-Core 是由基础配方、类和相关文件组成的元数据，这些文件在许多不同的 OpenEmbedded 派生系统（包括 Yocto 项目）中通用。OE-Core 是由 OpenEmbedded 社区开发的原始存储库的精选子集，已被缩减为一个更小、核心的一组不断验证的配方。结果是一套严格控制且质量有保证的核心配方。</p>
<p>您可以在metaYocto Project Source Repositories的目录中看到元数据。</p>
<p>OpenEmbedded 构建系统
特定于 Yocto 项目的构建系统。OpenEmbedded 构建系统基于另一个名为“Poky”的项目，该项目使用BitBake作为任务执行器。在整个 Yocto Project 文档集中，OpenEmbedded 构建系统有时简称为“构建系统”。如果引用了其他构建系统，例如主机或目标构建系统，则文档清楚地说明了差异。</p>
<p>笔记</p>
<p>有关 Poky 的一些历史信息，请参阅Poky术语。</p>
<p>包裹
在 Yocto 项目的上下文中，该术语指的是由 BitBake 生成的配方的打包输出（即“烘焙配方”）。包通常是从配方源生成的编译二进制文件。你通过 BitBake 运行它来“烘焙”一些东西。</p>
<p>值得注意的是，“包”一词通常具有微妙的含义。例如，“构建主机所需的包”部分中提到的包是编译后的二进制文件，在安装时会为您的 Linux 发行版添加功能。</p>
<p>另一点值得注意的是，历史上在 Yocto 项目中，配方被称为包 - 因此，存在几个看似错误命名的 BitBake 变量（例如 PR、PV和 PE）。</p>
<p>包组
任意组的软件配方。您使用包组来保存配方，这些配方在构建时通常会完成一项任务。例如，软件包组可能包含公司专有或增值软件的配方。或者，包组可以包含启用图形的配方。一个包组实际上只是另一个配方。因为包组文件是配方，所以它们以.bb文件扩展名结尾。</p>
<p>小精灵
Poky，发音为 Pock -ee，是一个参考嵌入式发行版和参考测试配置。Poky 提供以下功能：</p>
<p>用于说明如何自定义发行版的基本功能发行版。</p>
<p>一种测试 Yocto 项目组件的方法（即 Poky 用于验证 Yocto 项目）。</p>
<p>您可以通过它下载 Yocto 项目的车辆。</p>
<p>Poky 不是产品级发行版。相反，这是一个很好的定制起点。</p>
<p>笔记</p>
<p>Poky 最初是由 OpenedHand 开发的一个开源项目。OpenedHand 从现有的 OpenEmbedded 构建系统开发了 Poky，为嵌入式 Linux 创建了商业上可支持的构建系统。英特尔公司收购 OpenedHand 后，poky 项目成为 Yocto 项目构建系统的基础。</p>
<p>食谱
一组用于构建包的说明。配方描述了您从哪里获得源代码、应用哪些补丁、如何配置源代码、如何编译它等等。配方还描述了库或其他配方的依赖关系。配方代表执行的逻辑单元、要构建的软件、要构建的图像以及使用.bb文件扩展名。</p>
<p>参考套件
系统的工作示例，包括 BSP以及 构建主机和其他组件，可以在特定硬件上运行。</p>
<p>源目录
该术语指的是由于创建pokyGit 存储库的本地副本git://git.yoctoproject.org/poky或扩展已发布的pokytarball 而创建的目录结构。</p>
<p>笔记</p>
<p>创建 poky Git 存储库的本地副本是设置源目录的推荐方法。</p>
<p>有时您可能会听到用于指代此目录结构的术语“poky 目录”。</p>
<p>笔记</p>
<p>OpenEmbedded 构建系统不支持包含空格的文件或目录名称。确保您使用的源目录不包含这些类型的名称。</p>
<p>源目录包含所有支持 Yocto 项目的 BitBake、文档、元数据和其他文件。因此，为了使用 Yocto 项目进行任何开发，您必须在开发系统上安装源目录。</p>
<p>当您创建 Git 存储库的本地副本时，您可以将存储库命名为您喜欢的任何名称。在大部分文档中，“poky”被用作 poky Git 存储库本地副本的顶级文件夹的名称。因此，例如，克隆pokyGit 存储库会生成一个本地 Git 存储库，其顶级文件夹也名为“poky”。</p>
<p>虽然不建议您使用 tarball 扩展来设置 Source Directory，但如果您这样做，Source Directory 的顶级目录名称来自 Yocto Project 发布 tarball。例如，下载并解压 <a class="reference external" href="https://downloads.yoctoproject.org/releases/yocto/yocto-3.4.2/poky-honister-26.0.2.tar.bz2">https://downloads.yoctoproject.org/releases/yocto/yocto-3.4.2/poky-honister-26.0.2.tar.bz2</a> 会生成一个根文件夹名为 的源目录 poky-honister-26.0.2。</p>
<p>了解通过解压已发布的 tarball 创建的源目录与克隆创建的源目录之间的差异非常重要git://git.yoctoproject.org/poky。当您解压缩 tarball 时，您将拥有基于发布时间的文件的精确副本 - 一个固定的发布点。您对源目录中的本地文件所做的任何更改都在发布之上，并且将仅保留在本地。另一方面，当您克隆pokyGit 存储库时，您将拥有一个活动的开发存储库，可以访问上游存储库的分支和标签。在这种情况下，您对本地源目录所做的任何本地更改都可以稍后应用于上游pokyGit 存储库的活动开发分支。</p>
<p>有关与 Git 存储库、分支和标签相关的概念的更多信息，请参阅 Yocto 项目概述和概念手册中的“存储库、标签和分支”部分。</p>
<p>任务
BitBake 的每个配方执行单元（例如 do_compile、 do_fetch、 do_patch等）。构建系统的主要好处之一是，由于每个配方通常会产生大量任务的执行，因此许多任务完全有可能并行执行，无论是来自不同配方的任务还是同一配方中的独立任务，可能取决于构建系统的并行度。</p>
<p>烤面包机
Yocto 项目的OpenEmbedded 构建系统的 Web 界面。该界面使您能够配置和运行您的构建。有关构建的信息被收集并存储在数据库中。有关烤面包机的信息，请参阅 烤面包机用户手册。</p>
<p>上游
对不在开发系统本地但位于由源代码维护者控制的远程区域的源代码或存储库的引用。例如，为了让开发人员处理一段特定的代码，他们需要首先从“上游”源获取它的副本。</p>
<p>3 yocto项目发布和稳定的发布过程
Yocto Project 发布过程是可预测的，包括主要和次要（点）版本。这一简短的章节提供了有关如何命名版本、它们的生命周期和它们的稳定性的信息。</p>
<p>3.1主要和次要发布节奏
Yocto 项目使用大约每年四月和十月的六个月节奏发布主要版本（例如 3.4.2）。以下是一些主要 YP 版本的示例，其中还显示了它们的代号。有关与主要版本一起使用的代号的信息，请参阅“主要版本代号”部分。</p>
<p>2.2（莫蒂）</p>
<p>2.1（克罗格斯）</p>
<p>2.0（杰思罗）</p>
<p>虽然Cadyence永远不会完美，但这种时间尺度促进了具有强大的QA周期的常规版本，而不是压倒性的新版本。节奏是可预测的，避免了不同地区的许多主要假期。</p>
<p>Yocto 项目不定期地交付次要（点）版本，通常是由对相关主要版本的足够重要修复或增强的积累驱动的。以下是过去发布的一些示例：</p>
<p>2.1.1</p>
<p>2.1.2</p>
<p>2.2.1</p>
<p>点发布表示主要发布分支中的一个点，其中完整的 QA 周期和发布过程验证新分支的内容。</p>
<p>笔记</p>
<p>意识到当补丁可用时，可以将补丁合并到稳定版本分支上。</p>
<p>3.2主要版本代号
每个主要版本都会收到一个代号，用于标识Yocto Project Source Repositories中的版本。这个概念是具有相同代号的元数据分支可能是兼容的，因此可以一起工作。</p>
<p>笔记</p>
<p>代号与主要版本相关联，因为 Yocto Project 版本号（例如 3.4.2）可能与给定层或公司版本控制方案冲突。代号独特、有趣且易于识别。</p>
<p>发行版也被赋予了名义发行版，但出于这个原因在存储库中使用了代号。您可以在https://wiki.yoctoproject.org/wiki/Releases找到有关 Yocto 项目版本和代号的信息。</p>
<p>我们的发布信息详细说明了如何从 Yocto 项目的一个版本迁移到下一个版本。</p>
<p>3.3稳定发布流程
一旦发布，该版本进入稳定发布过程，此时一个人被指定为该稳定版本的维护者。该维护者通过调查和处理指定的补丁和反向移植活动来监控发布活动。只有首先应用于“主”分支（即当前的开发中分支）的修复和增强功能才会考虑向后移植到稳定版本。</p>
<p>笔记</p>
<p>当前有关向后移植的 Yocto 项目政策仅考虑错误修复和安全修复。政策规定功能不向后移植到稳定版本。此政策意味着通用配方版本升级不太可能被接受用于向后移植。当有一个强有力的原因（例如修复恰好也是首选的上游方法）时，会出现此策略的例外情况。</p>
<p>稳定发布分支在首次发布后大约一年的时间里进行强大的维护。如果发现任何版本的重大问题，无论其年龄如何，都可以将修复程序向后移植到旧版本。对于旧版本未向后移植的问题，社区 LTS 树和分支允许社区成员共享旧版本的补丁。但是，这些类型的补丁程序与单点发行版的发行过程不同。您可以在https://wiki.yoctoproject.org/wiki/Stable_branch_maintenance找到有关稳定分支维护的更多信息 。</p>
<p>3.4测试和质量保证
Yocto Project 开发和发布过程的一部分是通过执行测试策略来保证质量。测试策略为 Yocto 项目团队提供了一种确保发布得到验证的方法。此外，由于您作为开发人员可以看到测试策略，因此您可以验证您的项目。本节概述了 Yocto 项目中使用的可用测试基础设施。有关如何在项目上运行可用测试的信息，请参阅 Yocto 项目开发任务手册中的“执行自动化运行时测试”部分。</p>
<p>QA/测试基础设施被编织到项目中，以至于核心开发人员认为其中一些是理所当然的。基础设施由以下部分组成：</p>
<p>bitbake-selftest：一个独立的命令，对 BitBake 的关键部分及其提取器运行单元测试。</p>
<p>sanity.bbclass：这个自动包含的类检查构建环境是否缺少工具（例如 gcc）或常见的错误配置，例如 MACHINE设置不正确。</p>
<p>insane.bbclass：这个类检查生成的输出是否健全。例如，如果为 ARM 目标构建，构建是否会生成 ARM 二进制文件。例如，如果构建生成了 PPC 二进制文件，那么就会出现问题。</p>
<p>testimage*.bbclass：此类在构建图像后执行图像的运行时测试。这些测试通常与QEMU一起使用 来启动映像并检查组合的运行时结果启动操作和功能。但是，测试也可以使用机器的IP地址来测试。</p>
<p>ptest：针对给定软件的构建过程中生成的包运行测试。该测试允许包在目标映像中运行。</p>
<p>oe-selftest：测试组合 BitBake 调用。这些测试在 OpenEmbedded 构建系统本身之外运行。默认情况下 oe-selftest可以运行所有测试，也可以运行选定的测试或测试套件。</p>
<p>笔记</p>
<p>运行oe-selftest需要超出“基本”分组的主机包。有关详细信息，请参阅构建主机所需的包 部分。</p>
<p>最初，大部分测试都是手动完成的。然而，为了让更多的人可以使用它们，并且 Yocto Project 开发团队可以更快、更有效地运行它们，我们已经付出了巨大的努力来自动化测试。</p>
<p>Yocto 项目的主要 Autobuilder ( <a class="reference external" href="https://autobuilder.yoctoproject.org">https://autobuilder.yoctoproject.org</a> ) 公开测试 OpenEmbedded-Core (OE-Core)、Poky 和 ​​BitBake 存储库中的每个 Yocto 项目版本的代码。对“master”分支的当前状态和提交的补丁都进行测试。对提交的补丁的测试通常发生在poky-contrib存储库中的“ross/mut”分支（即 master-under-test 分支）或poky 存储库中的“master-next”分支中。</p>
<p>笔记</p>
<p>您可以在Yocto Project Source Repositories中找到所有这些分支 。</p>
<p>在这些公共分支中进行测试以公开可见的方式确保 OE-Core 中的所有主要假定架构和配方成功构建并正常运行。</p>
<p>各种功能，例如multilib，子架构（例如x32，，， 等等）， poky-tiny和作为发布的 QA 过程的一部分进行测试。Autobuilder 工作人员需要几个小时才能完成发布的测试和验证。muslno-x11bitbake-selftestoe-selftest</p>
<p>笔记</p>
<p>Autobuilder 工作人员是非同质的，这意味着会定期对各种 Linux 发行版进行测试。Autobuilder 仅限于测试基于 QEMU 的设置，而不是真正的硬件。</p>
<p>最后，除了 Autobuilder 的测试之外，Yocto Project QA 团队还在包括实际硬件在内的各种平台上进行测试，以确保获得预期的结果。</p>
<p>4源目录结构
源目录由许多文件、目录和子目录组成；了解它们的位置和内容是有效使用 Yocto 项目的关键。本章介绍源目录并提供有关这些文件和目录的信息。</p>
<p>有关如何在您的开发系统上建立本地源目录的信息，请参阅 Yocto 项目开发任务手册中的“定位 Yocto 项目源文件”部分。</p>
<p>笔记</p>
<p>OpenEmbedded 构建系统不支持包含空格的文件或目录名称。确保您使用的源目录不包含这些类型的名称。</p>
<p>4.1顶层核心组件
本节介绍Source Directory的顶级组件。</p>
<p>4.1.1bitbake/
该目录包含一个 BitBake 的副本以方便使用。该副本通常与 BitBake 项目中当前稳定的 BitBake 版本相匹配。元数据解释器BitBake读取 Yocto 项目元数据并运行由该数据定义的任务。失败通常是由元数据中的错误引起的，而不是由 BitBake 本身引起的。</p>
<p>当您运行该bitbake命令时，主 BitBake 可执行文件（位于bitbake/bin/目录中）将启动。获取环境设置脚本（即oe-init-build-env）会将scripts/和bitbake/bin/目录（按此顺序）放入 shell 的PATH环境变量中。</p>
<p>有关 BitBake 的更多信息，请参阅BitBake 用户手册。</p>
<p>4.1.2build/
此目录包含用户配置文件和 OpenEmbedded 构建系统在其标准配置中生成的输出，其中源树与输出相结合。构建目录 最初是在您source 使用 OpenEmbedded 构建环境设置脚本（即 oe-init-build-env）时创建的。</p>
<p>通过在设置脚本时提供目录名称，也可以将输出和配置文件放置在与源目录不同的目录中。source有关从本地源目录文件（通常描述为“树外”构建）分离输出的信息，请参阅“ oe-init-build-env ”部分。</p>
<p>4.1.3documentation/
该目录包含 Yocto Project 文档的源代码以及允许您生成手册的 PDF 和 HTML 版本的模板和工具。每本手册都包含在其自己的子文件夹中；例如，本参考手册的文件位于该 ref-manual/目录中。</p>
<p>4.1.4meta/
此目录包含最小的底层 OpenEmbedded-Core 元数据。qemux86该目录包含严格模拟目标（ 、、qemuarm等等）的配方、通用类和机器配置。</p>
<p>4.1.5meta-poky/
设计在meta/内容之上，这个目录添加了足够的元数据来定义 Poky 参考分布。</p>
<p>4.1.6meta-yocto-bsp/
此目录包含 Yocto 项目参考硬件板支持包 (BSP)。有关 BSP 的更多信息，请参阅 Yocto 项目板支持包开发人员指南。</p>
<p>4.1.7meta-selftest/
此目录添加 OpenEmbedded 自测使用的附加配方和附加文件，以验证构建系统的行为。bblayers.conf除非您想运行自测，否则您不必将此层添加到您的文件中。</p>
<p>4.1.8meta-skeleton/
此目录包含 BSP 和内核开发的模板配方。</p>
<p>4.1.9scripts/
该目录包含在 Yocto 项目环境中实现额外功能的各种集成脚本（例如 QEMU 脚本）。oe-init-build-env脚本将此目录添加到 shell 的环境 PATH变量中。</p>
<p>该scripts目录包含有助于回馈 Yocto 项目的有用脚本，例如create-pull-request和 send-pull-request.</p>
<p>4.1.10oe-init-build-env
此脚本设置 OpenEmbedded 构建环境。在 shell 中使用命令运行此脚本会 根据当前工作目录source更改和设置其他核心 BitBake 变量。PATH在运行 BitBake 命令之前，您需要运行环境设置脚本。该脚本使用scripts 目录中的其他脚本来完成大部分工作。</p>
<p>当你运行这个脚本时，你的 Yocto 项目环境就设置好了，一个 构建目录被创建，你的工作目录变成了构建目录，你会看到一些关于下一步做什么的简单建议，包括一些可能的目标列表建造。这是一个例子：</p>
<p>$ source oe-init-build-env</p>
<p>### Shell environment set up for builds. ###</p>
<p>You can now run ‘bitbake &lt;target&gt;’</p>
<dl class="simple">
<dt>Common targets are:</dt><dd><p>core-image-minimal
core-image-sato
meta-toolchain
meta-ide-support</p>
</dd>
</dl>
<p>You can also run generated QEMU images with a command like ‘runqemu qemux86-64’
oe-init-build-env脚本 的默认输出来自conf-notes.txt文件，该文件meta-poky位于Source Directory的目录中。如果您设计自定义发行版，则可以包含您自己的此配置文件版本，以提及您的发行版定义的目标。有关详细信息，请参阅 Yocto 项目开发任务手册中的“创建自定义模板配置目录”部分。</p>
<p>默认情况下，在没有 Build Directory 参数的情况下运行此脚本会build/在您当前的工作目录中创建目录。如果您source在编写脚本时提供了 Build Directory 参数，则指示 OpenEmbedded 构建系统创建您选择的 Build Directory。例如，以下命令创建一个名为Source Directorymybuilds/的构建目录：</p>
<p>$ source oe-init-build-env ~/mybuilds
OpenEmbedded 构建系统使用模板配置文件，这些文件默认位于meta-poky/conf/Source Directory 的目录中。有关详细信息，请参阅 Yocto 项目开发任务手册中的“创建自定义模板配置目录”部分。</p>
<p>笔记</p>
<p>OpenEmbedded 构建系统不支持包含空格的文件或目录名称。如果您尝试oe-init-build-env 从文件名或目录名中包含空格的源目录运行脚本，则脚本会返回错误，指示没有此类文件或目录。请务必使用名称中不含空格的源目录。</p>
<p>4.1.11LICENSE, README, and README.hardware
这些文件是标准的顶级文件。</p>
<p>4.2构建目录 -build/
当您运行构建环境设置脚本oe-init-build-env时，OpenEmbedded 构建系统会创建构建目录。如果您在运行设置脚本时没有为构建目录指定特定名称，则名称默认为.build/</p>
<p>对于后续的解析和处理，构建目录的名称可通过TOPDIR变量获得。</p>
<p>4.2.1build/buildhistory/
当您通过buildhistory类文件启用构建历史时，OpenEmbedded 构建系统会创建此目录。该目录将构建信息组织到映像、包和 SDK 子目录中。有关构建历史功能的信息，请参阅 Yocto 项目开发任务手册中的“维护构建输出质量”部分。</p>
<p>4.2.2build/conf/local.conf
此配置文件包含构建环境的所有本地用户配置。该local.conf文件包含有关各种配置选项的文档。此处设置的任何变量都会覆盖环境中其他地方设置的任何变量，除非该变量在文件中被硬编码（例如，使用’=’ 而不是’?=’）。一些变量因各种原因被硬编码，但此类变量相对较少。</p>
<p>至少，您通常会编辑此文件以选择目标 MACHINE、您希望使用的包类型 ( PACKAGE_CLASSES ) 以及您要访问下载文件的位置 ( DL_DIR )。</p>
<p>如果local.conf在您开始构建时不存在，则 OpenEmbedded 构建系统会local.conf.sample在您 source使用顶级构建环境设置脚本 oe-init-build-env时创建它。</p>
<p>使用的源local.conf.sample文件取决于 script 变量， 当您从 Yocto Project 开发环境构建时$TEMPLATECONF，默认为该变量，以及您从 OpenEmbedded-Core 环境构建时。因为脚本变量指向 文件的源，这意味着您可以通过在顶级构建环境设置脚本中设置变量来从任何层配置构建环境，如下所示：meta-poky/conf/meta/conf/local.conf.sample</p>
<p>TEMPLATECONF=your_layer/conf
一旦构建过程获得示例文件，它就会使用sed最终 的${OEROOT}值替换所有 ##OEROOT##值。</p>
<p>笔记</p>
<p>您可以通过查看Source Directory中的脚本来了解如何TEMPLATECONF使用该变量 。您可以在目录中找到该文件的 Yocto Project 版本。scripts/oe-setup-builddirlocal.conf.samplemeta-poky/conf</p>
<p>4.2.3build/conf/bblayers.conf
此配置文件定义了 层，它们是目录树，由 BitBake 遍历（或遍历）。该 bblayers.conf文件使用BBLAYERS 变量列出 BitBake 尝试查找的层。</p>
<p>如果bblayers.conf在您开始构建时不存在，则 OpenEmbedded 构建系统会bblayers.conf.sample在您source使用顶级构建环境设置脚本（即 oe-init-build-env）时创建它。</p>
<p>与local.conf文件一样，使用的源bblayers.conf.sample 文件取决于$TEMPLATECONF脚本变量，默认为meta-poky/conf/您从 Yocto Project 开发环境meta/conf/构建时以及从 OpenEmbedded-Core 环境构建时。因为脚本变量指向bblayers.conf.sample文件的源，这意味着您可以通过在顶级构建环境设置脚本中设置变量来从任何层构建构建，如下所示：</p>
<p>TEMPLATECONF=your_layer/conf
一旦构建过程获得示例文件，它就会使用sed最终 的${OEROOT}值替换所有##OEROOT##值。</p>
<p>笔记</p>
<p>您可以在Source Directory中查看TEMPLATECONF变量scripts/oe-setup-builddir 脚本。您可以在目录中找到该文件的 Yocto Project 版本 。bblayers.conf.samplemeta-poky/conf/</p>
<p>4.2.4build/cache/sanity_info
此文件指示健全性检查的状态，并在构建期间创建。</p>
<p>4.2.5build/downloads/
此目录包含下载的上游源代码压缩包。您可以将目录重复用于多个构建或将目录移动到另一个位置。您可以通过DL_DIR变量控制此目录的位置 。</p>
<p>4.2.6build/sstate-cache/
此目录包含共享状态缓存。您可以将目录重复用于多个构建或将目录移动到另一个位置。您可以通过SSTATE_DIR变量控制此目录的位置 。</p>
<p>4.2.7build/tmp/
OpenEmbedded 构建系统为所有构建系统的输出创建并使用此目录。TMPDIR变量指向该目录。</p>
<p>如果该目录不存在，BitBake 会创建它。作为最后的手段，要清理构建并从头开始（除了下载），您可以删除tmp目录中的所有内容或完全摆脱目录。如果这样做，您还应该完全删除该build/sstate-cache目录。</p>
<p>4.2.8build/tmp/buildstats/
此目录存储构建统计信息。</p>
<p>4.2.9build/tmp/cache/
当 BitBake 解析元数据（配方和配置文件）时，它会缓存结果build/tmp/cache/以加速未来的构建。结果存储在每台机器的基础上。</p>
<p>在后续构建期间，BitBake 检查每个配方（例如，连同包含或附加到其中的任何文件）以查看它们是否已被修改。例如，可以通过文件修改时间 (mtime) 更改和文件内容的散列来检测更改。如果未检测到对文件的更改，则重用存储在缓存中的解析结果。如果文件已更改，则重新解析。</p>
<p>4.2.10build/tmp/deploy/
该目录包含来自 OpenEmbedded 构建过程的任何“最终结果”输出。DEPLOY_DIR变量指向这个目录。有关deploy 目录内容的更多详细信息，请参阅 Yocto 项目概述和概念手册中的“图像”和“应用程序开发 SDK ”部分。</p>
<p>4.2.11build/tmp/deploy/deb/
该目录接收.deb构建过程生成的任何包。这些包被分类为不同架构类型的提要。</p>
<p>4.2.12build/tmp/deploy/rpm/
该目录接收.rpm构建过程生成的任何包。这些包被分类为不同架构类型的提要。</p>
<p>4.2.13build/tmp/deploy/ipk/
该目录接收.ipk构建过程生成的包。</p>
<p>4.2.14build/tmp/deploy/licenses/
此目录接收软件包许可信息。例如，该目录包含 、 和（以及其他）的子目录，这些子目录bash又busybox包含 glibc具有COPYING 其他许可信息的适当许可文件。有关许可的信息，请参阅Yocto 项目开发任务手册中的“在产品生命周期内保持开源许可合规性”部分。</p>
<p>4.2.15build/tmp/deploy/images/
该目录包含构建的基本输出对象（将它们视为构建过程的“生成的工件”），包括引导加载程序映像、内核、根文件系统等。如果您想将生成的映像从构建中闪存到设备上，请在此处查找必要的组件。</p>
<p>删除此目录中的文件时要小心。您可以安全地从此目录中删除旧图像（例如core-image-<em>）。但是，内核（*zImage</em>、<a href="#id29"><span class="problematic" id="id30">*</span></a>uImage*等）、引导加载程序和其他补充文件可能会在构建映像之前部署在此处。因为这些文件不是直接从镜像生成的，所以如果您删除它们，当您再次构建镜像时，它们不会自动重新创建。</p>
<p>如果您不小心删除了此处的文件，则需要强制重新创建它们。为此，您需要知道产生它们的目标。例如，这些命令重建并重新创建内核文件：</p>
<p>$ bitbake -c clean virtual/kernel
$ bitbake virtual/kernel
4.2.16build/tmp/deploy/sdk/
OpenEmbedded 构建系统会创建此目录来保存工具链安装程序脚本，这些脚本在执行时会安装与您的目标硬件匹配的 sysroot。您可以在 Yocto 项目应用程序开发和可扩展软件开发工具包 (eSDK) 手册中的“构建 SDK 安装程序”部分中找到有关这些安装程序的更多信息。</p>
<p>4.2.17build/tmp/sstate-control/
OpenEmbedded 构建系统将此目录用于共享状态清单文件。共享状态代码使用这些文件来记录每个 sstate 任务安装的文件，以便在清理配方或即将安装更新版本时删除这些文件。当一个任务的文件覆盖另一个任务的文件时，构建系统还使用清单来检测并产生警告。</p>
<p>4.2.18build/tmp/sysroots-components/
此目录是任务 do_prepare_recipe_sysroot 链接或复制到 DEPENDS 中列出的每个配方的特定于配方的sysroot 的sysroot内容的位置。此目录的填充是通过共享状态处理的，而路径由 COMPONENTS_DIR变量指定。除了一些不寻常的情况外，sysroots-components目录的处理应该是自动的，菜谱不应该直接引用 build/tmp/sysroots-components.</p>
<p>4.2.19build/tmp/sysroots/
以前版本的 OpenEmbedded 构建系统用于为每台机器创建一个全局共享 sysroot 以及本机 sysroot。从 Yocto 项目的 2.3 版本开始，在特定于配方的WORKDIR目录中有 sysroots。因此，该 build/tmp/sysroots/目录未被使用。</p>
<p>笔记</p>
<p>该build/tmp/sysroots/目录仍然可以使用 命令填充，并且在某些情况下可用于兼容性。但是，通常不建议填充此目录。应使用单个特定于配方的 sysroot。bitbake build-sysroots</p>
<p>4.2.20build/tmp/stamps/
此目录包含 BitBake 用于记帐目的的信息，以跟踪哪些任务已运行以及何时运行。该目录按体系结构、包名称和版本进行细分。下面是一个例子：</p>
<p>stamps/all-poky-linux/distcc-config/1.0-r0.do_build-2fdd….2do
尽管目录中的文件没有数据，但 BitBake 使用文件名和时间戳进行跟踪。</p>
<p>有关 BitBake 如何使用标记文件来确定是否应重新运行任务的信息，请参阅 Yocto 项目概述和概念手册中的“标记文件和任务的重新运行”部分。</p>
<p>4.2.21build/tmp/log/
此目录包含未使用包的WORKDIR放置的常规日志。日志的示例是 do_check_pkg或do_distro_check任务的输出。运行构建并不一定意味着创建了这个目录。</p>
<p>4.2.22build/tmp/work/
此目录包含由 BitBake 构建的包的特定于体系结构的工作子目录。所有任务都从相应的工作目录执行。例如，特定包的源代码在其自己的工作目录中进行解包、修补、配置和编译。在工作目录中，组织基于 WORKDIR定义的源代码正在编译的包组和版本。</p>
<p>值得考虑典型工作目录的结构。例如，考虑在 Yocto 项目中构建linux-yocto-kernel-3.0的机器。qemux86对于这个包，创建了一个 tmp/work/qemux86-poky-linux/linux-yocto/3.0+git1+&lt;…..&gt;称为WORKDIR的工作目录。在此目录中，源被解压缩到linux-qemux86-standard-buildQuilt，然后由 Quilt 修补。（有关详细信息，请参阅Yocto 项目开发任务手册中的“在工作流程中使用 Quilt ”部分。）在linux-qemux86-standard-build目录中，创建了标准 Quilt 目录，linux-3.0/patches并且linux-3.0/.pc可以使用标准 Quilt 命令。</p>
<p>WORKDIR中还生成了其他目录。最重要的目录是WORKDIR/temp/，其中包含每个任务的日志文件 ( log.do_*.pid) 并包含 BitBake 为每个任务运行的脚本 ( run.do_*.pid)。该WORKDIR/image/目录是“make install”放置其输出的位置，然后将其拆分为 WORKDIR/packages-split/.</p>
<p>4.2.23build/tmp/work/tunearch/recipename/version/
配方工作目录 - ${WORKDIR}.</p>
<p>如前面“ build/tmp/sysroots/ ”部分所述，从 Yocto 项目的 2.3 版本开始，OpenEmbedded 构建系统在其自己的工作目录（即 WORKDIR）中构建每个配方。工作目录的路径是使用给定构建的体系结构（例如 TUNE_PKGARCH、MACHINE_ARCH或“allarch”）、配方名称和配方版本（即 PE :PV -PR）构建的。</p>
<p>以下是每个配方工作目录中的关键子目录：</p>
<p>${WORKDIR}/temp：包含为此配方执行的每个任务的日志文件，每个已执行任务的“运行”文件，其中包含代码运行，以及一个log.task_order列出任务执行顺序的文件。</p>
<p>${WORKDIR}/image: 包含 do_install任务的输出，对应于该任务中的${D}变量。</p>
<p>${WORKDIR}/pseudo：包含伪数据库和在伪配方下执行的任何任务的日志。</p>
<p>${WORKDIR}/sysroot-destdir：包含 do_populate_sysroot任务的输出。</p>
<p>${WORKDIR}/package: 包含 do_package任务在输出被拆分为单个包之前的输出。</p>
<p>${WORKDIR}/packages-split：包含输出 do_package被拆分为单独的包后的任务输出。配方创建的每个单独的包都有子目录。</p>
<p>${WORKDIR}/recipe-sysroot：一个目录，其中填充了配方的目标依赖项。这个目录看起来像目标文件系统，并包含配方可能需要链接的库（例如 C 库）。</p>
<p>${WORKDIR}/recipe-sysroot-native：一个目录，其中填充了配方的本机依赖项。该目录包含配方需要构建的工具（例如编译器、Autoconf、libtool 等）。</p>
<p>${WORKDIR}/build：此子目录仅适用于支持源与构建工件分开的构建的配方。OpenEmbedded 构建系统将此目录用作单独的构建目录（即${B}）。</p>
<p>4.2.24build/tmp/work-shared/
为了提高效率，OpenEmbedded 构建系统创建并使用此目录来保存与其他配方共享工作目录的配方。在实践中，这仅用于gcc及其变体（例如gcc-cross、libgcc、gcc-runtime等）。</p>
<p>4.3元数据 -meta/
如前所述，元数据是 Yocto 项目的核心。元数据有几个重要的细分：</p>
<p>4.3.1meta/classes/
此目录包含*.bbclass文件。类文件用于抽象公共代码，因此它可以被多个包重用。每个包都继承base.bbclass文件。其他重要类的示例是autotools*.bbclass，理论上它允许任何启用 Autotool 的包以最小的努力与 Yocto 项目一起工作。另一个例子是kernel.bbclass，它包含用于使用 Linux 内核的通用代码和函数。图像生成或打包等功能也有其特定的类文件，例如 image.bbclass、rootfs*.bbclass和 package*.bbclass。</p>
<p>有关类的参考信息，请参阅“类”一章。</p>
<p>4.3.2meta/conf/
此目录包含核心配置文件集，bitbake.conf所有其他配置文件都包含在这些配置文件中。查看文件末尾的 include 语句，bitbake.conf 您会注意到 evenlocal.conf是从那里加载的。在bitbake.conf设置默认值时，您通常可以使用 ( local.conf) 文件、机器文件或分发配置文件来覆盖它们。</p>
<p>4.3.3meta/conf/machine/
该目录包含所有机器配置文件。如果设置 ，则 OpenEmbedded 构建系统 会在此目录中查找文件。该目录包含多台机器共有的各种数据。如果您想为 Yocto 项目添加对新机器的支持，请查看此目录。MACHINE = “qemux86”qemux86.confinclude</p>
<p>4.3.4meta/conf/distro/
此目录的内容控制任何特定于发行版的配置。对于 Yocto 项目，defaultsetup.conf这里是主文件。此目录包括此处配置的应用程序的版本和SRCDATE 定义。替代配置的一个示例可能是poky-bleeding.conf. 虽然这个文件主要是从 Poky 继承了它的配置。</p>
<p>4.3.5meta/conf/machine-sdk/
OpenEmbedded 构建系统在该目录中搜索与SDKMACHINE的值对应的配置文件 。默认情况下，支持某些 SDK 主机的 Yocto 项目附带 32 位和 64 位 x86 文件。但是，可以通过在另一层的此子目录中添加额外的配置文件来将该支持扩展到其他 SDK 主机。</p>
<p>4.3.6meta/files/
此目录包含构建系统使用的通用许可证文件和几个文本文件。文本文件包含最少的设备信息以及具有已知权限的文件和目录列表。</p>
<p>4.3.7meta/lib/
此目录包含构建过程中使用的 OpenEmbedded Python 库代码。</p>
<p>4.3.8meta/recipes-bsp/
此目录包含链接到特定硬件或硬件配置信息的任何内容，例如“u-boot”和“grub”。</p>
<p>4.3.9meta/recipes-connectivity/
此目录包含与与其他设备通信相关的库和应用程序。</p>
<p>4.3.10meta/recipes-core/
此目录包含构建基本工作 Linux 映像所需的内容，包括常用的依赖项。</p>
<p>4.3.11meta/recipes-devtools/
此目录包含主要由构建系统使用的工具。但是，这些工具也可以用于目标。</p>
<p>4.3.12meta/recipes-extended/
此目录包含与核心中的替代方案相比添加功能的非必要应用程序。您可能需要此目录来获得完整的工具功能。</p>
<p>4.3.13meta/recipes-gnome/
该目录包含与 GTK+ 应用程序框架相关的所有内容。</p>
<p>4.3.14meta/recipes-graphics/
该目录包含 X 和其他图形相关的系统库。</p>
<p>4.3.15meta/recipes-kernel/
此目录包含具有强内核依赖性的内核和通用应用程序和库。</p>
<p>4.3.16meta/recipes-multimedia/
此目录包含音频、图像和视频的编解码器和支持实用程序。</p>
<p>4.3.17meta/recipes-rt/
PREEMPT_RT此目录包含用于使用和测试内核的包和映像配方。</p>
<p>4.3.18meta/recipes-sato/
此目录包含 Sato 演示/参考 UI/UX 及其关联的应用程序和配置数据。</p>
<p>4.3.19meta/recipes-support/
该目录包含其他配方使用的配方，但不直接包含在图像中（即其他配方的依赖关系）。</p>
<p>4.3.20meta/site/
此目录包含各种架构的缓存结果列表。由于某些“autoconf”测试结果在交叉编译时无法确定，因为测试无法在实时系统上运行，因此该目录中的信息将传递给各种体系结构的“autoconf”。</p>
<p>4.3.21meta/recipes.txt
该文件是对recipes-<a href="#id31"><span class="problematic" id="id32">*</span></a>.</p>
<p>5班
类文件用于抽象通用功能并在多个配方 ( .bb) 文件之间共享。要使用类文件，您只需确保配方继承了类。在大多数情况下，当一个配方继承一个类时，它就足以启用它的功能。但是，在某些情况下，您可能需要在配方中设置变量或覆盖某些默认行为。</p>
<p>通常在配方中找到的任何元数据也可以放在类文件中。类文件由扩展名标识， .bbclass通常放置在Source Directory中找到的classes/目录下的目录中。类文件也可以由 BUILDDIR（例如）以与目录中的文件相同的方式 指向。使用与搜索文件相同的方法在BBPATH中搜索类文件 。meta*/build/.confconf.conf</p>
<p>本章只讨论最有用和最重要的类。meta/classes源目录中的目录中确实存在其他类。您可以直接参考这些.bbclass文件以获取更多信息。</p>
<p>5.1allarch.bbclass
该类allarch由不产生特定于体系结构的输出的配方继承。该类禁用生成可执行二进制文件的配方通常需要的功能（例如构建交叉编译器和 C 库作为先决条件，以及在打包过程中拆分调试符号）。</p>
<p>笔记</p>
<p>与某些发行版配方（例如 Debian）不同，OpenEmbedded 配方产生的软件包依赖于通过使用 RDEPENDS和 TUNE_PKGARCH变量进行调整，不应该为所有使用allarch. 即使配方不产生特定于体系结构的输出也是如此。</p>
<p>为所有架构配置此类配方会导致 do_package_write_*任务对于具有不同调整的机器具有不同的签名。此外，每次构建不同机器的映像时都会发生不必要的重建，即使配方从未改变。</p>
<p>默认情况下，所有配方都继承基类和 包类，从而启用生成可执行输出的配方所需的功能。例如，如果您的配方只生成包含配置文件、媒体文件或脚本（例如 Python 和 Perl）的包，那么它应该继承allarch该类。</p>
<p>5.2archiver.bbclass
该类archiver支持使用二进制文件发布源代码和其他材料。</p>
<p>有关源存档器的更多详细信息，请参阅Yocto 项目开发任务手册中的“在产品生命周期内维护开源许可证合规性”部分。您还可以查看ARCHIVER_MODE变量以获取有关有助于控制归档创建的变量标志 (varflags) 的信息。</p>
<p>5.3autotools*.bbclass
这些autotools*类支持 Autotooled 包。</p>
<p>、autoconf和包automake带来了libtool标准化。此类定义了一组适用于所有 Autotooled 包的任务（例如configure， compile等等）。通常定义几个标准变量就足够了，然后简单地定义. 这些类也可以与模拟 Autotools 的软件一起使用。有关详细信息，请参阅 Yocto 项目开发任务手册中的“自动工具包”部分。inherit autotools</p>
<p>默认情况下，这些autotools*类使用树外构建（即 autotools.bbclass使用 构建）。B != S</p>
<p>如果由配方构建的软件不支持使用树外构建，您应该让配方继承 autotools-brokensep该类。该类autotools-brokensep的行为与该类相同，但使用B == Sautotools构建。当树外构建支持不存在或被破坏时，此方法很有用。</p>
<p>笔记</p>
<p>建议尽可能修复和使用树外支持。</p>
<p>了解 autotools*类定义的任务如何工作以及它们在幕后做什么是很有用的。</p>
<p>do_configure - 重新生成配置脚本（使用autoreconf），然后使用交叉编译期间使用的一组标准参数启动它。您可以通过configureEXTRA_OECONF或 PACKAGECONFIG_CONFARGS变量 传递其他参数。</p>
<p>do_compile -make使用指定编译器和链接器的参数运行。您可以通过EXTRA_OEMAKE变量传递其他参数。</p>
<p>do_install - 运行并传入D作为.make install${}DESTDIR</p>
<p>5.4base.bbclass
该类base的特殊之处在于每个.bb文件都隐式继承了该类。此类包含标准基本任务的定义，例如获取、解包、配置（默认为空）、编译（运行任何Makefile存在）、安装（默认为空）和打包（默认为空）。这些类通常被其他类（例如 autotools类或 包类）覆盖或扩展。</p>
<p>该类还包含一些常用函数，例如 oe_runmake，它使用EXTRA_OEMAKEmake变量中指定的参数 以及直接传递给 的参数运行。oe_runmake</p>
<p>5.5bash-completion.bbclass
设置适用于构建包含 bash 完成数据的软件的配方的打包和依赖项。</p>
<p>5.6bin_package.bbclass
该类bin_package是一个辅助类，用于提取二进制包（例如 RPM）的内容并安装这些内容而不是从源代码构建二进制文件的配方。提取二进制包并创建配置的输出包格式的新包。专有二进制文件的提取和安装是此类的一个很好的示例。</p>
<p>笔记</p>
<p>对于不包含子目录的 RPM 和其他包，您应该指定适当的 fetcher 参数以指向子目录。例如，如果 BitBake 使用 Git 提取器 ( git://)，则“subpath”参数会将检出限制为树的特定子路径。这是一个示例，${BP}用于将文件提取到 S的默认值所期望的子目录中：</p>
<p>SRC_URI = “git://example.com/downloads/somepackage.rpm;subpath=${BP}”
有关支持的 BitBake Fetchers 的更多信息，请参阅 BitBake 用户手册中的“ Fetchers ”部分。</p>
<p>5.7binconfig.bbclass
该类binconfig有助于更正 shell 脚本中的路径。</p>
<p>在pkg-config普及之前，库提供了 shell 脚本以提供有关库的信息并包含构建软件所需的路径（通常命名为LIBNAME-config）。此类协助使用此类脚本的任何配方。</p>
<p>在暂存期间，OpenEmbedded 构建系统将此类脚本安装到sysroots/目录中。继承此类会导致这些脚本中的所有路径都更改为指向sysroots/目录，以便使用该脚本的所有构建都使用正确的目录进行交叉编译布局。有关详细信息，请参阅 BINCONFIG_GLOB变量。</p>
<p>5.8binconfig-disabled.bbclass
binconfig类的替代版本 ，它通过使二进制配置脚本返回错误来禁用二进制配置脚本，以支持使用pkg-config来查询信息。应使用继承类的配方中的BINCONFIG变量指定要禁用的脚本 。</p>
<p>5.9blacklist.bbclass
该类blacklist阻止 OpenEmbedded 构建系统构建特定配方。要使用此类，请全局继承该类并为您希望忽略的每个配方设置PNBLACKLIST 。将PN值指定 为变量标志 (varflag) 并提供一个原因，如果请求将包构建为该值，则会报告该原因。例如，如果您想忽略名为“exoticware”的配方，请将以下内容添加到您的local.conf或分发配置中：</p>
<p>INHERIT += “blacklist”
PNBLACKLIST[exoticware] = “Not supported by our organization.”
5.10buildhistory.bbclass
该类buildhistory记录构建输出元数据的历史，可用于检测可能的回归以及用于分析构建输出。有关使用构建历史的更多信息，请参阅 Yocto 项目开发任务手册中的“维护构建输出质量”部分。</p>
<p>5.11buildstats.bbclass
该类buildstats记录有关构建期间执行的每个任务的性能统计信息（例如，经过的时间、CPU 使用率和 I/O 使用率）。</p>
<p>使用此类时，输出将进入 BUILDSTATS_BASE目录，默认为${TMPDIR}/buildstats/. 您可以使用 分析经过的时间 scripts/pybootchartgui/pybootchartgui.py，它会生成整个构建过程的级联图，可用于突出显示瓶颈。</p>
<p>默认情况下，通过文件中的 USER_CLASSES变量 收集构建统计信息local.conf。因此，您无需执行任何操作即可启用该类。但是，如果您想禁用该类，只需从USER_CLASSES列表中删除“buildstats”即可。</p>
<p>5.12buildstats-summary.bbclass
当全局继承时，在 sstate 重用的构建结束时打印统计信息。为了发挥作用，此类需要 启用buildstats类。</p>
<p>5.13ccache.bbclass
该类ccache为构建启用 C/C++ 编译器缓存。此类用于在构建期间提供较小的性能提升。</p>
<p>有关C/C++ 编译器缓存的信息，请参见https://ccache.samba.org/ ， 有关如何在配置文件中启用此机制、如何为特定配方禁用它以及如何禁用它的详细信息，请参见ccache.bbclassccache文件 在构建之间共享文件。</p>
<p>但是，使用该类可能会导致意想不到的副作用。因此，不推荐使用此类。</p>
<p>5.14chrpath.bbclass
该类chrpath是“chrpath”实用程序的包装器，在构建过程中使用它来 nativesdk更改二进制文件中的记录，以使它们可重定位。crosscross-canadianRPATH</p>
<p>5.15cmake.bbclass
该类cmake允许需要使用CMake构建系统构建软件的配方。您可以使用EXTRA_OECMAKE变量来指定要使用cmake 命令行传递的其他配置选项。</p>
<p>如果您要安装由正在构建的应用程序提供的自定义 CMake 工具链文件，您应该将它们安装到首选的 CMake 模块目录：do_install${D}${datadir}/cmake/ 期间的模块 。</p>
<p>5.16cml1.bbclass
该类cml1为 Linux 内核样式构建配置系统提供基本支持。</p>
<p>5.17compress_doc.bbclass
启用手册页和信息页的压缩。此类旨在全局继承。默认压缩机制是 gz (gzip)，但您可以通过设置DOC_COMPRESS变量来选择替代机制 。</p>
<p>5.18copyleft_compliance.bbclass
出于许可证合规性的目的，该类copyleft_compliance保留源代码。该类是该类的替代品，archiver 尽管已弃用该类以支持归档器类，但某些用户仍在使用该类。</p>
<p>5.19copyleft_filter.bbclass
归档器和 copyleft_compliance类用于过滤许可证的类。该类copyleft_filter是一个内部类，不打算直接使用。</p>
<p>5.20core-image.bbclass
该类为图像配方core-image提供通用定义 core-image-<a href="#id33"><span class="problematic" id="id34">*</span></a>，例如支持额外的 IMAGE_FEATURES。</p>
<p>5.21cpan*.bbclass
这些cpan*类支持 Perl 模块。</p>
<p>Perl 模块的方法很简单。这些配方通常只需要指向源的存档，然后继承正确的类文件。根据模块作者使用的方法，构建分为两种方法。</p>
<p>使用Makefile.PL基于旧的构建系统的 模块cpan.bbclass在他们的配方中需要。</p>
<p>使用Build.PL-based 构建系统的模块需要 cpan_build.bbclass在其配方中使用。</p>
<p>两种构建方法都继承了cpan-base基本 Perl 支持的类。</p>
<p>5.22cross.bbclass
该类cross为构建交叉编译工具的配方提供支持。</p>
<p>5.23cross-canadian.bbclass
该类cross-canadian支持为 SDK 构建加拿大交叉编译工具的配方。有关这些交叉编译工具的更多讨论，请参阅 Yocto 项目概述和概念手册中的“交叉开发工具链生成”部分。</p>
<p>5.24crosssdk.bbclass
该类crosssdk为构建用于构建 SDK 的交叉编译工具的配方提供支持。有关这些交叉编译工具的更多讨论，请参阅 Yocto 项目概述和概念手册中的“交叉开发工具链生成”部分。</p>
<p>5.25cve-check.bbclass
该类cve-check在构建映像时查找已知的 CVE（常见漏洞和暴露）。此类旨在从配置文件全局继承：</p>
<p>INHERIT += “cve-check”
您还可以通过传递 给 BitBake 来查找特定包中的漏洞。您可以在开发任务手册的“检查漏洞”部分找到详细信息。-c cve_check</p>
<p>5.26debian.bbclass
该类debian重命名输出包，以便它们遵循 Debian 命名策略（即glibc成为libc6和 glibc-devel成为libc6-dev.）。重命名包括库名称和版本作为包名称的一部分。</p>
<p>如果配方为多个库（.so类型的共享目标文件）创建包，请使用配方中的LEAD_SONAME 变量来指定应用命名方案的库。</p>
<p>5.27deploy.bbclass
该类deploy处理将文件部署到 DEPLOY_DIR_IMAGE目录。该类的主要功能是允许通过共享状态来加速部署步骤。继承这个类的recipes应该定义自己的 do_deploy函数，将要部署的文件复制到DEPLOYDIR，并用于addtask在适当的地方添加任务，通常在 do_compile或 do_install之后。然后该类负责将文件从DEPLOYDIR 暂存到DEPLOY_DIR_IMAGE。</p>
<p>5.28devshell.bbclass
devshell班级添加do_devshell任务。分发策略规定是否包括此类。有关使用devshell. _</p>
<p>5.29devupstream.bbclass
该类devupstream使用 BBCLASSEXTEND添加从替代 URI（例如 Git）而不是 tarball 获取的配方的变体。下面是一个例子：</p>
<p>BBCLASSEXTEND = “devupstream:target”
SRC_URI:class-devupstream = “git://git.example.com/example”
SRCREV:class-devupstream = “abcd1234”
将上述语句添加到您的配方中会创建一个将 DEFAULT_PREFERENCE设置为“-1”的变体。因此，您需要选择配方的变体来使用它。任何特定于开发的调整都可以通过使用 class-devupstream覆盖来完成。这是一个例子：</p>
<p>DEPENDS:append:class-devupstream = ” gperf-native”
do_configure:prepend:class-devupstream() {</p>
<blockquote>
<div><p>touch ${S}/README</p>
</div></blockquote>
<p>}
该类目前仅支持创建目标配方的开发变体，不支持native或nativesdk变体。</p>
<p>BBCLASSEXTEND语法（即）提供对和变体的支持。因此，可以在未来的版本中添加此功能。devupstream:targetnativenativesdk</p>
<p>由于 BitBake 的自动获取依赖项（例如 subversion-native），对 Subversion 等其他版本控制系统的支持受到限制。</p>
<p>5.30distutils3*.bbclass
这些distutils3*类支持 Python 3.x 版扩展的配方，很简单。这些配方通常只需要指向源的存档，然后继承适当的类。根据模块作者使用的方法，构建分为三种方法。</p>
<p>使用基于 Autotools 的构建系统的扩展distutils在其配方中需要 Autotools 和 -based 类。</p>
<p>使用distutils基于 的构建系统的 扩展distutils在其配方中需要该类。</p>
<p>笔记</p>
<p>distutils在 Python 3.10 中已弃用，并将在 Python 3.12 中删除。出于这个原因，这些distutils3*类现在已被弃用，并将在不久的将来从核心中删除。相反，使用setuptools3*类。</p>
<p>使用基于的构建系统的扩展在其配方中setuptools3需要setuptools3类。</p>
<p>5.31externalsrc.bbclass
该类externalsrc支持从 OpenEmbedded 构建系统外部的源代码构建软件。从外部源代码树构建软件意味着不使用构建系统的正常获取、解包和修补过程。</p>
<p>默认情况下，OpenEmbedded 构建系统使用S 和B变量来分别定位解压的配方源代码并进行构建。当您的配方继承 externalsrc该类时，您使用 EXTERNALSRC和 EXTERNALSRC_BUILD变量来最终定义S和B。</p>
<p>默认情况下，此类期望源代码支持使用B变量指向 OpenEmbedded 构建系统放置从配方构建的生成对象的目录的配方构建。默认情况下，B目录设置为以下，与源目录（ S ）分开：</p>
<p>${WORKDIR}/${BPN}-{PV}/
有关详细信息，请参阅这些变量： WORKDIR、BPN和 PV，</p>
<p>有关该类的更多信息，请参阅Source Directory中externalsrc的注释 。有关如何使用 该类的信息，请参阅Yocto 项目开发任务手册中的“从外部源构建软件”部分。meta/classes/externalsrc.bbclassexternalsrc</p>
<p>5.32extrausers.bbclass
该类extrausers允许在图像级别应用其他用户和组配置。全局或从图像配方继承此类允许使用 EXTRA_USERS_PARAMS变量执行其他用户和组操作。</p>
<p>笔记</p>
<p>使用extrausers类添加的用户和组操作 不绑定到图像配方之外的特定配方。因此，可以在整个图像上执行操作。使用 useradd 类将用户和组配置添加到特定配方。</p>
<p>这是一个在图像配方中使用此类的示例：</p>
<p>inherit extrausers
EXTRA_USERS_PARAMS = “</p>
<blockquote>
<div><p>useradd -p ‘’ tester; groupadd developers; userdel nobody; groupdel -g video; groupmod -g 1020 developers; usermod -s /bin/sh tester; “</p>
</div></blockquote>
<p>这是一个添加两个名为“tester-jim”和“tester-sue”的用户并分配密码的示例。首先在主机上，创建密码哈希：</p>
<p>mkpasswd -m sha256crypt tester01
生成的散列设置为一个变量并在useradd命令参数中使用。请记住转义字符$：</p>
<p>inherit extrausers
PASSWD = “$X$ABC123$A-Long-Hash”
EXTRA_USERS_PARAMS = “</p>
<blockquote>
<div><p>useradd -p ‘${PASSWD}’ tester-jim; useradd -p ‘${PASSWD}’ tester-sue; “</p>
</div></blockquote>
<p>最后，这是一个设置 root 密码的示例：</p>
<p>inherit extrausers
EXTRA_USERS_PARAMS = “</p>
<blockquote>
<div><p>usermod -p ‘${PASSWD}’ root; “</p>
</div></blockquote>
<p>5.33features_check.bbclass
该类features_check允许单个配方检查所需的和冲突的 DISTRO_FEATURES、MACHINE_FEATURES或COMBINED_FEATURES。</p>
<p>此类为以下变量提供支持：</p>
<p>REQUIRED_DISTRO_FEATURES</p>
<p>CONFLICT_DISTRO_FEATURES</p>
<p>ANY_OF_DISTRO_FEATURES</p>
<p>REQUIRED_MACHINE_FEATURES</p>
<p>CONFLICT_MACHINE_FEATURES</p>
<p>ANY_OF_MACHINE_FEATURES</p>
<p>REQUIRED_COMBINED_FEATURES</p>
<p>CONFLICT_COMBINED_FEATURES</p>
<p>ANY_OF_COMBINED_FEATURES</p>
<p>如果使用上述变量的配方中指定的任何条件不满足，则将跳过配方，如果构建系统尝试构建配方，则会触发错误。</p>
<p>5.34fontcache.bbclass
该类fontcache为字体包生成正确的安装后和删除后（postinst 和 postrm）脚本。这些 scriptlet 调用fc-cache（部分Fontconfig）将字体添加到字体信息缓存中。由于缓存文件是特定于体系结构的，fc-cache因此如果在创建映像期间需要在构建主机上运行 postinst 脚本，则使用 QEMU 运行。</p>
<p>如果要安装的字体位于主包以外的包中，请设置FONT_PACKAGES以指定包含字体的包。</p>
<p>5.35fs-uuid.bbclass
该类从ROOTFSfs-uuid中提取 UUID ，该 UUID 必须在调用此函数时构建。该类仅适用于文件系统并依赖于.${}fs-uuidexttune2fs</p>
<p>5.36gconf.bbclass
该类gconf为需要安装 GConf 模式的配方提供通用功能。这些模式将被放入一个单独的包 ( ${PN}-gconf ) 中，该包在继承此类时会自动创建。此软件包使用适当的安装后和删除后 (postinst/postrm) 脚本来注册和取消注册目标映像中的模式。</p>
<p>5.37gettext.bbclass
该类为构建使用 GNU国际化和本地化系统gettext的软件提供支持。gettext所有使用的配方构建软件都gettext应该继承这个类。</p>
<p>5.38gnomebase.bbclass
该类gnomebase是从 GNOME 堆栈构建软件的配方的基类。此类设置 SRC_URI以从 GNOME 镜像下载源以及使用典型 GNOME 安装路径扩展FILES 。</p>
<p>5.39gobject-introspection.bbclass
为支持 GObject 内省的配方构建软件提供支持。仅当“gobject-introspection-data”功能位于 DISTRO_FEATURES中并且“qemu-usermode”位于 MACHINE_FEATURES中时，才会启用此功能。</p>
<p>笔记</p>
<p>此功能默认回填，如果不适用，应分别通过DISTRO_FEATURES_BACKFILL_CONSIDERED或 MACHINE_FEATURES_BACKFILL_CONSIDERED禁用。</p>
<p>5.40grub-efi.bbclass
该类grub-efi提供了grub-efi用于构建可启动映像的特定功能。</p>
<p>这个类支持几个变量：</p>
<p>INITRD：指示要连接并用作初始 RAM 磁盘 (initrd) 的文件系统映像列表（可选）。</p>
<p>ROOTFS：指示要作为根文件系统包含的文件系统映像（可选）。</p>
<p>GRUB_GFXSERIAL：将此设置为“1”以在启动菜单中显示图形和串行。</p>
<p>LABELS：自动配置的目标列表。</p>
<p>APPEND：每个附加字符串的覆盖列表LABEL。</p>
<p>GRUB_OPTS：添加到配置的附加选项（可选）。选项使用分号字符 (;) 分隔。</p>
<p>GRUB_TIMEOUT：执行默认值之前的超时时间LABEL（可选）。</p>
<p>5.41gsettings.bbclass
该类gsettings为需要安装 GSettings (glib) 模式的配方提供通用功能。假定模式是主包的一部分。添加了适当的安装后和删除后 (postinst/postrm) 脚本，以注册和取消注册目标映像中的模式。</p>
<p>5.42gtk-doc.bbclass
该类gtk-doc是一个辅助类，用于引入适当的 gtk-doc依赖项并禁用gtk-doc.</p>
<p>5.43gtk-icon-cache.bbclass
该类gtk-icon-cache为使用 GTK+ 和安装图标的包生成正确的安装后和删除后 (postinst/postrm) 脚本。这些小脚本调用gtk-update-icon-cache以将字体添加到 GTK+ 的图标缓存中。由于缓存文件是特定于体系结构的，gtk-update-icon-cache如果在创建映像期间需要在构建主机上运行 postinst 脚本，则使用 QEMU 运行。</p>
<p>5.44gtk-immodules-cache.bbclass
该类gtk-immodules-cache为安装虚拟键盘的 GTK+ 输入法模块的包生成正确的安装后和删除后 (postinst/postrm) 脚本。这些小脚本调用 gtk-update-icon-cache以将输入法模块添加到缓存中。由于缓存文件是特定于体系结构的， gtk-update-icon-cache如果在创建映像期间需要在构建主机上运行 postinst 脚本，则使用 QEMU 运行。</p>
<p>如果正在安装的输入法模块在主包以外的包中，设置 GTKIMMODULES_PACKAGES以指定包含模块的包。</p>
<p>5.45gzipnative.bbclass
该类gzipnative允许使用不同的本地版本， gzip而pigz不是来自构建主机的这些工具的版本。</p>
<p>5.46icecc.bbclass
该类icecc支持 Icecream，它有助于获取编译作业并将它们分布在远程机器上。</p>
<p>对于本机和交叉编译器，该类使用符号链接 fromgcc和g++to 暂存目录。icecc根据每次配置或编译，OpenEmbedded 构建系统将目录添加到PATH列表的头部，然后设置ICECC_CXX和 ICEC_CC变量，它们分别是g++和gcc 编译器的路径。</p>
<p>对于交叉编译器，该类创建一个tar.gz包含 Yocto Project 工具链的文件，并设置ICECC_VERSION相应的交叉开发工具链中使用的交叉编译器的版本。</p>
<p>该类处理所有三个不同的编译阶段（即本机、跨内核和目标）并创建 tar.gz远程机器使用的必要环境文件。该类还支持 SDK 生成。</p>
<p>如果您的文件中未设置 ICECC_PATHlocal.conf，则该类会尝试icecc使用which. 如果您的文件中设置了ICECC_ENV_EXEClocal.conf，则该变量应指向 icecc-create-env用户提供的脚本。如果您不指向用户提供的脚本，则构建系统将使用配方提供的默认脚本icecc-create-env-native.bb。</p>
<p>笔记</p>
<p>这个脚本是一个修改版本，不是icecc 自带的。</p>
<p>如果您不希望 Icecream 分布式编译支持应用于特定配方或类，您可以通过 在文件中分别使用ICECC_USER_PACKAGE_BL和 ICECC_USER_CLASS_BLlocal.conf变量列出配方和类来要求 Icecream 忽略它们。这样做会导致 OpenEmbedded 构建系统在本地处理这些编译。</p>
<p>此外，您可以使用文件中的 ICECC_USER_PACKAGE_WL变量列出配方，以使用空的PARALLEL_MAKElocal.conf变量强制启用配方。icecc</p>
<p>继承icecc类会更改所有 sstate 签名。因此，如果开发团队有一个专门的构建系统来填充SSTATE_MIRRORS并且他们想要重用来自 SSTATE_MIRRORS 的sstate，那么所有开发人员和构建系统都需要继承icecc该类，或者没有人应该继承。</p>
<p>在分发级别，您可以继承icecc该类以确保所有构建器都以相同的 sstate 签名开始。继承类后，您可以通过将 ICECC_DISABLED变量设置为“1”来禁用该功能，如下所示：</p>
<p>INHERIT_DISTRO:append = ” icecc”
ICECC_DISABLED ??= “1”
local.conf这种做法确保每个人都使用相同的签名，但也要求确实想使用 Icecream 的个人在您的文件中单独启用该功能，如下所示：</p>
<p>ICECC_DISABLED = “”
5.47image.bbclass
该类image有助于支持以不同格式创建图像。首先，使用其中一个文件（取决于使用的包格式）从包中创建根文件系统 rootfs*.bbclass，然后创建一个或多个图像文件。</p>
<p>IMAGE_FSTYPES变量控制要生成的图像类型。</p>
<p>IMAGE_INSTALL变量控制要安装到映像中的软件包列表。</p>
<p>有关自定义图像的信息，请参阅 Yocto 项目开发任务手册中的“自定义图像”部分。有关如何创建图像的信息，请参阅 Yocto 项目概述和概念手册中的“图像”部分。</p>
<p>5.48image-buildinfo.bbclass
该类image-buildinfo将信息写入/etc/build.</p>
<p>5.49image_types.bbclass
该类image_types定义了您可以通过 IMAGE_FSTYPES变量启用的所有标准图像输出类型。您可以将此类用作有关如何添加对自定义图像输出类型的支持的参考。</p>
<p>默认情况下，图像类会自动启用image_types该类。该类image使用 IMGCLASSES如下变量：</p>
<p>IMGCLASSES = “rootfs_${IMAGE_PKGTYPE} image_types ${IMAGE_CLASSES}”
IMGCLASSES += “${&#64;[‘populate_sdk_base’, ‘populate_sdk_ext’][‘linux’ in d.getVar(“SDK_OS”)]}”
IMGCLASSES += “<a class="reference external" href="mailto:${&#37;&#52;&#48;bb&#46;utils">${<span>&#64;</span>bb<span>&#46;</span>utils</a>.contains_any(‘IMAGE_FSTYPES’, ‘live iso hddimg’, ‘image-live’, ‘’, d)}”
IMGCLASSES += “<a class="reference external" href="mailto:${&#37;&#52;&#48;bb&#46;utils">${<span>&#64;</span>bb<span>&#46;</span>utils</a>.contains(‘IMAGE_FSTYPES’, ‘container’, ‘image-container’, ‘’, d)}”
IMGCLASSES += “image_types_wic”
IMGCLASSES += “rootfs-postcommands”
IMGCLASSES += “image-postinst-intercepts”
inherit ${IMGCLASSES}
该类image_types还处理图像的转换和压缩。</p>
<p>笔记</p>
<p>要构建 VMware VMDK 映像，您需要将“wic.vmdk”添加到 IMAGE_FSTYPES。这对于 Virtual Box 虚拟磁盘映像 (“vdi”) 和 QEMU Copy On Write Version 2 (“qcow2”) 映像也是类似的。</p>
<p>5.50image-live.bbclass
此类控制构建“实时”（即 HDDIMG 和 ISO）图像。如果 MACHINE_FEATURES包含“efi” ，实时映像包含用于传统引导的 syslinux，以及由EFI_PROVIDER指定的引导加载程序。</p>
<p>通常，您不直接使用此类。相反，您将“live”添加到 IMAGE_FSTYPES。</p>
<p>5.51image-prelink.bbclass
该类image-prelink允许在do_rootfsprelink任务期间使用该实用程序，从而优化共享库的动态链接以减少可执行文件的启动时间。</p>
<p>默认情况下，local.conf.template使用USER_CLASSES变量启用该类，如下所示：</p>
<p>USER_CLASSES ?= “buildstats image-prelink”
5.52insane.bbclass
该类insane向包生成过程添加了一个步骤，以便由 OpenEmbedded 构建系统生成输出质量保证检查。执行一系列检查以检查构建的输出以查找运行时出现的常见问题。分发策略通常规定是否包含此类。</p>
<p>您可以配置健全性检查，以便特定测试失败会引发警告或错误消息。通常，新测试的失败会生成警告。一旦元数据处于已知且良好的状态，同一测试的后续失败将生成错误消息。有关使用默认配置可能遇到的所有警告和错误消息的列表，请参阅“ QA 错误和警告消息”一章。</p>
<p>使用WARN_QA和 ERROR_QA变量在全局级别（即在您的自定义发行版配置中）控制这些检查的行为。但是，要跳过配方中的一项或多项检查，您应该使用INSANE_SKIP。例如，要跳过对.so配方主包中符号链接文件的检查，请将以下内容添加到配方中。您需要意识到必须使用包名称覆盖，在此示例${PN}中：</p>
<p>INSANE_SKIP:${PN} += “dev-so”
请记住，QA 检查旨在检测打包输出中的实际或潜在问题。因此，在禁用这些检查时要小心。</p>
<p>以下是您可以使用WARN_QA和 ERROR_QA变量列出的测试：</p>
<p>already-stripped:在构建系统提取调试符号之前，检查生成的二进制文件是否已被剥离。上游软件项目默认剥离输出二进制文件的调试符号是很常见的。为了使用-dbg包在目标上进行调试，必须禁用此剥离。</p>
<p>arch:检查任何二进制文件的可执行和可链接格式 (ELF) 类型、位大小和字节序，以确保它们与目标体系结构匹配。如果任何二进制文件与类型不匹配，则此测试将失败，因为存在不兼容性。测试可能表明使用了错误的编译器或编译器选项。有时软件（如引导加载程序）可能需要绕过此检查。</p>
<p>buildpaths:检查输出文件内构建主机上位置的路径。目前，此测试会触发太多误报，因此通常不会启用。</p>
<p>build-deps:确定是否存在通过DEPENDS、显式 RDEPENDS或任务级依赖项指定的构建时依赖项以匹配任何运行时依赖项。此确定对于发现在打包期间检测和添加运行时依赖项的位置特别有用。如果在元数据中没有明确指定依赖，那么在打包阶段要确保构建依赖为时已晚，因此在 do_rootfs任务期间将包安装到映像中时可能会出现错误，因为不满足自动检测到的依赖性。一个例子是 update-rc.d类自动添加对initscripts-functions包到安装了引用 . 的 initscript 的包 /etc/init.d/functions。配方确实应该有一个明确的 RDEPENDS用于所讨论的包，initscripts-functions 以便 OpenEmbedded 构建系统能够确保 initscripts实际构建配方，从而使 initscripts-functions包可用。</p>
<p>compile-host-path:检查 do_compile日志中是否使用了指向构建主机上位置的路径的指示。使用此类路径可能会导致构建输出受到主机污染。</p>
<p>debug-deps:检查除包之外的所有包-dbg不依赖-dbg包，这会导致打包错误。</p>
<p>debug-files:检查除包.debug之外的任何目录中的目录。-dbg调试文件应该都在-dbg 包中。因此，任何包装在其他地方的东西都是不正确的包装。</p>
<p>dep-cmp:检查包之间的运行时依赖关系中的无效版本比较语句（即在 RDEPENDS、 RRECOMMENDS、 RSUGGESTS、 RPROVIDES、 RREPLACES和 RCONFLICTS变量值中）。当传递给包管理器时，任何无效的比较都可能触发失败或不良行为。</p>
<p>desktop:desktop-file-validate针对任何 文件运行程序，以根据.desktop文件规范验证其内容.desktop。</p>
<p>dev-deps:检查除-dev或 -staticdev包之外的所有包不依赖-dev包，这将是一个打包错误。</p>
<p>dev-so:检查.so符号链接是否在 -dev包中，而不是在任何其他包中。通常，这些符号链接仅用于开发目的。因此， -dev包裹是他们的正确位置。在极少数情况下，例如动态加载的模块，主包中需要这些符号链接。</p>
<p>file-rdeps:检查 OpenEmbedded 构建系统在打包时识别的文件级依赖关系是否得到满足。例如，shell 脚本可能以行开头#!/bin/bash。此行将转换为对/bin/bash. 在 OpenEmbedded 构建系统支持的三个包管理器中，只有 RPM 直接处理文件级依赖关系，自动将它们解析为提供文件的包。但是，其他两个包管理器中缺少该功能并不意味着依赖项仍然不需要解决。此 QA 检查尝试确保存在显式声明 的 RDEPENDS以处理在打包文件中检测到的任何文件级依赖项。</p>
<p>files-invalid:检查包含“//”的FILES变量值，这是无效的。</p>
<p>host-user-contaminated:检查配方生成的包中是否不包含任何/home与运行 BitBake 的用户匹配的用户或组 ID 之外的文件。匹配通常表示使用不正确的 UID/GID 安装文件，因为目标 ID 独立于主机 ID。有关其他信息，请参阅描述 do_install任务的部分。</p>
<p>incompatible-license:报告由于被标记为 INCOMPATIBLE_LICENSE中的许可证而被排除在创建之外的包。</p>
<p>install-host-path:检查 do_install日志以获取有关使用构建主机上的位置的路径的指示。使用此类路径可能会导致构建输出受到主机污染。</p>
<p>installed-vs-shipped:通过FILES变量报告文件已安装do_install但未包含在任何包中的时间。未出现在任何包中的文件不能在稍后的构建过程中出现在映像中。理想情况下，所有已安装的文件都应打包或根本不安装。如果任何包中不需要这些文件，则可以在结束时删除这些文件 。do_install</p>
<p>invalid-chars:检查配方元数据变量 DESCRIPTION、 SUMMARY、LICENSE和 SECTION不包含非UTF-8字符。一些包管理器不支持这样的字符。</p>
<p>invalid-packageconfig:检查是否没有将未定义的功能添加到PACKAGECONFIG。例如，任何不存在以下形式的名称“foo”：</p>
<p>PACKAGECONFIG[foo] = “…”
la:检查.la任何TMPDIR路径的文件。任何.la 包含这些路径的文件都是不正确的，因为libtool在自动使用文件时添加了正确的 sysroot 前缀。</p>
<p>ldflags:确保二进制文件与 构建系统提供的LDFLAGS选项链接。如果此测试失败，请检查LDFLAGS变量是否正在传递给链接器命令。</p>
<p>libdir:检查安装到不正确（可能是硬编码）安装路径的库。例如，此测试将捕获“lib32”/lib/bar.so时安装的配方。${base_libdir}另一个例子是当食谱安装 /usr/lib64/foo.so时${libdir}是“/usr/lib”。</p>
<p>libexec:检查一个包是否包含 /usr/libexec. libexecdir 如果变量已显式设置为 ，则不执行此检查/usr/libexec。</p>
<p>packages-list:通过PACKAGES变量值检查是否多次列出同一个包。以这种方式安装包可能会导致打包过程中出错。</p>
<p>perm-config:报告fs-perms.txt格式无效的行。</p>
<p>perm-line:报告fs-perms.txt格式无效的行。</p>
<p>perm-link:报告fs-perms.txt指定目标已存在的“链接”中的行。</p>
<p>perms:目前，此检查未使用但已保留。</p>
<p>pkgconfig:检查.pc任何 TMPDIR / WORKDIR路径的文件。任何.pc包含这些路径的文件都是不正确 的，因为pkg-config在访问文件时它本身会添加正确的 sysroot 前缀。</p>
<p>pkgname:检查 PACKAGES中的所有包的名称是否不包含无效字符（即除 0-9、az、.、+ 和 - 以外的字符）。</p>
<p>pkgv-undefined:检查在do_package期间是否未定义PKGV变量。</p>
<p>pkgvarcheck:检查变量 RDEPENDS、 RRECOMMENDS、 RSUGGESTS、 RCONFLICTS、 RPROVIDES、 RREPLACES、FILES、 ALLOW_EMPTY、pkg_preinst、 和pkg_postinst，并报告是否存在非包特定的变量集。在没有包后缀的情况下使用这些变量是不好的做法，并且可能会不必要地使同一配方中其他包的依赖关系复杂化或产生其他意想不到的后果。pkg_prermpkg_postrm</p>
<p>pn-overrides:检查配方是否没有出现在 OVERRIDES中的名称 ( PN ) 值。如果一个配方被命名为它的PN值与OVERRIDES中已经存在的值匹配（例如 PN恰好与MACHINE或 DISTRO相同），它可能会产生意想不到的后果。例如，诸如有效地变成.FILES:${PN} = “xyz”FILES = “xyz”</p>
<p>rpaths:检查包含构建系统路径（例如TMPDIR ）的二进制文件中的 rpath 。如果此测试失败，则会将错误的-rpath 选项传递给链接器命令，并且您的二进制文件存在潜在的安全问题。</p>
<p>split-strip:报告从二进制文件中拆分或剥离调试符号失败。</p>
<p>staticdev:检查*.a非staticdev包中的静态库文件 ( )。</p>
<p>symlink-to-sysroot:检查指向主机上TMPDIR的包中的符号链接。这样的符号链接将在主机上工作，但在目标上运行时显然无效。</p>
<p>textrel:检查在其部分中包含重定位的 ELF 二进制文件.text，这可能会在运行时影响性能。有关运行时性能问题的更多信息，请参阅“ QA 错误和警告消息”中的消息说明。ELF binary</p>
<p>unlisted-pkg-lics:检查申请包的所有声明的许可证是否也在配方级别声明（即任何许可证LICENSE:<a href="#id35"><span class="problematic" id="id36">*</span></a>都应出现在LICENSE中）。</p>
<p>useless-rpaths:检查二进制文件中的动态库加载路径 (rpaths)，默认情况下，链接器在标准系统上搜索这些路径（例如/lib和/usr/lib）。虽然这些路径不会造成任何破损，但它们确实会浪费空间并且是不必要的。</p>
<p>var-undefined:在do_package期间未定义打包的基本变量（即WORKDIR、 DEPLOY_DIR、D、 PN和PKGD）时报告。</p>
<p>version-going-backwards:如果启用了构建历史记录，则报告正在写出的包的版本低于以前写入的同名包的版本。如果您将输出包放入提要并使用该提要升级目标系统上的包，则包的版本向后退可能会导致目标系统无法正确升级到包的“新”版本。</p>
<p>笔记</p>
<p>这仅在您在目标系统上使用运行时包管理时才相关。</p>
<p>xorg-driver-abi:检查所有包含 Xorg 驱动程序的包是否具有 ABI 依赖项。该xserver-xorg配方提供了驱动程序 ABI 名称。所有驱动程序都应依赖于构建它们的 ABI 版本。包含 xorg-driver-input.inc或xorg-driver-video.inc将自动获取这些版本的驱动程序配方。因此，您应该只需要显式地将依赖项添加到二进制驱动程序配方。</p>
<p>5.53insserv.bbclass
该类insserv使用该实用程序根据脚本本身中 LSB 标头指定的依赖关系insserv更新图像中符号链接的顺序。/etc/rc?.d/init.d</p>
<p>5.54kernel.bbclass
该类kernel处理构建 Linux 内核。该类包含构建所有内核树的代码。所有需要的头文件都暂存到 STAGING_KERNEL_DIR目录中，以允许使用模块类构建树外模块。</p>
<p>这意味着每个构建的内核模块都是单独打包的，并且通过解析modinfo输出来创建模块间的依赖关系。如果需要所有模块，则安装kernel-modules 包会安装所有带有模块的包和各种其他内核包，例如kernel-vmlinux.</p>
<p>该类kernel包含允许您在构建内核映像时嵌入初始 RAM 文件系统 (initramfs) 映像的逻辑。有关如何构建 initramfs 的信息，请参阅 Yocto 项目开发任务手册中的“构建初始 RAM 文件系统 (initramfs) 映像”部分。</p>
<p>kernel和module类内部使用了各种其他类，包括kernel-arch、 module-base和 linux-kernel-base类。</p>
<p>5.55kernel-arch.bbclass
该类为 Linux 内核编译（包括模块）kernel-arch设置ARCH环境变量。</p>
<p>5.56kernel-devicetree.bbclass
该类kernel-devicetree由 内核类继承，支持设备树生成。</p>
<p>5.57kernel-fitimage.bbclass
该类kernel-fitimage支持将内核映像、设备树、U-boot 脚本、Initramfs 包和 RAM 磁盘打包到单个 FIT 映像中。理论上，一个 FIT 映像可以支持任意数量的内核、U-boot 脚本、Initramfs 包、RAM 磁盘和设备树。但是，kernel-fitimage目前仅支持有限的用例：仅一个内核映像、一个可选的 U-boot 脚本、一个可选的 Initramfs 包、一个可选的 RAM 磁盘和任意数量的设备树。</p>
<p>要创建 FIT 图像，需要将KERNEL_CLASSES 设置为包含“kernel-fitimage”，并将KERNEL_IMAGETYPE 设置为“fitImage”。</p>
<p>创建 FIT 映像时 传递给的设备树编译器的选项是使用UBOOT_MKIMAGE_DTCOPTS变量指定的。mkimage -D</p>
<p>只能将单个内核添加到由 FIT 创建的 映像中，kernel-fitimage并且 FIT 中的内核映像是强制性的。U-Boot 加载内核映像的地址由UBOOT_LOADADDRESS指定，入口点由 UBOOT_ENTRYPOINT 指定。</p>
<p>可以将多个设备树添加到创建的 FIT 映像中， kernel-fitimage并且设备树是可选的。U-Boot 加载设备树的地址由UBOOT_DTBO_LOADADDRESS指定用于设备树覆盖，由UBOOT_DTB_LOADADDRESS 指定用于设备树二进制文件。</p>
<p>创建的 FIT 映像中只能添加单个 RAM 磁盘，并且 FIT kernel-fitimage中的 RAM 磁盘是可选的。U-Boot 加载 RAM 磁盘映像的地址由UBOOT_RD_LOADADDRESS指定，入口点由 UBOOT_RD_ENTRYPOINT 指定。当指定 INITRAMFS_IMAGE 并且 INITRAMFS_IMAGE_BUNDLE 设置为 0 时，ramdisk 被添加 到FIT映像 。</p>
<p>只能将单个 Initramfs 包添加到由 FIT 创建的 FIT 映像中， kernel-fitimage并且 FIT 中的 Initramfs 包是可选的。对于 Initramfs，内核被配置为与根文件系统捆绑在同一个二进制文件中（例如：zImage-initramfs- MACHINE .bin）。当内核被复制到 RAM 并执行时，它会解压 Initramfs 根文件系统。当指定INITRAMFS_IMAGE 并且INITRAMFS_IMAGE_BUNDLE设置为 1时，可以启用Initramfs 包。U-boot 加载 Initramfs 包的地址由UBOOT_LOADADDRESS指定，入口点由UBOOT_ENTRYPOINT 指定。</p>
<p>只能将单个 U-boot 引导脚本添加到由 FIT 创建的映像中， kernel-fitimage并且引导脚本是可选的。引导脚本在 ITS 文件中指定为包含 U-boot 命令的文本文件。使用引导脚本时，用户应配置 U-bootdo_install任务以将脚本复制到 sysroot。所以脚本可以通过kernel-fitimage 类包含在 FIT 图像中。在运行时，可以配置 U-boot CONFIG_BOOTCOMMAND 定义从 FIT 映像加载启动脚本并执行它。</p>
<p>kernel-fitimage当变量UBOOT_SIGN_ENABLE、UBOOT_MKIMAGE_DTCOPTS、 UBOOT_SIGN_KEYDIR和UBOOT_SIGN_KEYNAME被适当设置时，类生成的 FIT 图像被签名。FIT_HASH_ALG和 FIT_SIGN_ALG使用的默认值kernel-fitimage分别是“sha256”和“rsa2048”。当FIT_GENERATE_KEYS和 UBOOT_SIGN_ENABLE都设置为“1”时，可以使用kernel-fitimage类生成签署 fitImage 的密钥。</p>
<p>5.58kernel-grub.bbclass
该类kernel-grub使用内核作为优先引导机制更新引导区域和引导菜单，同时安装 RPM 以更新已部署目标上的内核。</p>
<p>5.59kernel-module-split.bbclass
该类kernel-module-split提供了将 Linux 内核模块拆分为单独包的通用功能。</p>
<p>5.60kernel-uboot.bbclass
该类kernel-uboot支持从 vmlinux 风格的内核源代码构建。</p>
<p>5.61kernel-uimage.bbclass
该类kernel-uimage提供对打包 uImage 的支持。</p>
<p>5.62kernel-yocto.bbclass
该类kernel-yocto提供了从 linux-yocto 风格的内核源代码库构建的通用功能。</p>
<p>5.63kernelsrc.bbclass
该类kernelsrc设置 Linux 内核源和版本。</p>
<p>5.64lib_package.bbclass
该类lib_package支持构建库和生成可执行二进制文件的配方，默认情况下不应将这些二进制文件与库一起安装。相反，这些二进制文件被添加到一个单独的${PN}-bin包中，以使其安装成为可选的。</p>
<p>5.65libc*.bbclass
这些libc*类支持构建包的配方libc：</p>
<p>该类libc-common为使用 libc.</p>
<p>该类libc-package支持打包glibc和 eglibc.</p>
<p>5.66license.bbclass
该类license提供许可证清单创建和许可证排除。默认情况下，使用INHERIT_DISTRO变量的默认值启用此类。</p>
<p>5.67linux-kernel-base.bbclass
该类linux-kernel-base为从 Linux 内核源代码树构建的配方提供通用功能。这些构建超出了内核本身。例如，Perf 配方也继承了这个类。</p>
<p>5.68linuxloader.bbclass
提供函数linuxloader()，它给出了平台上提供的动态加载器/链接器的值。该值被许多其他类使用。</p>
<p>5.69logging.bbclass
该类logging提供用于记录各种 BitBake 严重级别（即、 、bbplain、 bbnote和bbwarn）的消息的标准 shell 函数。bberrorbbfatalbbdebug</p>
<p>该类默认启用，因为它是由base 该类继承的。</p>
<p>5.70metadata_scm.bbclass
该类metadata_scm提供了查询源代码管理器 (SCM) 存储库的分支和修订的功能。</p>
<p>基类使用此类在开始每次构建之前打印每一层的修订。该类 metadata_scm默认启用，因为它是由base该类继承的。</p>
<p>5.71migrate_localcount.bbclass
该类migrate_localcount验证配方的 localcount 数据并适当地增加它。</p>
<p>5.72mime.bbclass
该类mime为安装 MIME 类型文件的包生成正确的安装后和删除后 (postinst/postrm) 脚本。这些小脚本调用update-mime-database以将 MIME 类型添加到共享数据库。</p>
<p>5.73mirrors.bbclass
该类为源代码镜像mirrors设置了一些标准 的MIRRORS条目。如果配方中SRC_URI中指定的上游源不可用，这些镜像提供了一个备用路径。</p>
<p>此类默认启用，因为它是由 基类继承的。</p>
<p>5.74module.bbclass
该类module为构建树外 Linux 内核模块提供支持。该类继承了 module-base和 kernel-module-split类，并实现了do_compile和 do_install任务。该类提供了构建和打包内核模块所需的一切。</p>
<p>有关 out-of-tree Linux 内核模块的一般信息，请参阅 Yocto Project Linux Kernel Development Manual 中的“ Incorporating Out-of-Tree Modules ”部分。</p>
<p>5.75module-base.bbclass
该类module-base提供了构建 Linux 内核模块的基本功能。通常，构建包含一个或多个内核模块并具有自己构建模块的方法的软件的配方会继承此类，而不是继承 模块类。</p>
<p>5.76multilib*.bbclass
这些multilib*类支持构建具有不同目标优化或目标体系结构的库，并将它们并排安装在同一映像中。</p>
<p>有关使用 Multilib 功能的更多信息，请参阅 Yocto 项目开发任务手册中的“将多个版本的库文件组合到一个图像中”部分。</p>
<p>5.77native.bbclass
该类为构建工具以在构建主机上运行（即使用编译器或来自构建主机的其他工具的工具）native的配方提供通用功能。</p>
<p>您可以创建一个配方来构建在主机上本地运行的工具，有几种不同的方式：</p>
<p>创建一个myrecipe-native.bb继承native 类的配方。如果使用此方法，则必须将配方中的继承语句排序在所有其他继承语句之后，以便 native最后继承该类。</p>
<p>笔记</p>
<p>以这种方式创建配方时，配方名称必须遵循以下命名约定：</p>
<p>myrecipe-native.bb
不使用此命名约定可能会导致由依赖于该命名约定的现有代码引起的微妙问题。</p>
<p>创建或修改包含以下内容的目标配方：</p>
<p>BBCLASSEXTEND = “native”
在配方中，使用:class-native和:class-target覆盖来指定特定于各自本机或目标案例的任何功能。</p>
<p>尽管应用方式不同，但native该类与这两种方法一起使用。第二种方法的优点是您不需要为本地和目标设置两个单独的配方（假设您都需要）。配方的所有常见部分都会自动共享。</p>
<p>5.78nativesdk.bbclass
该类nativesdk为希望构建工具以作为 SDK 的一部分运行的配方提供通用功能（即在 SDKMACHINE上运行的工具）。</p>
<p>您可以创建一个配方，以几种不同的方式构建在 SDK 机器上运行的工具：</p>
<p>创建一个nativesdk-myrecipe.bb继承 nativesdk类的配方。如果使用此方法，则必须将配方中的继承语句排序在所有其他继承语句之后，以便nativesdk最后继承该类。</p>
<p>nativesdk通过添加以下内容创建任何配方的变体：</p>
<p>BBCLASSEXTEND = “nativesdk”
在配方中，使用:class-nativesdk和:class-target覆盖来指定特定于相应 SDK 机器或目标案例的任何功能。</p>
<p>笔记</p>
<p>创建配方时，您必须遵循以下命名约定：</p>
<p>nativesdk-myrecipe.bb
不这样做可能会导致微妙的问题，因为存在依赖于命名约定的代码。</p>
<p>尽管应用方式不同，但nativesdk该类与这两种方法一起使用。第二种方法的优点是您不需要为 SDK 机器和目标提供两个单独的配方（假设您都需要）。配方的所有常见部分都会自动共享。</p>
<p>5.79nopackages.bbclass
禁用那些不需要打包的配方和类的打包任务。</p>
<p>5.80npm.bbclass
为构建使用节点包管理器 (NPM)获取的 Node.js 软件提供支持。</p>
<p>笔记</p>
<p>目前，继承此类的配方必须使用npm:// fetcher 来自动获取和打包依赖项。</p>
<p>有关如何创建 NPM 包的信息，请参阅 Yocto 项目开发任务手册中的“创建节点包管理器 (NPM) 包”部分。</p>
<p>5.81oelint.bbclass
该类是Source Directory中oelint可用的过时 lint 检查工具 。meta/classes</p>
<p>有些类在 OE-Core 中通常很有用，但在 OE-Core 本身中从未真正使用过。oelint类就是这样一个例子。然而，了解这个类可以减少跨多个层的相似类的不同版本的扩散。</p>
<p>5.82overlayfs.bbclass
在嵌入式系统设计中通常需要一个只读的根文件系统。但是许多不同的应用程序可能希望对文件系统的某些部分具有读写访问权限。当您的更新机制覆盖整个根文件系统时，它可能特别有用，但您可能希望在更新之间保留您的应用程序数据。overlayfs类提供了一种方法来实现这一点，同时overlayfs保持基本根文件系统为只读。</p>
<p>要使用此类，overlayfs请为将用作机器配置中上层的分区设置挂载点。底层文件系统可以是overlayfs. 这必须在您的机器配置中完成：</p>
<p>OVERLAYFS_MOUNT_POINT[data] = “/data”
笔记</p>
<p>如果您在配方中重新定义此变量，QA 检查将无法捕获文件存在！</p>
<p>仅检查 systemd 挂载单元文件的存在，而不检查其内容。</p>
<p>要了解更多关于overlayfs其内部结构和支持的操作的详细信息，请参阅Linux 内核的官方文档。</p>
<p>该类假定您data.mount在 BSP 的其他地方（例如在systemd-machine-units配方中）定义了一个 systemd 单元，并且它已安装到映像中。</p>
<p>然后，您可以根据配方指定可写目录（例如在 my-application.bb 中）：</p>
<p>OVERLAYFS_WRITABLE_PATHS[data] = “/usr/share/my-custom-application”
要支持多个挂载点，您可以使用不同的变量标志。假设我们想在文件系统上有一个可写位置，但不需要数据在重新启动后仍然存在，那么我们可以有一个 文件系统mnt-overlay.mount单元。tmpfs</p>
<p>在您的机器配置中：</p>
<p>OVERLAYFS_MOUNT_POINT[mnt-overlay] = “/mnt/overlay”
然后在你的食谱中：</p>
<p>OVERLAYFS_WRITABLE_PATHS[mnt-overlay] = “/usr/share/another-application”
实际上，您的应用程序配方可能需要在运行之前挂载多个覆盖，以避免写入底层文件系统（在只读文件系统的情况下可能会被禁止）为了实现这一点，overlayfs提供了一个systemd 用于挂载覆盖的辅助服务. 这个帮助服务被命名 并且可以在你的应用程序配方（在以下示例中${PN}-overlays.service命名）单元中被依赖，方法是向单元添加以下内容：applicationsystemd</p>
<p>[Unit]
After=application-overlays.service
Requires=application-overlays.service
笔记</p>
<p>该类不支持/etc目录本身，因为systemd依赖于它。为了进入/etcoverlayfs，请参阅overlayfs-etc。</p>
<p>5.83overlayfs-etc.bbclass
为了/etc在 overlayfs 中有目录，需要在早期引导阶段进行特殊处理。这个想法是提供一个自定义的 init 脚本， /etc在启动实际的 init 程序之前挂载，因为后者已经需要/etc挂载。</p>
<p>图像配方中的示例用法：</p>
<p>IMAGE_FEATURES += “overlayfs-etc”
笔记</p>
<p>这个类不能直接继承。使用IMAGE_FEATURES或EXTRA_IMAGE_FEATURES</p>
<p>您的机器配置应至少定义您将用于的设备、挂载点和文件系统类型overlayfs：</p>
<p>OVERLAYFS_ETC_MOUNT_POINT = “/data”
OVERLAYFS_ETC_DEVICE = “/dev/mmcblk0p2”
OVERLAYFS_ETC_FSTYPE ?= “ext4”
要控制更多挂载选项，您应该考虑设置挂载选项（defaults默认使用）：</p>
<p>OVERLAYFS_ETC_MOUNT_OPTIONS = “wsync”
该类提供了两个/sbin/init生成选项：</p>
<p>默认选项是将原始名称重命名为/sbin/init并将/sbin/init.orig 生成的 init 放在原始名称下，即/sbin/init. 它的优点是您无需更改任何内核参数即可使其工作，但它带来了无法使用包管理的限制，因为更新 init 管理器会删除生成的脚本。</p>
<p>如果你想保持原来的初始化，你可以设置：</p>
<p>OVERLAYFS_ETC_USE_ORIG_INIT_NAME = “0”
然后生成的 init 将被命名/sbin/preinit，您需要在引导加载程序配置中手动扩展内核参数。</p>
<p>5.84own-mirrors.bbclass
该类own-mirrors可以更轻松地设置您自己的 PREMIRRORS ，在尝试从每个配方中SRC_URI中指定的上游获取源之前，首先从中获取源 。</p>
<p>要使用此类，请全局继承它并指定 SOURCE_MIRROR_URL。这是一个例子：</p>
<p>INHERIT += “own-mirrors”
SOURCE_MIRROR_URL = “<a class="reference external" href="http://example.com/my-source-mirror">http://example.com/my-source-mirror</a>”
您只能在SOURCE_MIRROR_URL中指定一个 URL 。</p>
<p>5.85package.bbclass
该类package支持从构建的输出生成包。核心通用功能位于package.bbclass. 特定包类型的特定代码驻留在这些包特定类中： package_deb、 package_rpm、 package_ipk和 package_tar。</p>
<p>笔记</p>
<p>package_tar 类已损坏且不受支持。建议您不要使用此类。</p>
<p>您可以使用配置文件中定义的PACKAGE_CLASSES变量来控制生成的包格式列表，该 变量conf/local.conf 位于Build Directory中。定义变量时，可以指定一种或多种包类型。由于图像是从包中生成的，因此需要一个包装类来启用图像生成。此变量中列出的第一个类用于图像生成。</p>
<p>如果您采取可选步骤在 DNF 可以使用的开发主机上设置存储库（包提要），您可以在目标上运行映像时从提要安装包（即包的运行时安装）。有关详细信息，请参阅 Yocto 项目开发任务手册中的“使用运行时包管理”部分。</p>
<p>您选择的特定于包的类会影响构建时性能并具有空间影响。一般来说，与使用 RPM 构建相同或相似的软件包相比，使用 IPK 构建软件包所需的时间减少了大约 30%。此比较考虑了包的完整构建以及之前构建的所有依赖项。这种差异的原因是因为 RPM 包管理器创建和处理的元数据比 IPK 包管理器多。因此，如果您正在构建较小的系统，您可能会考虑将PACKAGE_CLASSES设置为“package_ipk”。</p>
<p>但是，在做出包管理器决定之前，您应该考虑一些关于使用 RPM 的进一步事项：</p>
<p>RPM 开始提供比 IPK 更多的功能，因为它处理更多的元数据。例如，此信息包括单个文件类型、文件校验和生成和安装评估、稀疏文件支持、Multilib 系统的冲突检测和解决、ACID 样式升级以及回滚的重新打包能力。</p>
<p>对于较小的系统，用于伯克利数据库的额外空间和使用 RPM 时的元数据量会影响您执行设备上升级的能力。</p>
<p>您可以在这两个 Yocto Project 邮件列表链接中找到有关包类效果的更多信息：</p>
<p><a class="reference external" href="https://lists.yoctoproject.org/pipermail/poky/2011-May/006362.html">https://lists.yoctoproject.org/pipermail/poky/2011-May/006362.html</a></p>
<p><a class="reference external" href="https://lists.yoctoproject.org/pipermail/poky/2011-May/006363.html">https://lists.yoctoproject.org/pipermail/poky/2011-May/006363.html</a></p>
<p>5.86package_deb.bbclass
该类package_deb支持创建使用 Debian (ie .deb) 文件格式的包。该类确保包以.deb文件格式 写入${DEPLOY_DIR_DEB}目录。</p>
<p>此类继承包类，并通过文件中的PACKAGE_CLASSES 变量启用local.conf。</p>
<p>5.87package_ipk.bbclass
该类package_ipk支持创建使用 IPK（即.ipk）文件格式的包。该类确保包以.ipk文件格式 写入${DEPLOY_DIR_IPK}目录。</p>
<p>此类继承包类，并通过文件中的PACKAGE_CLASSES 变量启用local.conf。</p>
<p>5.88package_rpm.bbclass
该类package_rpm支持创建使用 RPM（即.rpm）文件格式的包。该类确保包以.rpm文件格式 写入${DEPLOY_DIR_RPM}目录。</p>
<p>此类继承包类，并通过文件中的PACKAGE_CLASSES 变量启用local.conf。</p>
<p>5.89package_tar.bbclass
该类package_tar提供对创建 tarball 的支持。该类确保包以 tarball 格式写入 ${DEPLOY_DIR_TAR}目录。</p>
<p>此类继承包类，并通过文件中的PACKAGE_CLASSES 变量启用local.conf。</p>
<p>笔记</p>
<p>您不能package_tar首先使用 PACKAGE_CLASSES变量指定类。您的图像或 SDK 必须使用.deb、.ipk或.rpm 文件格式。</p>
<p>5.90packagedata.bbclass
该类packagedata提供了用于读取 pkgdata在PKGDATA_DIR中找到的文件的通用功能。这些文件包含有关 OpenEmbedded 构建系统生成的每个输出包的信息。</p>
<p>该类默认启用，因为它是由 包类继承的。</p>
<p>5.91packagegroup.bbclass
该类packagegroup设置适用于包组配方的默认值（例如PACKAGES、PACKAGE_ARCH、ALLOW_EMPTY等）。强烈建议所有包组配方都继承这个类。</p>
<p>有关如何使用此类的信息，请参阅Yocto 项目开发任务手册中的“使用自定义包组自定义图像”部分。</p>
<p>以前，这个类被称为task类。</p>
<p>5.92patch.bbclass
该类提供了在do_patch任务patch期间应用补丁的所有功能。</p>
<p>此类默认启用，因为它是由 基类继承的。</p>
<p>5.93perlnative.bbclass
当被配方继承时，perlnative该类支持使用由构建系统构建的本机版本的 Perl，而不是使用构建主机提供的版本。</p>
<p>5.94pixbufcache.bbclass
该类pixbufcache为安装 pixbuf 加载器的包生成正确的安装后和删除后 (postinst/postrm) 小脚本，与gdk-pixbuf. 这些 scriptlet 调用update_pixbuf_cache以将 pixbuf 加载程序添加到缓存中。由于缓存文件是特定于体系结构的，update_pixbuf_cache 如果在创建映像期间需要在构建主机上运行 postinst 脚本，则使用 QEMU 运行。</p>
<p>如果要安装的 pixbuf 加载器位于配方主包以外的包中，请设置 PIXBUF_PACKAGES以指定包含加载器的包。</p>
<p>5.95pkgconfig.bbclass
该类pkgconfig提供了一种标准方法来使用pkg-config. 此类旨在平滑集成pkg-config到使用它的库中。</p>
<p>在暂存期间，BitBake 将pkg-config数据安装到 sysroots/目录中。通过使用 sysroot 中的功能 pkg-config，pkgconfig该类不再需要操作文件。</p>
<p>5.96populate_sdk.bbclass
该类populate_sdk提供对仅 SDK 配方的支持。有关使用do_populate_sdk 任务构建交叉开发工具链时获得的优势的信息，请参阅 Yocto 项目应用程序开发和可扩展软件开发工具包 (eSDK) 手册中的“构建 SDK 安装程序”部分。</p>
<p>5.97populate_sdk_*.bbclass
这些populate_sdk_*类支持 SDK 创建并由以下类组成：</p>
<p>populate_sdk_base：所有包管理器（即DEB、RPM、opkg）下支持SDK创建的基类。</p>
<p>populate_sdk_deb: 支持基于 Debian 包管理器创建 SDK。</p>
<p>populate_sdk_rpm: 支持创建给定 RPM 包管理器的 SDK。</p>
<p>populate_sdk_ipk：支持在给定 opkg（IPK 格式）包管理器的情况下创建 SDK。</p>
<p>populate_sdk_ext：支持在所有包管理器下创建可扩展的 SDK。</p>
<p>该类基于 IMAGE_PKGTYPEpopulate_sdk_base继承适当的 populate_sdk_*（即deb、rpm和） 。ipk</p>
<p>基类确保建立所有源目录和目标目录，然后填充 SDK。填充 SDK 后， populate_sdk_base该类构建两个 sysroot： ${SDK_ARCH}-nativesdk包含交叉编译器和相关工具，以及 target 包含为 SDK 使用配置的目标根文件系统。这两个图像位于SDK_OUTPUT中，其中包含以下内容：</p>
<p>${SDK_OUTPUT}/${SDK_ARCH}-nativesdk-pkgs
${SDK_OUTPUT}/${SDKTARGETSYSROOT}/target-pkgs
最后，基础填充 SDK 类创建工具链环境设置脚本、SDK 的压缩包和安装程序。</p>
<p>各自populate_sdk_deb的populate_sdk_rpm、 和 populate_sdk_ipk类都支持特定类型的 SDK。这些类由该类继承并与populate_sdk_base 该类一起使用。</p>
<p>有关交叉开发工具链生成的更多信息，请参阅 Yocto 项目概述和概念手册中的“交叉开发工具链生成”部分。有关使用do_populate_sdk 任务构建交叉开发工具链时获得的优势的信息，请参阅 Yocto 项目应用程序开发和可扩展软件开发工具包 (eSDK) 手册中的“构建 SDK 安装程序”部分。</p>
<p>5.98prexport.bbclass
该类prexport提供导出 PR值的功能。</p>
<p>笔记</p>
<p>此类不打算直接使用。而是在使用“ ”时启用。bitbake-prserv-tool export</p>
<p>5.99primport.bbclass
该类primport提供了用于导入 PR值的功能。</p>
<p>笔记</p>
<p>此类不打算直接使用。而是在使用“ ”时启用。bitbake-prserv-tool import</p>
<p>5.100prserv.bbclass
该类prserv提供使用PR 服务的功能，以便自动管理 每个配方的PR变量的递增。</p>
<p>该类默认启用，因为它是由 包类继承的。但是，除非设置了PRSERV_HOST，否则 OpenEmbedded 构建系统将不会启用此类的功能 。</p>
<p>5.101ptest.bbclass
该类ptest为构建提供这些测试的软件的配方提供了打包和安装运行时测试的功能。</p>
<p>此类旨在由各个配方继承。但是，除非“ptest”出现在DISTRO_FEATURES中，否则该类的功能在很大程度上被禁用 。有关 ptest 的更多信息，请参阅 Yocto 项目开发任务手册中的“使用 ptest 测试包”部分。</p>
<p>5.102ptest-gnome.bbclass
启用专门针对 GNOME 包的包测试 (ptests)，这些包的测试旨在使用gnome-desktop-testing.</p>
<p>有关设置和运行 ptest 的信息，请参阅 Yocto 项目开发任务手册中的“使用 ptest 测试包”部分。</p>
<p>5.103python3-dir.bbclass
该类python3-dir提供 Python 3 的基本版本、位置和站点包位置。</p>
<p>5.104python3native.bbclass
该类python3native支持使用构建系统构建的 Python 3 的本机版本，而不是支持构建主机提供的版本。</p>
<p>5.105python3targetconfig.bbclass
该类python3targetconfig支持使用构建系统构建的 Python 3 的本机版本，而不是支持构建主机提供的版本，除了目标机器的配置是可访问的（例如正确的安装目录）。这也增加了对 target 的依赖python3，因此只能在适当的地方使用，以避免不必要地延长构建。</p>
<p>5.106qemu.bbclass
该类qemu为需要 QEMU 或测试 QEMU 存在的配方提供功能。通常，此类用于使用 QEMU 的应用程序仿真模式在构建主机上为目标系统运行程序。</p>
<p>5.107recipe_sanity.bbclass
该类recipe_sanity检查是否存在任何可能影响构建的主机系统配方先决条件（例如，设置的变量或存在的软件）。</p>
<p>5.108relocatable.bbclass
当relocatable二进制文件安装到 sysroot 中时，该类允许重新定位二进制文​​件。</p>
<p>此类使用chrpath类，并由交叉类和 本地类使用。</p>
<p>5.109remove-libtool.bbclass
该类向do_installremove-libtool任务添加了一个 post 函数， 以删除由. 删除这些文件会导致它们在 sysroot 和目标包中都不存在。.lalibtool</p>
<p>如果配方需要.la安装文件，则配方可以通过设置REMOVE_LIBTOOL_LA为“0”来覆盖删除，如下所示：</p>
<p>REMOVE_LIBTOOL_LA = “0”
笔记</p>
<p>remove-libtool默认情况下不启用该类。</p>
<p>5.110report-error.bbclass
该类report-error支持启用“错误报告工具”，它允许您将构建错误信息提交到中央数据库。</p>
<p>该类收集配方、配方版本、任务、机器、发行版、构建系统、目标系统、主机发行版、分支、提交和日志的调试信息。根据这些信息，使用 JSON 格式的报告文件被创建并存储在 ${LOG_DIR}/error-report中。</p>
<p>5.111rm_work.bbclass
该类rm_work支持删除临时工作区，这可以减轻您在构建过程中对硬盘的需求。</p>
<p>OpenEmbedded 构建系统可以在构建过程中使用大量磁盘空间。该空间的一部分是${TMPDIR}/work每个配方目录下的工作文件。一旦构建系统为配方生成了包，就不再需要该配方的工作文件。但是，默认情况下，构建系统会保留这些文件以供检查和可能的调试目的。如果您希望在构建过程中删除这些文件以节省磁盘空间，您可以rm_work通过将以下内容添加到您的local.conf文件中来启用，该文件位于构建目录中。</p>
<p>INHERIT += “rm_work”
如果您正在修改和构建配方的工作目录之外的源代码，启用rm_work可能会导致您对源的更改丢失。要排除某些配方的工作目录被 删除rm_work，您可以将您正在处理的一个或多个配方的名称添加到RM_WORK_EXCLUDE变量中，该变量也可以在您的local.conf文件中设置。这是一个例子：</p>
<p>RM_WORK_EXCLUDE += “busybox glibc”
5.112rootfs*.bbclass
这些rootfs*类支持为图像创建根文件系统，并由以下类组成：</p>
<p>该类rootfs-postcommands定义了图像配方的文件系统后处理功能。</p>
<p>该类支持为使用包rootfs_deb构建的图像创建根文件系统。.deb</p>
<p>该类支持为使用包rootfs_rpm构建的图像创建根文件系统。.rpm</p>
<p>该类支持为使用包rootfs_ipk构建的图像创建根文件系统。.ipk</p>
<p>该类rootfsdebugfiles将在构建主机上找到的附加文件直接安装到根文件系统中。</p>
<p>根文件系统是使用由PACKAGE_CLASSES变量rootfs*.bbclass确定 的文件之一从包创建的 。</p>
<p>有关如何创建根文件系统映像的信息，请参阅 Yocto 项目概述和概念手册中的“映像生成”部分。</p>
<p>5.113sanity.bbclass
该类sanity检查主机系统上是否存在必备软件，以便通知用户可能影响其构建的潜在问题。该类还从local.conf配置文件执行基本的用户配置检查，以防止导致构建失败的常见错误。分发策略通常决定是否包含这个类。</p>
<p>5.114scons.bbclass
该类scons支持需要构建使用 SCons 构建系统的软件的配方。您可以使用 EXTRA_OESCONS变量来指定要传递给 SCons 命令行的其他配置选项。</p>
<p>5.115sdl.bbclass
该类sdl支持需要构建使用简单 DirectMedia 层 (SDL) 库的软件的配方。</p>
<p>5.116setuptools3.bbclass
该类setuptools3支持使用基于setuptools. 如果您的配方使用这些构建系统，则配方需要继承setuptools3该类。</p>
<p>5.117setuptools3-base.bbclass
该类setuptools3-base为支持构建 Python 3.x 版扩展的其他类提供了可重用的基础。如果您需要setuptools3类未提供的功能，您可能需要. 有些配方不需要setuptools3类中的任务，而是继承这个类。inherit setuptools3-base</p>
<p>5.118sign_rpm.bbclass
该类sign_rpm支持生成签名的 RPM 包。</p>
<p>5.119sip.bbclass
该类sip支持构建或打包基于 SIP 的 Python 绑定的配方。</p>
<p>5.120siteconfig.bbclass
该类siteconfig提供处理站点配置的功能。autotools类使用 该类来加速 do_configure任务。</p>
<p>5.121siteinfo.bbclass
该类siteinfo提供有关其他类或配方可能需要的目标的信息。</p>
<p>例如，考虑 Autotools，它可能需要必须在目标硬件上执行的测试。由于这在交叉编译时通常是不可能的，因此站点信息用于提供缓存的测试结果，因此可以跳过这些测试，但仍然可以提供正确的值。包含分类为不同类别的测试结果，例如架构、字节序和使用。站点信息提供了一个文件列表，其中包含与 Autotools 自动获取的CONFIG_SITE变量中的当前构建相关的数据。meta/site directorylibc</p>
<p>该类还提供了SITEINFO_ENDIANNESS和 SITEINFO_BITS等变量，可以在元数据的其他地方使用。</p>
<p>5.122sstate.bbclass
该类sstate提供对共享状态 (sstate) 的支持。默认情况下，通过 INHERIT_DISTRO变量的默认值启用该类。</p>
<p>有关 sstate 的更多信息，请参阅 Yocto 项目概述和概念手册中的“共享状态缓存”部分。</p>
<p>5.123staging.bbclass
该类staging将文件安装到 sysroot 的各个配方工作目录中。该课程包含以下关键任务：</p>
<p>do_populate_sysroot任务，负责处理最终在配方 sysroot 中的文件。</p>
<p>do_prepare_recipe_sysroot 任务（ 任务的“伙伴”populate_sysroot任务），它将文件安装到各个配方工作目录（即 WORKDIR）。</p>
<p>类中的代码staging很复杂，基本上分两个阶段工作：</p>
<p>第一阶段：第一阶段处理具有要与其他依赖于原始配方的配方共享文件的配方。通常这些依赖项是通过do_install任务安装到 ${D}中的。该do_populate_sysroot任务将这些文件的一个子集复制到${SYSROOT_DESTDIR}. 此文件子集由 SYSROOT_DIRS、 SYSROOT_DIRS_NATIVE和 SYSROOT_DIRS_BLACKLIST 变量控制。</p>
<p>笔记</p>
<p>此外，配方可以通过在SYSROOT_PREPROCESS_FUNCS 变量中声明处理函数来进一步自定义文件。</p>
<p>共享状态 (sstate) 对象是从这些文件构建的，这些文件放置在 build/tmp/sysroots-components/的子​​目录中。扫描文件以查找原始安装位置的硬编码路径。如果在文本文件中找到该位置，则硬编码的位置将被标记替换，并创建需要此类替换的文件列表。这些调整被称为“FIXME”。扫描路径的文件列表由SSTATE_SCAN_FILES 变量控制。</p>
<p>第二阶段：第二阶段解决想要使用另一个配方中的某些内容的配方，并通过DEPENDS变量声明对该配方的依赖关系。配方将有一个 do_prepare_recipe_sysroot 任务，当该任务执行时，它会在配方工作目录（即 WORKDIR）中创建recipe-sysroot and 。OpenEmbedded 构建系统从配方工作目录创建到相关文件副本的硬链接 。recipe-sysroot-nativesysroots-components</p>
<p>笔记</p>
<p>如果无法进行硬链接，则构建系统将使用实际副本。</p>
<p>然后，构建系统将任何“FIXME”寻址到从第一阶段创建的列表中定义的路径。</p>
<p>最后，${bindir}系统根目录中所有前缀为“ postinst-”的文件都会被执行。</p>
<p>笔记</p>
<p>尽管不建议将此类 sysroot 安装后脚本用于一般用途，但这些文件确实允许解决一些问题，例如用户创建和模块索引。</p>
<p>因为配方可以在DEPENDS之外有其他依赖项 （例如），所以还添加了 sysroot 创建函数作为那些依赖项不是通过 DEPENDS但操作类似的任务的前置函数。do_unpack[depends] += “tar-native:do_populate_sysroot”extend_recipe_sysroot</p>
<p>将依赖项安装到 sysroot 中时，代码会遍历依赖关系图并以与从 sstate 安装依赖项的方式完全相同的方式处理依赖项。这种处理意味着，例如，本机工具将添加其本机依赖项，​​但目标库不会遍历或安装其依赖项。使用相同的 sstate 依赖代码，因此无论是否使用 sstate，构建都应该是相同的。要仔细查看，请参阅 sstate类setscene_depvalid()中的函数 。</p>
<p>构建系统会小心维护它安装的文件的清单，以便可以根据需要安装任何给定的依赖项。已安装项目的 sstate 哈希也被存储，因此如果它发生变化，构建系统可以重新安装它。</p>
<p>5.124syslinux.bbclass
该类syslinux提供用于构建可引导映像的 syslinux 特定功能。</p>
<p>该类支持以下变量：</p>
<p>INITRD：指示要连接并用作初始 RAM 磁盘 (initrd) 的文件系统映像列表。这个变量是可选的。</p>
<p>ROOTFS：指示要作为根文件系统包含的文件系统映像。这个变量是可选的。</p>
<p>AUTO_SYSLINUXMENU：设置为“1”时启用创建自动菜单。</p>
<p>标签：列出自动配置的目标。</p>
<p>APPEND：列出每个标签的附加字符串覆盖。</p>
<p>SYSLINUX_OPTS：列出要添加到 syslinux 文件的其他选项。分号字符分隔多个选项。</p>
<p>SYSLINUX_SPLASH：当您使用启动菜单时，列出 VGA 启动菜单的背景。</p>
<p>SYSLINUX_DEFAULT_CONSOLE：设置为“console=ttyX”以更改内核引导默认控制台。</p>
<p>SYSLINUX_SERIAL：设置备用串行端口。或者，当变量设置为空字符串时关闭串行。</p>
<p>SYSLINUX_SERIAL_TTY：设置备用“console=tty…”内核引导参数。</p>
<p>5.125systemd.bbclass
该类systemd为安装 systemd 单元文件的配方提供支持。</p>
<p>除非您在DISTRO_FEATURES中有“systemd”，否则此类的功能将被禁用。</p>
<p>在此类下，配方或 Makefile（即在do_install任务期间调用的任何配方）将单元文件安装到 ${D}${systemd_unitdir}/system中。如果正在安装的单元文件进入主包以外的包中，则需要在配方中设置SYSTEMD_PACKAGES以标识将安装文件的包。</p>
<p>您应该将SYSTEMD_SERVICE设置为服务文件的名称。您还应该使用包名称覆盖来指示该值适用的包。如果该值适用于配方的主包，请使用${PN}。这是 connman 食谱中的一个示例：</p>
<p>SYSTEMD_SERVICE:${PN} = “connman.service”
除非您将SYSTEMD_AUTO_ENABLE设置为“禁用”，否则服务设置为在启动时自动启动 。</p>
<p>有关 的更多信息systemd，请参阅 Yocto 项目开发任务手册中的“选择初始化管理器”部分。</p>
<p>5.126systemd-boot.bbclass
该类systemd-boot提供特定于 systemd-boot 引导加载程序的功能，用于构建可引导映像。这是一个内部类，不打算直接使用。</p>
<p>笔记</p>
<p>该类systemd-boot是将gummiboot以前 Yocto Project 版本中使用的类与systemd项目合并的结果。</p>
<p>将EFI_PROVIDER变量设置为“systemd-boot”以使用此类。这样做会创建一个不依赖于 systemd 的独立 EFI 引导加载程序。</p>
<p>有关此类中使用和支持的更多变量的信息，请参阅SYSTEMD_BOOT_CFG、 SYSTEMD_BOOT_ENTRIES和 SYSTEMD_BOOT_TIMEOUT变量。</p>
<p>您还可以查看Systemd-boot 文档 以获取更多信息。</p>
<p>5.127terminal.bbclass
该类terminal提供对启动终端会话的支持。OE_TERMINAL变量控制会话使用哪个终端仿真器。</p>
<p>其他类在terminal需要启动单独的终端会话的任何地方使用该类。例如， 假设 PATCHRESOLVE设置为“user”的 补丁类， cml1类和 devshell类都使用 该类。terminal</p>
<p>5.128testimage*.bbclass
这些testimage*类支持使用 QEMU 和在实际硬件上针对图像运行自动化测试。这些类处理加载测试和启动图像。要使用这些类，您需要执行设置环境的步骤。</p>
<p>笔记</p>
<p>最佳实践包括使用IMAGE_CLASSES而不是 INHERIT来继承testimage用于自动图像测试的类。</p>
<p>测试是在目标系统上运行的命令ssh。每个测试都用 Python 编写并使用该unittest模块。</p>
<p>使用以下testimage.bbclass命令调用图像时运行测试：</p>
<p>$ bitbake -c testimage image
构建图像后，该类testimage-auto对图像运行测试（即 TESTIMAGE_AUTO必须设置为“1”）。</p>
<p>有关如何启用、运行和创建新测试的信息，请参阅 Yocto 项目开发任务手册中的“执行自动化运行时测试”部分。</p>
<p>5.129testsdk.bbclass
此类支持针对软件开发工具包 (SDK) 运行自动化测试。该类testsdk在使用以下命令调用时在 SDK 上运行测试：</p>
<p>$ bitbake -c testsdk image
笔记</p>
<p>最佳实践包括使用IMAGE_CLASSES而不是 INHERIT来继承testsdk类以进行自动化 SDK 测试。</p>
<p>5.130texinfo.bbclass
此类应由其上游包texinfo在构建时调用实用程序的配方继承。本机和交叉配方使用 提供的虚拟脚本texinfo-dummy-native，以提高性能。目标架构配方使用真正的 Texinfo 实用程序。默认情况下，他们使用主机系统上的 Texinfo 实用程序。</p>
<p>笔记</p>
<p>如果您想使用构建系统附带的 Texinfo 配方，您可以从 ASSUME_PROVIDED 中删除“texinfo-native”并从SANITY_REQUIRED_UTILITIES中删除makeinfo 。</p>
<p>5.131toaster.bbclass
该类toaster收集有关包和图像的信息，并将它们作为 BitBake 用户界面可以接收的事件发送。该类在 Toaster 用户界面运行时启用。</p>
<p>此类不打算直接使用。</p>
<p>5.132toolchain-scripts.bbclass
该类toolchain-scripts提供了用于为已安装的 SDK 设置环境的脚本。</p>
<p>5.133typecheck.bbclass
该类typecheck支持根据其定义的类型验证在配置级别设置的变量的值。OpenEmbedded 构建系统允许您使用“type”varflag 定义变量的类型。这是一个例子：</p>
<p>IMAGE_FEATURES[type] = “list”
5.134uboot-config.bbclass
该类uboot-config为机器的 U-Boot 配置提供支持。在您的配方中指定机器，如下所示：</p>
<p>UBOOT_CONFIG ??= &lt;default&gt;
UBOOT_CONFIG[foo] = “config,images”
您还可以使用此方法指定机器：</p>
<p>UBOOT_MACHINE = “config”
有关其他信息，请参阅UBOOT_CONFIG和UBOOT_MACHINE变量。</p>
<p>5.135uninative.bbclass
尝试将构建系统与主机发行版的 C 库隔离，以便在不同的主机发行版之间重复使用本机共享状态工件。启用此类后，将在构建开始时下载包含预构建 C 库的 tarball。在 Poky 参考发行版中，默认情况下通过meta/conf/distro/include/yocto-uninative.inc. 其他不是从 poky 派生的发行版也可以“ ”使用它。或者，如果您愿意，您可以自己构建 uninative-tarball 配方，发布生成的 tarball（例如通过 HTTP）并 进行适当的设置。例如，请参阅.require conf/distro/include/yocto-uninative.incUNINATIVE_URLUNINATIVE_CHECKSUMmeta/conf/distro/include/yocto-uninative.inc</p>
<p>可扩展 SDK 也无条件使用uninative该类。在构建可扩展 SDK 时，uninative-tarball会构建并且生成的 tarball 包含在 SDK 中。</p>
<p>5.136update-alternatives.bbclass
当多个源提供相同的命令时，update-alternatives该类有助于替代系统。当使用相同名称安装多个具有相同或相似功能的程序时，就会出现这种情况。例如，该ar命令可从busybox,binutils和elfutils包中获得。该类 update-alternatives处理重命名二进制文件，以便可以安装多个包而不会发生冲突。无论安装或随后删除了哪些软件包，该ar命令仍然有效。该类重命名每个包中的冲突二进制文件，并在安装或删除包期间符号链接最高优先级的二进制文件。</p>
<p>要使用这个类，你需要定义一些变量：</p>
<p>选择</p>
<p>ALTERNATIVE_LINK_NAME</p>
<p>ALTERNATIVE_TARGET</p>
<p>ALTERNATIVE_PRIORITY</p>
<p>这些变量列出了包所需的替代命令，提供链接的路径名、目标的默认链接等等。有关如何使用此类的详细信息，请参阅 update-alternatives.bbclass 文件中的注释。</p>
<p>笔记</p>
<p>您可以update-alternatives直接在食谱中使用该命令。然而，这个类在大多数情况下简化了事情。</p>
<p>5.137update-rc.d.bbclass
该类update-rc.d用于update-rc.d代表包安全地安装初始化脚本。OpenEmbedded 构建系统负责处理细节，例如确保在删除包之前停止脚本并在安装包时启动脚本。</p>
<p>三个变量控制这个类：INITSCRIPT_PACKAGES、 INITSCRIPT_NAME和INITSCRIPT_PARAMS。有关详细信息，请参阅变量链接。</p>
<p>5.138useradd*.bbclass
这些useradd*类支持添加用户或组以供目标上的包使用。例如，如果您的包包含应在其自己的用户或组下运行的系统服务，则可以使用这些类来启用用户或组的创建。源目录中的meta-skeleton/recipes-skeleton/useradd/useradd-example.bb 配方提供了一个简单的示例，展示了如何将三个用户和组添加到两个包中。</p>
<p>该类useradd_base为用户或组设置提供基本功能。</p>
<p>这些useradd*类支持 USERADD_PACKAGES、 USERADD_PARAM、 GROUPADD_PARAM和 GROUPMEMS_PARAM变量。</p>
<p>该类useradd-staticids支持添加具有静态用户标识 ( uid) 和组标识 ( gid) 值的用户或组。</p>
<p>当包在包安装期间添加用户和组时，OpenEmbedded 构建系统用于分配uid和值的默认行为 是动态添加它们。gid这适用于不关心结果用户和组的值的程序。在这些情况下，安装顺序决定了最终值uid和gid值。但是，如果非确定性 uid和gid值是一个问题，您可以通过设置静态值来覆盖这些值的默认动态应用。当您设置静态值时，OpenEmbedded 构建系统会在 BBPATH 和文件中 查找这些值。files/passwdfiles/group</p>
<p>要使用静态uid和gid值，您需要设置一些变量。请参阅USERADDEXTENSION、 USERADD_UID_TABLES、 USERADD_GID_TABLES和 USERADD_ERROR_DYNAMIC变量。您还可以查看useradd类以获取更多信息。</p>
<p>笔记</p>
<p>您不useradd-staticids直接使用该类。您可以通过设置USERADDEXTENSION变量来启用或禁用该类。如果您在配置的系统中启用或禁用该类，TMPDIR可能包含不正确的uid和gid值。删除TMPDIR 目录将纠正这种情况。</p>
<p>5.139utility-tasks.bbclass
该类utility-tasks为适用于所有配方的各种“实用”类型任务提供支持，例如 do_clean和 do_listtasks。</p>
<p>此类默认启用，因为它是由 基类继承的。</p>
<p>5.140utils.bbclass
该类utils提供了一些有用的 Python 函数，这些函数通常用于内联 Python 表达式（例如${&#64;…}）。一个示例用途是 for bb.utils.contains()。</p>
<p>此类默认启用，因为它是由 基类继承的。</p>
<p>5.141vala.bbclass
该类vala支持需要构建使用 Vala 编程语言编写的软件的配方。</p>
<p>5.142waf.bbclass
该类waf支持需要构建使用 Waf 构建系统的软件的配方。您可以使用 EXTRA_OECONF或 PACKAGECONFIG_CONFARGS变量来指定要在 Waf 命令行上传递的其他配置选项。</p>
<p>6 个任务
任务是 BitBake 的执行单元。配方（.bb文件）使用任务来完成软件的配置、编译和打包。本章提供了 OpenEmbedded 构建系统中定义的任务的参考。</p>
<p>6.1普通配方构建任务
以下部分描述了与构建配方相关的常规任务。有关任务和依赖项的更多信息，请参阅 BitBake 用户手册中的“任务”和“依赖项”部分。</p>
<p>6.1.1do_build
所有配方的默认任务。此任务取决于构建配方所需的所有其他正常任务。</p>
<p>6.1.2do_compile
编译源代码。此任务在当前工作目录设置为${B}的情况下运行。</p>
<p>此任务的默认行为是在找到oe_runmake生成文件（Makefile、makefile或GNUmakefile）时运行该函数。如果没有找到这样的文件，该do_compile任务什么也不做。</p>
<p>6.1.3do_compile_ptest_base
编译包含在正在构建的软件中的运行时测试套件。</p>
<p>6.1.4do_configure
通过启用和禁用正在构建的软件的任何构建时间和配置选项来配置源。该任务在当前工作目录设置为${B}的情况下运行。</p>
<p>此任务的默认行为是在找到生成文件（、、或）且 CLEANBROKEN未设置为“1”时运行。如果未找到此类文件或CLEANBROKEN变量设置为“1”，则该 任务不执行任何操作。oe_runmake cleanMakefilemakefileGNUmakefiledo_configure</p>
<p>6.1.5do_configure_ptest_base
配置正在构建的软件中包含的运行时测试套件。</p>
<p>6.1.6do_deploy
将要部署的输出文件写入 ${DEPLOY_DIR_IMAGE}。该任务在当前工作目录设置为 ${B}的情况下运行。</p>
<p>实现此任务的配方应继承 部署类，并应将输出写入${DEPLOYDIR}，不要与${DEPLOY_DIR}. 部署类设置 do_deploy为共享状态 (sstate) 任务，可以通过使用 sstate 来加速。sstate 机制负责将输出从 复制${DEPLOYDIR}到${DEPLOY_DIR_IMAGE}。</p>
<p>笔记</p>
<p>不要将输出直接写入${DEPLOY_DIR_IMAGE}，因为这会导致 sstate 机制发生故障。</p>
<p>该do_deploy任务默认不作为任务添加，因此需要手动添加。如果您希望任务在do_compile之后运行，您可以通过执行以下操作来添加它：</p>
<p>addtask deploy after do_compile
do_deploy在其他任务之后添加的工作方式相同。</p>
<p>笔记</p>
<p>您不需要添加到命令中（尽管它是无害的），因为基类包含以下内容：before do_buildaddtask</p>
<p>do_build[recrdeptask] += “do_deploy”
有关详细信息，请参阅 BitBake 用户手册中的“依赖项”部分。</p>
<p>如果do_deploy任务重新执行，任何先前的输出都会被删除（即“清理”）。</p>
<p>6.1.7do_fetch
获取源代码。此任务使用 SRC_URI变量和参数的前缀来确定正确的提取器 模块。</p>
<p>6.1.8do_image
开始图像生成过程。该do_image任务在 OpenEmbedded 构建系统运行 do_rootfs任务后运行，在此过程中识别要安装到映像中的包并创建根文件系统，并完成后处理。</p>
<p>该任务通过IMAGE_PREPROCESS_COMMANDdo_image对图像进行预处理， 并根据需要动态生成支持任务。do_image_*</p>
<p>有关图像创建的更多信息，请参阅 Yocto 项目概述和概念手册中的“图像生成”部分。</p>
<p>6.1.9do_image_complete
完成图像生成过程。该do_image_complete任务在 OpenEmbedded 构建系统运行 do_image任务之后运行，在此期间会进行图像预处理，并通过动态生成do_image_* 的任务构建图像。</p>
<p>该do_image_complete任务通过 IMAGE_POSTPROCESS_COMMAND对图像执行后处理。</p>
<p>有关图像创建的更多信息，请参阅 Yocto 项目概述和概念手册中的“图像生成”部分。</p>
<p>6.1.10do_install
将要打包的文件复制到保存区 ${D}中。此任务在当前工作目录设置为${B}的情况下运行，即编译目录。该do_install任务以及直接或间接依赖于已安装文件的其他任务（例如 do_package、do_package_write_*和 do_rootfs）在 fakeroot下运行。</p>
<p>笔记</p>
<p>安装文件时，请注意不要将已安装文件的所有者和组 ID 设置为意外值。一些复制文件的方法，尤其是使用递归cp命令时，可以保留原始文件的 UID 和/或 GID，这通常不是您想要的。host-user-contaminatedQA 检查检查可能具有错误所有权的文件。</p>
<p>安装文件的安全方法包括：</p>
<p>install实用程序。此实用程序是首选方法。</p>
<p>cp带有“–no-preserve=ownership”选项的命令。</p>
<p>tar带有“–no-same-owner”选项的命令。示例参见 源目录目录中的bin_package.bbclass文件。meta/classes</p>
<p>6.1.11do_install_ptest_base
将运行时测试套件文件从编译目录复制到保存区域。</p>
<p>6.1.12do_package
分析保存区 ${D}的内容，并根据可用的包和文件将内容拆分为子集。此任务使用 PACKAGES和FILES 变量。</p>
<p>该do_package任务与 do_packagedata任务一起，还保存了一些重要的包元数据。有关其他信息，请参阅 Yocto 项目概述和概念手册中的 PKGDESTWORK变量和“自动添加的运行时依赖项”部分。</p>
<p>6.1.13do_package_qa
对打包文件运行 QA 检查。有关这些检查的更多信息，请参阅insane类。</p>
<p>6.1.14do_package_write_deb
创建 Debian 包（即*.deb文件）并将它们放在包源区域的 ${DEPLOY_DIR_DEB}目录中。有关更多信息，请参阅 Yocto 项目概述和概念手册中的“包提要”部分。</p>
<p>6.1.15do_package_write_ipk
创建 IPK 包（即*.ipk文件）并将它们放在包源区域的 ${DEPLOY_DIR_IPK}目录中。有关更多信息，请参阅 Yocto 项目概述和概念手册中的“包提要”部分。</p>
<p>6.1.16do_package_write_rpm
创建 RPM 包（即*.rpm文件）并将它们放在包源区域的 ${DEPLOY_DIR_RPM}目录中。有关更多信息，请参阅 Yocto 项目概述和概念手册中的“包提要”部分。</p>
<p>6.1.17do_package_write_tar
创建 tarball 并将它们放在包源区域的 ${DEPLOY_DIR_TAR}目录中。有关更多信息，请参阅 Yocto 项目概述和概念手册中的“包提要”部分。</p>
<p>6.1.18do_packagedata
将do_package任务 生成的包元数据保存 在PKGDATA_DIR中，以使其全局可用。</p>
<p>6.1.19do_patch
找到补丁文件并将它们应用于源代码。</p>
<p>在获取并解压源文件后，构建系统使用配方的SRC_URI语句来定位补丁文件并将其应用于源代码。</p>
<p>笔记</p>
<p>构建系统使用FILESPATH变量来确定搜索补丁时的默认目录集。</p>
<p>默认情况下，补丁文件是*.patch创建*.diff并保存在保存配方文件的目录的子目录中的文件。例如，考虑来自 OE-Core 层的 bluez5 配方（即poky/meta）：</p>
<p>poky/meta/recipes-connectivity/bluez5
这个配方有两个补丁文件位于这里：</p>
<p>poky/meta/recipes-connectivity/bluez5/bluez5
在秘籍中bluez5，SRC_URI语句指向构建包所需的源文件和补丁文件。</p>
<p>笔记</p>
<p>在bluez5_5.48.bb配方的情况下，SRC_URI语句来自包含文件bluez5.inc。</p>
<p>如前所述，构建系统将文件类型为 .patch和的文件.diff视为补丁文件。但是，您可以在SRC_URI语句中使用“apply=yes”参数来将任何文件指示为补丁文件：</p>
<dl class="simple">
<dt>SRC_URI = ” </dt><dd><p>git://path_to_repo/some_package file://file;apply=yes “</p>
</dd>
</dl>
<p>相反，如果您有一个文件类型为.patchor的文件，.diff 并且您想排除它以便do_patch任务在补丁阶段不应用它，您可以在 SRC_URI语句中使用“apply=no”参数：</p>
<dl class="simple">
<dt>SRC_URI = ” </dt><dd><p>git://path_to_repo/some_package file://file1.patch file://file2.patch;apply=no “</p>
</dd>
</dl>
<p>在前面的示例file1.patch中，默认情况下将作为补丁应用，而file2.patch不会应用。</p>
<p>您可以在 Yocto 项目概述和概念手册中的“修补”部分和 Yocto 项目开发任务手册中的“修补代码”部分中找到有关修补过程的更多信息。</p>
<p>6.1.20do_populate_lic
为稍后在构建映像时收集的配方写入许可证信息。</p>
<p>6.1.21do_populate_sdk
为可安装的 SDK 创建文件和目录结构。有关更多信息，请参阅 Yocto 项目概述和概念手册中的“ SDK 生成”部分。</p>
<p>6.1.22do_populate_sdk_ext
为可安装的可扩展 SDK (eSDK) 创建文件和目录结构。有关更多信息，请参阅 Yocto 项目概述和概念手册中的“ SDK 生成”部分。</p>
<p>6.1.23do_populate_sysroot
将do_install任务安装的文件子集暂存（复制） 到相应的 sysroot 中。有关如何从其他配方访问这些文件的信息，请参阅STAGING_DIR*变量。/etc默认情况下，不会复制其他配方在构建时通常不需要的目录（例如）。</p>
<p>有关默认复制哪些目录的信息，请参阅 SYSROOT_DIRS*变量。如果您需要在构建时为其他配方提供更多（或更少）目录，您可以在配方中更改这些变量。</p>
<p>该do_populate_sysroot任务是共享状态（sstate）任务，这意味着可以通过使用sstate来加速该任务。还要意识到，如果重新执行任务，任何先前的输出都会被删除（即“清理”）。</p>
<p>6.1.24do_prepare_recipe_sysroot
将文件安装到单个配方特定的 sysroot 中（即 recipe-sysroot，recipe-sysroot-native根据 DEPENDS指定的依赖关系在${WORKDIR下）。有关更多信息，请参阅“ staging ”类。}</p>
<p>6.1.25do_rm_work
在 OpenEmbedded 构建系统完成后删除工作文件。您可以通过查看“ rm_work.bbclass ”部分了解更多信息。</p>
<p>6.1.26do_unpack
${将源代码解压缩到WORKDIR指向的工作目录中 }。S变量还在解压缩的源文件最终驻留的 位置中发挥作用。有关如何解压缩源文件的更多信息，请参阅Yocto 项目概述和概念手册中的“ Source Fetching ”部分，另请参阅WORKDIR和S变量描述。</p>
<p>6.2手动调用的任务
这些任务通常是手动触发的（例如，通过使用 命令行选项）：bitbake -c</p>
<p>6.2.1do_checkuri
验证SRC_URI值。</p>
<p>6.2.2do_clean
从do_unpack任务转发中删除目标的所有输出文件 （do_unpack即 do_configure、 do_compile、 do_install和 do_package）。</p>
<p>您可以使用 BitBake 运行此任务，如下所示：</p>
<p>$ bitbake -c clean recipe
运行此任务不会删除 sstate缓存文件。因此，如果没有进行任何更改并且在清理后重新构建配方，则输出文件会简单地从 sstate 缓存中恢复。如果要删除配方的 sstate 缓存文件，则需要改用do_cleansstate任务（即配方）。bitbake -c cleansstate</p>
<p>6.2.3do_cleanall
删除目标的所有输出文件、共享状态 ( sstate ) 缓存和下载的源文件（即 DL_DIR的内容）。本质上，该do_cleanall任务与do_cleansstate任务相同，只是添加了删除下载的源文件。</p>
<p>您可以使用 BitBake 运行此任务，如下所示：</p>
<p>$ bitbake -c cleanall recipe
通常，您通常不会使用该cleanall任务。仅当您想重新开始执行do_fetch 任务时才这样做。</p>
<p>6.2.4do_cleansstate
删除目标的所有输出文件和共享状态 ( sstate ) 缓存。本质上，该do_cleansstate任务与 do_clean任务相同，但增加了共享状态 ( sstate ) 缓存的删除。</p>
<p>您可以使用 BitBake 运行此任务，如下所示：</p>
<p>$ bitbake -c cleansstate recipe
当您运行do_cleansstate任务时，OpenEmbedded 构建系统不再使用任何 sstate。因此，可以保证从头开始构建配方。</p>
<p>笔记</p>
<p>该do_cleansstate任务无法从远程 sstate 镜像中删除 sstate。如果您需要使用远程镜像从头开始构建目标，请使用“-f”选项，如下所示：</p>
<p>$ bitbake -f -c do_cleansstate target
6.2.5do_pydevshell
启动一个 shell，其中一个交互式 Python 解释器允许您与 BitBake 构建环境进行交互。在这个 shell 中，您可以直接检查和设置数据存储中的位，并像在 BitBake 环境中一样执行函数。有关使用pydevshell. _</p>
<p>6.2.6do_devshell
启动一个 shell，其环境设置用于开发、调试或两者兼而有之。有关使用devshell. _</p>
<p>6.2.7do_listtasks
列出目标的所有已定义任务。</p>
<p>6.2.8do_package_index
在Package Feeds区域中创建或更新索引。</p>
<p>笔记</p>
<p>与本节中的其他任务一样，此任务不会通过命令行选项触发。因为此任务专门针对配方，所以您使用.bitbake -cpackage-indexbitbake package-index</p>
<p>6.3图像相关任务
以下任务适用于图像配方。</p>
<p>6.3.1do_bootimg
创建可启动的实时映像。有关实时图像类型的更多信息，请参阅 IMAGE_FSTYPES变量。</p>
<p>6.3.2do_bundle_initramfs
将初始 RAM 磁盘 (initramfs) 映像和内核组合在一起以形成单个映像。CONFIG_INITRAMFS_SOURCE变量包含有关这些图像类型的 更多信息。</p>
<p>6.3.3do_rootfs
为图像创建根文件系统（文件和目录结构）。有关如何创建根文件系统的更多信息，请参阅 Yocto 项目概述和概念手册中的“图像生成”部分。</p>
<p>6.3.4do_testimage
启动映像并在映像内执行运行时测试。有关自动测试图像的信息，请参阅 Yocto 项目开发任务手册中的“执行自动运行时测试”部分。</p>
<p>6.3.5do_testimage_auto
构建镜像后立即启动镜像并在镜像内执行运行时测试。此任务在您将 TESTIMAGE_AUTO设置为“1”时启用。</p>
<p>有关自动测试图像的信息，请参阅 Yocto 项目开发任务手册中的“执行自动运行时测试”部分。</p>
<p>6.4内核相关的任务
以下任务适用于内核配方。其中一些任务（例如do_menuconfig任务）也适用于使用 Linux 内核样式配置的配方，例如 BusyBox 配方。</p>
<p>6.4.1do_compile_kernelmodules
运行构建内核模块的步骤（如果需要）。构建内核包括两个步骤：1）vmlinux构建内核（），以及2）构建模块（即）。make modules</p>
<p>6.4.2do_diffconfig
当用户调用此任务时，该任务会创建一个文件，其中包含由 do_kernel_configme任务生成的原始配置与用户通过其他方法（即使用 ( do_kernel_menuconfig )）所做的更改之间的差异。创建差异文件后，它可以用于创建仅包含差异的配置片段。您可以从命令行调用此任务，如下所示：</p>
<p>$ bitbake linux-yocto -c diffconfig
有关详细信息，请参阅 Yocto Project Linux 内核开发手册中的“创建配置片段”部分。</p>
<p>6.4.3do_kernel_checkout
将新解压的内核源代码转换为 OpenEmbedded 构建系统可以使用的形式。因为可以通过多种不同的方式获取内核源代码，所以该do_kernel_checkout任务确保为后续任务提供一个干净的内核工作树副本，并签出正确的分支。</p>
<p>6.4.4do_kernel_configcheck
验证do_kernel_menuconfig任务生成的配置 。do_kernel_configcheck当请求的配置未出现在最终.config文件中或您覆盖硬件配置片段中的策略配置时，该 任务会产生警告。您可以使用以下命令显式运行此任务并查看输出：</p>
<p>$ bitbake linux-yocto -c kernel_configcheck -f
有关详细信息，请参阅 Yocto Project Linux 内核开发手册中的“验证配置”部分。</p>
<p>6.4.5do_kernel_configme
在do_patch 任务修补内核后，该do_kernel_configme任务将所有内核配置片段组装并合并到一个合并的配置中，然后可以将其传递给适当的内核配置阶段。这也是应用用户指定的 defconfigs（如果存在）的时间，以及应用配置模式等–allnoconfig的时间。</p>
<p>6.4.6do_kernel_menuconfig
由用户调用以操作.config用于构建 linux-yocto 配方的文件。此任务启动 Linux 内核配置工具，然后您可以使用它来修改内核配置。</p>
<p>笔记</p>
<p>您还可以从命令行调用此工具，如下所示：</p>
<p>$ bitbake linux-yocto -c menuconfig
有关此配置工具的更多信息，请参阅 Yocto Project Linux 内核开发手册中的“使用 menuconfig ”部分。</p>
<p>6.4.7do_kernel_metadata
收集给定内核构建所需的所有功能，无论这些功能来自SRC_URI还是来自 Git 存储库。收集后，do_kernel_metadata任务将特征处理成一系列配置片段和补丁，然后可以由后续任务应用，例如 do_patch和 do_kernel_configme。</p>
<p>6.4.8do_menuconfig
为内核运行。有关 的信息 ，请参阅 Yocto Project Linux 内核开发手册中的“使用 menuconfig ”部分。make menuconfigmenuconfig</p>
<p>6.4.9do_savedefconfig
当由用户调用时，创建一个可用于代替默认 defconfig 的 defconfig 文件。保存的 defconfig 包含默认 defconfig 与用户使用其他方法（即 do_kernel_menuconfig任务）所做的更改之间的差异。您可以使用以下命令调用该任务：</p>
<p>$ bitbake linux-yocto -c savedefconfig
6.4.10do_shared_workdir
在编译内核之后但在编译内核模块之前，此任务会将模块构建所需的文件以及从内核构建生成的文件复制到共享工作目录中。成功复制这些副本后， do_compile_kernelmodules任务可以在构建的下一步中成功构建内核模块。</p>
<p>6.4.11do_sizecheck
内核构建完成后，此任务会根据 KERNEL_IMAGE_MAXSIZE检查剥离后的内核映像的大小。如果设置了该变量并且剥离内核的大小超过了该大小，则内核构建会对此产生警告。</p>
<p>6.4.12do_strip
如果KERNEL_IMAGE_STRIP_EXTRA_SECTIONS已定义，此任务会从 中删除该变量中命名的部分vmlinux。这种剥离通常用于去除不重要的部分，例如.comment 此剥离通常用于从对尺寸敏感的配置</p>
<p>6.4.13do_validate_branches
在内核解包之后但在修补之前，此任务确保由 SRCREV变量指定的机器和元数据分支确实存在于指定的分支上。否则，如果未使用AUTOREV，则 do_validate_branches任务在构建期间失败。</p>
<p>7devtool快速参考
命令行devtool工具提供了许多帮助您构建、测试和打包软件的功能。此命令与bitbake命令一起可用。此外，该devtool命令是可扩展 SDK 的关键部分。</p>
<p>本章提供该devtool命令的快速参考。有关在使用可扩展 SDK 时如何应用命令的更多信息，请参阅 Yocto 项目应用程序开发和可扩展软件开发工具包 (eSDK) 手册中的“使用可扩展 SDK ”一章。</p>
<p>7.1获得帮助
命令行的devtool组织方式与 Git 类似，每个函数都有许多子命令。您可以运行 以查看所有命令：devtool –help</p>
<p>$ devtool -h
NOTE: Starting bitbake server…
usage: devtool [–basepath BASEPATH] [–bbpath BBPATH] [-d] [-q] [–color COLOR] [-h] &lt;subcommand&gt; …</p>
<p>OpenEmbedded development tool</p>
<dl>
<dt>options:</dt><dd><dl class="option-list">
<dt><kbd><span class="option">--basepath <var>BASEPATH</var></span></kbd></dt>
<dd><p>Base directory of SDK / build directory</p>
</dd>
<dt><kbd><span class="option">--bbpath <var>BBPATH</var></span></kbd></dt>
<dd><p>Explicitly specify the BBPATH, rather than getting it from the metadata</p>
</dd>
<dt><kbd><span class="option">-d</span>, <span class="option">--debug</span></kbd></dt>
<dd><p>Enable debug output</p>
</dd>
<dt><kbd><span class="option">-q</span>, <span class="option">--quiet</span></kbd></dt>
<dd><p>Print only errors</p>
</dd>
<dt><kbd><span class="option">--color <var>COLOR</var></span></kbd></dt>
<dd><p>Colorize output (where COLOR is auto, always, never)</p>
</dd>
<dt><kbd><span class="option">-h</span>, <span class="option">--help</span></kbd></dt>
<dd><p>show this help message and exit</p>
</dd>
</dl>
</dd>
<dt>subcommands:</dt><dd><dl class="simple">
<dt>Beginning work on a recipe:</dt><dd><p>add                   Add a new recipe
modify                Modify the source for an existing recipe
upgrade               Upgrade an existing recipe</p>
</dd>
<dt>Getting information:</dt><dd><p>status                Show workspace status
latest-version        Report the latest version of an existing recipe
check-upgrade-status  Report upgradability for multiple (or all) recipes
search                Search available recipes</p>
</dd>
<dt>Working on a recipe in the workspace:</dt><dd><p>build                 Build a recipe
rename                Rename a recipe file in the workspace
edit-recipe           Edit a recipe file
find-recipe           Find a recipe file
configure-help        Get help on configure script options
update-recipe         Apply changes from external source tree to recipe
reset                 Remove a recipe from your workspace
finish                Finish working on a recipe in your workspace</p>
</dd>
<dt>Testing changes on target:</dt><dd><p>deploy-target         Deploy recipe output files to live target machine
undeploy-target       Undeploy recipe output files in live target machine
build-image           Build image including workspace recipe packages</p>
</dd>
<dt>Advanced:</dt><dd><p>create-workspace      Set up workspace in an alternative location
extract               Extract the source for an existing recipe
sync                  Synchronize the source tree for an existing recipe
menuconfig            Alter build-time configuration for a recipe
import                Import exported tar archive into workspace
export                Export workspace into a tar archive</p>
</dd>
<dt>other:</dt><dd><p>selftest-reverse      Reverse value (for selftest)
pluginfile            Print the filename of this plugin
bbdir                 Print the BBPATH directory of this plugin
count                 How many times have this plugin been registered.
multiloaded           How many times have this plugin been initialized</p>
</dd>
</dl>
</dd>
</dl>
<p>Use devtool &lt;subcommand&gt; –help to get help on a specific command
按照一般帮助输出中的指示，您可以通过提供命令名称并使用以下命令获得有关特定命令的更多语法–help：</p>
<p>$ devtool add –help
NOTE: Starting bitbake server…
usage: devtool add [-h] [–same-dir | –no-same-dir] [–fetch URI] [–npm-dev] [–version VERSION] [–no-git] [–srcrev SRCREV | –autorev] [–srcbranch SRCBRANCH] [–binary] [–also-native] [–src-subdir SUBDIR] [–mirrors]</p>
<blockquote>
<div><p>[–provides PROVIDES]
[recipename] [srctree] [fetchuri]</p>
</div></blockquote>
<p>Adds a new recipe to the workspace to build a specified source tree. Can optionally fetch a remote URI and unpack it to create the source tree.</p>
<dl>
<dt>arguments:</dt><dd><p>recipename            Name for new recipe to add (just name - no version, path or extension). If not specified, will attempt to auto-detect it.
srctree               Path to external source tree. If not specified, a subdirectory of /media/build1/poky/build/workspace/sources will be used.
fetchuri              Fetch the specified URI and extract it to create the source tree</p>
</dd>
<dt>options:</dt><dd><dl class="option-list">
<dt><kbd><span class="option">-h</span>, <span class="option">--help</span></kbd></dt>
<dd><p>show this help message and exit</p>
</dd>
<dt><kbd><span class="option">--same-dir</span>, <span class="option">-s</span></kbd></dt>
<dd><p>Build in same directory as source</p>
</dd>
<dt><kbd><span class="option">--no-same-dir</span></kbd></dt>
<dd><p>Force build in a separate build directory</p>
</dd>
<dt><kbd><span class="option">--fetch <var>URI</var></span>, <span class="option">-f <var>URI</var></span></kbd></dt>
<dd><p>Fetch the specified URI and extract it to create the source tree (deprecated - pass as positional argument instead)</p>
</dd>
<dt><kbd><span class="option">--npm-dev</span></kbd></dt>
<dd><p>For npm, also fetch devDependencies</p>
</dd>
<dt><kbd><span class="option">--version <var>VERSION</var></span>, <span class="option">-V <var>VERSION</var></span></kbd></dt>
<dd><p>Version to use within recipe (PV)</p>
</dd>
<dt><kbd><span class="option">--no-git</span>, <span class="option">-g</span></kbd></dt>
<dd><p>If fetching source, do not set up source tree as a git repository</p>
</dd>
<dt><kbd><span class="option">--srcrev <var>SRCREV</var></span>, <span class="option">-S <var>SRCREV</var></span></kbd></dt>
<dd><p>Source revision to fetch if fetching from an SCM such as git (default latest)</p>
</dd>
<dt><kbd><span class="option">--autorev</span>, <span class="option">-a</span></kbd></dt>
<dd><p>When fetching from a git repository, set SRCREV in the recipe to a floating revision instead of fixed</p>
</dd>
<dt><kbd><span class="option">--srcbranch <var>SRCBRANCH</var></span>, <span class="option">-B <var>SRCBRANCH</var></span></kbd></dt>
<dd><p>Branch in source repository if fetching from an SCM such as git (default master)</p>
</dd>
<dt><kbd><span class="option">--binary</span>, <span class="option">-b</span></kbd></dt>
<dd><p>Treat the source tree as something that should be installed verbatim (no compilation, same directory structure). Useful with binary packages e.g. RPMs.</p>
</dd>
<dt><kbd><span class="option">--also-native</span></kbd></dt>
<dd><p>Also add native variant (i.e. support building recipe for the build host as well as the target machine)</p>
</dd>
<dt><kbd><span class="option">--src-subdir <var>SUBDIR</var></span></kbd></dt>
<dd><p>Specify subdirectory within source tree to use</p>
</dd>
<dt><kbd><span class="option">--mirrors</span></kbd></dt>
<dd><p>Enable PREMIRRORS and MIRRORS for source tree fetching (disable by default).</p>
</dd>
<dt><kbd><span class="option">--provides <var>PROVIDES</var></span>, <span class="option">-p <var>PROVIDES</var></span></kbd></dt>
<dd><p>Specify an alias for the item provided by the recipe. E.g. virtual/libgl</p>
</dd>
</dl>
</dd>
</dl>
<p>7.2工作区层结构
devtool使用“工作区”层来完成构建。该层不特定于任何单个devtool命令，而是跨工具使用的公共工作区域。</p>
<p>下图显示了工作区结构：</p>
<p>../_images/build-workspace-directory.png
attic - A directory created if devtool believes it must preserve</p>
<blockquote>
<div><p>anything when you run “devtool reset”.  For example, if you
run “devtool add”, make changes to the recipe, and then
run “devtool reset”, devtool takes notice that the file has
been changed and moves it into the attic should you still
want the recipe.</p>
</div></blockquote>
<dl class="simple">
<dt>README - Provides information on what is in workspace layer and how to</dt><dd><p>manage it.</p>
</dd>
</dl>
<p>.devtool_md5 - A checksum file used by devtool.</p>
<dl class="simple">
<dt>appends - A directory that contains <a href="#id37"><span class="problematic" id="id38">*</span></a>.bbappend files, which point to</dt><dd><p>external source.</p>
</dd>
</dl>
<p>conf - A configuration directory that contains the layer.conf file.</p>
<dl class="simple">
<dt>recipes - A directory containing recipes.  This directory contains a</dt><dd><p>folder for each directory added whose name matches that of the
added recipe.  devtool places the recipe.bb file
within that sub-directory.</p>
</dd>
<dt>sources - A directory containing a working copy of the source files used</dt><dd><p>when building the recipe.  This is the default directory used
as the location of the source tree when you do not provide a
source tree path.  This directory contains a folder for each
set of source files matched to a corresponding recipe.</p>
</dd>
</dl>
<p>7.3向工作区层添加新配方
使用该命令将新配方添加到工作区层。您添加的配方不应该存在 -为您创建它。配方使用的源文件应该存在于外部区域中。devtool adddevtool</p>
<p>以下示例创建并添加一个名为jackson该工具创建的工作区图层的新配方。配方构建的源代码位于/home/user/sources/jackson：</p>
<p>$ devtool add jackson /home/user/sources/jackson
如果您添加一个配方并且工作空间层不存在，该命令将创建该层并按照“工作空间层结构”部分中的描述填充它。</p>
<p>在工作空间层存在时运行会导致该工具将配方、附加文件和源文件添加到现有工作空间层中。创建该文件以指向外部源代码树。devtool add.bbappend</p>
<p>笔记</p>
<p>如果您的配方定义了运行时依赖项，则在尝试运行您的应用程序之前，您必须确保这些包存在于目标硬件上。如果目标上不存在依赖包（例如库），您的应用程序在运行时将无法找到这些函数。有关详细信息，请参阅“在目标机器上部署您的软件”部分。</p>
<p>默认情况下，从远程 URI 解压缩文件时使用最新版本（即主版本）。在某些情况下，您可能希望通过分支、标记或提交哈希指定源修订。您可以在使用命令时指定这些选项：devtool adddevtool add</p>
<p>要指定源分支，请使用以下–srcbranch选项：</p>
<p>$ devtool add –srcbranch honister jackson /home/user/sources/jackson
在前面的示例中，您正在检查 honister 分支。</p>
<p>要指定特定标签或提交哈希，请使用以下–srcrev 选项：</p>
<p>$ devtool add –srcrev yocto-3.4.2 jackson /home/user/sources/jackson
$ devtool add –srcrev some_commit_hash /home/user/sources/jackson
前面的示例检查了 yocto-3.4.2 标记和与 some_commit_hash 哈希关联的提交。</p>
<p>笔记</p>
<p>如果您希望每次构建配方时都使用最新版本，请使用选项–autorev或-a。</p>
<p>7.4提取现有配方的来源
使用该命令提取现有配方的源。当您使用此命令时，您必须提供配方的根名称（即没有版本、路径或扩展名），并且您必须提供要将源提取到的目录。devtool extract</p>
<p>其他命令选项让您可以控制可以检出源代码的开发分支的名称以及是否保留临时目录，这对于调试很有用。</p>
<p>7.5同步配方的提取源树
使用该命令为现有配方同步先前提取的源树。当您使用此命令时，您必须提供配方的根名称（即没有版本、路径或扩展名），并且您必须提供要将源提取到的目录。devtool sync</p>
<p>其他命令选项让您可以控制可以检出源代码的开发分支的名称以及是否保留临时目录，这对于调试很有用。</p>
<p>7.6修改现有配方
使用该命令开始修改现有配方的来源。此命令与add命令非常相似， 只是它不会在工作空间层中物理创建配方，因为配方已经存在于另一层中。devtool modify</p>
<p>该命令提取配方的源，如果尚未从 Git 获取源，则将其设置为 Git 存储库，签出分支以进行开发，并将配方中的任何补丁作为提交应用到顶部。您可以使用以下命令检出源文件：devtool modify</p>
<p>$ devtool modify recipe
使用上述命令形式，devtool使用现有配方的 SRC_URI语句定位上游源，将源提取到工作区中的默认源位置。使用的默认开发分支是“devtool”。</p>
<p>7.7编辑现有配方
使用该命令在指定的配方上运行使用变量标识的默认编辑器。devtool edit-recipeEDITOR</p>
<p>当您使用该命令时，您必须提供配方的根名称（即没有版本、路径或扩展名）。此外，作为or命令的结果，配方文件本身必须驻留在工作区中 。devtool edit-recipedevtool adddevtool upgrade</p>
<p>7.8更新配方
使用该命令使用反映您对源文件所做更改的补丁来更新您的配方。例如，如果您知道要处理一些代码，您可以首先使用 devtool modify命令提取代码并设置工作区。之后，您可以修改、编译和测试代码。devtool update-recipe</p>
<p>当您对结果感到满意并且您已将更改提交到 Git 存储库时，您可以运行 以创建补丁并更新配方：devtool update-recipe</p>
<p>$ devtool update-recipe recipe
如果您在 未提交更改的情况下运行，该命令将忽略更改。devtool update-recipe</p>
<p>通常，您可能希望在您自己的层中应用对您的软件所做的自定义，而不是将它们应用到原始配方。如果是这样，您可以在命令中使用-aor–append选项 。这些选项允许您指定要写入附加文件的层：devtool update-recipe</p>
<p>$ devtool update-recipe recipe -a base-layer-directory
该*.bbappend文件是在指定层目录内的适当路径中创建的，该目录可能在您的文件中，也可能不在您的bblayers.conf文件中。如果附加文件已经存在，该命令会适当地更新它。</p>
<p>7.9查看配方升级状态
上游配方随时间而变化。因此，您可能会发现您需要确定是否可以将配方升级到较新的版本。</p>
<p>要检查配方的升级状态，您可以使用该 命令快速显示当前版本和上游可用的最新版本。要获得更全局的图片，请使用该命令，该命令将食谱列表作为输入，或者不使用参数，在这种情况下，它会检查所有可用的食谱。此命令将仅打印新上游版本可用的配方。每个这样的配方都会有它的当前版本和最新的上游版本，以及维护者的电子邮件和任何附加信息，例如提交哈希或无法升级它的原因，显示在一个表格中。devtool latest-version recipedevtool check-upgrade-status</p>
<p>此升级检查机制依赖于包配方中的可选UPSTREAM_CHECK_URI、 UPSTREAM_CHECK_REGEX、UPSTREAM_CHECK_GITTAGREGEX、 UPSTREAM_CHECK_COMMITS和UPSTREAM_VERSION_UNKNOWN 变量。</p>
<p>笔记</p>
<p>大多数时候，上述变量是不必要的。仅当上游发生异常情况时才需要它们，并且默认机制无法找到新的上游版本。</p>
<p>对于该oe-core层，配方维护者来自 maintainers.inc 文件。</p>
<p>如果配方使用Git Fetcher (git://) 而不是 tarball，则提交哈希指向与配方的最新版本标签匹配的提交，或者在没有合适标签的情况下，指向最新提交（当UPSTREAM_CHECK_COMMITS设置时在1 食谱中）。</p>
<p>与所有devtool命令一样，您可以获得有关单个命令的帮助：</p>
<p>$ devtool check-upgrade-status -h
NOTE: Starting bitbake server…
usage: devtool check-upgrade-status [-h] [–all] [recipe [recipe …]]</p>
<p>Prints a table of recipes together with versions currently provided by recipes, and latest upstream versions, when there is a later version available</p>
<dl>
<dt>arguments:</dt><dd><p>recipe      Name of the recipe to report (omit to report upgrade info for all recipes)</p>
</dd>
<dt>options:</dt><dd><dl class="option-list">
<dt><kbd><span class="option">-h</span>, <span class="option">--help</span></kbd></dt>
<dd><p>show this help message and exit</p>
</dd>
<dt><kbd><span class="option">--all</span>, <span class="option">-a</span></kbd></dt>
<dd><p>Show all recipes, not just recipes needing upgrade</p>
</dd>
</dl>
</dd>
</dl>
<p>除非您在命令行上提供特定的配方名称，否则该命令会检查所有已配置层中的所有配方。</p>
<p>以下是报告所有配方的部分示例表。注意报告的不升级base-passwd配方的原因。在此示例中，虽然上游有新版本可用，但您不想使用它，因为cdebconf不容易满足对的依赖。维护者可以通过将RECIPE_NO_UPDATE_REASON变量添加到相应的配方来明确显示的原因。有关示例，请参见base-passwd.bb 。</p>
<p>$ devtool check-upgrade-status
…
INFO: bind                      9.16.20         9.16.21         Armin Kuster &lt;<a class="reference external" href="mailto:akuster808&#37;&#52;&#48;gmail&#46;com">akuster808<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;
INFO: inetutils                 2.1             2.2             Tom Rini &lt;<a class="reference external" href="mailto:trini&#37;&#52;&#48;konsulko&#46;com">trini<span>&#64;</span>konsulko<span>&#46;</span>com</a>&gt;
INFO: iproute2                  5.13.0          5.14.0          Changhyeok Bae &lt;<a class="reference external" href="mailto:changhyeok&#46;bae&#37;&#52;&#48;gmail&#46;com">changhyeok<span>&#46;</span>bae<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;
INFO: openssl                   1.1.1l          3.0.0           Alexander Kanavin &lt;<a class="reference external" href="mailto:alex&#46;kanavin&#37;&#52;&#48;gmail&#46;com">alex<span>&#46;</span>kanavin<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;
INFO: base-passwd               3.5.29          3.5.51          Anuj Mittal &lt;<a class="reference external" href="mailto:anuj&#46;mittal&#37;&#52;&#48;intel&#46;com">anuj<span>&#46;</span>mittal<span>&#64;</span>intel<span>&#46;</span>com</a>&gt;  cannot be updated due to: Version 3.5.38 requires cdebconf for update-passwd utility
…
最后但同样重要的是 ，当当前无法确定其最新的上游版本时，您可以在配方中将UPSTREAM_VERSION_UNKNOWN设置为。1</p>
<p>7.10升级配方
随着软件的成熟，上游配方升级到更新版本。作为开发人员，您需要使本地配方与上游版本保持同步。有几种升级配方的方法。您可以在 Yocto 项目开发任务手册的“升级配方”部分阅读它们。本节概述了该命令。devtool upgrade</p>
<p>在升级配方之前，您可以检查其升级状态。有关详细信息，请参阅“检查配方的升级状态”部分。</p>
<p>该命令将现有配方升级到上游配方的更新版本。该命令将升级后的配方文件以及任何相关文件放入“工作区”，并在必要时将源树提取到指定位置。在升级过程中，与配方相关的补丁会根据需要重新设置或添加。devtool upgrade</p>
<p>当您使用该命令时，您必须提供配方的根名称（即没有版本、路径或扩展名），并且您必须提供您希望将源代码提取到的目录。附加的命令选项让您可以控制诸如要升级到的版本号（即PV）、要升级到的源版本（即 SRCREV）、是否应用补丁等。devtool upgrade</p>
<p>您可以在 Yocto 项目应用程序开发和可扩展软件开发工具包 (eSDK) 手册中的“使用 devtool 升级创建支持较新版本软件的配方版本”部分中阅读有关工作流程的更多信息。您还可以在 Yocto 项目开发任务手册中的“使用 devtool 升级”部分查看如何使用的示例。devtool upgradedevtool upgrade</p>
<p>7.11重置配方
使用该命令从工作区层中删除一个配方及其配置（例如相应的文件）。意识到这个命令会删除配方和附加文件。该命令不会为您实际移动它们。因此，在运行命令之前，您必须确保在物理上将更新的配方和附加文件重新定位到工作区层之外。devtool reset.bbappenddevtool reset</p>
<p>如果该命令检测到配方或附加文件已被修改，则该命令将修改后的文件保存在工作区层下单独的“阁楼”子目录中。devtool reset</p>
<p>这是一个重置包含 mtr配方的工作区目录的示例：</p>
<p>$ devtool reset mtr
NOTE: Cleaning sysroot for recipe mtr…
NOTE: Leaving source tree /home/scottrif/poky/build/workspace/sources/mtr as-is; if you no longer need it then please delete it manually
$
7.12建立你的食谱
使用该命令构建您的配方。命令等同于 命令 。devtool builddevtool buildbitbake -c populate_sysroot</p>
<p>当您使用该命令时，您必须提供配方的根名称（即不提供版本、路径或扩展名）。您可以使用或选项在构建期间禁用并行生成。这是一个例子：devtool build-s–disable-parallel-make</p>
<p>$ devtool build recipe
7.13建立你的形象
使用该命令构建映像，将其扩展为包括工作区中配方的包。当您想要一个准备好立即部署到设备上进行测试的映像时，使用此命令很有用。为了正确集成到最终图像中，您需要适当地编辑自定义图像配方。devtool build-image</p>
<p>当您使用该命令时，您必须提供图像的名称。此命令没有命令行选项：devtool build-image</p>
<p>$ devtool build-image image
7.14在目标机器上部署你的软件
使用命令将配方的构建输出部署到实时目标机器：devtool deploy-target</p>
<p>$ devtool deploy-target recipe target
target 是目标机器的地址，它必须运行 SSH 服务器（即user&#64;hostname[:destdir]）。</p>
<p>此命令部署在 do_install任务期间安装的所有文件。此外，您不需要在目标机器中启用包管理。如果这样做，包管理器将被绕过。</p>
<p>笔记</p>
<p>该deploy-target功能仅用于开发。您永远不应该使用它来更新将在生产中使用的图像。</p>
<p>某些情况可能会阻止已部署的应用程序按预期运行。当满足以下两个条件时，您的应用程序在目标上运行时可能无法正常运行：</p>
<p>您正在将一个新应用程序部署到目标，并且您用于构建应用程序的配方具有正确定义的运行时依赖项。</p>
<p>目标实际上没有安装应用程序所依赖的包。</p>
<p>如果满足这两个条件，您的应用程序将不会按预期运行。这种错误行为的原因是该 命令没有部署新应用程序所依赖的包（例如库）。假设包已经在目标上。因此，当在应用程序中对依赖函数（例如库调用）进行运行时调用时，无法找到该函数。devtool deploy-target</p>
<p>为确保您拥有目标本地的所有依赖项，您需要确保在尝试运行应用程序之前已在目标上预先部署（安装）包。</p>
<p>7.15从目标机器中删除您的软件
使用该命令从目标机器中删除已部署的构建输出。要使该 命令正常工作，您必须以前使用过“ devtool deploy-target ”命令。devtool undeploy-targetdevtool undeploy-target</p>
<p>$ devtool undeploy-target recipe target
target 是目标机器的地址，它必须运行 SSH 服务器（即 <a class="reference external" href="mailto:user&#37;&#52;&#48;hostname">user<span>&#64;</span>hostname</a>）。</p>
<p>7.16在替代位置创建工作区层
使用该命令在您的Build Directory中创建一个新的工作区层。当您创建一个新的工作空间层时，它只填充了文件和 目录。devtool create-workspaceREADMEconf</p>
<p>以下示例在您当前的工作中创建一个新的工作区层，默认情况下将工作区层命名为“workspace”：</p>
<p>$ devtool create-workspace
您可以通过在命令中提供路径名来在任何地方创建工作区层。以下命令创建一个名为“new-workspace”的新工作区层：</p>
<p>$ devtool create-workspace /home/scottrif/new-workspace
7.17获取工作区中配方的状态
使用该命令列出当前工作区中的配方。信息包括到它们各自的外部源树的路径。devtool status</p>
<p>该命令没有命令行选项：devtool status</p>
<p>$ devtool status
以下是使用devtool add 创建mtr_0.86.bb配方并将其添加到目录后的示例输出 workspace：</p>
<p>$ devtool status
mtr:/home/scottrif/poky/build/workspace/sources/mtr (/home/scottrif/poky/build/workspace/recipes/mtr/mtr_0.86.bb)
$
7.18搜索可用的目标配方
使用该命令搜索可用的目标配方。该命令与配方名称、包名称、描述和安装的文件相匹配。该命令将配方名称显示为匹配的结果。devtool search</p>
<p>使用该命令时，必须提供关键字。该命令在搜索匹配项时使用关键字。devtool search</p>
<p>8 OpenEmbedded Kickstart ( .wks) 参考
8.1简介
当前的 Wic 实现仅支持基本的 kickstart 分区命令：（partition或part简称）和 bootloader.</p>
<p>笔记</p>
<p>未来的更新将实施更多的命令和选项。如果您使用不受特别支持的任何内容，结果可能无法预测。</p>
<p>本章提供有关可用 kickstart 命令的参考。这些信息列出了命令、它们的语法和含义。Kickstart 命令基于 Fedora kickstart 版本，但经过修改以反映 Wic 功能。您可以在以下链接中查看这些命令的原始文档： https ://pykickstart.readthedocs.io/en/latest/kickstart-docs.html</p>
<p>8.2命令：part 或 partition
这些命令中的任何一个都会在系统上创建一个分区并使用以下语法：</p>
<p>part [mntpoint]
partition [mntpoint]
如果您不提供 mntpoint，Wic 会创建一个分区但不会挂载它。</p>
<p>这mntpoint是分区的安装位置，必须采用以下形式之一：</p>
<p>/path：例如，“/”、“/usr”或“/home”</p>
<p>swap：创建的分区用作交换空间</p>
<p>指定 mntpoint 会导致分区自动挂载。Wic 通过在图像生成期间向文件系统表 (fstab) 添加条目来实现这一点。为了让 Wic 生成有效的 fstab，您还必须提供–ondrive、–ondisk或 –use-uuidpartition 选项之一作为命令的一部分。</p>
<p>笔记</p>
<p>挂载程序必须理解您使用的 PARTUUID 语法 –use-uuid和非根挂载点，包括交换。OpenEmbedded 中 BusyBox 的默认配置支持此功能，但在自定义配置中可能会禁用此功能。</p>
<p>这是一个使用“/”作为挂载点的示例。该命令用于 –ondisk将分区强制到sdb磁盘上：</p>
<p>part / –source rootfs –ondisk sdb –fstype=ext3 –label platform –align 1024
以下列表描述了可与partandpartition命令一起使用的其他受支持选项：</p>
<p>–size：最小分区大小。指定为整数值，可选地后跟单位之一“k”/“K”表示千字节，“M”表示兆字节，“G”表示吉字节。如果没有给出默认单位是“M”。如果您使用–source.</p>
<p>–fixed-size：确切的分区大小。指定为整数值，可选地后跟单位之一“k”/“K”表示千字节，“M”表示兆字节，“G”表示吉字节。如果没有给出默认单位是“M”。不能与 一起指定–size。如果分区数据大于–fixed-size.</p>
<p>–source：此选项是特定于 Wic 的选项，用于命名填充分区的数据源。此选项最常见的值是“rootfs”，但您可以使用映射到有效源插件的任何值。有关源插件的信息，请参阅 Yocto 项目开发任务手册中的“使用 Wic 插件接口”部分。</p>
<p>如果使用，Wic 会根据需要创建一个分区，并用命令行选项指向的根文件系统或从命令行选项派生的等效根文件系统的内容填充它。用于创建分区的文件系统类型由 为分区指定的选项的值驱动。有关详细信息，请参阅以下条目 。–source rootfs-r-e–fstype–fstype</p>
<p>如果您使用，Wic 会根据需要创建一个分区，并使用由命令行选项指向的数据或从命令行派生的等效根文件系统使用指定插件名称生成的分区的内容填充它 -线选项。这些内容到底是什么以及使用的文件系统类型取决于给定的插件实现。–source plugin-name-r-e</p>
<p>如果不使用该–source选项，该wic命令将创建一个空分区。因此，您必须使用该–size 选项来指定空分区的大小。</p>
<p>–ondisk或–ondrive：强制在特定磁盘上创建分区。</p>
<p>–fstype：设置分区的文件系统类型。有效值为：</p>
<p>btrfs</p>
<p>erofs</p>
<p>ext2</p>
<p>ext3</p>
<p>ext4</p>
<p>squashfs</p>
<p>swap</p>
<p>–fsoptions: 指定挂载文件系统时要使用的自由格式的选项字符串。该字符串被复制到 /etc/fstab已安装系统的文件中，并且应该用引号引起来。如果未指定，则默认字符串为“defaults”。</p>
<p>–label label：指定要在分区上创建的文件系统的标签。如果给定标签已被另一个文件系统使用，则为分区创建一个新标签。</p>
<p>–active：将分区标记为活动的。</p>
<p>–align (in KBytes)：此选项是 Wic 特定选项，表示在给定 x KBytes 的边界上启动分区。</p>
<p>–offset：此选项是 Wic 特定的选项，表示将分区放置在指定的偏移量处。如果分区不能放置在指定的偏移量，则镜像构建将失败。指定为整数值，可选地后跟单位之一“s”/“S”表示 512 字节扇区，“k”/“K”表示千字节，“M”表示兆字节，“G”表示吉字节。如果没有给出默认单位是“k”。</p>
<p>–no-table：此选项是特定于 Wic 的选项。使用该选项为分区保留空间并使其填充。但是，分区不会添加到分区表中。</p>
<p>–exclude-path：此选项是特定于 Wic 的选项，它从结果图像中排除给定的相对路径。此选项仅对 rootfs 源插件有效。</p>
<p>–extra-space：此选项是 Wic 特定选项，在分区内容填充的空间之后添加额外空间。最终大小可以超过–size 选项指定的大小。默认值为 10M。指定为整数值，可选地后跟单位之一“k”/“K”表示千字节，“M”表示兆字节，“G”表示吉字节。如果没有给出默认单位是“M”。</p>
<p>–overhead-factor：此选项是 Wic 特定的选项，它将分区的大小乘以选项的值。您必须提供一个大于或等于“1”的值。默认值为“1.3”。</p>
<p>–part-name：此选项是特定于 Wic 的选项，用于指定 GPT 分区的名称。</p>
<p>–part-type：此选项是特定于 Wic 的选项，用于指定 GPT 分区的分区类型全局唯一标识符 (GUID)。您可以在https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs找到分区类型 GUID 的列表 。</p>
<p>–use-uuid：此选项是 Wic 特定选项，它会导致 Wic 为分区生成随机 GUID。生成的标识符在引导加载程序配置中用于指定根分区。</p>
<p>–uuid：此选项是 Wic 特定的选项，用于指定分区 UUID。</p>
<p>–fsuuid：此选项是 Wic 特定的选项，用于指定文件系统 UUID。如果在运行 Wic 之前将预配置的文件系统 UUID 添加到引导加载程序配置中的内核命令行，则可以使用此选项生成或修改 WKS_FILE 。</p>
<p>–system-id：此选项是 Wic 特定选项，用于指定分区系统 ID，它是一个字节长的十六进制参数，带或不带 0x 前缀。</p>
<p>–mkfs-extraopts：此选项指定要传递给mkfs实用程序的附加选项。某些文件系统的某些默认选项不会生效。请参阅 Wic 对 kickstart 的帮助（即 ）。wic help kickstart</p>
<p>8.3命令：引导加载程序
此命令指定应如何配置引导加载程序并支持以下选项：</p>
<p>笔记</p>
<p>引导加载程序功能和引导分区由实现引导加载程序功能的各种 –source 插件实现。bootloader 命令本质上提供了一种修改引导加载程序配置的方法。</p>
<p>–timeout：指定引导加载程序超时并引导默认选项之前的秒数。</p>
<p>–append: 指定内核参数。这些参数将被添加到 syslinux APPEND或grub内核命令行中。</p>
<p>–configfile：为引导加载程序指定用户定义的配置文件。您可以为文件或文件夹中的文件提供完整路径名canned-wks。此选项会覆盖所有其他引导加载程序选项。</p>
<p>9 QA 错误和警告信息
9.1简介
在构建配方时，OpenEmbedded 构建系统对输出执行各种 QA 检查，以确保检测和报告常见问题。有时，当您创建新配方来构建新软件时，它会毫无问题地构建。如果不是这种情况，或者当您在构建任何软件时遇到 QA 问题，可能需要一些时间来解决它们。</p>
<p>虽然忽略 QA 消息甚至禁用 QA 检查很诱人，但最好尝试解决任何报告的 QA 问题。本章提供了 QA 消息列表和您可能遇到的问题的简要说明，以便您正确解决问题。</p>
<p>下一部分提供了基于默认配置的所有 QA 错误和警告消息的列表。每个条目都提供消息或错误表单以及解释。</p>
<p>笔记</p>
<p>在每条消息的末尾，相关 QA 测试的名称（如“ insane.bbclass ”部分中列出的）出现在方括号中。</p>
<p>如前所述，此错误和警告消息列表仅用于 QA 检查。该列表未涵盖您可能遇到的所有可能的构建错误或警告。</p>
<p>由于默认情况下禁用了某些 QA 检查，因此此列表不包括所有可能的 QA 检查错误和警告。</p>
<p>9.2错误和警告
&lt;packagename&gt;: &lt;path&gt; is using libexec please relocate to &lt;libexecdir&gt; [libexec]</p>
<p>/usr/libexec当发行版配置使用不同的路径时，指定的包包含文件，&lt;libexecdir&gt;默认情况下&lt;libexecdir&gt;是$prefix/libexec. 但是，可以更改此默认值（例如${libdir}）。</p>
<p>package &lt;packagename&gt; contains bad RPATH &lt;rpath&gt; in file &lt;file&gt; [rpaths]</p>
<p>配方生成的指定二进制文件包含动态库加载路径 (rpaths)，其中包含构建系统路径，例如 TMPDIR，这对于目标不正确并且可能是一个安全问题。在do_compile日志中检查-rpath 传递给链接器的 错误选项。根据正在构建的软件使用的构建系统，可能有一个配置选项可以在软件构建中完全禁用 rpath 使用。</p>
<p>&lt;packagename&gt;: &lt;file&gt; contains probably-redundant RPATH &lt;rpath&gt; [useless-rpaths]</p>
<p>配方生成的指定二进制文件包含在标准系统上默认由链接器搜索的动态库加载路径 (rpaths)（例如/lib和/usr/lib）。虽然这些路径不会造成任何破损，但它们确实会浪费空间并且是不必要的。根据正在构建的软件使用的构建系统，可能有一个配置选项可以在软件构建中完全禁用 rpath 使用。</p>
<p>&lt;packagename&gt; requires &lt;files&gt;, but no providers in its RDEPENDS [file-rdeps]</p>
<p>已从指定文件的指定包中识别出文件级依赖关系，但RDEPENDS中没有明确的对应条目。如果在运行时需要特定文件，则应在配方中声明RDEPENDS以确保构建提供它们的包。</p>
<p>&lt;packagename1&gt; rdepends on &lt;packagename2&gt;, but it isn’t a build dependency? [build-deps]</p>
<p>两个指定的包之间存在运行时依赖关系，但配方中没有明确的内容来启用 OpenEmbedded 构建系统以确保满足依赖关系。这种情况通常是由 在打包阶段而不是预先添加的RDEPENDS值触发的，这通常是根据包的内容自动进行的。在大多数情况下，您应该更改配方以为依赖项添加显式RDEPENDS。</p>
<p>non -dev/-dbg/nativesdk- package contains symlink .so: &lt;packagename&gt; path ‘&lt;path&gt;’ [dev-so]</p>
<p>符号链接.so文件仅用于开发，因此应放入-dev包中。如果您添加 <em>.so*而不是添加</em>.so.*到非开发包，则可能会发生这种情况。更改 FILES（可能还有 PACKAGES），以使指定的.so 文件进入适当的-dev包。</p>
<p>non -staticdev package contains static .a library: &lt;packagename&gt; path ‘&lt;path&gt;’ [staticdev]</p>
<p>静态.a库文件应该放入一个-staticdev包中。更改FILES（可能还有 PACKAGES），以使指定的.a文件进入适当的-staticdev包。</p>
<p>&lt;packagename&gt;: found library in wrong location [libdir]</p>
<p>指定的文件可能已安装到不正确的（可能是硬编码的）安装路径中。例如，此测试将捕获“lib32”/lib/bar.so时安装的配方。${base_libdir}另一个例子是当食谱安装 /usr/lib64/foo.so时${libdir}是“/usr/lib”。偶尔会出现误报。对于这些情况，将“libdir”添加到 包的INSANE_SKIP。</p>
<p>non debug package contains .debug directory: &lt;packagename&gt; path &lt;path&gt; [debug-files]</p>
<p>指定的包包含一个.debug目录，该目录不应出现在-dbg包之外的任何内容中。如果您添加包含.debug目录的路径并且未将.debug目录显式添加到-dbg包中，则可能会发生这种情况。如果是这种情况，请将.debug目录显式添加到 FILES:${PN}-dbg. 有关FILES的更多信息，请参阅FILES。</p>
<p>Architecture did not match (&lt;file_arch&gt;, expected &lt;machine_arch&gt;) in &lt;file&gt; [arch]</p>
<p>默认情况下，OpenEmbedded 构建系统会检查任何二进制文件的可执行和可链接格式 (ELF) 类型、位大小和字节序，以确保它们与目标体系结构匹配。如果任何二进制文件与类型不匹配，则此测试将失败，因为存在不兼容性。测试可能表明使用了错误的编译器或编译器选项。有时软件（如引导加载程序）可能需要绕过此检查。如果您收到错误的文件是不打算在目标操作系统中执行或打算在设备内的单独处理器上运行的固件，您可以将“arch”添加到 包的INSANE_SKIP。另一种选择是检查do_compile日志并验证正在使用的编译器选项是否正确。</p>
<p>Bit size did not match (&lt;file_bits&gt;, expected &lt;machine_bits&gt;) in &lt;file&gt; [arch]</p>
<p>默认情况下，OpenEmbedded 构建系统会检查任何二进制文件的可执行和可链接格式 (ELF) 类型、位大小和字节序，以确保它们与目标体系结构匹配。如果任何二进制文件与类型不匹配，则此测试将失败，因为存在不兼容性。测试可能表明使用了错误的编译器或编译器选项。有时软件（如引导加载程序）可能需要绕过此检查。如果您收到错误的文件是不打算在目标操作系统中执行或打算在设备内的单独处理器上运行的固件，您可以将“arch”添加到 包的INSANE_SKIP。另一种选择是检查do_compile日志并验证正在使用的编译器选项是否正确。</p>
<p>Endianness did not match (&lt;file_endianness&gt;, expected &lt;machine_endianness&gt;) in &lt;file&gt; [arch]</p>
<p>默认情况下，OpenEmbedded 构建系统会检查任何二进制文件的可执行和可链接格式 (ELF) 类型、位大小和字节序，以确保它们与目标体系结构匹配。如果任何二进制文件与类型不匹配，则此测试将失败，因为存在不兼容性。测试可能表明使用了错误的编译器或编译器选项。有时软件（如引导加载程序）可能需要绕过此检查。如果您收到错误的文件是不打算在目标操作系统中执行或打算在设备内的单独处理器上运行的固件，您可以将“arch”添加到 包的INSANE_SKIP。另一种选择是检查do_compile日志并验证正在使用的编译器选项是否正确。</p>
<p>ELF binary ‘&lt;file&gt;’ has relocations in .text [textrel]</p>
<p>指定的 ELF 二进制文件在其.text 部分中包含重定位。这种情况可能会导致运行时的性能影响。</p>
<p>通常，解决此性能问题的方法是将“-fPIC”或“-fpic”添加到编译器命令行选项。例如，给定在构建时读取CFLAGS的软件，您可以将以下内容添加到您的配方中：</p>
<p>CFLAGS:append = ” -fPIC ”
有关运行时文本重定位的更多信息，请参阅 https://www.akkadia.org/drepper/textrelocs.html。</p>
<p>File ‘&lt;file&gt;’ in package ‘&lt;package&gt;’ doesn’t have GNU_HASH (didn’t pass LDFLAGS?) [ldflags]</p>
<p>这表明构建配方时生成的二进制文件没有与构建系统提供的LDFLAGS选项链接。检查以确保LDFLAGS 变量正在传递给链接器命令。这种情况的常见解决方法是在配方中使用 TARGET_CC_ARCH传入LDFLAGS，如下所示：</p>
<p>TARGET_CC_ARCH += “${LDFLAGS}”
Package &lt;packagename&gt; contains Xorg driver (&lt;driver&gt;) but no xorg-abi- dependencies [xorg-driver-abi]</p>
<p>指定的包包含 Xorg 驱动程序，但没有相应的 ABI 包依赖项。xserver-xorg 配方提供驱动程序 ABI 名称。所有驱动程序都应依赖于构建它们的 ABI 版本。包含xorg-driver-input.inc或xorg-driver-video.inc将自动获取这些版本的驱动程序配方。因此，您应该只需要显式地将依赖项添加到二进制驱动程序配方。</p>
<p>The /usr/share/info/dir file is not meant to be shipped in a particular package. [infodir]</p>
<p>/usr/share/info/dir不应打包。将以下行添加到您的do_install任务或 do_install:append配方中，如下所示：</p>
<p>rm ${D}${infodir}/dir
Symlink &lt;path&gt; in &lt;packagename&gt; points to TMPDIR [symlink-to-sysroot]</p>
<p>指定的符号链接指向主机上的TMPDIR 。这样的符号链接将在主机上工作。但是，在目标上运行时，它们显然是无效的。您应该更正符号链接以使用相对路径或删除符号链接。</p>
<p>&lt;file&gt; failed sanity test (workdir) in path &lt;path&gt; [la]</p>
<p>指定的.la文件包含TMPDIR 路径。任何.la包含这些路径的文件都是不正确的，因为 libtool在自动使用文件时添加了正确的 sysroot 前缀。</p>
<p>&lt;file&gt; failed sanity test (tmpdir) in path &lt;path&gt; [pkgconfig]</p>
<p>指定的.pc文件包含 TMPDIR /WORKDIR 路径。任何.pc包含这些路径的文件都是不正确 的，因为pkg-config在访问文件时它本身会添加正确的 sysroot 前缀。</p>
<p>&lt;packagename&gt; rdepends on &lt;debug_packagename&gt; [debug-deps]</p>
<p>指定的非 dbg 包（即名称不以 结尾-dbg的包）和作为包的包 之间存在依赖关系dbg。这些dbg包包含调试符号，并使用几种不同的方法引入：</p>
<p>使用dbg-pkgs IMAGE_FEATURES值。</p>
<p>使用IMAGE_INSTALL。</p>
<p>作为dbg使用上述方法之一引入的另一个包的依赖项。</p>
<p>依赖项可能已被自动添加，因为 dbg包错误地包含不应包含的文件（例如非符号链接.so文件），或者可能已手动添加（例如通过添加到RDEPENDS）。</p>
<p>&lt;packagename&gt; rdepends on &lt;dev_packagename&gt; [dev-deps]</p>
<p>指定的非开发包（名称不以 结尾-dev的包）和作为包的包之间存在依赖关系dev 。这些dev包包含开发头文件，通常使用几种不同的方法引入：</p>
<p>使用dev-pkgs IMAGE_FEATURES值。</p>
<p>使用IMAGE_INSTALL。</p>
<p>作为dev使用上述方法之一引入的另一个包的依赖项。</p>
<p>依赖项可能是自动添加的（因为 dev包错误地包含了它不应该有的文件（例如非符号链接.so文件），或者它可能是手动添加的（例如通过添加到RDEPENDS）。</p>
<p>&lt;var&gt;:&lt;packagename&gt; is invalid: &lt;comparison&gt; (&lt;value&gt;)   only comparisons &lt;, =, &gt;, &lt;=, and &gt;= are allowed [dep-cmp]</p>
<p>如果要将版本化依赖关系添加到依赖变量之一（RDEPENDS、 RRECOMMENDS、 RSUGGESTS、 RPROVIDES、 RREPLACES或 RCONFLICTS），则只能使用命名的比较运算符。更改您要添加的版本依赖值以匹配消息中列出的值。</p>
<p>&lt;recipename&gt;: The compile log indicates that host include and/or library paths were used. Please check the log ‘&lt;logfile&gt;’ for more information. [compile-host-path]</p>
<p>do_compile任务的日志表明在主机上的路径中搜索了文件，这在交叉编译时是不合适的。在指定的日志文件中查找“is unsafe for cross-compilation”或“CROSS COMPILE Badness”。</p>
<p>&lt;recipename&gt;: The install log indicates that host include and/or library paths were used. Please check the log ‘&lt;logfile&gt;’ for more information. [install-host-path]</p>
<p>do_install任务的日志表明在主机上的路径中搜索了文件，这在交叉编译时是不合适的。在指定的日志文件中查找“is unsafe for cross-compilation”或“CROSS COMPILE Badness”。</p>
<p>This autoconf log indicates errors, it looked at host include and/or library paths while determining system capabilities. Rerun configure task after fixing this. [configure-unsafe]</p>
<p>do_configure任务的日志表明在主机上的路径中搜索了文件，这在交叉编译时是不合适的。在指定的日志文件中查找“is unsafe for cross-compilation”或“CROSS COMPILE Badness”。</p>
<p>&lt;packagename&gt; doesn’t match the [a-z0-9.+-]+ regex [pkgname]</p>
<p>OpenEmbedded 构建系统中的约定（有时由包管理器本身强制执行）是要求包名称全部小写并允许一组受限字符。如果您的配方名称与此不匹配，或者您将包添加到 不符合约定的PACKAGES中，那么您将收到此错误。重命名你的食谱。或者，如果您向PACKAGES添加了不符合要求的包名称，请适当更改包名称。</p>
<p>&lt;recipe&gt;: configure was passed unrecognized options: &lt;options&gt; [unknown-configure-option]</p>
<p>配置脚本报告指定的选项无法识别。这种情况可能是因为这些选项以前有效但已从配置脚本中删除。或者，添加选项时出错，应该使用另一个选项。如果您不确定，请查阅上游构建文档、输出和上游更改日志或发行说明。确定适当的更改后，您可以相应地更新 EXTRA_OECONF、 PACKAGECONFIG_CONFARGS或单独的PACKAGECONFIG选项值。./configure –help</p>
<p>Recipe &lt;recipefile&gt; has PN of “&lt;recipename&gt;” which is in OVERRIDES, this can result in unexpected behavior. [pn-overrides]</p>
<p>指定的配方具有出现在OVERRIDES中的名称 ( PN ) 值。如果一个配方被命名为它的PN值与OVERRIDES中已经存在的值匹配 （例如PN恰好与MACHINE 或DISTRO相同），它可能会产生意想不到的后果。例如，诸如 有效地变成. 重命名您的配方（或者如果明确设置了 PN，请更改 PN值），以免发生冲突。有关其他信息，请参阅 文件。FILES:${PN} = “xyz”FILES = “xyz”</p>
<p>&lt;recipefile&gt;: Variable &lt;variable&gt; is set as not being package specific, please fix this. [pkgvarcheck]</p>
<p>某些变量（RDEPENDS、 RRECOMMENDS、 RSUGGESTS、 RCONFLICTS、 RPROVIDES、 RREPLACES、FILES、 pkg_preinst、pkg_postinst、pkg_prerm、pkg_postrm和 ALLOW_EMPTY）应始终设置为特定于包（即它们应设置为包名称覆盖，例如而不是 ）。如果您收到此错误，请更正配方中对这些变量的任何分配。RDEPENDS:${PN} = “value”RDEPENDS = “value”</p>
<p>recipe uses DEPENDS:${PN}, should use DEPENDS [pkgvarcheck]</p>
<p>此检查查找DEPENDS:${PN} 错误设置的实例（DEPENDS是一个配方范围的变量，因此为特定包指定它是不正确的，这样的分配也不会真正起作用。）改为设置DEPENDS。</p>
<p>File ‘&lt;file&gt;’ from &lt;recipename&gt; was already stripped, this will prevent future debugging! [already-stripped]</p>
<p>生成的二进制文件在构建系统提取调试符号之前已经被剥离。上游软件项目默认剥离输出二进制文件的调试符号是很常见的。为了使用-dbg包在目标上进行调试，必须禁用此剥离。</p>
<p>根据正在构建的软件使用的构建系统，禁用此剥离可能与指定附加配置选项一样简单。如果没有，禁用剥离可能涉及修补构建脚本。在后一种情况下，查找对“strip”或“STRIP”的引用，或在链接器命令行上指定的“-s”或“-S”命令行选项（如果前面带有“可能通过编译器命令行” -Wl，”）。</p>
<p>笔记</p>
<p>在这里禁用剥离并不意味着最终打包的二进制文件将被取消剥离。一旦 OpenEmbedded 构建系统将调试符号拆分到-dbg包中，它就会从二进制文件中删除符号。</p>
<p>&lt;packagename&gt; is listed in PACKAGES multiple times, this leads to packaging errors. [packages-list]</p>
<p>包名称在PACKAGES变量中只能出现一次 。如果您尝试向PACKAGES添加一个已经在变量值中的包，您可能会收到此错误。</p>
<p>FILES variable for package &lt;packagename&gt; contains ‘//’ which is invalid. Attempting to fix this but you should correct the metadata. [files-invalid]</p>
<p>字符串“//”在 Unix 路径中无效。更正此字符串出现在FILES变量中的所有匹配项，以便只有一个“/”。</p>
<p>&lt;recipename&gt;: Files/directories were installed but not shipped in any package [installed-vs-shipped]</p>
<p>文件已安装在 do_install任务中，但尚未通过FILES 变量包含在任何包中。未出现在任何包中的文件不能在稍后的构建过程中出现在映像中。您需要执行以下操作之一：</p>
<p>将文件添加到您希望它们出现的包的FILES中（例如，主包的FILES:${PN ）。}</p>
<p>do_install如果任何包中不需要这些文件，请在任务结束时删除这些文件。</p>
<p>&lt;oldpackage&gt;-&lt;oldpkgversion&gt; was registered as shlib provider for &lt;library&gt;, changing it to &lt;newpackage&gt;-&lt;newpkgversion&gt; because it was built later</p>
<p>这个消息意味着两者都&lt;oldpackage&gt;提供&lt;newpackage&gt; 了指定的共享库。当配方重命名时，您可能会收到此消息。但是，如果不是这种情况，则该消息可能表明某个库的私有版本被错误地选择为公共库的提供者。如果是这种情况，您应该在提供库的私有版本的配方中将库的.so文件名添加到 PRIVATE_LIBS。</p>
<p>LICENSE:&lt;packagename&gt; includes licenses (&lt;licenses&gt;) that are not listed in LICENSE [unlisted-pkg-lics]</p>
<p>配方的许可证应该是此配方生产的所有包的所有许可证的超集。换句话说，任何许可证LICENSE:<a href="#id39"><span class="problematic" id="id40">*</span></a>也应该出现在 LICENSE中。</p>
<p>AM_GNU_GETTEXT used but no inherit gettext [configure-gettext]</p>
<p>如果配方正在构建使用 automake 的东西并且 automake 文件包含AM_GNU_GETTEXT指令，那么如果配方中没有声明以确保 gettext 在构建期间可用，则此检查将失败。添加以删除警告。inherit gettextinherit gettext</p>
<p>package contains mime types but does not inherit mime: &lt;packagename&gt; path ‘&lt;file&gt;’ [mime]</p>
<p>指定的包包含 mime 类型文件（.xmlfiles in ${datadir}/mime/packages），但不继承 mime 类，这将确保这些文件得到正确安装。如果不需要，请添加到配方中或删除步骤中的文件 。inherit mimedo_install</p>
<p>package contains desktop file with key ‘MimeType’ but does not inhert mime-xdg: &lt;packagename&gt; path ‘&lt;file&gt;’ [mime-xdg]</p>
<p>指定的包包含一个带有“MimeType”键的 .desktop 文件，但不继承激活它所需的 mime-xdg 类。如果不需要，请添加到配方中或删除步骤中的文件。inherit mimedo_install</p>
<p>&lt;recipename&gt;: SRC_URI uses unstable GitHub archives [src-uri-bad]</p>
<p>GitHub 提供了“归档”压缩包，但是这些压缩包可以即时重新生成，因此文件的签名将不一定与 SRC_URI 校验和中的签名匹配，从而导致构建失败。建议您使用官方发布的 tarball 或切换到在实际 git 存储库中拉取相应的修订版本。</p>
<p>SRC_URI uses PN not BPN [src-uri-bad]</p>
<p>如果SRC_URI的某些部分需要引用配方名称，它应该使用 ${ BPN } 而不是 ${ PN } 这样做，因为后者会因同一配方的不同变体而改变，例如，当使用BBCLASSEXTEND 或 multilib 时。如果在SRC_URI值${PN} 中找到对的引用，此检查将失败- 改为改为。${BPN}</p>
<p>&lt;recipename&gt;: recipe doesn’t inherit features_check [unhandled-features-check]</p>
<p>此检查确保如果使用features_check 类支持的变量之一（例如REQUIRED_DISTRO_FEATURES），则配方继承features_check以使需求实际起作用。如果您看到此消息，请添加到您的配方或删除对变量的引用（如果不需要）。inherit features_check</p>
<p>&lt;recipename&gt;: recipe defines ALTERNATIVE:&lt;packagename&gt; but doesn’t inherit update-alternatives. This might fail during do_rootfs later! [missing-update-alternatives]</p>
<p>此检查确保如果配方设置了ALTERNATIVE变量，该配方也继承更新替代品，以便正确设置替代品。如果您看到此消息，请添加到您的配方或删除对变量的引用（如果不需要）。inherit update-alternatives</p>
<p>&lt;packagename&gt;: &lt;file&gt; maximum shebang size exceeded, the maximum size is 128. [shebang-size]</p>
<p>此检查确保#!脚本的 shebang 行（在第一行中）不超过 128 个字符，这可能会在运行时导致错误，具体取决于操作系统。如果您看到此消息，则可能需要修补指定的脚本以使其更短，以避免运行时问题。</p>
<p>&lt;packagename&gt; contains perllocal.pod (&lt;files&gt;), should not be installed [perllocalpod]</p>
<p>perllocal.pod是本地安装模块的索引文件，因此不应由任何分发包安装。cpan类已经设置NO_PERLLOCAL为停止大多数 Perl 配方生成此文件，但如果直接使用配方，那么MakeMaker它们可能无法正确执行此操作。此检查确保 perllocal.pod 不在任何包中，以避免多个包运送此文件，因此如果安装在一起，它们的包会发生冲突。</p>
<p>&lt;packagename&gt; package is not obeying usrmerge distro feature. /&lt;path&gt; should be relocated to /usr. [usrmerge]</p>
<p>如果usrmerge在DISTRO_FEATURES中，此检查将确保没有包将文件安装到根 ( /bin, /sbin, /lib, /lib64) 目录。如果您看到此消息，则表明该do_install步骤（或者可能 do_install正在调用的构建过程，例如使用硬编码路径而不是为此设置的变量（,等），并且应该更改它做。make installbindirsbindir</p>
<p>Fuzz detected: &lt;patch output&gt; [patch-fuzz]</p>
<p>do_patch 当在任务中应用补丁时，此检查会寻找“模糊”的证据。补丁模糊是patch工具忽略某些上下文行以应用补丁的情况。考虑这个例子：</p>
<p>要应用的补丁：</p>
<p>— filename
+++ filename</p>
<blockquote>
<div><p>context line 1
context line 2
context line 3</p>
</div></blockquote>
<dl class="simple">
<dt>+newly added line</dt><dd><p>context line 4
context line 5
context line 6</p>
</dd>
</dl>
<p>原始源代码：</p>
<p>different context line 1
different context line 2
context line 3
context line 4
different context line 5
different context line 6
结果（应用带有模糊的补丁后）：</p>
<p>different context line 1
different context line 2
context line 3
newly added line
context line 4
different context line 5
different context line 6
很可能，新添加的行实际上添加到了完全错误的位置，或者它已经在原始源中并且是第二次添加的。如果上下文第 3 行和第 4 行是空白的或者其中只有通用的东西，例如#endifor ，这尤其可能}。根据修补的代码，错误修补的文件完全有可能仍然编译而没有错误。</p>
<p>如何消除补丁模糊警告</p>
<p>使用devtool警告中解释的命令。首先，将源代码解压到 devtool 工作区中：</p>
<p>devtool modify &lt;recipe&gt;
这将应用所有补丁，并在工作区中创建新的提交——补丁上下文已更新。</p>
<p>然后，替换配方层中的补丁：</p>
<p>devtool finish –force-patch-refresh &lt;recipe&gt; &lt;layer_path&gt;
然后需要审查补丁更新（最好使用并行差异工具）以确保它们确实在做正确的事情，即：</p>
<p>它们被应用在文件中的正确位置；</p>
<p>他们不会引入重复的行，或以其他方式做不再需要的事情。</p>
<p>要确认这些事情，您还可以在 devtool 的工作区中查看已修补的源代码，通常在&lt;build_dir&gt;/workspace/sources/&lt;recipe&gt;/</p>
<p>审核完成后，您可以使用修改上下文的补丁更新创建和发布层提交。Devtool 也可能会刷新补丁中的其他内容，这些可以被丢弃。</p>
<p>9.3配置和禁用 QA 检查
您可以分别使用WARN_QA和ERROR_QA 变量全局配置 QA 检查，以便特定检查失败引发警告或错误消息 。您还可以使用INSANE_SKIP禁用特定配方中的检查。有关如何使用 QA 检查的信息，请参阅“ insane.bbclass ”部分。</p>
<p>笔记</p>
<p>请记住，QA 检查旨在检测打包输出中的实际或潜在问题。因此，在禁用这些检查时要小心。</p>
<p>10张图片
OpenEmbedded 构建系统提供了几个示例图像以满足不同的需求。当您发出bitbake命令时，您提供了一个“顶级”配方，基本上开始构建您想要的图像类型。</p>
<p>笔记</p>
<p>构建没有 GNU 通用公共许可证版本 3 (GPLv3)、GNU 宽通用公共许可证版本 3 (LGPLv3) 和 GNU Affero 通用公共许可证版本 3 (AGPL-3.0) 组件的映像仅支持最小和基本映像。此外，如果您要使用非 GPLv3 和类似许可的组件构建映像，则必须local.conf 在使用 BitBake 命令构建最小或基本映像之前对文件进行以下更改：</p>
<ol class="arabic simple">
<li><p>Comment out the EXTRA_IMAGE_FEATURES line</p></li>
</ol>
<p>2. Set INCOMPATIBLE_LICENSE = “GPL-3.0 LGPL-3.0 AGPL-3.0”
在pokyGit 存储库中，您可以使用以下命令显示源目录 中包含图像配方文件的目录列表：</p>
<p>$ ls meta*/recipes*/images/<a href="#id41"><span class="problematic" id="id42">*</span></a>.bb
以下是支持的食谱列表：</p>
<p>build-appliance-image：一个示例虚拟机，其中包含使用构建系统以及构建系统本身运行构建所需的所有部分。您可以使用VMware Player或 VMware Workstation引导和运行映像。有关此映像的更多信息，请参阅 Yocto 项目网站上的构建设备页面。</p>
<p>core-image-base：完全支持目标设备硬件的仅控制台映像。</p>
<p>core-image-full-cmdline：仅控制台映像，安装了更全功能的 Linux 系统功能。</p>
<p>core-image-lsb：符合 Linux 标准基础 (LSB) 规范的映像。此映像需要支持 LSB 合规性的分发配置（例如poky-lsb）。如果您在 core-image-lsb没有该配置的情况下构建，则映像将不符合 LSB。</p>
<p>core-image-lsb-dev：core-image-lsb适合使用主机进行开发工作的图像。该映像包括可在主机开发环境中使用的标头和库。此映像需要支持 LSB 合规性的分发配置（例如poky-lsb）。如果您在core-image-lsb-dev没有该配置的情况下构建，则映像将不符合 LSB。</p>
<p>core-image-lsb-sdk:core-image-lsb包括跨工具链中的所有内容，还包括开发头文件和库，以形成完整的独立 SDK。此映像需要支持 LSB 合规性的分发配置（例如 poky-lsb）。如果您在core-image-lsb-sdk没有该配置的情况下构建，则映像将不符合 LSB。此图像适合使用目标进行开发。</p>
<p>core-image-minimal：一个小图像，只是能够允许设备启动。</p>
<p>core-image-minimal-dev：core-image-minimal适合使用主机进行开发工作的图像。该映像包括可在主机开发环境中使用的标头和库。</p>
<p>core-image-minimal-initramfs：core-image-minimal具有基于最小 RAM 的初始根文件系统 (initramfs) 作为内核一部分的映像，它允许系统更有效地找到第一个“init”程序。有关使用 initramfs 图像时有用的其他信息，请参阅 PACKAGE_INSTALL变量。</p>
<p>core-image-minimal-mtdutils:core-image-minimal支持 Minimal MTD Utilities 的映像，它允许用户与内核中的 MTD 子系统交互以在闪存设备上执行操作。</p>
<p>core-image-rt：core-image-minimal图像加上适合实时使用的实时测试套件和工具。</p>
<p>core-image-rt-sdk：core-image-rt包含跨工具链中所有内容的图像。该镜像还包括开发头和库，形成完整的独立SDK，适合使用目标进行开发。</p>
<p>core-image-sato：具有佐藤支持的图像，移动环境和视觉风格，适用于移动设备。该图像支持带有 Sato 主题的 X11 和终端、编辑器、文件管理器、媒体播放器等应用程序。</p>
<p>core-image-sato-dev：core-image-sato适合使用主机开发的图像。该映像包括在设备本身上构建应用程序所需的库、测试和分析工具以及调试符号。此图像以前是core-image-sdk.</p>
<p>core-image-sato-sdk：core-image-sato包含跨工具链中所有内容的图像。该映像还包括开发头文件和库，以形成完整的独立 SDK，适合使用目标进行开发。</p>
<p>core-image-testmaster：设计用于自动运行时测试的“控制器”映像。提供部署到单独分区的“已知良好”映像，以便您可以启动到它并使用它来部署要测试的第二个映像。您可以在 Yocto 项目开发任务手册中的“执行自动运行时测试”部分中找到有关运行时测试的更多信息。</p>
<p>core-image-testmaster-initramfs：一个基于 RAM 的初始根文件系统 (initramfs) 映像，专为与 core-image-testmaster映像一起使用而设计。</p>
<p>core-image-weston：带有终端的非常基本的 Wayland 图像。此图像提供 Wayland 协议库和参考 Weston 合成器。有关更多信息，请参阅 Yocto 项目开发任务手册中的“使用 Wayland 和 Weston ”部分。</p>
<p>core-image-x11：带有终端的非常基本的 X11 图像。</p>
<p>11特点
本章提供了可以包含在图像中的已发货机器和发行版功能的参考、可以选择的图像功能的参考以及功能回填的参考。</p>
<p>特性提供了一种机制来确定哪些包应该包含在生成的图像中。发行版可以通过DISTRO_FEATURES变量选择他们想要支持的功能，该变量在发行版的配置文件中设置或附加，例如poky.conf、等。机器特性在MACHINE_FEATURES变量中设置，该变量在机器配置文件中设置并指定给定机器的硬件特性。poky-tiny.confpoky-lsb.conf</p>
<p>这两个变量结合起来计算出要包含的内核模块、实用程序和其他包。给定的发行版可以支持选定的功能子集，因此如果发行版本身不支持某些机器功能，则可能不包括它们。</p>
<p>您可以用来确定哪些配方正在检查以查看是否包含特定功能的一种方法是grep通过该 功能的元数据。这是一个示例，它发现其构建可能基于给定功能而更改的配方：</p>
<p>$ cd poky
$ git grep ‘contains.*MACHINE_FEATURES.*feature’
11.1机器特性
以下项目是您可以与 MACHINE_FEATURES一起使用的功能。功能与包没有一一对应的关系，它们可以超越简单地控制一个或多个包的安装。有时，一项功能会影响某些配方的构建方式。例如，一项功能可能会确定是否在do_configure任务中为特定配方指定了特定配置选项。</p>
<p>此功能列表仅表示 Yocto 项目元数据附带的功能：</p>
<p>acpi：硬件具有 ACPI（仅限 x86/x86_64）</p>
<p>alsa：硬件具有 ALSA 音频驱动程序</p>
<p>apm：硬件使用 APM（或 APM 仿真）</p>
<p>蓝牙：硬件已集成BT</p>
<p>efi：支持通过 EFI 引导</p>
<p>ext2：硬件 HDD 或 Microdrive</p>
<p>键盘：硬件有键盘</p>
<p>pcbios：支持通过 BIOS 启动</p>
<p>pci：硬件有PCI总线</p>
<p>pcmcia：硬件具有 PCMCIA 或 CompactFlash 插槽</p>
<p>电话：手机（语音）支持</p>
<p>qvga：机器有一个 QVGA (320x240) 显示器</p>
<p>rtc：机器有一个实时时钟</p>
<p>screen：硬件有屏幕</p>
<p>serial：硬件有串口支持（通常是RS232）</p>
<p>触摸屏：硬件有触摸屏</p>
<p>usbgadget：硬件支持 USB gadget 设备</p>
<p>usbhost：硬件支持 USB 主机</p>
<p>vfat： FAT 文件系统支持</p>
<p>wifi：硬件已集成WiFi</p>
<p>11.2发行版功能
以下项目是您可以与 DISTRO_FEATURES一起使用以在您的发行版中启用功能的功能。功能与包没有一一对应的关系，它们可以超越简单地控制一个或多个包的安装。In most cases, the presence or absence of a feature translates to the appropriate option supplied to the configure script during the do_configure task for the recipes that optionally support the feature.</p>
<p>一些发行版功能也是机器功能。这些选择功能对于在机器和分布配置级别进行控制都是有意义的。有关更多信息，请参阅 COMBIED_FEATURES变量。</p>
<p>此列表仅代表 Yocto 项目元数据附带的功能：</p>
<p>alsa：包括 ALSA 支持（如果可用，安装 OSS 兼容性内核模块）。</p>
<p>api-documentation：在配方构建期间启用 API 文档的生成。使用该命令时，生成的文档将添加到 SDK tarball。请参阅 Yocto 项目应用程序开发和可扩展软件开发工具包 (eSDK) 手册中的“将 API 文档添加到标准 SDK ”部分。bitbake -c populate_sdk</p>
<p>蓝牙：包括蓝牙支持（仅限集成 BT）。</p>
<p>cramfs：包括 CramFS 支持。</p>
<p>directfb：包括 DirectFB 支持。</p>
<p>ext2：包括支持具有内部 HDD/Microdrive 的设备用于存储文件（而不是仅 Flash 设备）的工具。</p>
<p>ipsec：包括 IPSec 支持。</p>
<p>ipv6：包括 IPv6 支持。</p>
<p>键盘：包括键盘支持（例如，键盘映射将在启动期间加载）。</p>
<p>ldconfig：包括对 ldconfig 和ld.so.conf目标的支持。</p>
<p>nfs：包括 NFS 客户端支持（用于在设备上安装 NFS 导出）。</p>
<p>opengl：包括开放图形库，它是一个跨语言、多平台的应用程序编程接口，用于渲染二维和三维图形。</p>
<p>pci：包括 PCI 总线支持。</p>
<p>pcmcia：包括 PCMCIA/CompactFlash 支持。</p>
<p>ppp：包括 PPP 拨号支持。</p>
<p>ptest：允许在单个配方支持的情况下构建包测试。有关包测试的更多信息，请参阅 Yocto 项目开发任务手册中的“使用 ptest 测试包”部分。</p>
<p>smbfs：包括 SMB 网络客户端支持（用于在设备上安装 Samba/Microsoft Windows 共享）。</p>
<p>systemd：包括对这个init管理器的支持，它完全替代了 for init，具有并行启动服务、减少 shell 开销和其他功能。init许多发行版都使用此管理器。</p>
<p>usbgadget：包括 USB 小工具设备支持（用于 USB 网络/串行/存储）。</p>
<p>usbhost：包括 USB 主机支持（允许连接外部键盘、鼠标、存储、网络等）。</p>
<p>usrmerge：将/bin、/sbin、/lib和/lib64 目录合并到目录中各自对应的/usr 目录中，以提供更好的包和应用程序兼容性。</p>
<p>wayland：包括 Wayland 显示服务器协议和支持它的库。</p>
<p>wifi：包括 WiFi 支持（仅限集成）。</p>
<p>x11：包括 X 服务器和库。</p>
<p>11.3图像特征
OpenEmbedded 构建系统生成的图像内容可以由您通常在图像配方中配置的IMAGE_FEATURES和 EXTRA_IMAGE_FEATURES变量控制。通过这些变量，您可以添加几个不同的预定义包，例如开发实用程序或包含调查应用程序问题或分析应用程序所需的调试信息的包。</p>
<p>以下是适用于所有图像的图像功能：</p>
<p>allow-empty-password：允许 Dropbear 和 OpenSSH 接受 root 登录和来自具有空密码字符串的帐户的登录。</p>
<p>dbg-pkgs：为给定映像中安装的所有软件包安装调试符号软件包。</p>
<p>debug-tweaks：使图像适合开发（例如，允许 root 登录而无需密码并启用安装后日志记录）。有关更多信息，请参阅此列表中的“allow-empty-password”、“empty-root-password”和“post-install-logging”功能。</p>
<p>dev-pkgs：为给定映像中安装的所有包安装开发包（头文件和额外的库链接）。</p>
<p>doc-pkgs：为给定映像中安装的所有包安装文档包。</p>
<p>empty-root-password：将 root 密码设置为空字符串，允许使用空密码登录。</p>
<p>overlayfs-etc：配置/etc目录在overlayfs. 这允许将设备特定信息存储在其他地方，尤其是在根文件系统配置为只读的情况下。</p>
<p>包管理：安装包管理工具并保留包管理器数据库。</p>
<p>post-install-logging：/var/log/postinstall.log启用在目标系统上首次启动映像时将安装后脚本运行记录到文件中。</p>
<p>笔记</p>
<p>要使/var/log目标上的目录持久化，请使用 VOLATILE_LOG_DIR变量，将其设置为“no”。</p>
<p>ptest-pkgs：为所有启用 ptest 的配方安装 ptest 包。</p>
<p>read-only-rootfs：创建一个根文件系统为只读的镜像。有关更多信息，请参阅 Yocto 项目开发任务手册中的“创建只读根文件系统”部分。</p>
<p>splash：启用在启动过程中显示启动屏幕。默认情况下，此屏幕由 提供psplash，它允许自定义。如果您更喜欢使用其他启动屏幕包，您可以通过SPLASH在映像配方或发行版配置级别将变量设置为不同的包名称（或名称）来实现。</p>
<p>staticdev-pkgs：为给定镜像中安装的所有包安装静态开发包，即静态库（即*.a文件）。</p>
<p>某些图像功能仅在您继承 core-image类时可用。这些有效功能的当前列表如下：</p>
<p>hwcodecs：安装硬件加速编解码器。</p>
<p>nfs-server：安装 NFS 服务器。</p>
<p>perf：安装分析工具，例如perf、systemtap和 LTTng. 有关用户空间工具的一般信息，请参阅 Yocto 项目应用程序开发和可扩展软件开发工具包 (eSDK)手册。</p>
<p>ssh-server-dropbear：安装 Dropbear 最小 SSH 服务器。</p>
<p>ssh-server-openssh：安装OpenSSH SSH服务器，比Dropbear功能更全。请注意，如果 OpenSSH SSH 服务器和 Dropbear 最小 SSH 服务器都存在于 IMAGE_FEATURES中，则 OpenSSH 将优先并且不会安装 Dropbear。</p>
<p>tools-debug：安装调试工具，如strace和 gdb。有关 GDB 的信息，请参阅 Yocto 项目开发任务手册中的“使用 GNU 项目调试器 (GDB) 远程调试”部分。有关跟踪和分析的信息，请参阅Yocto 项目分析和跟踪手册。</p>
<p>tools-sdk：安装在设备上运行的完整 SDK。</p>
<p>tools-testapps：安装设备测试工具（例如触摸屏调试）。</p>
<p>x11：安装 X 服务器。</p>
<p>x11-base：以最小环境安装 X 服务器。</p>
<p>x11-sato：安装 OpenedHand Sato 环境。</p>
<p>11.4特征回填
有时需要在 OpenEmbedded 构建系统中扩展 MACHINE_FEATURES或 DISTRO_FEATURES以控制之前启用但无法禁用的功能。对于这些情况，我们需要添加一个额外的特性项以出现在这些变量之一中，但我们不希望强制在其配置中具有变量值的开发人员添加新特性以保持相同的整体功能级别。因此，OpenEmbedded 构建系统具有一种机制，可以自动将这些添加的功能“回填”到现有的发行版或机器配置中。您可以通过查找 DISTRO_FEATURES_BACKFILL和 MACHINE_FEATURES_BACKFILL来查看执行此操作的功能列表 文件中的变量meta/conf/bitbake.conf。</p>
<p>由于这些功能默认回填到上一段所述的所有配置中，因此希望禁用新功能的开发人员需要能够有选择地防止回填发生。他们可以通过将不需要的功能或功能添加到发行版功能和机器功能的 DISTRO_FEATURES_BACKFILL_CONSIDERED 或 MACHINE_FEATURES_BACKFILL_CONSIDERED 变量来实现。</p>
<p>下面是两个示例来帮助说明特征回填：</p>
<p>“pulseaudio”发行版功能选项：以前，PulseAudio 支持在 Qt 和 GStreamer 框架中启用。因此，该功能被回填，因此通过文件中的DISTRO_FEATURES_BACKFILL变量 为所有发行版启用meta/conf/bitbake.conf。但是，您的发行版需要禁用该功能。您可以通过在您的发行版文件中添加“pulseaudio”到DISTRO_FEATURES_BACKFILL_CONSIDERED来禁用该功能而不影响需要 PulseAudio 支持的其他现有发行版配置。.conf当特性也存在于DISTRO_FEATURES_BACKFILL变量中时，将该特性添加到该变量会阻止构建系统将该特性添加到配置的DISTRO_FEATURES，有效地禁用该特定发行版的功能。</p>
<p>“rtc”机器功能选项：以前，所有目标设备都启用了实时时钟 (RTC) 支持。因此，该功能被回填，因此通过文件中的 MACHINE_FEATURES_BACKFILL变量 为所有机器启用meta/conf/bitbake.conf。但是，您的目标设备没有此功能。您可以通过将功能添加到机器文件中机器的MACHINE_FEATURES_BACKFILL_CONSIDERED 列表中来禁用对您的设备的 RTC 支持，而不会影响需要 RTC 支持的其他机器.conf。当该功能也存在于MACHINE_FEATURES_BACKFILL 变量中时，将该功能添加到该变量会阻止构建系统将该功能添加到您的配置的MACHINE_FEATURES，有效地禁用对该特定机器的 RTC 支持。</p>
<hr class="docutils" />
<p>14常见问题
问： Poky 与OpenEmbedded有何不同？</p>
<p>答：该术语Poky是指 Yocto 项目提供的特定参考构建系统。Poky 基于 OpenEmbedded-Core (OE-Core)和BitBake。因此，这里用于构建系统的通用术语是“OpenEmbedded 构建系统”。在 Yocto 项目中使用 Poky 的开发与 OpenEmbedded 密切相关，更改总是先合并到 OE-Core 或 BitBake，然后再拉回 Poky。这种做法立即使这两个项目受益。</p>
<p>问：我的开发系统不符合要求的 Git、tar 和 Python 版本。特别是，我没有 Python 3.6.0 或更高版本。我还能使用 Yocto 项目吗？</p>
<p>答：您可以通过几种不同的方式在主机开发系统上获得所需的工具（即构建 tarball 或下载 tarball）。有关如何更新构建工具的步骤，请参阅“所需的 Git、tar、Python 和 gcc 版本”部分。</p>
<p>问：你怎么能说 Poky / OpenEmbedded-Core 是稳定的？</p>
<p>答：有三个方面有助于稳定；</p>
<p>Yocto 项目团队保持OpenEmbedded-Core (OE-Core)小而专注，包含大约 830 个配方，而不是其他 OpenEmbedded 社区层中可用的数千个。保持较小的尺寸使其易于测试和维护。</p>
<p>Yocto 项目团队使用一组固定的小型参考硬件和模拟目标来运行手动和自动测试。</p>
<p>Yocto 项目使用自动构建器，它提供持续的构建和集成测试。</p>
<p>问：如何获得对添加到 Yocto 项目的板的支持？</p>
<p>答：通过为其创建板支持包 (BSP) 层来添加对附加板的支持。有关如何创建 BSP 层的更多信息，请参阅Yocto 项目开发任务手册和 Yocto 项目板支持包开发人员指南中的“理解和创建层”部分。</p>
<p>通常，如果董事会不是完全陌生的，在 Yocto 项目中添加支持是相当简单的。</p>
<p>问：有没有使用 OpenEmbedded 构建系统构建的产品？</p>
<p>答：在Vernier LabQuest上运行的软件是使用 OpenEmbedded 构建系统构建的。有关详细信息，请参阅Vernier LabQuest网站。有许多使用 OpenEmbedded 构建系统的预生产设备，Yocto 项目团队会在它们发布后立即公布它们。</p>
<p>问： OpenEmbedded 构建系统输出什么？</p>
<p>答：因为您可以使用同一组配方来创建各种格式的输出，所以 OpenEmbedded 构建的输出取决于您如何启动它。通常，输出是为目标设备准备的可闪存映像。</p>
<p>问：如何将我的包添加到 Yocto 项目？</p>
<p>答：要添加包，您需要创建 BitBake 配方。有关如何创建 BitBake 配方的信息，请参阅 Yocto 项目开发任务手册中的“编写新配方”部分。</p>
<p>问：重新编译软件包时，我是否必须用新的 Yocto Project 映像重新刷新我的整个电路板？</p>
<p>答： OpenEmbedded 构建系统可以构建各种格式的包，例如用于 OPKG 的 IPK、Debian 包 ( .deb) 或 RPM。然后，您可以使用设备上的软件包工具升级软件包，就像在 Ubuntu 或 Fedora 等桌面发行版上一样。但是，目标上的包管理完全是可选的。</p>
<p>问：我看到错误“ ”。怎么了？chmod: XXXXX new permissions are r-xrwxrwx, not r-xr-xr-x</p>
<p>答：您可能正在 NTFS 文件系统上运行构建。使用 ext2,ext3或ext4代替。</p>
<p>问：当 OpenEmbedded 构建系统尝试下载源代码时，我看到很多文件的 404 响应。有什么问题吗？</p>
<p>答：没有错。OpenEmbedded 构建系统在从上游源下载之前检查任何配置的源镜像。构建系统会搜索源存档和 SCM 管理的软件的预检出版本。这些检查有助于大型安装，因为它可以减少 SCM 服务器本身的负载。上面的地址是配置到构建系统中的默认镜像之一。因此，如果上游源消失，团队可以将源放在那里，以便构建继续工作。</p>
<p>问：我的包中只有一台机器的机器特定数据，但在所有情况下，包都被标记为机器特定，我该如何防止这种情况发生？</p>
<p>答：在文件中设置SRC_URI_OVERRIDES_PACKAGE_ARCH = “0”，.bb但确保手动将包标记为特定于机器的情况下需要它。处理 SRC_URI_OVERRIDES_PACKAGE_ARCH的代码在 meta/classes/base.bbclass文件中。</p>
<p>问：我在防火墙后面，需要使用代理服务器。我怎么做？</p>
<p>答： OpenEmbedded 构建系统的大多数源代码获取都是由 完成的 wget，因此您需要在一个 .wgetrc文件中指定代理设置，如果您是单个用户，该文件可以在您的主目录中，也可以/usr/local/etc/wgetrc作为全局用户文件在其中。</p>
<p>以下是在文件中设置各种代理类型的适用代码 .wgetrc。默认情况下，这些设置在评论中被禁用。要使用它们，请删除评论：</p>
<p># You can set the default proxies for Wget to use for http, https, and ftp.
# They will override the value in the environment.
#https_proxy = <a class="reference external" href="http://proxy.yoyodyne.com:18023/">http://proxy.yoyodyne.com:18023/</a>
#http_proxy = <a class="reference external" href="http://proxy.yoyodyne.com:18023/">http://proxy.yoyodyne.com:18023/</a>
#ftp_proxy = <a class="reference external" href="http://proxy.yoyodyne.com:18023/">http://proxy.yoyodyne.com:18023/</a></p>
<p># If you do not want to use proxy at all, set this to off.
#use_proxy = on
Yocto 项目还包括一个 meta-poky/conf/site.conf.sample文件，该文件显示了如何在需要时配置 CVS 和 Git 代理服务器。有关设置各种代理类型和配置代理服务器的更多信息，请参阅“在网络代理背后工作”Wiki 页面。</p>
<p>问：target和有什么区别target-native？</p>
<p>答：目标*-native设计为在用于构建的系统上运行。这些通常是以某种方式协助构建所需的工具，例如quilt-native用于应用补丁的工具。非本地版本是在目标设备上运行的版本。</p>
<p>问：我看到随机构建失败。帮助？！</p>
<p>答：如果相同的构建以完全不同且随机的方式失败，最可能的解释是：</p>
<p>您正在运行构建的硬件有一些问题。</p>
<p>您正在虚拟化下运行构建，在这种情况下，虚拟化可能存在错误。</p>
<p>OpenEmbedded 构建系统处理大量数据，这些数据会导致大量网络、磁盘和 CPU 活动，并且对这些区域中的任何一个位故障都很敏感。真正的随机故障总是可以追溯到硬件或虚拟化问题。</p>
<p>问：当我尝试构建原生配方时，构建失败并 iconv.h出现问题。</p>
<p>答：如果您收到错误消息，表明 GNU未libiconv在使用中，但iconv.h已从.libiconv/usr/local/include</p>
<p>#error GNU libiconv not in use but included iconv.h is from libiconv
如果您发现以前安装的文件，您应该卸载它或暂时重命名它并再次尝试构建。</p>
<p>此问题只是 OpenEmbedded 构建系统在本机构建期间发现并使用以前安装的文件时导致的“系统泄漏”问题的单一表现。此类问题可能不限于iconv.h. 确保不会从任何 位置/usr/local/include发生泄漏/opt。</p>
<p>问：为了遵守许可证，我们需要运送什么？</p>
<p>答：这是一个很难的问题，您需要咨询您的律师以了解您的具体案件的答案。值得牢记的是，为了符合 GPL，需要提供足够的信息，以允许其他人重建并产生与您所提供的相同的最终结果。这意味着共享源代码、应用到它的任何补丁，以及有关如何配置和构建该包的任何配置信息。</p>
<p>您可以在 Yocto 项目概述和概念手册中的“许可”部分以及 Yocto 项目开发任务手册中的“在产品生命周期内维护开源许可合规性”部分中找到有关许可的更多信息。</p>
<p>问：如何禁用触摸屏设备上的光标？</p>
<p>答：您需要按照 Yocto 项目板支持包 (BSP) 开发人员指南中的“其他 BSP 特定配方文件”部分中的说明创建一个外形文件。将HAVE_TOUCHSCREEN变量设置为等于 1，如下所示：</p>
<p>HAVE_TOUCHSCREEN=1
问：如何确保默认启用已连接的网络接口？</p>
<p>答： netbase 配方提供的默认接口文件不会自动启动网络接口。因此，您将需要添加一个包含接口文件的特定于 BSP 的网络库。有关创建这些类型的其他配方文件的信息，请参阅 Yocto 项目板支持包 (BSP) 开发人员指南中的“其他 BSP 特定配方文件”部分。</p>
<p>例如，将以下文件添加到您的图层：</p>
<p>meta-MACHINE/recipes-bsp/netbase/netbase/MACHINE/interfaces
meta-MACHINE/recipes-bsp/netbase/netbase_5.0.bbappend
问：如何创建具有更多可用空间的图像？</p>
<p>答：默认情况下，OpenEmbedded 构建系统创建的映像是填充的根文件系统大小的 1.3 倍。要影响图像大小，您需要设置各种配置：</p>
<p>图像大小： OpenEmbedded 构建系统使用 IMAGE_ROOTFS_SIZE变量来定义图像的大小（以千字节为单位）。构建系统通过考虑在任何修改之前的初始根文件系统大小来确定大小，例如请求的图像大小和任何请求的要添加到图像的额外可用磁盘空间。</p>
<p>开销：使用 IMAGE_OVERHEAD_FACTOR变量定义构建系统应用于初始图像大小的乘数，默认为 1.3。</p>
<p>额外的可用空间：使用 IMAGE_ROOTFS_EXTRA_SPACE 变量为图像添加额外的可用空间。构建系统在确定其 IMAGE_ROOTFS_SIZE后将此空间添加到映像。</p>
<p>问：为什么不支持路径名中有空格的目录？</p>
<p>A： Yocto Project 团队之前尝试过这样做，但是 OpenEmbedded 构建系统依赖的工具太多，例如 autoconf，当他们在路径名中找到空格时会中断。在这种情况发生变化之前，团队将不支持路径名中的空格。</p>
<p>问：如何使用外部工具链？</p>
<p>A：工具链配置非常灵活和可定制。它主要由TCMODE变量控制。此变量控制tcmode-<a href="#id43"><span class="problematic" id="id44">*</span></a>.inc要从 Source Directorymeta/conf/distro/include中的目录中包含的文件。</p>
<p>TCMODE的默认值为“default”，它告诉 OpenEmbedded 构建系统使用其内部构建的工具链（即 tcmode-default.inc）。但是，接受其他模式。特别是，“external-<a href="#id45"><span class="problematic" id="id46">*</span></a>”指的是外部工具链。一个例子是 Sourcery G++ 工具链。对此工具链的支持位于https://github.com/MentorEmbedded/meta-sourcery/meta-sourcery的单独层中 。</p>
<p>除了工具链配置，还需要一个对应的工具链配方文件。此配方文件需要打包工具链中的任何预构建对象，例如libgcc、 libstdcc++、任何语言环境和libc.</p>
<p>问： OpenEmbedded 构建系统如何获取源代码，它能否在我的防火墙或代理服务器后工作？</p>
<p>A：构建系统获取源代码的方式是高度可配置的。如果 HTTP 传输可用，您可以设置构建系统以在大多数环境中获取源代码。</p>
<p>当构建系统搜索源代码时，它首先会尝试本地下载目录。如果该位置失败，Poky 会尝试 PREMIRRORS，上游源，然后 按顺序尝试MIRRORS。</p>
<p>假设你的发行版是“poky”的，OpenEmbedded 构建系统默认使用 Yocto Project 源PREMIRRORS用于基于 SCM 的源，上游用于普通 tarball，然后如果这些镜像失败，则回退到包括 Yocto Project 源镜像在内的许多其他镜像.</p>
<p>local.conf例如，您可以通过在配置文件中添加如下内容来为构建系统添加特定服务器，以便在任何其他服务器之前尝试 ：</p>
<dl class="simple">
<dt>PREMIRRORS:prepend = “</dt><dd><p>git://.*/.* https://downloads.yoctoproject.org/mirror/sources/ ftp://.*/.* https://downloads.yoctoproject.org/mirror/sources/ http://.*/.* https://downloads.yoctoproject.org/mirror/sources/ https://.*/.* https://downloads.yoctoproject.org/mirror/sources/”</p>
</dd>
</dl>
<p>这些更改导致构建系统拦截 Git、FTP、HTTP 和 HTTPS 请求并将它们定向到http://源镜像。您也可以使用file://URL 指向本地目录或网络共享。</p>
<p>以下是其他选项：</p>
<p>BB_NO_NETWORK = “1”
该语句告诉 BitBake 发出错误而不是尝试访问 Internet。如果您想确保仅从本地源构建代码，则此技术很有用。</p>
<p>这是另一种技术：</p>
<p>BB_FETCH_PREMIRRORONLY = “1”
此语句将构建系统限制为仅从 PREMIRRORS中提取源代码。同样，这种技术对于复制构建很有用。</p>
<p>这是另一种技术：</p>
<p>BB_GENERATE_MIRROR_TARBALLS = “1”
该语句告诉构建系统生成镜像 tarball。如果要创建镜像服务器，此技术很有用。但是，如果不是，该技术只会在构建过程中浪费时间。</p>
<p>最后，考虑一个位于仅 HTTP 防火墙后面的示例。local.conf只要PREMIRRORS服务器是最新的，您就可以对配置文件进行以下更改：</p>
<dl class="simple">
<dt>PREMIRRORS:prepend = “</dt><dd><p>git://.*/.* https://downloads.yoctoproject.org/mirror/sources/ ftp://.*/.* https://downloads.yoctoproject.org/mirror/sources/ http://.*/.* https://downloads.yoctoproject.org/mirror/sources/ https://.*/.* https://downloads.yoctoproject.org/mirror/sources/”</p>
</dd>
</dl>
<p>BB_FETCH_PREMIRRORONLY = “1”
这些更改将导致构建系统通过 HTTP 成功获取源，并且任何对 PREMIRRORS以外的任何内容的网络访问都将失败。</p>
<p>构建系统还支持标准 shell 环境变量 http_proxy、ftp_proxy、https_proxy，并all_proxy通过代理服务器重定向请求。</p>
<p>笔记</p>
<p>您可以在“在网络代理背后工作”Wiki 页面上找到更多信息。</p>
<p>问：我可以去掉构建输出以便重新开始吗？</p>
<p>答：是的 - 您可以轻松做到这一点。当您使用 BitBake 构建映像时，所有构建输出都会进入您运行构建环境设置脚本时创建的目录（即 oe-init-build-env）。默认情况下，此构建目录 已命名build，但您可以随意命名。</p>
<p>在构建目录中，是tmp目录。要删除所有构建输出但保留以前构建的任何源代码或下载的文件，只需删除该tmp目录即可。</p>
<p>问：为什么配方${bindir}有${libdir}奇怪的值 ？-native</p>
<p>答：可执行文件和库可能需要从最初安装它们的目录以外的目录中使用。使这种情况复杂化的事实是，有时这些可执行文件和库在编译时期望从初始安装目标目录运行。如果是这种情况，移动它们会导致问题。</p>
<p>对于主流 Linux 发行版的包维护者以及 OpenEmbedded 构建系统来说，这种情况是一个基本问题。因此，存在完善的解决方案。Makefiles、Autotools 配置脚本和其他构建系统应该尊重环境变量，例如bindir, libdir, 并 sysconfdir指示程序实际运行时可执行文件、库和数据所在的位置。他们还应该尊重DESTDIR环境变量，当构建系统实际安装文件时，该变量会附加到所有其他变量中。据了解，该程序实际上并非从内部运行 DESTDIR。</p>
<p>当 OpenEmbedded 构建系统使用配方构建目标架构程序（即，旨在包含在正在构建的映像中的程序）时，该程序最终会从该映像的根文件系统运行。因此，构建系统为 提供“/usr/bin”bindir值，为 提供“/usr/lib”值libdir，依此类推。</p>
<p>同时，DESTDIR是Build Directory中的路径。然而，当配方构建一个本地程序（即打算在构建机器上运行的程序）时，该程序永远不会直接安装到构建机器的根文件系统中。因此，构建系统使用构建目录中的路径DESTDIR和bindir相关变量。为了更好地理解这一点，请考虑以下两条路径，其中第一条相对正常，而第二条则不正常：</p>
<p>笔记</p>
<p>由于这些冗长的示例，为了便于阅读，路径被人为地跨行断开。</p>
<dl class="simple">
<dt>/home/maxtothemax/poky-bootchart2/build/tmp/work/i586-poky-linux/zlib/</dt><dd><p>1.2.8-r0/sysroot-destdir/usr/bin</p>
</dd>
<dt>/home/maxtothemax/poky-bootchart2/build/tmp/work/x86_64-linux/</dt><dd><p>zlib-native/1.2.8-r0/sysroot-destdir/home/maxtothemax/poky-bootchart2/
build/tmp/sysroots/x86_64-linux/usr/bin</p>
</dd>
</dl>
<p>即使路径看起来不寻常，它们都是正确的——第一个用于目标，第二个用于本地配方。这些路径是DESTDIR 机制的结果，虽然它们看起来很奇怪，但它们是正确的并且在实践中非常有效。</p>
<p>问：我的*-native配方提供的文件似乎不适用于其他配方。本机 sysroot 中缺少文件，我的配方安装到错误的位置，或者我在配方中的 do_install 任务期间遇到权限错误！怎么了？</p>
<p>答：当构建系统无法识别BitBake提供给它的环境变量时，就会出现这种情况。提示此 FAQ 条目的事件涉及使用名为的环境变量BINDIR而不是更标准的变量的 Makefile bindir。makefile 的硬编码默认值“/usr/bin”大部分时间都有效，但不适用于配方的-native 变体。再举一个例子，权限错误可能是由忽略DESTDIR该环境变量或使用不同名称的 Makefile 引起的。检查构建系统以查看是否存在此类问题。</p>
<p>问：我在配方中添加了一个二进制文件，但它在图像中有所不同，是什么改变了它？</p>
<p>答：第一个最明显的变化是系统从中剥离了调试符号。设置INHIBIT_PACKAGE_STRIP以停止调试符号被剥离和/或 INHIBIT_PACKAGE_DEBUG_SPLIT停止调试符号被拆分到单独的文件中，这将确保二进制文件不变。可能发生的另一件不太明显的事情是图像的预链接。这是通过 USER_CLASSES在 local.conf 中默认设置的，它可以包含“image-prelink”。如果您删除它，图像将不会被预链接，这意味着二进制文件将保持不变。</p>
<p>1板级支持包 (BSP) - 开发人员指南
板级支持包 (BSP) 是定义如何支持特定硬件设备、设备集或硬件平台的信息集合。BSP 包括有关设备上存在的硬件功能的信息和内核配置信息以及所需的任何其他硬件驱动程序。除了通用 Linux 软件堆栈之外，BSP 还列出了必要的和可选平台功能所需的任何其他软件组件。</p>
<p>本指南提供有关 BSP 层的信息，定义组件结构以使 BSP 遵循通常理解的布局，讨论如何为 BSP 定制配方，解决 BSP 许可问题，并提供信息，向您展示如何使用bitbake-layers 工具。</p>
<p>1.1 BSP 层
BSP 由基本目录中的文件结构组成。总而言之，您可以将基本目录、其文件结构和内容视为 BSP 层。虽然不是严格要求，但 Yocto 项目中的 BSP 层使用以下公认的命名约定：</p>
<p>meta-bsp_root_name
字符串“meta-”附加在机器或平台名称之前，即上述形式的“bsp_root_name”。</p>
<p>笔记</p>
<p>因为 BSP 层命名约定已经确立，所以在创建层时建议遵循它。从技术上讲，BSP 层名称不需要以 . 开头meta-。但是，Yocto Project 开发环境中的各种脚本和工具都采用这种约定。</p>
<p>为了帮助理解 BSP 层概念，请考虑 Yocto 项目支持并随每个版本提供的 BSP。您可以 通过https://git.yoctoproject.org/cgit/cgit.cgi/ 的 Web 界面查看Yocto 项目源存储库中的层。如果您转到该界面，您将在“Yocto 元数据层”下找到一个存储库列表。</p>
<p>笔记</p>
<p>作为 Yocto 项目的一部分不再积极支持的层显示在标题“Yocto 元数据层存档”下。</p>
<p>每个存储库都是 Yocto 项目支持的 BSP 层（例如 meta-raspberrypi和meta-intel）。这些层中的每一个都是其自身的存储库，单击层名称会显示两个 URL，您可以从中将层的存储库克隆到本地系统。这是一个克隆 Raspberry Pi BSP 层的示例：</p>
<p>$ git clone git://git.yoctoproject.org/meta-raspberrypi
除了 BSP 层之外，该meta-yocto-bsp层也是交付的poky存储库的一部分。该meta-yocto-bsp层维护了几个“参考”BSP，包括基于 ARM 的 Beaglebone、基于 MIPS 的 EdgeRouter，以及 32 位和 64 位 IA 机器的通用版本。</p>
<p>有关典型 BSP 开发工作流程的信息，请参阅 开发板级支持包 (BSP) 部分。有关如何从 Git 存储库设置源文件的本地副本的更多信息，请参阅 Yocto 项目开发任务手册中的 定位 Yocto 项目源文件 部分。</p>
<p>BSP 层的基目录 ( meta-bsp_root_name) 是该层的根目录。该目录是您添加到 Build Directory中文件中 的BBLAYERS变量的 目录，该目录是在您运行 OpenEmbedded 构建环境设置脚本（即oe-init-build-env）后建立的。添加根目录允许OpenEmbedded 构建系统 识别 BSP 层并从中构建映像。这是一个例子：conf/bblayers.conf</p>
<dl class="simple">
<dt>BBLAYERS ?= ” </dt><dd><p>/usr/local/src/yocto/meta /usr/local/src/yocto/meta-poky /usr/local/src/yocto/meta-yocto-bsp /usr/local/src/yocto/meta-mylayer “</p>
</dd>
</dl>
<p>笔记</p>
<p>BBLAYERS中列出的层的顺序和BBFILE_PRIORITY 很 重要。例如，如果多个层定义了一个机器配置，OpenEmbedded 构建系统使用给定相似层优先级的最后一层搜索。构建系统自上而下通过BBLAYERS中列出的层工作。</p>
<p>一些 BSP 需要或依赖于 BSP 根层之外的附加层才能发挥作用。在这种情况下，您需要README在 BSP 根层的“依赖项”部分中指定这些层。此外，如果 BSP 存在任何构建指令，您必须将它们添加到“依赖项”部分。</p>
<p>一些层用作保存其他 BSP 层的层。这些层被称为“容器层”。这种类型的层的一个例子是 OpenEmbedded 的 meta-openembedded 层。该meta-openembedded层包含许多meta-<a href="#id47"><span class="problematic" id="id48">*</span></a>层。在这种情况下，您需要包含要使用的实际图层的名称，例如：</p>
<dl class="simple">
<dt>BBLAYERS ?= ” </dt><dd><p>/usr/local/src/yocto/meta /usr/local/src/yocto/meta-poky /usr/local/src/yocto/meta-yocto-bsp /usr/local/src/yocto/meta-mylayer …/meta-openembedded/meta-oe …/meta-openembedded/meta-perl …/meta-openembedded/meta-networking “</p>
</dd>
</dl>
<p>等等。</p>
<p>有关层的更多信息，请参阅 Yocto 项目开发任务手册的“理解和创建层”部分。</p>
<p>1.2准备构建主机以使用 BSP 层
本节介绍如何让您的构建主机准备好使用 BSP 层。设置好主机后，您可以按照“使用 bitbake-layers 脚本创建新的 BSP 层”部分中的说明创建层。</p>
<p>笔记</p>
<p>有关 BSP 的结构信息，请参阅 示例文件系统布局部分。</p>
<p>设置构建环境：确保您已设置为在 shell 中使用 BitBake。有关如何准备好构建主机的信息，请参阅 Yocto 项目开发任务手册中的“准备构建主机”部分，该主机既可以是本机 Linux 机器，也可以是使用 CROPS 的机器。</p>
<p>克隆 poky 存储库：您需要有 Yocto 项目源目录的本地副本（即本地 poky存储库）。请参阅 Yocto 项目开发任务手册中的“克隆 poky 存储库”以及可能的“在 Poky 中按分支签出”或“在 Poky 中按标签签出”部分，了解有关如何克隆poky存储库并签出适当的信息分支为您的工作。</p>
<p>确定您想要的 BSP 层： Yocto 项目支持许多 BSP，这些 BSP 在它们自己的层中或在设计用于包含多个 BSP 的层中进行维护。要通过 BSP 层了解机器支持，您可以查看 该版本的机器索引 。</p>
<p>可选择克隆元英特尔 BSP 层：如果您的硬件基于当前的英特尔 CPU 和设备，则可以利用此 BSP 层。有关meta-intelBSP 层的详细信息，请参阅该层的 README文件。</p>
<p>导航到您的源目录：通常，您在源目录中设置 meta-intelGit 存储库（例如 ）。poky</p>
<p>$ cd /home/you/poky
克隆图层：</p>
<p>$ git clone git://git.yoctoproject.org/meta-intel.git
Cloning into ‘meta-intel’…
remote: Counting objects: 15585, done.
remote: Compressing objects: 100% (5056/5056), done.
remote: Total 15585 (delta 9123), reused 15329 (delta 8867)
Receiving objects: 100% (15585/15585), 4.51 MiB | 3.19 MiB/s, done.
Resolving deltas: 100% (9123/9123), done.
Checking connectivity… done.
签出正确的分支：您签出的分支 meta-intel必须与您用于 Yocto 项目版本的分支匹配（例如honister）：</p>
<p>$ cd meta-intel
$ git checkout -b honister remotes/origin/honister
Branch honister set up to track remote branch
honister from origin.
Switched to a new branch ‘honister’
笔记</p>
<p>要查看克隆存储库中可用的分支名称，请使用该命令。有关更多信息，请参阅Yocto 项目开发任务手册中的“在 Poky 中按分支检查”部分。git branch -al</p>
<p>（可选）设置备用 BSP 层：如果您的硬件可以更紧密地用于不在 meta-intelBSP 层内的现有 BSP，则可以克隆该 BSP 层。</p>
<p>该过程与用于meta-intel 图层的过程相同，但图层名称除外。例如，如果您确定您的硬件与 最接近meta-raspberrypi，请克隆该层：</p>
<p>$ git clone git://git.yoctoproject.org/meta-raspberrypi
Cloning into ‘meta-raspberrypi’…
remote: Counting objects: 4743, done.
remote: Compressing objects: 100% (2185/2185), done.
remote: Total 4743 (delta 2447), reused 4496 (delta 2258)
Receiving objects: 100% (4743/4743), 1.18 MiB | 0 bytes/s, done.
Resolving deltas: 100% (2447/2447), done.
Checking connectivity… done.
初始化构建环境：在源目录（即poky）的根目录中，运行 oe-init-build-env环境设置脚本以在您的构建主机上定义 OpenEmbedded 构建环境。</p>
<p>$ source oe-init-build-env
除其他外，该脚本创建了Build Directory， build在这种情况下，它位于Source Directory中。脚本运行后，您的当前工​​作目录将设置为该build 目录。</p>
<p>1.3示例文件系统布局
定义一个通用的 BSP 目录结构可以让最终用户理解并熟悉该标准。通用格式还鼓励对硬件的软件支持进行标准化。</p>
<p>本节中描述的建议表单确实具有特定于 OpenEmbedded 构建系统的元素。除了 OpenEmbedded 构建系统之外，开发人员还可以将此结构与其他构建系统一起使用。如果需要，还可以很容易地提取信息并将其转换为其他格式。OpenEmbedded 构建系统通过其标准的层机制，可以直接接受描述为层的格式。BSP 层使用标准格式在一个位置捕获所有特定于硬件的细节，这对于希望使用硬件平台的任何人都非常有用，无论他们使用的是什么构建系统。</p>
<p>BSP 规范不包括构建系统或其他工具 - 该规范仅涉及特定于硬件的组件。在最终分发点，您可以将 BSP 层与构建系统和其他工具相结合。意识到保持 BSP 层、构建系统和工具是可以在某些最终产品中组合的独立组件这一区别很重要。</p>
<p>在查看 BSP 层内的目录结构的推荐形式之前，您应该知道有一些要求才能使 BSP 层被认为与 Yocto 项目兼容。有关该要求列表，请参阅“已发布的 BSP 要求”部分。</p>
<p>下面是 BSP 层的典型目录结构。虽然这种基本形式代表了标准，但要意识到各个 BSP 的实际布局可能会有所不同。</p>
<p>meta-bsp_root_name/
meta-bsp_root_name/bsp_license_file
meta-bsp_root_name/README
meta-bsp_root_name/README.sources
meta-bsp_root_name/binary/bootable_images
meta-bsp_root_name/conf/layer.conf
meta-bsp_root_name/conf/machine/<em>.conf
meta-bsp_root_name/recipes-bsp/</em>
meta-bsp_root_name/recipes-core/*
meta-bsp_root_name/recipes-graphics/*
meta-bsp_root_name/recipes-kernel/linux/linux-yocto_kernel_rev.bbappend
以下是可从Source Repositories获得的 Raspberry Pi BSP 层的示例：</p>
<p>meta-raspberrypi/COPYING.MIT
meta-raspberrypi/README.md
meta-raspberrypi/classes
meta-raspberrypi/classes/sdcard_image-rpi.bbclass
meta-raspberrypi/conf/
meta-raspberrypi/conf/layer.conf
meta-raspberrypi/conf/machine/
meta-raspberrypi/conf/machine/raspberrypi-cm.conf
meta-raspberrypi/conf/machine/raspberrypi-cm3.conf
meta-raspberrypi/conf/machine/raspberrypi.conf
meta-raspberrypi/conf/machine/raspberrypi0-wifi.conf
meta-raspberrypi/conf/machine/raspberrypi0.conf
meta-raspberrypi/conf/machine/raspberrypi2.conf
meta-raspberrypi/conf/machine/raspberrypi3-64.conf
meta-raspberrypi/conf/machine/raspberrypi3.conf
meta-raspberrypi/conf/machine/include
meta-raspberrypi/conf/machine/include/rpi-base.inc
meta-raspberrypi/conf/machine/include/rpi-default-providers.inc
meta-raspberrypi/conf/machine/include/rpi-default-settings.inc
meta-raspberrypi/conf/machine/include/rpi-default-versions.inc
meta-raspberrypi/conf/machine/include/tune-arm1176jzf-s.inc
meta-raspberrypi/docs
meta-raspberrypi/docs/Makefile
meta-raspberrypi/docs/conf.py
meta-raspberrypi/docs/contributing.md
meta-raspberrypi/docs/extra-apps.md
meta-raspberrypi/docs/extra-build-config.md
meta-raspberrypi/docs/index.rst
meta-raspberrypi/docs/layer-contents.md
meta-raspberrypi/docs/readme.md
meta-raspberrypi/files
meta-raspberrypi/files/custom-licenses
meta-raspberrypi/files/custom-licenses/Broadcom
meta-raspberrypi/recipes-bsp
meta-raspberrypi/recipes-bsp/bootfiles
meta-raspberrypi/recipes-bsp/bootfiles/bcm2835-bootfiles.bb
meta-raspberrypi/recipes-bsp/bootfiles/rpi-config_git.bb
meta-raspberrypi/recipes-bsp/common
meta-raspberrypi/recipes-bsp/common/firmware.inc
meta-raspberrypi/recipes-bsp/formfactor
meta-raspberrypi/recipes-bsp/formfactor/formfactor
meta-raspberrypi/recipes-bsp/formfactor/formfactor/raspberrypi
meta-raspberrypi/recipes-bsp/formfactor/formfactor/raspberrypi/machconfig
meta-raspberrypi/recipes-bsp/formfactor/formfactor_0.0.bbappend
meta-raspberrypi/recipes-bsp/rpi-u-boot-src
meta-raspberrypi/recipes-bsp/rpi-u-boot-src/files
meta-raspberrypi/recipes-bsp/rpi-u-boot-src/files/boot.cmd.in
meta-raspberrypi/recipes-bsp/rpi-u-boot-src/rpi-u-boot-scr.bb
meta-raspberrypi/recipes-bsp/u-boot
meta-raspberrypi/recipes-bsp/u-boot/u-boot
meta-raspberrypi/recipes-bsp/u-boot/u-boot/<em>.patch
meta-raspberrypi/recipes-bsp/u-boot/u-boot_%.bbappend
meta-raspberrypi/recipes-connectivity
meta-raspberrypi/recipes-connectivity/bluez5
meta-raspberrypi/recipes-connectivity/bluez5/bluez5
meta-raspberrypi/recipes-connectivity/bluez5/bluez5/</em>.patch
meta-raspberrypi/recipes-connectivity/bluez5/bluez5/BCM43430A1.hcd
meta-raspberrypi/recipes-connectivity/bluez5/bluez5brcm43438.service
meta-raspberrypi/recipes-connectivity/bluez5/bluez5_%.bbappend
meta-raspberrypi/recipes-core
meta-raspberrypi/recipes-core/images
meta-raspberrypi/recipes-core/images/rpi-basic-image.bb
meta-raspberrypi/recipes-core/images/rpi-hwup-image.bb
meta-raspberrypi/recipes-core/images/rpi-test-image.bb
meta-raspberrypi/recipes-core/packagegroups
meta-raspberrypi/recipes-core/packagegroups/packagegroup-rpi-test.bb
meta-raspberrypi/recipes-core/psplash
meta-raspberrypi/recipes-core/psplash/files
meta-raspberrypi/recipes-core/psplash/files/psplash-raspberrypi-img.h
meta-raspberrypi/recipes-core/psplash/psplash_git.bbappend
meta-raspberrypi/recipes-core/udev
meta-raspberrypi/recipes-core/udev/udev-rules-rpi
meta-raspberrypi/recipes-core/udev/udev-rules-rpi/99-com.rules
meta-raspberrypi/recipes-core/udev/udev-rules-rpi.bb
meta-raspberrypi/recipes-devtools
meta-raspberrypi/recipes-devtools/bcm2835
meta-raspberrypi/recipes-devtools/bcm2835/bcm2835_1.52.bb
meta-raspberrypi/recipes-devtools/pi-blaster
meta-raspberrypi/recipes-devtools/pi-blaster/files
meta-raspberrypi/recipes-devtools/pi-blaster/files/<em>.patch
meta-raspberrypi/recipes-devtools/pi-blaster/pi-blaster_git.bb
meta-raspberrypi/recipes-devtools/python
meta-raspberrypi/recipes-devtools/python/python-rtimu
meta-raspberrypi/recipes-devtools/python/python-rtimu/</em>.patch
meta-raspberrypi/recipes-devtools/python/python-rtimu_git.bb
meta-raspberrypi/recipes-devtools/python/python-sense-hat_2.2.0.bb
meta-raspberrypi/recipes-devtools/python/rpi-gpio
meta-raspberrypi/recipes-devtools/python/rpi-gpio/<em>.patch
meta-raspberrypi/recipes-devtools/python/rpi-gpio_0.6.3.bb
meta-raspberrypi/recipes-devtools/python/rpio
meta-raspberrypi/recipes-devtools/python/rpio/</em>.patch
meta-raspberrypi/recipes-devtools/python/rpio_0.10.0.bb
meta-raspberrypi/recipes-devtools/wiringPi
meta-raspberrypi/recipes-devtools/wiringPi/files
meta-raspberrypi/recipes-devtools/wiringPi/files/<em>.patch
meta-raspberrypi/recipes-devtools/wiringPi/wiringpi_git.bb
meta-raspberrypi/recipes-graphics
meta-raspberrypi/recipes-graphics/eglinfo
meta-raspberrypi/recipes-graphics/eglinfo/eglinfo-fb_%.bbappend
meta-raspberrypi/recipes-graphics/eglinfo/eglinfo-x11_%.bbappend
meta-raspberrypi/recipes-graphics/mesa
meta-raspberrypi/recipes-graphics/mesa/mesa-gl_%.bbappend
meta-raspberrypi/recipes-graphics/mesa/mesa_%.bbappend
meta-raspberrypi/recipes-graphics/userland
meta-raspberrypi/recipes-graphics/userland/userland
meta-raspberrypi/recipes-graphics/userland/userland/</em>.patch
meta-raspberrypi/recipes-graphics/userland/userland_git.bb
meta-raspberrypi/recipes-graphics/vc-graphics
meta-raspberrypi/recipes-graphics/vc-graphics/files
meta-raspberrypi/recipes-graphics/vc-graphics/files/egl.pc
meta-raspberrypi/recipes-graphics/vc-graphics/files/vchiq.sh
meta-raspberrypi/recipes-graphics/vc-graphics/vc-graphics-hardfp.bb
meta-raspberrypi/recipes-graphics/vc-graphics/vc-graphics.bb
meta-raspberrypi/recipes-graphics/vc-graphics/vc-graphics.inc
meta-raspberrypi/recipes-graphics/wayland
meta-raspberrypi/recipes-graphics/wayland/weston_%.bbappend
meta-raspberrypi/recipes-graphics/xorg-xserver
meta-raspberrypi/recipes-graphics/xorg-xserver/xserver-xf86-config
meta-raspberrypi/recipes-graphics/xorg-xserver/xserver-xf86-config/rpi
meta-raspberrypi/recipes-graphics/xorg-xserver/xserver-xf86-config/rpi/xorg.conf
meta-raspberrypi/recipes-graphics/xorg-xserver/xserver-xf86-config/rpi/xorg.conf.d
meta-raspberrypi/recipes-graphics/xorg-xserver/xserver-xf86-config/rpi/xorg.conf.d/10-evdev.conf
meta-raspberrypi/recipes-graphics/xorg-xserver/xserver-xf86-config/rpi/xorg.conf.d/98-pitft.conf
meta-raspberrypi/recipes-graphics/xorg-xserver/xserver-xf86-config/rpi/xorg.conf.d/99-calibration.conf
meta-raspberrypi/recipes-graphics/xorg-xserver/xserver-xf86-config_0.1.bbappend
meta-raspberrypi/recipes-graphics/xorg-xserver/xserver-xorg_%.bbappend
meta-raspberrypi/recipes-kernel
meta-raspberrypi/recipes-kernel/linux-firmware
meta-raspberrypi/recipes-kernel/linux-firmware/files
meta-raspberrypi/recipes-kernel/linux-firmware/files/brcmfmac43430-sdio.bin
meta-raspberrypi/recipes-kernel/linux-firmware/files/brcfmac43430-sdio.txt
meta-raspberrypi/recipes-kernel/linux-firmware/linux-firmware_%.bbappend
meta-raspberrypi/recipes-kernel/linux
meta-raspberrypi/recipes-kernel/linux/linux-raspberrypi-dev.bb
meta-raspberrypi/recipes-kernel/linux/linux-raspberrypi.inc
meta-raspberrypi/recipes-kernel/linux/linux-raspberrypi_4.14.bb
meta-raspberrypi/recipes-kernel/linux/linux-raspberrypi_4.9.bb
meta-raspberrypi/recipes-multimedia
meta-raspberrypi/recipes-multimedia/gstreamer
meta-raspberrypi/recipes-multimedia/gstreamer/gstreamer1.0-omx
meta-raspberrypi/recipes-multimedia/gstreamer/gstreamer1.0-omx/<em>.patch
meta-raspberrypi/recipes-multimedia/gstreamer/gstreamer1.0-omx_%.bbappend
meta-raspberrypi/recipes-multimedia/gstreamer/gstreamer1.0-plugins-bad_%.bbappend
meta-raspberrypi/recipes-multimedia/gstreamer/gstreamer1.0-omx-1.12
meta-raspberrypi/recipes-multimedia/gstreamer/gstreamer1.0-omx-1.12/</em>.patch
meta-raspberrypi/recipes-multimedia/omxplayer
meta-raspberrypi/recipes-multimedia/omxplayer/omxplayer
meta-raspberrypi/recipes-multimedia/omxplayer/omxplayer/<a href="#id49"><span class="problematic" id="id50">*</span></a>.patch
meta-raspberrypi/recipes-multimedia/omxplayer/omxplayer_git.bb
meta-raspberrypi/recipes-multimedia/x264
meta-raspberrypi/recipes-multimedia/x264/x264_git.bbappend
meta-raspberrypi/wic meta-raspberrypi/wic/sdimage-raspberrypi.wks
以下部分描述了提议的 BSP 格式的每个部分。</p>
<p>1.3.1许可证文件
您可以在 BSP 层中找到这些文件：</p>
<p>meta-bsp_root_name/bsp_license_file
这些可选文件满足 BSP 的许可要求。此处的文件类型可能因许可要求而异。例如，在 Raspberry Pi BSP 中，所有许可要求都由COPYING.MIT文件处理。</p>
<p>许可文件可以是 MIT、BSD、GPLv* 等。这些文件推荐用于 BSP，但它们是可选的，完全取决于 BSP 开发人员。有关如何维护许可证合规性的信息，请参阅Yocto 项目开发任务手册中的“在产品生命周期内维护开源许可证合规性”部分。</p>
<p>1.3.2自述文件
您可以在 BSP 层中找到此文件：</p>
<p>meta-bsp_root_name/README
此文件提供有关如何引导可选包含在binary/目录中的实时映像的信息。该README文件还提供了构建映像所需的信息。</p>
<p>该文件至少README必须包含依赖关系列表，例如 BSP 所依赖的任何其他层的名称以及 BSP 维护者的名称及其联系信息。</p>
<p>1.3.3 README.sources 文件
您可以在 BSP 层中找到此文件：</p>
<p>meta-bsp_root_name/README.sources
此文件提供有关在何处查找用于构建驻留在 中的映像（如果有）的 BSP 源文件的信息 meta-bsp_root_name/binary。中的图像binary将是与 BSP 一起发布的图像。文件中的信息README.sources还可以帮助您找到 用于生成 BSP 附带的图像的元数据。</p>
<p>笔记</p>
<p>如果 BSP 的binary目录丢失或目录没有图像，则现有README.sources文件是没有意义的，通常不存在。</p>
<p>1.3.4预构建的用户二进制文件
您可以在 BSP 层中找到这些文件：</p>
<p>meta-bsp_root_name/binary/bootable_images
此可选区域包含有用的预构建内核和随 BSP 发布的适用于目标系统的用户空间文件系统映像。当 BSP 压缩包已创建并在Yocto 项目网站上可用时，此目录通常包含图形（例如 Sato）和最小的实时图像。您可以使用这些内核和映像来运行系统并快速开始开发任务。</p>
<p>存在的二进制文件的确切类型高度依赖于硬件。README文件应该存在于 BSP 层中，它解释了如何将图像与目标硬件一起使用。 此外， 应该存在README.sources文件以定位用于构建图像的源并提供有关元数据的信息。</p>
<p>1.3.5层配置文件
您可以在 BSP 层中找到此文件：</p>
<p>meta-bsp_root_name/conf/layer.conf
该conf/layer.conf文件将文件结构标识为层，标识层的内容，并包含有关构建系统应如何使用它的信息。通常，标准样板文件如下所示。在以下示例中，您将用 BSP 的实际名称替换“bsp”（即示例模板中的“bsp_root_name”）。</p>
<p># We have a conf and classes directory, add to BBPATH
BBPATH .= “:${LAYERDIR}”</p>
<p># We have a recipes directory containing .bb and .bbappend files, add to BBFILES
BBFILES += “${LAYERDIR}/recipes-<em>/</em>/<a href="#id51"><span class="problematic" id="id52">*</span></a>.bb </p>
<blockquote>
<div><p>${LAYERDIR}/recipes-<em>/</em>/<a href="#id53"><span class="problematic" id="id54">*</span></a>.bbappend”</p>
</div></blockquote>
<p>BBFILE_COLLECTIONS += “bsp”
BBFILE_PATTERN_bsp = “^${LAYERDIR}/”
BBFILE_PRIORITY_bsp = “6”
LAYERDEPENDS_bsp = “intel”
为了说明字符串替换，下面是 Raspberry Piconf/layer.conf文件中的相应语句：</p>
<p># We have a conf and classes directory, append to BBPATH
BBPATH .= “:${LAYERDIR}”</p>
<p># We have a recipes directory containing .bb and .bbappend files, add to BBFILES
BBFILES += “${LAYERDIR}/recipes*/<em>/</em>.bb </p>
<blockquote>
<div><p>${LAYERDIR}/recipes*/<em>/</em>.bbappend”</p>
</div></blockquote>
<p>BBFILE_COLLECTIONS += “raspberrypi”
BBFILE_PATTERN_raspberrypi := “^${LAYERDIR}/”
BBFILE_PRIORITY_raspberrypi = “9”</p>
<p># Additional license directories.
LICENSE_PATH += “${LAYERDIR}/files/custom-licenses”
.
.
.
这个文件只是让BitBake知道配方和配置目录。该文件必须存在，以便 OpenEmbedded 构建系统可以识别 BSP。</p>
<p>1.3.6硬件配置选项
您可以在 BSP 层中找到这些文件：</p>
<p>meta-bsp_root_name/conf/machine/<a href="#id55"><span class="problematic" id="id56">*</span></a>.conf
机器文件将 BSP 中其他地方包含的所有信息绑定到构建系统可以理解的格式中。每个 BSP 层至少需要一个机器文件。如果 BSP 支持多台机器，则可以存在多个机器配置文件。这些文件名对应于用户设置 MACHINE变量的值。</p>
<p>这些文件定义了诸如要使用的内核包（virtual /kernel的PREFERRED_PROVIDER）、要包含在不同类型映像中的硬件驱动程序、所需的任何特殊软件组件、任何引导加载程序信息以及任何特殊映像格式要求等内容。</p>
<p>此配置文件还可以包括一个硬件“调整”文件，该文件通常用于定义封装架构和指定优化标志，这些优化标志经过精心挑选，可在给定处理器上提供最佳性能。</p>
<p>调整文件位于meta/conf/machine/includeSource Directory的目录中。例如，许多tune-<a href="#id57"><span class="problematic" id="id58">*</span></a>文件（例如tune-arm1136jf-s.inc、 tune-1586-nlp.inc等）驻留在 poky/meta/conf/machine/include目录中。</p>
<p>要使用包含文件，您只需将它们包含在机器配置文件中。例如，Raspberry Pi BSP raspberrypi3.conf包含以下语句：</p>
<p>include conf/machine/include/rpi-base.inc
1.3.7其他 BSP 特定配方文件
您可以在 BSP 层中找到这些文件：</p>
<p>meta-bsp_root_name/recipes-bsp/*
此可选目录包含 BSP 的各种配方文件。最值得注意的是外形文件。例如，在 Raspberry Pi BSP 中，有一个formfactor_0.0.bbappend文件，它是一个附加文件，用于扩充启动构建的配方。此外，在构建过程中使用了特定于机器的设置，这些设置由machconfig目录中更下方的文件定义。这是machconfigRaspberry Pi BSP 的文件：</p>
<p>HAVE_TOUCHSCREEN=0
HAVE_KEYBOARD=1</p>
<p>DISPLAY_CAN_ROTATE=0
DISPLAY_ORIENTATION=0
DISPLAY_DPI=133
笔记</p>
<p>如果 BSP 没有格式因子条目，则根据主要格式因子配方安装的格式因子配置文件建立默认值，该格式因子配方 meta/recipes-bsp/formfactor/formfactor_0.0.bb位于Source Directory中。</p>
<p>1.3.8显示支持文件
您可以在 BSP 层中找到这些文件：</p>
<p>meta-bsp_root_name/recipes-graphics/*
如果 BSP 对图形支持有特殊要求，此可选目录包含它的配方。BSP 支持显示所需的所有文件都保存在这里。</p>
<p>1.3.9 Linux 内核配置
您可以在 BSP 层中找到这些文件：</p>
<p>meta-bsp_root_name/recipes-kernel/linux/linux*.bbappend
meta-bsp_root_name/recipes-kernel/linux/<em>.bb
附加文件 ( *.bbappend) 修改用于构建映像的主内核配方。这些</em>.bb文件将是开发人员提供的内核配方。BSP 层次结构的这个区域可以包含这两种类型的文件，尽管在实践中，您可能会拥有其中一种。</p>
<p>对于您的 BSP，您通常希望使用在源目录 中 找到的现有 Yocto 项目内核配方meta/recipes-kernel/linux。您可以使用类似名称的附加文件将特定于机器的更改附加到内核配方，该文件位于目标设备的 BSP 层中（例如 meta-bsp_root_name/recipes-kernel/linux目录）。</p>
<p>假设您正在使用linux-yocto_4.4.bb配方来构建内核。换句话说，您 “bsp_root_name”.conf通过添加 PREFERRED_PROVIDER和PREFERRED_VERSION 语句在文件中选择了内核，如下所示：</p>
<p>PREFERRED_PROVIDER_virtual/kernel ?= “linux-yocto”
PREFERRED_VERSION_linux-yocto ?= “4.4%”
笔记</p>
<p>默认情况下假定首选提供程序时，PREFERRED_PROVIDER 语句不会出现在”bsp_root_name”.conf文件中。</p>
<p>您将使用该linux-yocto_4.4.bbappend文件将特定的 BSP 设置附加到内核，从而为您的特定 BSP 配置内核。</p>
<p>您可以在 Yocto Project Linux 内核开发手册中的“创建附加文件”部分中找到有关附加文件应包含内容的更多信息。</p>
<p>另一种情况是您为 BSP 创建自己的内核配方。一个很好的例子是 Raspberry Pi BSP。如果您检查 recipes-kernel/linux目录，您会看到以下内容：</p>
<p>linux-raspberrypi-dev.bb
linux-raspberrypi.inc
linux-raspberrypi_4.14.bb
linux-raspberrypi_4.9.bb
该目录包含三个内核配方和一个公共包含文件。</p>
<p>1.4开发板级支持包 (BSP)
本节描述了创建 BSP 可以遵循的高级过程。尽管创建 BSP 不需要meta-intel ，但包含 Yocto 项目支持的许多 BSP 的存储库是示例的一部分。</p>
<p>有关显示如何使用工具创建新层的示例，请参阅“使用 bitbake-layers 脚本创建新的 BSP 层”部分。</p>
<p>下面的插图和列表总结了 BSP 创建的一般工作流程。</p>
<p>../_images/bsp-dev-flow.png
设置您的主机开发系统以支持使用 Yocto 项目的开发：有关如何让系统准备好使用 Yocto 项目的选项，请参阅 Yocto 项目开发任务手册中的“准备构建主机”部分。</p>
<p>在您的系统上建立元英特尔存储库：在您的系统上拥有这些受支持的 BSP 层的本地副本使您可以访问在创建 BSP 时可以利用的层。有关如何获取这些文件的信息，请参阅“准备构建主机以使用 BSP 层”部分。</p>
<p>使用 bitbake-layers 脚本创建您自己的 BSP 层： 层非常适合隔离和存储给定硬件的工作。层实际上只是一个位置或区域，您可以在其中放置 BSP 的配方和配置。事实上，BSP 本身就是一种特殊类型的层。创建符合 Yocto 项目的新 BSP 层的最简单方法是使用 bitbake-layers脚本。有关该脚本的信息，请参阅“使用 bitbake-layers 脚本创建新的 BSP 层”部分。</p>
<p>说明层的另一个示例是应用程序。假设您正在创建一个具有库或其他依赖项的应用程序，以便它能够编译和运行。在这种情况下，该层将保存定义这些依赖关系的所有配方。层的关键在于它是一个隔离区域，其中包含 OpenEmbedded 构建系统所知道的项目的所有相关信息。有关层的更多信息，请参阅 Yocto 项目概述和概念手册中的“ Yocto 项目层模型”部分。您还可以参考 Yocto 项目开发任务手册中的“理解和创建图层”部分。有关 BSP 层的更多信息，请参阅“ BSP 层”部分。</p>
<p>笔记</p>
<p>Yocto Project 版本中有四个硬件参考 BSP，位于poky/meta-yocto-bsp BSP 层：</p>
<p>德州仪器 Beaglebone ( beaglebone-yocto)</p>
<p>Ubiquiti Networks EdgeRouter Lite ( edgerouter)</p>
<p>两个通用 IA 平台（genericx86和genericx86-64）</p>
<p>Yocto Project 版本中有三个核心英特尔 BSP，在meta-intel层中：</p>
<p>intel-core2-32，这是针对 Core2 系列 CPU 以及 Silvermont 内核之前的所有 CPU 优化的 BSP。</p>
<p>intel-corei7-64，这是针对 Nehalem 和更高版本的 Core 和 Xeon CPU 以及 Silvermont 和更高版本的 Atom CPU（例如 Baytrail SoC）优化的 BSP。</p>
<p>intel-quark，这是针对英特尔 Galileo gen1 和 gen2 开发板进行优化的 BSP。</p>
<p>为新 BSP 设置层时，应遵循标准布局。此布局在“示例文件系统布局”部分中进行了描述。在标准布局中，请注意建议的配方和配置信息结构。meta-intel您可以通过检查在源目录内的层中找到的任何受支持的 BSP 来查看 BSP 的标准布局。</p>
<p>对新的 BSP 层进行配置更改：标准的 BSP 层结构组织了您需要在其中编辑的文件conf以及 BSP 层中的多个recipes-<a href="#id59"><span class="problematic" id="id60">*</span></a>目录。配置更改确定您的新层在本地系统上的位置，并确定您将使用的内核。当您运行 bitbake-layers脚本时，您可以交互地为 BSP 配置许多东西（例如键盘、触摸屏等）。</p>
<p>对您的新 BSP 层进行配方更改：配方更改包括更改配方（<a href="#id61"><span class="problematic" id="id62">*</span></a>.bb文件）、删除您不使用的配方以及添加.bbappend支持您的硬件的新配方或附加文件（）。</p>
<p>为构建做准备：对 BSP 层进行所有更改后，您还需要为 OpenEmbedded 构建系统做一些事情，以便它创建您的映像。您需要通过获取环境设置脚本（即oe-init-build-env）来准备好构建环境，并且您需要确保正确配置了两个关键配置文件：the conf/local.conf和conf/bblayers.conf文件。您必须让 OpenEmbedded 构建系统知道您的新层。有关如何让构建系统了解您的新层的信息，请参阅 Yocto 项目开发任务手册中的“启用您的层”部分。</p>
<p>构建镜像： OpenEmbedded 构建系统使用 BitBake 工具根据您要创建的镜像类型构建镜像。您可以在BitBake 用户手册中找到有关 BitBake 的更多信息 。</p>
<p>构建过程支持多种类型的图像以满足不同的需求。有关支持的图像的信息，请参阅 Yocto 项目参考手册中的“图像”一章。</p>
<p>1.5对已发布 BSP 的要求和建议
本节描述了被认为符合 Yocto 项目的已发布 BSP 的要求和建议。</p>
<p>1.5.1发布的 BSP 要求
在查看 BSP 要求之前，您应该考虑以下几点：</p>
<p>这里的要求假设 BSP 层是一个格式良好的“合法”层，可以添加到 Yocto 项目中。有关创建满足这些基本要求的层的指南，请参阅本手册中的“ BSP 层”部分和 Yocto 项目开发任务手册中的“理解和创建层”部分。</p>
<p>无论您如何打包 BSP，本节中的要求都适用。您应该查阅特定发布过程的包装和分发指南。有关打包和分发要求的示例，请参阅“第三方 BSP 发布流程”wiki 页面。</p>
<p>提供给开发人员的 BSP 要求完全独立于 BSP 的发布形式。例如，BSP 元数据可以包含在 Git 存储库中，并且可以具有与正式发布的 BSP 层中出现的完全不同的目录结构。</p>
<p>除了对 Yocto 项目的一般合规性要求之外，BSP 层中不需要存在特定的包或包修改。例如，没有要求在给定的 BSP 中使用特定的内核或内核版本。</p>
<p>以下是符合 Yocto 项目的已发布 BSP 的要求：</p>
<p>层名称： BSP 必须具有遵循 Yocto 项目标准的层名称。有关 BSP 层名称的信息，请参阅“ BSP 层”部分。</p>
<p>文件系统布局：如果可能，请在 BSP 层中使用与文件中列出的相同的目录名称，该recipes.txt文件位于源目录poky/meta的目录或https://git.openembedded.org 的 OpenEmbedded-Core 层 ( ) 中 /openembedded-core/tree/meta。openembedded-core</p>
<p>您应该按照功能区域将配方（<em>.bb文件）和配方修改（</em>.bbappend文件）放入recipes-<a href="#id63"><span class="problematic" id="id64">*</span></a>子目录中，如recipes.txt. 如果您找不到recipes.txt适合特定配方的类别，您可以创建自己的recipes-<a href="#id65"><span class="problematic" id="id66">*</span></a>子目录。</p>
<p>在任何特定recipes-<a href="#id67"><span class="problematic" id="id68">*</span></a>类别中，布局应与 OpenEmbedded-Core Git 存储库 ( openembedded-core) 或源目录 ( poky) 中的内容相匹配。换句话说，确保将相关文件放置在 recipes-<a href="#id69"><span class="problematic" id="id70">*</span></a>特定于配方功能的适当相关子目录中，或者放在包含一组密切相关配方的子目录中。配方本身应遵循“ OpenEmbedded 样式指南”中的 Yocto 项目中使用的配方的一般准则。</p>
<p>许可证文件：您必须在目录中包含许可证文件 meta-bsp_root_name。该许可证涵盖整个 BSP 元数据。您必须指定要使用的许可证，因为不存在默认许可证。以 BSP 层中树莓派 BSP的 COPYING.MIT 文件meta-raspberrypi为例。</p>
<p>自述文件：您必须README在目录中包含一个文件 meta-bsp_root_name。以 BSP 层中树莓派 BSP的 README.md 文件meta-raspberrypi为例。</p>
<p>该README文件至少应包含以下内容：</p>
<p>目标硬件的简要说明。</p>
<p>BSP 的所有依赖项的列表。这些依赖项通常是构建 BSP 所需层的列表。但是，依赖关系还应包含有关 BSP 可能具有的任何其他依赖关系的信息。</p>
<p>任何所需的特殊许可信息。例如，此信息包括有关满足 EULA 所需的特殊变量的信息，或有关构建或分发从 BSP 元数据构建的二进制文件所需的信息的说明。</p>
<p>BSP 层维护者的姓名和联系信息。这是应该向其发送补丁和问题的人。有关如何找到合适人选的信息，请参阅Yocto 项目开发任务手册中的“向 Yocto 项目提交更改”部分。</p>
<p>关于如何使用 BSP 层构建 BSP 的说明。</p>
<p>有关如何从 BSP 层引导 BSP 构建的说明。</p>
<p>有关如何引导 binary目录中包含的二进制映像（如果存在）的说明。</p>
<p>有关用户在构建或启动 BSP 二进制文件时应了解的任何已知错误或问题的信息。</p>
<p>README.sources 文件：如果您的 BSP 目录中包含二进制图像，则 binary必须在目录中包含一个README.sources文件meta-bsp_root_name。该文件准确地指定了您可以在哪里找到用于生成二进制图像的源。</p>
<p>层配置文件：您必须conf/layer.conf 在目录中包含一个文件meta-bsp_root_name。该文件将meta-bsp_root_nameBSP 层标识为构建系统的层。</p>
<p>机器配置文件：您必须在目录中包含一个或多个 conf/machine/bsp_root_name.conf文件 meta-bsp_root_name。这些配置文件定义了可以使用 BSP 层构建的机器目标。多个机器配置文件定义了 BSP 支持的机器配置的变体。如果 BSP 支持多个机器变体，则需要在 BSPREADME文件中充分描述每个变体。不要使用多个机器配置文件来描述不同的硬件。如果您确实有非常不同的目标，您应该为每个目标创建单独的 BSP 层。</p>
<p>笔记</p>
<p>开发人员完全有可能将工作存储库构建为不相关的 BSP 文件的集合体，并可能使用脚本或一些其他机制（例如 meta-yocto-bsp层）从该目录生成目标用于发布的 BSP。此类考虑超出了本文档的范围。</p>
<p>1.5.2发布的 BSP 建议
以下是针对符合 Yocto 项目的已发布 BSP 的建议：</p>
<p>可启动映像：已发布的 BSP 可以包含一个或多个可启动映像。包括可启动映像允许用户使用自己的硬件轻松试用 BSP。</p>
<p>在某些情况下，包含可引导映像可能不方便。如果是这样，您可能希望提供两个版本的 BSP：一个包含二进制图像，另一个不包含。不包含可启动映像的版本避免了对映像不感兴趣的用户不必要的下载时间。</p>
<p>如果您需要分发 BSP 并包含可引导映像或构建内核和文件系统以允许用户引导 BSP 以进行评估，则应将映像和工件放在目录中的 binary/子目录中meta-bsp_root_name 。</p>
<p>笔记</p>
<p>如果您确实将可引导映像作为 BSP 的一部分，并且该映像是由 GPL 或其他开源许可涵盖的软件构建的，则您有责任了解并满足所有许可要求，其中可能包括源文件的分发。</p>
<p>使用 Yocto Linux 内核： BSP 中的内核配方应基于 Yocto Linux 内核。将您的配方基于这些内核可降低维护 BSP 的成本并提高其可扩展性。请参阅这些内核的源存储库中的类别 。Yocto Linux Kernel</p>
<p>1.6为 BSP 定制配方
如果您计划为特定 BSP 定制配方，您需要执行以下操作：</p>
<p>为修改后的配方创建一个*.bbappend文件。有关使用附加文件的信息，请参阅Yocto 项目开发任务手册中的“使用您的图层附加其他图层元数据”部分。</p>
<p>确保支持您的机器的 BSP 层中的目录结构使得 OpenEmbedded 构建系统可以找到它。有关详细信息，请参阅本节后面的示例。</p>
<p>将附加文件放在名称与机器名称匹配的目录中，并且位于 BSP 层内的适当子目录中（即recipes-bsp、recipes-graphics、recipes-core等）。</p>
<p>将 BSP 特定文件放在 BSP 层内的适当目录中。层的扩展程度会影响您必须放置这些文件的位置。例如，如果您的图层支持多种不同的机器类型，您需要确保图层的目录结构包含根据机器分隔文件的层次结构。如果您的层不支持多台机器，则该层将没有额外的层次结构，并且文件显然无法驻留在特定于机器的目录中。</p>
<p>以下是一个具体示例，可帮助您更好地理解该过程。此示例通过添加一个名为interfacesinit-ifupdown_1.0.bb“xyz”机器的 配方的特定于 BSP 的配置文件来自定义配方，其中 BSP 层还支持其他几台机器：</p>
<p>编辑该init-ifupdown_1.0.bbappend文件，使其包含以下内容：</p>
<p>FILESEXTRAPATHS:prepend := “${THISDIR}/files:”
附加文件需要在meta-xyz/recipes-core/init-ifupdown 目录中。</p>
<p>在此处创建新的interfaces配置文件并将其放置在 BSP 层中：</p>
<p>meta-xyz/recipes-core/init-ifupdown/files/xyz-machine-one/interfaces
笔记</p>
<p>如果该meta-xyz层不支持多台机器，您可以将接口配置文件放在该层中：</p>
<p>meta-xyz/recipes-core/init-ifupdown/files/interfaces
附加文件中的FILESEXTRAPATHS变量扩展了构建系统在构建期间用于查找文件的搜索路径。因此，对于此示例，您需要将files目录与附加文件放在同一位置。</p>
<p>1.7 BSP 许可注意事项
在某些情况下，BSP 包含一个或多个组件的单独许可的知识产权 (IP)。对于这些情况，您需要接受需要某种明确的最终用户许可协议 (EULA) 的商业或其他类型许可的条款。一旦您接受许可，OpenEmbedded 构建系统就可以构建相应的组件并将其包含在最终的 BSP 映像中。如果 BSP 可作为预构建镜像使用，您可以在同意许可或 EULA 后下载该镜像。</p>
<p>您会发现某些对系统正常运行至关重要的单独许可组件可能没有不受限制（或免费）的替代品。如果没有这些基本组件，系统将无法正常工作。再说一次，您可能会发现其他简单“必备”或纯选修的许可组件确实有一个您可以使用的不受阻碍的免费替换组件，而不是同意单独许可的组件。即使对于系统必不可少的组件，您也可能会发现一个不受阻碍的组件，它并不相同，但将作为 BSP 配方中许可版本的功能较弱的版本。</p>
<p>对于您可以替换免费组件并仍保持系统功能的情况，Yocto 项目网站上“软件”选项卡中的“下载”选项可提供完全没有任何 IP 限制的去功能 BSP。对于这些情况，您可以直接使用替代，而无需任何进一步的许可要求。如果存在，这些完全去特征化的 BSP 的命名与其各自的受阻 BSP 的名称相比会适当地不同。如果可用，这些替换是您最简单和最喜欢的选择。显然，使用这些替换假定生成的功能满足系统要求。</p>
<p>笔记</p>
<p>但是，如果非抵押版本不可用或它提供不合适的功能或质量，您可以使用抵押版本。</p>
<p>OpenEmbedded 构建系统中有两种不同的方法可以满足受担保 BSP 的许可要求。以下列表按优先顺序描述了它们：</p>
<p>使用 LICENSE_FLAGS 变量来定义具有商业或其他类型的特殊许可包的配方：对于这些配方中的每一个，您可以在名为LICENSE_FLAGS_WHITELISTlocal.conf的变量 中指定匹配的许可证字符串。指定匹配的许可证字符串表示您同意该许可证。因此，构建系统可以构建相应的配方并将组件包含在映像中。请参阅“启用商业许可食谱”有关如何使用这些变量的详细信息，</p>
<p>如果您像往常一样构建，而不在LICENSE_FLAGS_WHITELIST变量中指定任何配方，则构建将停止并为您提供您尝试包含在需要LICENSE_FLAGS_WHITELIST条目的图像中的配方列表变量中条目的映像中的配方列表。在其中输入适当的许可证标志后，重新启动构建以从中断处继续。在构建过程中，由于您已满足要求，因此不会再次出现提示。</p>
<p>一旦适当的许可标志出现在LICENSE_FLAGS_WHITELIST变量中的白名单上 ，您就可以在完全不改变正常构建过程的情况下构建受阻镜像。</p>
<p>获取 BSP 的预构建版本：您可以通过从Yocto Project 网站上的“软件”选项卡中选择“下载”项来获取这种类型的 BSP 。作为下载过程的一部分，您可以在同意每个单独担保包的许可要求后下载包含专有组件的 BSP tarball。通过这种方式获取 BSP，您可以在同意网站提供的点击许可协议后立即访问受担保的图像。如果您想使用 BSP tarball 中包含的配方自己构建映像，您仍需要创建适当的 LICENSE_FLAGS_WHITELIST以匹配 BSP 中的受阻配方。</p>
<p>笔记</p>
<p>预编译的映像与一个限时内核捆绑在一起，该内核在强制系统重新启动之前运行预定的时间（10 天）。此限制旨在阻止直接重新分发图像。如果要删除此限制，您最终必须重建映像。</p>
<p>1.8bitbake-layers使用脚本创建新的 BSP 层
该脚本自动创建 BSP 层。使层成为“BSP 层”的原因是至少存在一个机器配置文件。此外，BSP 层通常有一个内核配方或一个利用现有内核配方的附加文件。然而，主要要求是机器配置。bitbake-layers create-layer</p>
<p>使用以下步骤创建 BSP 层：</p>
<p>创建一个通用层：使用bitbake-layers带有子命令的脚本 create-layer来创建一个新的通用层。有关如何使用 bitbake-layers脚本创建通用层的说明，请参阅Yocto 项目开发任务手册中的“使用 bitbake-layers 脚本创建通用层”部分。</p>
<p>创建层配置文件：每个层都需要一个层配置文件。此配置文件为层的配方、层的优先级等建立位置。layer.conf您可以在 Yocto Project Source Repositories中找到文件示例。要在配置文件中获取您需要的示例，请找到一个层（例如“meta-ti”）并检查 local.conf 文件。</p>
<p>创建机器配置文件：创建 conf/machine/bsp_root_name.conf文件。 有关示例文件，请参见 meta-yocto-bsp/conf/machine 。bsp_root_name.conf还有其他示例，例如 来自其他供应商的meta-ti 和 meta-freescale ，它们具有更具体的机器和调整示例。</p>
<p>创建内核配方：recipes-kernel/linux通过使用内核附加文件或新的自定义内核配方文件（例如yocto-linux_4.12.bb）来创建内核配方 。上一步中提到的 BSP 层也包含不同的内核示例。有关如何创建自定义内核的信息，请参阅 Yocto Project Linux 内核开发手册中的“修改现有配方”部分。</p>
<p>本节的其余部分提供了对 Beaglebone 的 Yocto 项目参考 BSP 的描述，它位于 meta-yocto-bsp 层中。</p>
<p>1.8.1 BSP层配置示例
该层的conf目录包含layer.conf配置文件。在此示例中，conf/layer.conf如下所示：</p>
<p># We have a conf and classes directory, add to BBPATH
BBPATH .= “:${LAYERDIR}”</p>
<p># We have a recipes directory containing .bb and .bbappend files, add to BBFILES
BBFILES += “${LAYERDIR}/recipes-<em>/</em>/<a href="#id71"><span class="problematic" id="id72">*</span></a>.bb </p>
<blockquote>
<div><p>${LAYERDIR}/recipes-<em>/</em>/<a href="#id73"><span class="problematic" id="id74">*</span></a>.bbappend”</p>
</div></blockquote>
<p>BBFILE_COLLECTIONS += “yoctobsp”
BBFILE_PATTERN_yoctobsp = “^${LAYERDIR}/”
BBFILE_PRIORITY_yoctobsp = “5”
LAYERVERSION_yoctobsp = “4”
LAYERSERIES_COMPAT_yoctobsp = “honister”
此文件中使用的变量配置图层。了解层配置文件的一个好方法是检查来自 Source Repositories的各种 BSP 文件。</p>
<p>有关此特定层配置文件的详细说明，请参阅Yocto 项目开发任务手册中描述如何创建层的讨论中的“步骤 3 ”。</p>
<p>1.8.2 BSP机器配置示例
正如本节前面提到的，与通用层或内核层相比，机器配置文件的存在使层成为 BSP 层。</p>
<p>该层的目录中有一个或多个机器配置文件 bsp_layer/conf/machine/：</p>
<p>bsp_layer/conf/machine/machine1.conf
bsp_layer/conf/machine/machine2.conf
bsp_layer/conf/machine/machine3.conf
… more …
例如，BeagleBone 和 BeagleBone Black 开发板的机器配置文件位于该层poky/meta-yocto-bsp/conf/machine并命名为 beaglebone-yocto.conf：</p>
<p><a class="reference external" href="mailto:#&#37;&#52;&#48;TYPE">#<span>&#64;</span>TYPE</a>: Machine
<a class="reference external" href="mailto:#&#37;&#52;&#48;NAME">#<span>&#64;</span>NAME</a>: Beaglebone-yocto machine
<a class="reference external" href="mailto:#&#37;&#52;&#48;DESCRIPTION">#<span>&#64;</span>DESCRIPTION</a>: Reference machine configuration for <a class="reference external" href="http://beagleboard.org/bone">http://beagleboard.org/bone</a> and <a class="reference external" href="http://beagleboard.org/black">http://beagleboard.org/black</a> boards</p>
<p>PREFERRED_PROVIDER_virtual/xserver ?= “xserver-xorg”
XSERVER ?= “xserver-xorg </p>
<blockquote>
<div><blockquote>
<div><p>xf86-video-modesetting </p>
</div></blockquote>
<p>“</p>
</div></blockquote>
<p>MACHINE_EXTRA_RRECOMMENDS = “kernel-modules kernel-devicetree”</p>
<p>EXTRA_IMAGEDEPENDS += “u-boot”</p>
<p>DEFAULTTUNE ?= “cortexa8hf-neon”
include conf/machine/include/arm/armv7a/tune-cortexa8.inc</p>
<p>IMAGE_FSTYPES += “tar.bz2 jffs2 wic wic.bmap”
EXTRA_IMAGECMD:jffs2 = “-lnp ”
WKS_FILE ?= “beaglebone-yocto.wks”
IMAGE_INSTALL:append = ” kernel-devicetree kernel-image-zimage”
do_image_wic[depends] += “mtools-native:do_populate_sysroot dosfstools-native:do_populate_sysroot”</p>
<p>SERIAL_CONSOLES ?= “115200;ttyS0 115200;ttyO0”
SERIAL_CONSOLES_CHECK = “${SERIAL_CONSOLES}”</p>
<p>PREFERRED_PROVIDER_virtual/kernel ?= “linux-yocto”
PREFERRED_VERSION_linux-yocto ?= “5.0%”</p>
<p>KERNEL_IMAGETYPE = “zImage”
KERNEL_DEVICETREE = “am335x-bone.dtb am335x-boneblack.dtb am335x-bonegreen.dtb”
KERNEL_EXTRA_ARGS += “LOADADDR=${UBOOT_ENTRYPOINT}”</p>
<p>SPL_BINARY = “MLO”
UBOOT_SUFFIX = “img”
UBOOT_MACHINE = “am335x_evm_defconfig”
UBOOT_ENTRYPOINT = “0x80008000”
UBOOT_LOADADDRESS = “0x80008000”</p>
<p>MACHINE_FEATURES = “usbgadget usbhost vfat alsa”</p>
<p>IMAGE_BOOT_FILES ?= “u-boot.${UBOOT_SUFFIX} MLO zImage am335x-bone.dtb am335x-boneblack.dtb am335x-bonegreen.dtb”
用于配置机器的变量定义了机器特定的属性；例如，与机器相关的软件包、机器调优、要构建的内核类型和 U-Boot 配置。</p>
<p>以下列表对 BeagleBone 开发板的示例参考机器配置文件中的语句提供了一些解释。意识到可以将更多内容定义为机器配置文件的一部分。一般来说，您可以通过在 Yocto 项目参考手册中的“变量词汇表”中定位变量来了解本示例中没有的相关变量。</p>
<p>PREFERRED_PROVIDER_virtual/xserver：找到多个提供者时提供“virtual/xserver”的配方。在这种情况下，提供“virtual/xserver”的配方是“xserver-xorg”，在 poky/meta/recipes-graphics/xorg-xserver.</p>
<p>XSERVER：应该安装的软件包，为机器提供 X 服务器和驱动程序。在此示例中，安装了“xserver-xorg”和“xf86-video-modesetting”。</p>
<p>MACHINE_EXTRA_RRECOMMENDS：与机器相关的软件包列表，对于启动映像不是必需的。因此，如果包不存在，构建不会失败。但是，功能齐全的映像需要这些软件包。</p>
<p>提示</p>
<p>有许多MACHINE*变量可以帮助您配置特定的硬件。</p>
<p>EXTRA_IMAGEDEPENDS：要构建的配方不提供用于安装到根文件系统中的软件包，但构建映像取决于配方。有时需要配方来构建最终映像，但在根文件系统中不需要。在这种情况下，必须为映像构建 U-Boot 配方。</p>
<p>DEFAULTTUNE：机器使用调优来优化机器、CPU 和应用程序性能。这些特性统称为“调整特性”，设置在OpenEmbedded-Core (OE-Core)层（例如 poky/meta/conf/machine/include）中。在此示例中，默认调整文件是cortexa8hf-neon.</p>
<p>笔记</p>
<p>拉入 conf/machine/include/arm/tune-cortexa8.inc文件的包含语句提供了许多调整可能性。</p>
<p>IMAGE_FSTYPES：OpenEmbedded 构建系统在创建根文件系统时在构建过程中使用的格式。在此示例中，支持四种类型的图像。</p>
<p>EXTRA_IMAGECMD：指定图像创建命令的附加选项。在此示例中，创建 JFFS2映像时使用了“-lnp”选项。</p>
<p>WKS_FILE：OpenEmbedded 构建系统用来创建分区映像 (image.wic)的Wic kickstart文件的位置。</p>
<p>IMAGE_INSTALL ：指定要通过图像类安装到图像中的包 配方使用IMAGE_INSTALL变量。</p>
<p>do_image_wic[depends]：在构建期间构建的任务。在此示例中，该任务依赖于特定工具，以便在构建 Wic 映像时创建 sysroot。</p>
<p>SERIAL_CONSOLES：定义一个串行控制台 (TTY) 以使用 getty 启用。在这种情况下，波特率为“115200”，设备名称为“ttyO0”。</p>
<p>PREFERRED_PROVIDER_virtual/kernel：指定在找到多个提供程序时提供“虚拟/内核”的配方。在这种情况下，提供“virtual/kernel”的配方是“linux-yocto”，它存在于层的 recipes-kernel/linux目录中。</p>
<p>PREFERRED_VERSION_linux-yocto：定义用于构建内核的配方版本，在本例中为“5.0”。</p>
<p>KERNEL_IMAGETYPE：为设备构建的内核类型。在这种情况下，OpenEmbedded 构建系统会创建一个“zImage”图像类型。</p>
<p>KERNEL_DEVICETREE：生成的 Linux 内核设备树（即 <a href="#id75"><span class="problematic" id="id76">*</span></a>.dtb）文件的名称。包括各种 BeagleBone 设备的所有设备树。</p>
<p>KERNEL_EXTRA_ARGS：OpenEmbedded 构建系统在编译内核时传递的附加make命令行参数。在此示例中， LOADADDR=${UBOOT_ENTRYPOINT}作为命令行参数传递。</p>
<p>SPL_BINARY：定义辅助程序加载器 (SPL) 二进制类型。在这种情况下，SPL 二进制设置为“MLO”，代表多媒体卡加载器。</p>
<p>BeagleBone 开发板需要 SPL 才能启动，并且 SPL 文件类型必须是 MLO。因此，机器配置需要将SPL_BINARY定义为MLO.</p>
<p>笔记</p>
<p>有关如何使用 SPL 变量的更多信息，请参见 u-boot.inc 包含文件。</p>
<p>UBOOT_*：定义构建 U-Boot 映像所需的各种 U-Boot 配置。在此示例中，需要 U-Boot 映像来引导 BeagleBone 设备。有关详细信息，请参阅以下变量：</p>
<p>UBOOT_SUFFIX：指向生成的 U-Boot 扩展。</p>
<p>UBOOT_MACHINE：指定在构建 U-Boot 映像时在 make 命令行上传递的值。</p>
<p>UBOOT_ENTRYPOINT：指定 U-Boot 映像的入口点。</p>
<p>UBOOT_LOADADDRESS：指定 U-Boot 映像的加载地址。</p>
<p>MACHINE_FEATURES：指定 BeagleBone 设备能够支持的硬件功能列表。在这种情况下，设备支持“usbgadget usbhost vfat alsa”。</p>
<p>IMAGE_BOOT_FILESbootimg-partition ：使用带有或 bootimg-efi源插件的 Wic 工具准备映像时安装到设备启动分区中的文件</p>
<p>1.8.3 BSP 内核配方示例
用于为 BeagleBone 设备构建内核映像的内核配方已在机器配置中建立：</p>
<p>PREFERRED_PROVIDER_virtual/kernel ?= “linux-yocto”
PREFERRED_VERSION_linux-yocto ?= “5.0%”
层中的meta-yocto-bsp/recipes-kernel/linux目录包含用于构建内核的元数据。在这种情况下，内核附加文件（即linux-yocto_5.0.bbappend）用于覆盖已建立的内核配方（即linux-yocto_5.0.bb），该文件位于 <a class="reference external" href="https://git.yoctoproject.org/cgit/cgit.cgi/poky/tree/meta/recipes">https://git.yoctoproject.org/cgit/cgit.cgi/poky/tree/meta/recipes</a> -内核/Linux。</p>
<p>以下是附加文件的内容：</p>
<p>KBRANCH:genericx86 = “v5.0/standard/base”
KBRANCH:genericx86-64 = “v5.0/standard/base”
KBRANCH:edgerouter = “v5.0/standard/edgerouter”
KBRANCH:beaglebone-yocto = “v5.0/standard/beaglebone”</p>
<p>KMACHINE:genericx86 ?= “common-pc”
KMACHINE:genericx86-64 ?= “common-pc-64”
KMACHINE:beaglebone-yocto ?= “beaglebone”</p>
<p>SRCREV_machine:genericx86 ?= “3df4aae6074e94e794e27fe7f17451d9353cdf3d”
SRCREV_machine:genericx86-64 ?= “3df4aae6074e94e794e27fe7f17451d9353cdf3d”
SRCREV_machine:edgerouter ?= “3df4aae6074e94e794e27fe7f17451d9353cdf3d”
SRCREV_machine:beaglebone-yocto ?= “3df4aae6074e94e794e27fe7f17451d9353cdf3d”</p>
<p>COMPATIBLE_MACHINE:genericx86 = “genericx86”
COMPATIBLE_MACHINE:genericx86-64 = “genericx86-64”
COMPATIBLE_MACHINE:edgerouter = “edgerouter”
COMPATIBLE_MACHINE:beaglebone-yocto = “beaglebone-yocto”</p>
<p>LINUX_VERSION:genericx86 = “5.0.3”
LINUX_VERSION:genericx86-64 = “5.0.3”
LINUX_VERSION:edgerouter = “5.0.3”
LINUX_VERSION:beaglebone-yocto = “5.0.3”
这个特定的附加文件适用于作为该meta-yocto-bsp层一部分的所有机器。相关语句附加了“beaglebone-yocto”字符串。OpenEmbedded 构建系统使用这些语句来覆盖内核配方中的类似语句：</p>
<p>KBRANCH：标识在构建期间经过验证、修补和配置的内核分支。</p>
<p>KMACHINE：标识内核已知的机器名称，有时与 OpenEmbedded 构建系统已知的名称不同。</p>
<p>SRCREV：标识用于构建映像的源代码的修订版本。</p>
<p>COMPATIBLE_MACHINE：一个正则表达式，解析为一个或多个与配方兼容的目标机器。</p>
<p>LINUX_VERSION：来自 kernel.org 的 Linux 版本，被 OpenEmbedded 构建系统用于构建内核映像。</p>
<hr class="docutils" />
<p>Yocto Project Linux 内核开发手册</p>
<p>1简介
1.1概述
无论您打算如何使用 Yocto 项目，您都有可能使用 Linux 内核。本手册描述了如何设置您的构建主机以支持内核开发，介绍内核开发过程，提供有关 Yocto Linux 内核元数据的背景信息，描述您可以使用内核工具执行的常见任务，向您展示如何使用内核元数据需要在 Yocto 项目中使用内核，并深入了解 Yocto 项目团队如何开发和维护 Yocto Linux 内核 Git 存储库和元数据。</p>
<p>每个 Yocto 项目版本都有一组 Yocto Linux 内核配方，您可以在“Yocto Linux 内核”标题下的Yocto源代码库中查看其 Git 存储库 。该版本的新配方跟踪来自https://www.kernel.org的最新 Linux 内核上游开发，并介绍了新支持的平台。该版本中的先前配方已更新并支持至少一个额外的 Yocto Project 版本。当它们对齐时，这些以前的版本会更新，以包括来自长期支持倡议 (LTSI) 项目的最新版本。您可以在“ Yocto 项目内核开发和维护”部分了解有关 Yocto Linux 内核和 LTSI 的更多信息。</p>
<p>linux-yocto-dev.bb如果您想使用最新的上游 Yocto Linux 内核开发和内核元数据开发，还包括一个 Yocto Linux 内核开发秘诀 ( )。</p>
<p>笔记</p>
<p>有关 Yocto Linux 内核的更多信息，请参阅“ Yocto 项目内核开发和维护”部分。</p>
<p>Yocto 项目还提供了一套强大的内核工具来管理 Yocto Linux 内核源和配置数据。您可以使用这些工具进行单个配置更改、应用多个补丁或使用您自己的内核源代码。</p>
<p>特别是，内核工具允许您生成配置片段，只指定您必须做的，仅此而已。配置片段只需要包含 CONFIGYocto Linux 内核menuconfig 系统提供的最高级别的可见选项。.config 将此与包含所有自动选择的选项的完整 Yocto Linux 内核文件进行对比CONFIG。这种效率减少了您的维护工作，并允许您以对您的项目有意义的方式进一步分离您的配置。常见的拆分将策略和硬件分开。例如，您的所有内核可能都支持procandsys文件系统，但只有特定的板需要声音、U​​SB 或特定的驱动程序。单独指定这些配置允许您根据需要将它们聚合在一起，但只在一个地方维护它们。类似的逻辑适用于分离源更改。</p>
<p>如果您不维护自己的内核源代码并且只需要对源代码进行最小的更改，则发布的配方提供了一个经过审查的基础，您可以在此基础上对您的更改进行分层。这样做可以让您受益于在 Yocto 项目开发期间执行的持续内核集成和测试。</p>
<p>相反，如果您有一个非常特定的 Linux 内核源代码树并且无法与官方 Yocto Linux 内核配方之一保持一致，那么您可以通过自己的内核源使用 Yocto Project Linux 内核工具。</p>
<p>本手册的其余部分提供了完成特定 Linux 内核开发任务的说明。这些说明假设您熟悉使用BitBake配方和基本的开源开发工具。理解这些概念将有助于使用内核配方的过程。如果您发现需要一些额外的背景知识，请务必查看并理解以下文档：</p>
<p>Yocto 项目快速构建文档。</p>
<p>Yocto 项目概述和概念手册。</p>
<p>在 Yocto 项目应用程序开发和可扩展软件开发工具包 (eSDK) 手册中描述的devtool 工作流程。</p>
<p>Yocto 项目开发任务手册中的“理解和创建层”部分。</p>
<p>“内核修改工作流程”部分。</p>
<p>1.2内核修改工作流程
内核修改涉及更改 Yocto Project 内核，这可能涉及更改配置选项以及添加新的内核配方。可以以配置片段的形式添加配置更改，而配方修改来自recipes-kernel您创建的内核层中的内核区域。</p>
<p>本节提供了 Yocto Project 内核修改工作流程的高级概述。插图和随附列表提供了一般信息和进一步信息的参考。</p>
<p>kernel-dev-flow.png</p>
<p>设置您的主机开发系统以支持使用 Yocto 项目的开发：请参阅 Yocto 项目开发任务手册中的“设置以使用 Yocto 项目”部分，了解有关如何让构建主机准备好使用 Yocto 项目的选项。</p>
<p>为内核开发设置主机开发系统：建议您使用devtool可扩展的 SDK 进行内核开发。或者，您可以使用 Yocto 项目的传统内核开发方法。无论哪种方式，您都需要采取一些步骤来准备好开发环境。</p>
<p>使用devtool和 eSDK 要求您有一个干净的映像构建，并且您设置了适当的 eSDK。有关更多信息，请参阅“准备使用 devtool 进行开发”部分。</p>
<p>使用传统的内核开发要求您在隔离的本地 Git 存储库中拥有可用的内核源代码。有关详细信息，请参阅“为传统内核开发做准备”部分。</p>
<p>如果适用，对内核源代码进行更改：修改内核并不总是意味着直接更改源文件。但是，如果您必须这样做，如果您使用的是devtool. 有关详细信息，请参阅“使用 devtool 修补内核”部分。</p>
<p>如果您使用传统的内核开发，您可以在内核的本地 Git 存储库中编辑源文件。有关详细信息，请参阅“使用传统内核开发修补内核”部分。</p>
<p>如果适用，进行内核配置更改：如果您的情况需要更改内核的配置，您可以使用 menuconfig，它允许您交互式地开发和测试您对内核所做的配置更改。保存您通过menuconfig 更新内核.config文件所做的更改。</p>
<p>笔记</p>
<p>尽量抵制直接编辑现有.config 文件的诱惑，该文件位于构建目录中用于构建的源代码中。这样做会在 OpenEmbedded 构建系统重新生成配置文件时产生意外结果。</p>
<p>一旦您对使用所做的配置更改感到满意 menuconfig并保存了它们，您可以直接将生成的.config文件与现有的原始文件进行比较，并将这些更改收集到 配置片段文件中，以便从内核.bbappend文件中引用。</p>
<p>此外，如果您在 BSP 层工作并且需要修改 BSP 的内核配置，您可以使用menuconfig.</p>
<p>使用您的更改重建内核映像：重建内核映像会应用您的更改。根据您的目标硬件，您可以在实际硬件或 QEMU 上验证您的更改。</p>
<p>本开发人员指南的其余部分涵盖了内核开发、高级元数据使用和 Yocto Linux 内核维护概念期间通常使用的常见任务。</p>
<p>2常见任务
本章介绍了在使用 Yocto Project Linux 内核时执行的几个常见任务。这些任务包括为内核开发准备主机开发系统、准备层、修改现有配方、修补内核、配置内核、迭代开发、使用您自己的源代码以及合并树外模块。</p>
<p>笔记</p>
<p>本章中介绍的示例适用于 Yocto Project 2.4 Release 和 forward。</p>
<p>2.1准备构建主机在内核上工作
在进行任何内核开发之前，您需要确保您的构建主机设置为使用 Yocto 项目。有关如何设置的信息，请参阅 Yocto 项目开发任务手册中的“设置以使用 Yocto 项目”部分。准备系统的一部分是在您的系统上创建源目录( poky)的本地 Git 存储库 。按照 Yocto 项目开发任务手册中“克隆 poky 存储库”部分中的步骤设置源目录。</p>
<p>笔记</p>
<p>确保您签出适当的开发分支，或者通过签出特定标签来创建本地分支以获得所需的 Yocto Project 版本。有关更多信息，请参阅Yocto 项目开发任务手册中的“在 Poky 中按分支签出”和“在 Poky 中按标签签出”部分。</p>
<p>内核开发最好使用 devtool完成 ，而不是通过传统的内核工作流方法。本节的其余部分提供了这两种情况的信息。</p>
<p>2.1.1准备开发使用devtool
按照以下步骤准备使用 devtool. 完成此过程将为您留下一个干净的内核映像并准备好进行修改，如“使用 devtool 修补内核”部分所述：</p>
<p>初始化 BitBake 环境：在构建可扩展 SDK 之前，您需要通过获取构建环境脚本（即oe-init-build-env）来初始化 BitBake 构建环境：</p>
<p>$ cd poky
$ source oe-init-build-env
笔记</p>
<p>前面的命令假定 Yocto 项目源存储库 （即poky）已使用 Git 克隆，并且本地存储库名为“poky”。</p>
<p>准备你的 local.conf 文件：默认情况下， MACHINE变量设置为“qemux86-64”，如果你正在为 64 位模式的 QEMU 模拟器构建，这很好。但是，如果不是，则需要 在构建目录中找到的文件中 适当地设置MACHINE变量（即 在此示例中）。conf/local.confpoky/build</p>
<p>此外，由于您准备处理内核映像，因此需要设置 MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS 变量以包含内核模块。</p>
<p>在这个例子中，我们希望为 qemux86 构建，因此我们必须将 MACHINE变量设置为“qemux86”并添加“kernel-modules”。如前所述，我们通过附加到conf/local.conf：</p>
<p>MACHINE = “qemux86”
MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS += “kernel-modules”
为补丁创建一个层：您需要创建一个层来保存为内核映像创建的补丁。您可以使用以下 命令：bitbake-layers create-layer</p>
<p>$ cd poky/build
$ bitbake-layers create-layer ../../meta-mylayer
NOTE: Starting bitbake server…
Add your new layer with ‘bitbake-layers add-layer ../../meta-mylayer’
$
笔记</p>
<p>有关使用公共层和 BSP 层的背景信息，请分别参见Yocto 项目开发任务手册中的“理解和创建层”部分和 Yocto 项目板支持 (BSP) 开发人员指南中的“ BSP 层”部分。有关如何使用该命令快速设置图层的信息，请参阅Yocto 项目开发任务手册中的“使用 bitbake-layers 脚本创建通用图层”部分。bitbake-layers create-layer</p>
<p>通知 BitBake 构建环境关于您的层：按照创建层时的指示，您需要将层添加到文件中的 BBLAYERS变量中 bblayers.conf，如下所示：</p>
<p>$ cd poky/build
$ bitbake-layers add-layer ../../meta-mylayer
NOTE: Starting bitbake server…
$
构建可扩展 SDK：使用 BitBake 构建专门用于使用 QEMU 运行的图像的可扩展 SDK：</p>
<p>$ cd poky/build
$ bitbake core-image-minimal -c populate_sdk_ext
构建完成后，您可以 <a href="#id77"><span class="problematic" id="id78">*</span></a>.sh在以下目录中找到 SDK 安装程序文件（即文件）：</p>
<p>poky/build/tmp/deploy/sdk
对于此示例，安装程序文件名为 poky-glibc-x86_64-core-image-minimal-i586-toolchain-ext-3.4.2.sh.</p>
<p>安装可扩展 SDK：使用以下命令安装 SDK。对于此示例，将 SDK 安装在默认 poky_sdk目录中：</p>
<p>$ cd poky/build/tmp/deploy/sdk
$ ./poky-glibc-x86_64-core-image-minimal-i586-toolchain-ext-3.4.2.sh
Poky (Yocto Project Reference Distro) Extensible SDK installer version 3.4.2
============================================================================
Enter target directory for SDK (default: poky_sdk):
You are about to install the SDK to “/home/scottrif/poky_sdk”. Proceed [Y/n]? Y
Extracting SDK………………………………..done
Setting it up…
Extracting buildtools…
Preparing build system…
Parsing recipes: 100% <a href="#id131"><span class="problematic" id="id132">|#################################################################|</span></a> Time: 0:00:52
Initializing tasks: 100% <a href="#id133"><span class="problematic" id="id134">|############## ###############################################|</span></a> Time: 0:00:04
Checking sstate mirror object availability: 100% <a href="#id135"><span class="problematic" id="id136">|######################################|</span></a> Time: 0:00:00
Parsing recipes: 100% <a href="#id137"><span class="problematic" id="id138">|#################################################################|</span></a> Time: 0:00:33
Initializing tasks: 100% <a href="#id139"><span class="problematic" id="id140">|##############################################################|</span></a> Time: 0:00:00
done
SDK has been successfully set up and is ready to be used.
Each time you wish to use the SDK in a new shell session, you need to source the environment setup script e.g.</p>
<blockquote>
<div><p>$ . /home/scottrif/poky_sdk/environment-setup-i586-poky-linux</p>
</div></blockquote>
<p>设置新终端以使用可扩展 SDK：您必须设置新终端以使用 SDK。您不能使用与构建安装程序相同的 BitBake shell。</p>
<p>打开新的 shell 后，按照安装 SDK 的输出指示运行 SDK 环境设置脚本：</p>
<p>$ source poky_sdk/environment-setup-i586-poky-linux
“SDK environment now set up; additionally you may now run devtool to perform development tasks.
Run devtool –help for further details.
笔记</p>
<p>如果您收到有关尝试在设置为运行 BitBake 的环境中使用可扩展 SDK 的警告，则说明您没有使用新的 shell。</p>
<p>构建干净的映像：devtool准备在内核上工作的最后一步是使用您刚刚为 SDK 工作设置和初始化的新终端构建初始映像：</p>
<p>$ devtool build-image
Parsing recipes: 100% <a href="#id141"><span class="problematic" id="id142">|##########################################|</span></a> Time: 0:00:05
Parsing of 830 .bb files complete (0 cached, 830 parsed). 1299 targets, 47 skipped, 0 masked, 0 errors.
WARNING: No packages to add, building image core-image-minimal unmodified
Loading cache: 100% <a href="#id143"><span class="problematic" id="id144">|############################################|</span></a> Time: 0:00:00
Loaded 1299 entries from dependency cache.
NOTE: Resolving any missing task queue dependencies
Initializing tasks: 100% <a href="#id145"><span class="problematic" id="id146">|#######################################|</span></a> Time: 0:00:07
Checking sstate mirror object availability: 100% <a href="#id147"><span class="problematic" id="id148">|###############|</span></a> Time: 0:00:00
NOTE: Executing SetScene Tasks
NOTE: Executing RunQueue Tasks
NOTE: Tasks Summary: Attempted 2866 tasks of which 2604 didn’t need to be rerun and all succeeded.
NOTE: Successfully built core-image-minimal. You can find output files in /home/scottrif/poky_sdk/tmp/deploy/images/qemux86
如果您正在构建实际硬件而不是仿真，则可以将映像闪存到 USB 记忆棒上/dev/sdd并启动您的设备。有关使用 Minnowboard 的示例，请参阅 TipsAndTricks / KernelDevelopmentWithEsdk Wiki 页面。</p>
<p>至此，您已设置好开始使用可扩展 SDK 对内核进行修改。有关后续示例，请参阅“使用 devtool 修补内核”部分。</p>
<p>2.1.2为传统内核开发做准备
使用 Yocto 项目为传统内核开发做准备涉及许多与上一节所述相同的步骤。但是，您需要建立内核源代码的本地副本，因为您将编辑这些文件。</p>
<p>按照以下步骤准备使用 Yocto 项目的传统内核开发流程更新内核映像。完成此过程后，您就可以按照“使用传统内核开发修补内核”部分中所述对内核源代码进行修改：</p>
<p>初始化 BitBake 环境：在使用 BitBake 进行任何操作之前，您需要通过获取构建环境脚本（即 oe-init-build-env）来初始化 BitBake 构建环境。此外，对于此示例，请确保您签出的本地分支poky是 Yocto Project Honister 分支。如果您需要签出 Honister 分支，请参阅Yocto 项目开发任务手册中的“在 Poky 中按分支签出”部分。</p>
<p>$ cd poky
$ git branch
master
* honister
$ source oe-init-build-env
笔记</p>
<p>前面的命令假定 Yocto 项目源存储库 （即poky）已使用 Git 克隆，并且本地存储库名为“poky”。</p>
<p>准备你的 local.conf 文件：默认情况下， MACHINE变量设置为“qemux86-64”，如果你正在为 64 位模式的 QEMU 模拟器构建，这很好。但是，如果不是，则需要 在构建目录中找到的文件中 适当地设置MACHINE变量（即 在此示例中）。conf/local.confpoky/build</p>
<p>此外，由于您准备处理内核映像，因此需要设置 MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS 变量以包含内核模块。</p>
<p>在这个例子中，我们希望为 qemux86 构建，因此我们必须将 MACHINE变量设置为“qemux86”并添加“kernel-modules”。如前所述，我们通过附加到conf/local.conf：</p>
<p>MACHINE = “qemux86”
MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS += “kernel-modules”
为补丁创建一个层：您需要创建一个层来保存为内核映像创建的补丁。您可以使用以下 命令：bitbake-layers create-layer</p>
<p>$ cd poky/build
$ bitbake-layers create-layer ../../meta-mylayer
NOTE: Starting bitbake server…
Add your new layer with ‘bitbake-layers add-layer ../../meta-mylayer’
笔记</p>
<p>有关使用公共层和 BSP 层的背景信息，请分别参见Yocto 项目开发任务手册中的“理解和创建层”部分和 Yocto 项目板支持 (BSP) 开发人员指南中的“ BSP 层”部分。有关如何使用该命令快速设置图层的信息，请参阅Yocto 项目开发任务手册中的“使用 bitbake-layers 脚本创建通用图层”部分。bitbake-layers create-layer</p>
<p>通知 BitBake 构建环境关于您的层：按照创建层时的指示，您需要将层添加到文件中的 BBLAYERS变量中 bblayers.conf，如下所示：</p>
<p>$ cd poky/build
$ bitbake-layers add-layer ../../meta-mylayer
NOTE: Starting bitbake server …
$
创建内核 Git 存储库的本地副本：您可以在https://git.yoctoproject.org/cgit/cgit.cgi/的 Yocto 项目源存储库中的“Yocto Linux 内核”下找到支持的 Yocto 项目内核的 Git 存储库 .</p>
<p>为简单起见，建议您在 源目录之外创建内核 Git 存储库的副本，该目录通常命名为poky. 另外，请确保您在 standard/base分支中。</p>
<p>以下命令显示如何创建 linux-yocto-4.12内核的本地副本并位于standard/base分支中。</p>
<p>笔记</p>
<p>linux-yocto-4.12内核可以与 Yocto Project 2.4 版本和转发版本一起使用。您不能将linux-yocto-4.12内核与 Yocto Project 2.4 之前的版本一起使用。</p>
<p>$ cd ~
$ git clone git://git.yoctoproject.org/linux-yocto-4.12 –branch standard/base
Cloning into ‘linux-yocto-4.12’…
remote: Counting objects: 6097195, done.
remote: Compressing objects: 100% (901026/901026), done.
remote: Total 6097195 (delta 5152604), reused 6096847 (delta 5152256)
Receiving objects: 100% (6097195/6097195), 1.24 GiB | 7.81 MiB/s, done.
Resolving deltas: 100% (5152604/5152604), done. Checking connectivity… done.
Checking out files: 100% (59846/59846), done.
创建内核缓存 Git 存储库的本地副本：为简单起见，建议您在 源目录之外创建内核缓存 Git 存储库的副本，通常命名为poky. 此外，对于此示例，请确保您在yocto-4.12分支中。</p>
<p>以下命令显示如何创建本地副本 yocto-kernel-cache并切换到yocto-4.12分支：</p>
<p>$ cd ~
$ git clone git://git.yoctoproject.org/yocto-kernel-cache –branch yocto-4.12
Cloning into ‘yocto-kernel-cache’…
remote: Counting objects: 22639, done.
remote: Compressing objects: 100% (9761/9761), done.
remote: Total 22639 (delta 12400), reused 22586 (delta 12347)
Receiving objects: 100% (22639/22639), 22.34 MiB | 6.27 MiB/s, done.
Resolving deltas: 100% (12400/12400), done.
Checking connectivity… done.
此时，您已准备好开始使用传统的内核开发步骤对内核进行修改。有关后续示例，请参阅“使用传统内核开发修补内核”部分。</p>
<p>2.2创建和准备层
如果您要修改内核配方，建议您创建并准备自己的层来完成您的工作。您的层包含自己的BitBake 附加文件 ( .bbappend)，并提供了一种方便的机制来创建您自己的配方文件 ( .bb) 以及存储和使用内核补丁文件。有关使用层的背景信息，请参阅 Yocto 项目开发任务手册中的“理解和创建层”部分。</p>
<p>笔记</p>
<p>Yocto 项目附带了许多工具，可以简化您需要执行的任务。一个这样的工具是 命令，它简化了创建新层的过程。有关如何使用此脚本快速设置新层的信息，请参阅 Yocto 项目开发任务手册中的“使用 bitbake-layers 脚本创建通用层”部分。bitbake-layers create-layer</p>
<p>为了更好地理解您为内核开发创建的层，以下部分将介绍如何在不借助工具的情况下创建层。这些步骤假定创建一个mylayer在您的主目录中命名的层：</p>
<p>创建结构：创建层的结构：</p>
<p>$ mkdir meta-mylayer
$ mkdir meta-mylayer/conf
$ mkdir meta-mylayer/recipes-kernel
$ mkdir meta-mylayer/recipes-kernel/linux
$ mkdir meta-mylayer/recipes-kernel/linux/linux-yocto
该conf目录包含您的配置文件，而该 recipes-kernel目录包含您的附加文件和最终的补丁文件。</p>
<p>创建层配置文件：移动到 meta-mylayer/conf目录并创建layer.conf文件，如下所示：</p>
<p># We have a conf and classes directory, add to BBPATH
BBPATH .= “:${LAYERDIR}”</p>
<p># We have recipes-* directories, add to BBFILES
BBFILES += “${LAYERDIR}/recipes-<em>/</em>/<a href="#id79"><span class="problematic" id="id80">*</span></a>.bb </p>
<blockquote>
<div><p>${LAYERDIR}/recipes-<em>/</em>/<a href="#id81"><span class="problematic" id="id82">*</span></a>.bbappend”</p>
</div></blockquote>
<p>BBFILE_COLLECTIONS += “mylayer”
BBFILE_PATTERN_mylayer = “^${LAYERDIR}/”
BBFILE_PRIORITY_mylayer = “5”
请注意mylayer作为最后三个语句的一部分。</p>
<p>创建内核配方附加文件：移动到 meta-mylayer/recipes-kernel/linux目录并创建内核的附加文件。此示例使用linux-yocto-4.12 内核。因此，附加文件的名称是 linux-yocto_4.12.bbappend：</p>
<p>FILESEXTRAPATHS:prepend := “${THISDIR}/${PN}:”</p>
<p>SRC_URI:append = ” <a class="reference external" href="file://patch-file-one.patch">file://patch-file-one.patch</a>”
SRC_URI:append = ” <a class="reference external" href="file://patch-file-two.patch">file://patch-file-two.patch</a>”
SRC_URI:append = ” <a class="reference external" href="file://patch-file-three.patch">file://patch-file-three.patch</a>”
FILESEXTRAPATHS和SRC_URI语句使 OpenEmbedded 构建系统能够找到补丁文件。有关使用附加文件的更多信息，请参阅Yocto 项目开发任务手册中的“使用您的层附加其他层元数据”部分。</p>
<p>2.3修改现有配方
在许多情况下，您可以自定义现有的 linux-yocto 配方以满足项目的需要。Yocto 项目的每个版本都提供了一些可供您选择的 Linux 内核配方。这些位于meta/recipes-kernel/linux. _</p>
<p>修改现有配方可以包括以下内容：</p>
<p>创建附加文件</p>
<p>应用补丁</p>
<p>更改配置</p>
<p>在修改现有配方之前，请确保您已经创建了一个可以使用的最小自定义层。有关信息，请参阅“创建和准备图层”部分。</p>
<p>2.3.1创建附加文件
您在自定义层中创建此文件。您还可以根据您使用的 linux-yocto 配方相应地命名它。例如，如果您正在修改meta/recipes-kernel/linux/linux-yocto_4.12.bb配方，附加文件通常位于您的自定义层中，如下所示：</p>
<p>your-layer/recipes-kernel/linux/linux-yocto_4.12.bbappend
附加文件最初应 通过将包含文件的目录添加到 FILESEXTRAPATHS变量来扩展FILESPATH搜索路径， 如下所示：</p>
<p>FILESEXTRAPATHS:prepend := “${THISDIR}/${PN}:”
对于此示例，路径${THISDIR }/${PN} 在当前目录中扩展为“linux-yocto”。如果您添加任何修改内核配方的新文件，并且您已如上所述扩展FILESPATH ，则必须将文件放在您的层中的以下区域：</p>
<p>your-layer/recipes-kernel/linux/linux-yocto/
笔记</p>
<p>如果您正在开发新机器板支持包 (BSP)，请务必参考Yocto 项目板支持包开发人员指南。</p>
<p>例如，考虑以下 BSP 使用的附加文件 meta-yocto-bsp：</p>
<p>meta-yocto-bsp/recipes-kernel/linux/linux-yocto_4.12.bbappend
以下是该文件的内容。请注意，此示例列表中的实际提交 ID 字符串可能与meta-yocto-bsp上游层文件中的实际字符串不同。</p>
<p>KBRANCH:genericx86  = “standard/base”
KBRANCH:genericx86-64  = “standard/base”</p>
<p>KMACHINE:genericx86 ?= “common-pc”
KMACHINE:genericx86-64 ?= “common-pc-64”
KBRANCH:edgerouter = “standard/edgerouter”
KBRANCH:beaglebone = “standard/beaglebone”</p>
<p>SRCREV_machine:genericx86    ?= “d09f2ce584d60ecb7890550c22a80c48b83c2e19”
SRCREV_machine:genericx86-64 ?= “d09f2ce584d60ecb7890550c22a80c48b83c2e19”
SRCREV_machine:edgerouter ?= “b5c8cfda2dfe296410d51e131289fb09c69e1e7d”
SRCREV_machine:beaglebone ?= “b5c8cfda2dfe296410d51e131289fb09c69e1e7d”</p>
<p>COMPATIBLE_MACHINE:genericx86 = “genericx86”
COMPATIBLE_MACHINE:genericx86-64 = “genericx86-64”
COMPATIBLE_MACHINE:edgerouter = “edgerouter”
COMPATIBLE_MACHINE:beaglebone = “beaglebone”</p>
<p>LINUX_VERSION:genericx86 = “4.12.7”
LINUX_VERSION:genericx86-64 = “4.12.7”
LINUX_VERSION:edgerouter = “4.12.10”
LINUX_VERSION:beaglebone = “4.12.10”
此附加文件包含用于支持 Yocto 项目附带的多个 BSP 的语句。该文件使用 COMPATIBLE_MACHINE 变量定义机器，并使用 KMACHINE变量确保 OpenEmbedded 构建系统使用的机器名称映射到 Linux Yocto 内核使用的机器名称。该文件还使用可选的KBRANCH变量来确保构建过程使用适当的内核分支。</p>
<p>虽然这个特定的例子没有使用它，但 KERNEL_FEATURES 变量可用于启用特定于内核的功能。附加文件指向 源目录Git 存储库和metaGit 存储库分支中的特定提交，以识别构建 BSP 所需的确切内核。</p>
<p>在开发 BSP 时通常需要的这个特定 BSP 中缺少的一件事是 BSP 的内核配置文件 ( .config)。在开发 BSP 时，您可能有一个内核配置文件或一组内核配置文件，当它们一起定义您的 BSP 的内核配置时。您可以通过将配置放在一个文件或一组文件中来完成此定义，该文件或一组文件位于与内核附加文件相同级别的目录中，并且与内核的主配方文件具有相同的名称。满足所有这些条件后，只需在附加文件的SRC_URI语句中引用这些文件。</p>
<p>例如，假设您在一个名为 network_configs.cfg. 您可以将该文件放在名为的目录中linux-yocto，然后将如下所示的SRC_URI语句添加到附加文件中。当 OpenEmbedded 构建系统构建内核时，会选择并应用配置选项。</p>
<p>SRC_URI += “<a class="reference external" href="file://network_configs.cfg">file://network_configs.cfg</a>”
要将相关配置分组到多个文件中，请执行类似的过程。这是一个示例，它将专门针对以太网和图形的单独配置分组到它们自己的文件中，并通过在附加文件中使用如下SRC_URI语句添加配置：</p>
<dl class="simple">
<dt>SRC_URI += “<a class="reference external" href="file://myconfig.cfg">file://myconfig.cfg</a> </dt><dd><p><a class="reference external" href="file://eth.cfg">file://eth.cfg</a> <a class="reference external" href="file://gfx.cfg">file://gfx.cfg</a>”</p>
</dd>
</dl>
<p>您可以在内核配方附加文件中使用的另一个变量是 FILESEXTRAPATHS 变量。当您使用此语句时，您正在扩展 OpenEmbedded 系统使用的位置，以便在处理配方时查找文件和补丁。</p>
<p>笔记</p>
<p>还有其他分组和定义配置选项的方法。例如，如果您正在使用内核存储库的本地克隆，您可以签出内核的meta分支，进行更改，然后将更改推送到内核的本地裸克隆。结果是您直接将配置选项添加到metaBSP 的分支。如果 BSP 被添加到 Yocto 项目中，配置选项很可能最终会出现在该位置。</p>
<p>然而，一般来说，Yocto 项目的维护者负责将SRC_URI 指定的配置选项移动到内核的meta分支。不仅 BSP 开发人员不必将这些配置放在分支中更容易，而且让维护人员这样做允许他们应用关于树中多个 BSP 通常使用的常见配置选项种类的“全局”知识。这允许将通用配置提升为通用特征。</p>
<p>2.3.2应用补丁
如果您想要将单个补丁或一小部分补丁应用于 Linux 内核源代码，则可以像使用任何其他秘诀一样执行此操作。您首先将补丁复制到添加到 文件中FILESEXTRAPATHS的路径.bbappend中，如上一节所述，然后在SRC_URI 语句中引用它们。</p>
<p>例如，您可以通过将以下行添加到层中的 linux-yocto.bbappend文件来应用三补丁系列：</p>
<p>SRC_URI += “<a class="reference external" href="file://0001-first-change.patch">file://0001-first-change.patch</a>”
SRC_URI += “<a class="reference external" href="file://0002-second-change.patch">file://0002-second-change.patch</a>”
SRC_URI += “<a class="reference external" href="file://0003-third-change.patch">file://0003-third-change.patch</a>”
下次您运行 BitBake 构建 Linux 内核时，BitBake 会检测配方中的更改并在构建内核之前获取并应用补丁。</p>
<p>有关如何使用 修补内核的详细示例 devtool，请参阅“使用 devtool 修补内核”和“使用传统内核开发来修补内核”部分。</p>
<p>2.3.3更改配置
您可以通过包含一个文件并在 SRC_URI中指定要应用于该文件的配置片段来.config 对用于最终 Linux 内核配置的最终文件进行 大规模或增量更改。defconfig</p>
<p>如果你有一个完整的、工作的 Linux 内核.config文件你想用于配置，像以前一样，将该文件复制到${PN}层目录中的适当目录recipes-kernel/linux ，并将复制的文件重命名为“defconfig”。然后，将以下行添加到层中的 linux-yocto.bbappend文件中：</p>
<p>FILESEXTRAPATHS:prepend := “${THISDIR}/${PN}:”
SRC_URI += “file://defconfig”
SRC_URI告诉构建系统如何搜索文件，而 FILESEXTRAPATHS 扩展FILESPATH 变量（搜索目录）以包含您为保存配置更改而创建的目录。${PN}</p>
<p>您还可以使用由do_savedefconfigdefconfig任务生成的常规文件， 而不是完整的文件。这仅指定非默认配置值。您需要 在层 的 linux-yocto文件中另外设置KCONFIG_MODE ：.config.bbappend</p>
<p>KCONFIG_MODE = “alldefconfig”
笔记</p>
<p>构建系统defconfig 在应用任何后续配置片段之前应用文件中的配置。最终的内核配置是defconfig文件中的配置和您提供的任何配置片段的组合。您需要意识到，如果您有任何配置片段，构建系统会在应用现有defconfig文件配置的顶部和之后应用这些片段。</p>
<p>一般来说，首选方法是确定您想要进行的增量更改并将其添加为配置片段。例如，如果要添加对基本串行控制台的支持，请8250.cfg在${PN}目录中创建一个名为的文件，其内容如下（不带缩进）：</p>
<p>CONFIG_SERIAL_8250=y
CONFIG_SERIAL_8250_CONSOLE=y
CONFIG_SERIAL_8250_PCI=y
CONFIG_SERIAL_8250_NR_UARTS=4
CONFIG_SERIAL_8250_RUNTIME_UARTS=4
CONFIG_SERIAL_CORE=y
CONFIG_SERIAL_CORE_CONSOLE=y
接下来，包含此配置片段并在文件中扩展FILESPATH变量 .bbappend：</p>
<p>FILESEXTRAPATHS:prepend := “${THISDIR}/${PN}:”
SRC_URI += “file://8250.cfg”
下次您运行 BitBake 构建 Linux 内核时，BitBake 会检测配方中的更改，并在构建内核之前获取并应用新配置。</p>
<p>有关显示如何配置内核的详细示例，请参阅“配置内核”部分。</p>
<p>2.3.4使用“树内”  defconfig文件
可能需要通过defconfig从配置机器的内核源代码树中提取的文件来支持内核配置片段。默认情况下，OpenEmbedded 构建系统defconfig在用于元数据的层（即“树外”）中查找文件，然后使用以下内容对其进行配置：</p>
<p>SRC_URI += “<a class="reference external" href="file://defconfig">file://defconfig</a>”
如果您不想 defconfig在您的层中维护文件的副本，而是希望允许用户使用内核树中的默认配置，并且仍然能够 通过例如附加文件将配置片段添加到SRC_URI ，您可以将OpenEmbedded 构建系统使用 defconfig“in-tree”文件。</p>
<p>要指定“in-tree”defconfig文件，请使用以下语句形式：</p>
<p>KBUILD_DEFCONFIG_KMACHINE ?= “defconfig_file”
这是一个示例，它基于“ raspberrypi2”分配KBUILD_DEFCONFIGdefconfig变量，并提供“in-tree”文件的路径以用于基于 Broadcom 2708/2709 芯片组的 Raspberry Pi 2：</p>
<p>KBUILD_DEFCONFIG:raspberrypi2 ?= “bcm2709_defconfig”
除了修改您的内核配方和提供您自己的 defconfig文件之外，您需要确保没有文件或语句将 SRC_URI设置为使用defconfig您的“in-tree”文件（例如内核的linux-机器.inc文件）之外的其他文件。换句话说，如果构建系统检测到标识“树外” defconfig文件的语句，该语句将覆盖您的 KBUILD_DEFCONFIG变量。</p>
<p>有关详细信息，请参阅 KBUILD_DEFCONFIG 变量描述。</p>
<p>2.4用于内核devtool补丁
此过程中的步骤向您展示如何使用可扩展 SDK 和devtool.</p>
<p>笔记</p>
<p>在尝试此过程之前，请确保您已按照“准备使用 devtool 进行开发”部分中所述的步骤为更新内核做好准备。</p>
<p>修补内核涉及更改或添加现有内核的配置，更改或添加支持特定硬件功能所需的内核配方，甚至更改源代码本身。</p>
<p>此示例通过在内核源代码文件printk中的语句在 引导时添加一些 QEMU 仿真器控制台输出来创建一个简单的补丁。calibrate.c应用补丁并启动修改后的映像会导致添加的消息出现在模拟器的控制台上。该示例是“准备使用 devtool 进行开发”部分中的设置过程的延续。</p>
<p>Check Out the Kernel Source Files：首先你必须devtool 在它的工作空间中检查内核源代码。确保您在终端设置中使用可扩展 SDK。</p>
<p>笔记</p>
<p>有关详细信息，请参阅“准备使用 devtool 进行开发”部分中的此步骤。</p>
<p>使用以下devtool命令检查代码：</p>
<p>$ devtool modify linux-yocto
笔记</p>
<p>在结帐操作过程中，存在一个可能导致以下错误的错误：</p>
<dl class="simple">
<dt>ERROR: Taskhash mismatch 2c793438c2d9f8c3681fd5f7bc819efa versus</dt><dd><p>be3a89ce7c47178880ba7bf6293d7404 for
/path/to/esdk/layers/poky/meta/recipes-kernel/linux/linux-yocto_4.10.bb.do_unpack</p>
</dd>
</dl>
<p>您可以放心地忽略这些消息。源代码已正确签出。</p>
<p>编辑源文件按照以下步骤对源文件进行一些简单的更改：</p>
<p>更改工作目录：在上一步中，输出说明了您可以找到源文件的位置（例如 poky_sdk/workspace/sources/linux-yocto）。在对文件进行编辑之前更改内核源代码的位置 calibrate.c：</p>
<p>$ cd poky_sdk/workspace/sources/linux-yocto
编辑源文件：编辑init/calibrate.c文件以进行以下更改：</p>
<p>void calibrate_delay(void)
{</p>
<blockquote>
<div><p>unsigned long lpj;
static bool printed;
int this_cpu = smp_processor_id();</p>
<p>printk(“<strong>*********************************</strong>n”);
printk(“*                                   <em>n”);
printk(“</em>        HELLO YOCTO KERNEL         <em>n”);
printk(“</em>                                   <em>n”);
printk(“************************************</em>n”);</p>
<dl class="simple">
<dt>if (per_cpu(cpu_loops_per_jiffy, this_cpu)) {</dt><dd><p>.</p>
</dd>
</dl>
</div></blockquote>
<p>构建更新的内核源代码：要构建更新的内核源代码，请使用devtool：</p>
<p>$ devtool build linux-yocto
使用新内核创建映像：使用该 命令创建具有新内核的新映像。devtool build-image</p>
<p>笔记</p>
<p>如果您最初创建的映像生成了 Wic 文件，则可以使用替代方法创建具有更新内核的新映像。有关示例，请参阅 TipsAndTricks/KernelDevelopmentWithEsdk Wiki 页面中的步骤。</p>
<p>$ cd ~
$ devtool build-image core-image-minimal
测试新镜像：对于这个例子，您可以使用 QEMU 运行新镜像来验证您的更改：</p>
<p>启动镜像：使用以下命令在 QEMU 模拟器中启动修改后的镜像：</p>
<p>$ runqemu qemux86
验证更改：使用无密码登录机器root，然后使用以下 shell 命令滚动控制台的引导输出。</p>
<p># dmesg | less
printk当您向下滚动控制台窗口时，您应该会看到语句的结果作为输出的一部分。</p>
<p>暂存并提交您的更改：在您的 eSDK 终端中，将您的工作目录更改为您修改calibrate.c文件的位置，然后使用这些 Git 命令暂存并提交您的更改：</p>
<p>$ cd poky_sdk/workspace/sources/linux-yocto
$ git status
$ git add init/calibrate.c
$ git commit -m “calibrate: Add printk example”
导出补丁并创建附加文件：要将提交作为补丁导出并创建.bbappend文件，请在用于使用可扩展 SDK 的终端中使用以下命令。此示例使用之前建立的名为 的层meta-mylayer。</p>
<p>$ devtool finish linux-yocto ~/meta-mylayer
笔记</p>
<p>有关设置此层的信息，请参阅“准备使用 devtool 进行开发”部分的第 3 步。</p>
<p>命令完成后，补丁和.bbappend文件将位于 ~/meta-mylayer/recipes-kernel/linux目录中。</p>
<p>使用修改后的内核构建映像：您现在可以构建包含内核补丁的映像。从终端设置中的构建目录执行以下命令 以运行 BitBake：</p>
<p>$ cd poky/build
$ bitbake core-image-minimal
2.5使用传统内核开发打内核
此过程中的步骤向您展示了如何使用传统的内核开发来修补内核（即不使用“使用 devtool 修补内核devtool”部分中描述的可扩展 SDK ）。</p>
<p>笔记</p>
<p>在尝试此过程之前，请确保您已按照“为传统内核开发做准备”部分中所述的步骤为更新内核做好准备。</p>
<p>修补内核涉及更改或添加现有内核的配置，更改或添加支持特定硬件功能所需的内核配方，甚至更改源代码本身。</p>
<p>本节中的示例通过在启动时通过内核源代码文件printk中的语句添加一些 QEMU 仿真器控制台输出来创建一个简单的补丁。calibrate.c应用补丁并启动修改后的映像会导致添加的消息出现在模拟器的控制台上。该示例是“为传统内核开发做准备”部分中的设置过程的延续。</p>
<p>编辑源文件在此步骤之前，您应该使用 Git 为您的内核创建存储库的本地副本。假设您按照“为传统内核开发做准备”部分中的指示创建了存储库，请使用以下命令来编辑calibrate.c文件：</p>
<p>更改工作目录：您需要在内核 Git 存储库的本地副本中找到源文件。在对文件进行编辑之前更改内核源代码的位置 calibrate.c：</p>
<p>$ cd ~/linux-yocto-4.12/init
编辑源文件：编辑calibrate.c文件以进行以下更改：</p>
<p>void calibrate_delay(void)
{</p>
<blockquote>
<div><p>unsigned long lpj;
static bool printed;
int this_cpu = smp_processor_id();</p>
<p>printk(“<strong>*********************************</strong>n”);
printk(“*                                   <em>n”);
printk(“</em>        HELLO YOCTO KERNEL         <em>n”);
printk(“</em>                                   <em>n”);
printk(“************************************</em>n”);</p>
<dl class="simple">
<dt>if (per_cpu(cpu_loops_per_jiffy, this_cpu)) {</dt><dd><p>.</p>
</dd>
</dl>
</div></blockquote>
<p>暂存并提交您的更改：使用标准 Git 命令暂存并提交您刚刚所做的更改：</p>
<p>$ git add calibrate.c
$ git commit -m “calibrate.c - Added some printk statements”
如果您不暂存并提交您的更改，OpenEmbedded 构建系统将不会接收这些更改。</p>
<p>更新 local.conf 文件以指向源文件：除了local.conf指定使用“kernel-modules”和“qemux86”机器的文件外，它还必须指向更新的内核源文件。将类似于以下内容的SRC_URI和 SRCREV语句添加 到您的local.conf:</p>
<p>$ cd poky/build/conf
将以下内容添加到local.conf：</p>
<dl class="simple">
<dt>SRC_URI:pn-linux-yocto = “git:///path-to/linux-yocto-4.12;protocol=file;name=machine;branch=standard/base; </dt><dd><p>git:///path-to/yocto-kernel-cache;protocol=file;type=kmeta;name=meta;branch=yocto-4.12;destsuffix=${KMETA}”</p>
</dd>
</dl>
<p>SRCREV_meta:qemux86 = “${AUTOREV}”
SRCREV_machine:qemux86 = “${AUTOREV}”
笔记</p>
<p>请务必将path-to替换 为本地 Git 存储库的路径名。此外，您必须确保指定正确的分支和机器类型。对于这个例子，分支是standard/base，机器是qemux86。</p>
<p>构建映像：修改源代码、暂存并提交更改以及local.conf指向内核文件的文件后，您现在可以使用 BitBake 构建映像：</p>
<p>$ cd poky/build
$ bitbake core-image-minimal
启动映像：使用此命令在 QEMU 模拟器中启动修改后的映像。当提示登录 QEMU 控制台时，请使用“root”而不使用密码：</p>
<p>$ cd poky/build
$ runqemu qemux86
寻找你的改变：当 QEMU 启动时，你可能已经看到你的改变快速滚动。如果没有，请使用以下命令查看您的更改：</p>
<p># dmesg | less
printk当您向下滚动控制台窗口时，您应该会看到语句的结果 作为输出的一部分。</p>
<p>生成补丁文件：一旦你确定你的补丁工作正常，你可以*.patch在内核源代码库中生成一个文件：</p>
<p>$ cd ~/linux-yocto-4.12/init
$ git format-patch -1
0001-calibrate.c-Added-some-printk-statements.patch
将补丁文件移动到您的层：为了让后续构建获取补丁，您需要将您在上一步中创建的补丁文件移动到您的层meta-mylayer。对于此示例，之前创建的层位于您的主目录中，即 meta-mylayer. 使用 yocto-create脚本创建层时，没有创建额外的层次结构来支持补丁。在移动补丁文件之前，您需要使用以下命令向层添加额外的结构：</p>
<p>$ cd ~/meta-mylayer
$ mkdir recipes-kernel
$ mkdir recipes-kernel/linux
$ mkdir recipes-kernel/linux/linux-yocto
在层中创建此层次结构后，您可以使用以下命令移动补丁文件：</p>
<p>$ mv ~/linux-yocto-4.12/init/0001-calibrate.c-Added-some-printk-statements.patch ~/meta-mylayer/recipes-kernel/linux/linux-yocto
创建附加文件：最后，您需要创建 linux-yocto_4.12.bbappend文件并插入允许 OpenEmbedded 构建系统找到补丁的语句。附加文件需要在您的图层recipes-kernel/linux目录中，并且必须命名linux-yocto_4.12.bbappend并具有以下内容：</p>
<p>FILESEXTRAPATHS:prepend := “${THISDIR}/${PN}:”
SRC_URI:append = “file://0001-calibrate.c-Added-some-printk-statements.patch”
FILESEXTRAPATHS和SRC_URI语句使 OpenEmbedded 构建系统能够找到补丁文件。</p>
<p>有关附加文件和补丁的更多信息，请参阅“创建附加文件”和“应用补丁”部分。您还可以查看Yocto 项目开发任务手册中的“使用您的图层附加其他图层元数据”部分。</p>
<p>笔记</p>
<p>要再次构建core-image-minimal并查看补丁的效果，您可以 poky/build/tmp/work/…通过输入以下命令序列从根本上消除保存在构建中的临时源文件和残余影响：</p>
<p>$ cd poky/build
$ bitbake -c cleanall yocto-linux
$ bitbake core-image-minimal -c cleanall
$ bitbake core-image-minimal
$ runqemu qemux86
2.6配置内核
配置 Yocto 项目内核包括确保 .config文件中包含您正在构建的映像的所有正确信息。您可以使用menuconfig工具和配置片段来确保您的.config文件正是您所需要的。您还可以将已知配置保存defconfig在构建系统可用于内核配置的文件中。</p>
<p>本节介绍如何使用menuconfig、创建和使用配置片段，以及如何以交互方式修改 .config文件以创建尽可能精简的内核配置文件。</p>
<p>有关内核配置的更多信息，请参阅“更改配置”部分。</p>
<p>2.6.1使用  menuconfig
定义内核配置的最简单方法是通过menuconfig工具进行设置。此工具提供了一种用于设置内核配置的交互式方法。有关 的一般信息 menuconfig，请参阅https://en.wikipedia.org/wiki/Menuconfig。</p>
<p>要menuconfig在 Yocto Project 开发环境中使用该工具，您必须执行以下操作：</p>
<p>因为您menuconfig使用 BitBake 启动，所以您必须确保通过运行 Build Directory中的oe-init-build-env脚本来设置您的环境。</p>
<p>您必须确定 Source Directory中构建配置的状态。</p>
<p>您的构建主机必须安装以下两个软件包：</p>
<p>libncurses5-dev
libtinfo-dev
以下命令初始化 BitBake 环境，运行 do_kernel_configme 任务，然后启动menuconfig. 这些命令假定源目录的顶级文件夹是poky：</p>
<p>$ cd poky
$ source oe-init-build-env
$ bitbake linux-yocto -c kernel_configme -f
$ bitbake linux-yocto -c menuconfig
一旦menuconfig出现，它的标准界面允许您以交互方式检查和配置所有内核配置参数。进行更改后，只需退出工具并保存更改即可创建 .config配置文件的更新版本。</p>
<p>笔记</p>
<p>您可以将整个.config文件用作defconfig文件。有关defconfig文件的信息，请参阅“更改配置”、“使用“树内”defconfig 文件”和“创建 defconfig 文件”部分。</p>
<p>考虑一个为 linux-yocto-4.12内核配置“CONFIG_SMP”设置的示例。</p>
<p>笔记</p>
<p>OpenEmbedded 构建系统linux-yocto 通过元数据（例如PREFERRED_VERSION）识别此内核。_linux-yocto ?= “12.4%”</p>
<p>menuconfig启动后，使用界面浏览选项以找到您感兴趣的配置设置。对于此示例，您通过清除“Symmetric Multi-Processing Support”选项取消选择“CONFIG_SMP”。使用该界面，您可以在“处理器类型和功能”下找到选项。要取消选择“CONFIG_SMP”，请使用箭头键突出显示“Symmetric Multi-Processing Support”并输入“N”以清除星号。完成后，退出并保存更改。</p>
<p>保存选择会更新.config配置文件。这是 OpenEmbedded 构建系统在构建期间用于配置内核的文件。您可以在tmp/work/. 实际.config位于构建特定内核的区域。例如，如果您正在构建基于内核的 Linux Yocto 内核，linux-yocto-4.12并且您正在构建针对x86体系结构的 QEMU 映像，则该.config文件将是：</p>
<p>poky/build/tmp/work/qemux86-poky-linux/linux-yocto/4.12.12+gitAUTOINC+eda4d18…
…967-r0/linux-qemux86-standard-build/.config
笔记</p>
<p>前面的示例目录是人为拆分的，并且省略了实际文件名中的许多字符，以使其更具可读性。此外，根据您使用的内核，确切的路径名可能会有所不同。</p>
<p>在该.config文件中，您可以看到内核设置。例如，以下条目显示未设置对称多处理器支持：</p>
<p># CONFIG_SMP is not set
隔离更改配置的一个好方法是结合使用该menuconfig工具和简单的 shell 命令。在使用 更改配置之前menuconfig，复制现有的.config并将其重命名为其他内容，使用menuconfig进行任意数量的更改并保存它们，然后将重命名的配置文件与新创建的文件进行比较。您可以使用产生的差异作为基础来创建配置片段以永久保存在内核层中。</p>
<p>笔记</p>
<p>一定要复制.config文件，不要只是重命名它。构建系统需要一个现有的.config文件才能工作。</p>
<p>2.6.2创建  defconfig文件
defconfigYocto 项目上下文中的文件通常 是.config从构建中复制或defconfig从内核树中获取并移动到配方空间的文件。您可以使用一个 defconfig文件来保留一组已知的内核配置，OpenEmbedded 构建系统可以从中提取以创建最终 .config文件。</p>
<p>笔记</p>
<p>开箱即用，Yocto 项目从不发布defconfigor.config 文件。OpenEmbedded 构建系统创建.config用于配置内核的最终文件。</p>
<p>要创建一个defconfig，从一个完整的、工作的 Linux 内核 .config文件开始。将该文件复制到图层目录中相应的 ${PN目录，并将复制的文件重命名为“defconfig”（例如 ）。然后，将以下行添加到层中的 linux-yocto文件中：}recipes-kernel/linux~/meta-mylayer/recipes-kernel/linux/linux-yocto/defconfig.bbappend</p>
<p>FILESEXTRAPATHS:prepend := “${THISDIR}/${PN}:”
SRC_URI += “file://defconfig”
SRC_URI告诉构建系统如何搜索文件，而 FILESEXTRAPATHS扩展FILESPATH 变量（搜索目录）以包含您为保存配置更改而创建的目录。${PN}</p>
<p>笔记</p>
<p>构建系统defconfig 在应用任何后续配置片段之前应用文件中的配置。最终的内核配置是defconfig文件中的配置和您提供的任何配置片段的组合。您需要意识到，如果您有任何配置片段，构建系统会在应用现有defconfig文件配置的顶部和之后应用这些片段。</p>
<p>有关配置内核的更多信息，请参阅“更改配置”部分。</p>
<p>2.6.3创建配置片段
配置片段只是出现在文件中的内核选项，OpenEmbedded 构建系统可以在其中找到并应用它们。构建系统在应用文件中的配置后应用配置片段defconfig。因此，最终的内核配置是 defconfig文件中配置的组合，然后是您提供的任何配置片段。构建系统在应用现有的 defconfig 文件配置之上和之后应用片段。</p>
<p>从语法上讲，配置语句与文件中出现的相同，该.config文件位于Build Directory中。</p>
<p>笔记</p>
<p>有关.config文件所在位置的更多信息，请参阅“使用 menuconfig ”部分中的示例。</p>
<p>创建配置片段很简单。一种方法是使用 shell 命令。例如，从 shell 发出以下命令会创建一个名为的配置片段文件，该文件my_smp.cfg在内核中启用多处理器支持：</p>
<p>$ echo “CONFIG_SMP=y” &gt;&gt; my_smp.cfg
笔记</p>
<p>所有配置片段文件都必须使用.cfg扩展名，以便 OpenEmbedded 构建系统将它们识别为配置片段。</p>
<p>另一种方法是使用两个配置文件之间的差异创建配置片段：一个是以前创建并保存的，一个是使用该menuconfig工具新创建的。</p>
<p>要使用此方法创建配置片段，请执行以下步骤：</p>
<p>通过内核配置完成构建：至少通过内核配置任务完成构建，如下所示：</p>
<p>$ bitbake linux-yocto -c kernel_configme -f
此步骤可确保您 .config从已知状态创建文件。因为在某些情况下您的构建状态可能会变得未知，所以最好在开始之前运行此任务menuconfig。</p>
<p>启动 menuconfig：运行menuconfig命令：</p>
<p>$ bitbake linux-yocto -c menuconfig
创建配置片段：运行diffconfig命令准备一个配置片段。生成的文件 fragment.cfg放置在 ${WORKDIR} 目录中：</p>
<p>$ bitbake linux-yocto -c diffconfig
该diffconfig命令创建一个文件，该文件是 Linux 内核 CONFIG_分配的列表。有关如何将输出用作配置片段的更多信息，请参阅“更改配置”部分。</p>
<p>笔记</p>
<p>您还可以使用此方法为 BSP 创建配置片段。有关详细信息，请参阅“ BSP 说明”部分。</p>
<p>您将配置片段文件放在哪里？您可以按照文件的指示将这些文件放置在 SRC_URI指向 的区域中bblayers.conf，该文件位于您的层中。OpenEmbedded 构建系统获取配置并将其添加到内核的配置中。例如，假设您在一个名为myconfig.cfg. 如果您将该文件放在一个名为的目录linux-yocto中，该目录与您的层中的内核附加文件位于同一目录中，然后将以下语句添加到内核的附加文件中，则这些配置选项将在内核构建时被拾取并应用：</p>
<p>FILESEXTRAPATHS:prepend := “${THISDIR}/${PN}:”
SRC_URI += “file://myconfig.cfg”
如前所述，您可以将相关配置分组到多个文件中，并在SRC_URI语句中将它们全部命名。例如，您可以将专门针对以太网和图形的单独配置分组到它们自己的文件中，并通过在附加文件中使用 如下SRC_URI语句添加这些配置：</p>
<dl class="simple">
<dt>SRC_URI += “<a class="reference external" href="file://myconfig.cfg">file://myconfig.cfg</a> </dt><dd><p><a class="reference external" href="file://eth.cfg">file://eth.cfg</a> <a class="reference external" href="file://gfx.cfg">file://gfx.cfg</a>”</p>
</dd>
</dl>
<p>2.6.4验证配置
您可以使用 do_kernel_configcheck 任务来提供配置验证：</p>
<p>$ bitbake linux-yocto -c kernel_configcheck -f
当请求的配置未出现在最终.config文件中或您覆盖硬件配置片段中的策略配置时，运行此任务会产生警告。</p>
<p>要运行此任务，您必须有一个现有.config文件。有关如何创建配置文件的信息，请参阅“使用 menuconfig ”部分。</p>
<p>以下是do_kernel_configcheck任务的示例输出：</p>
<p>Loading cache: 100% <a href="#id149"><span class="problematic" id="id150">|########################################################|</span></a> Time: 0:00:00
Loaded 1275 entries from dependency cache.
NOTE: Resolving any missing task queue dependencies</p>
<dl class="simple">
<dt>Build Configuration:</dt><dd><p>.</p>
</dd>
</dl>
<p>NOTE: Executing SetScene Tasks
NOTE: Executing RunQueue Tasks
WARNING: linux-yocto-4.12.12+gitAUTOINC+eda4d18ce4_16de014967-r0 do_kernel_configcheck:</p>
<blockquote>
<div><p>[kernel config]: specified values did not make it into the kernel’s final configuration:</p>
</div></blockquote>
<p>———- CONFIG_X86_TSC —————–
Config: CONFIG_X86_TSC
From: /home/scottrif/poky/build/tmp/work-shared/qemux86/kernel-source/.kernel-meta/configs/standard/bsp/common-pc/common-pc-cpu.cfg
Requested value:  CONFIG_X86_TSC=y
Actual value:</p>
<p>———- CONFIG_X86_BIGSMP —————–
Config: CONFIG_X86_BIGSMP
From: /home/scottrif/poky/build/tmp/work-shared/qemux86/kernel-source/.kernel-meta/configs/standard/cfg/smp.cfg</p>
<blockquote>
<div><p>/home/scottrif/poky/build/tmp/work-shared/qemux86/kernel-source/.kernel-meta/configs/standard/defconfig</p>
</div></blockquote>
<p>Requested value:  # CONFIG_X86_BIGSMP is not set
Actual value:</p>
<p>———- CONFIG_NR_CPUS —————–
Config: CONFIG_NR_CPUS
From: /home/scottrif/poky/build/tmp/work-shared/qemux86/kernel-source/.kernel-meta/configs/standard/cfg/smp.cfg</p>
<blockquote>
<div><p>/home/scottrif/poky/build/tmp/work-shared/qemux86/kernel-source/.kernel-meta/configs/standard/bsp/common-pc/common-pc.cfg
/home/scottrif/poky/build/tmp/work-shared/qemux86/kernel-source/.kernel-meta/configs/standard/defconfig</p>
</div></blockquote>
<p>Requested value:  CONFIG_NR_CPUS=8
Actual value:     CONFIG_NR_CPUS=1</p>
<p>———- CONFIG_SCHED_SMT —————–
Config: CONFIG_SCHED_SMT
From: /home/scottrif/poky/build/tmp/work-shared/qemux86/kernel-source/.kernel-meta/configs/standard/cfg/smp.cfg</p>
<blockquote>
<div><p>/home/scottrif/poky/build/tmp/work-shared/qemux86/kernel-source/.kernel-meta/configs/standard/defconfig</p>
</div></blockquote>
<p>Requested value:  CONFIG_SCHED_SMT=y
Actual value:</p>
<p>NOTE: Tasks Summary: Attempted 288 tasks of which 285 didn’t need to be rerun and all succeeded.</p>
<p>Summary: There were 3 WARNING messages shown.
笔记</p>
<p>前面的输出示例具有人工换行符以使其更具可读性。</p>
<p>输出描述了您可能遇到的各种问题以及在哪里可以找到有问题的配置项。您可以使用日志中的信息来调整配置文件，然后重复 do_kernel_configme 和 do_kernel_configcheck 任务，直到它们不产生警告。</p>
<p>有关如何使用该menuconfig工具的更多信息，请参阅 使用 menuconfig部分。</p>
<p>2.6.5微调内核配置文件
您可以通过读取内核配置片段审计的输出、注意任何问题、进行更改以纠正问题然后重复来确保.config文件尽可能精简或高效。</p>
<p>作为内核构建过程的一部分，do_kernel_configcheck任务运行。.config此任务通过根据输入文件检查最终文件来验证内核配置 。在检查期间，任务会针对以下问题生成警告消息：</p>
<p>未生成最终.config文件的请求选项。</p>
<p>在同一个配置片段中出现两次的配置项。</p>
<p>被覆盖的标记为“必需”的配置项。</p>
<p>板覆盖非板特定选项。</p>
<p>列出的选项对正在处理的内核无效。换句话说，该选项不会出现在任何地方。</p>
<p>笔记</p>
<p>do_kernel_configcheck任务还可以选择性地报告处理过程中是否覆盖了选项。</p>
<p>对于每个输出警告，一条消息指向包含选项列表的文件和指向定义它们的配置片段的指针。总的来说，这些文件是简化配置的关键。</p>
<p>要简化配置，请执行以下操作：</p>
<p>使用有效配置：从您知道有效的完整配置开始。确保配置构建并成功启动。将此配置文件用作您的基准。</p>
<p>运行配置和检查任务：分别运行 do_kernel_configme和do_kernel_configcheck任务：</p>
<p>$ bitbake linux-yocto -c kernel_configme -f
$ bitbake linux-yocto -c kernel_configcheck -f
处理结果：从任务警告中获取文件的结果列表 do_kernel_configcheck并执行以下操作：</p>
<p>删除在片段中重新定义但不更改最终.config文件的值。</p>
<p>分析并可能从文件中删除.config覆盖所需配置的值。</p>
<p>分析并可能删除非董事会特定选项。</p>
<p>删除重复和无效的选项。</p>
<p>重新运行配置和检查任务：完成内核配置审计的输出后，您可以重新运行 do_kernel_configme和do_kernel_configcheck任务以查看更改的结果。如果您有更多问题，您可以按照上一步中的说明进行处理。</p>
<p>迭代地完成第二步到第四步最终会产生一个最小的、流线型的配置文件。一旦你拥有了最好的 .config，你就可以构建 Linux Yocto 内核。</p>
<p>2.7扩展变量
有时在构建过程中确定变量扩展为什么是有帮助的。您可以通过检查命令的输出来检查变量的值。输出很长，在文本文件中更容易管理，这样可以轻松搜索：bitbake -e</p>
<p>$ bitbake -e virtual/kernel &gt; some_text_file
在文本文件中，您可以准确地看到 OpenEmbedded 构建系统如何扩展和使用每个变量。</p>
<p>2.8使用“脏”的内核版本字符串
如果您构建内核映像并且版本字符串末尾有“+”或“-dirty”，则表示内核源目录中有未提交的修改。请按照以下步骤清理版本字符串：</p>
<p>发现未提交的更改：转到内核的本地克隆 Git 存储库（源目录）并使用以下 Git 命令列出已更改、添加或删除的文件：</p>
<p>$ git status
提交更改：无论您是否要保存、导出或使用更改，都应该将这些更改提交到内核源代码树：</p>
<p>$ git add
$ git commit -s -a -m “getting rid of -dirty”
重建内核映像：提交更改后，重建内核。</p>
<p>根据您的特定内核开发工作流程，您用于重建内核的命令可能会有所不同。有关使用时构建内核映像的信息devtool，请参阅“使用 devtool 修补内核”部分。有关使用 Bitbake 构建内核映像的信息，请参阅“使用传统内核开发修补内核”部分。</p>
<p>2.9使用自己的资源
如果您无法使用现有 linux-yocto 配方支持的 Linux 内核版本之一，您仍然可以通过使用自己的源代码来使用 Yocto Project Linux 内核工具。当您使用自己的源时，您将无法利用 linux-yocto 源的现有内核元数据和稳定工作。但是，您将能够以与 linux-yocto 源相同的格式管理自己的元数据。保持格式兼容性有助于在未来相互支持的内核版本上与 linux-yocto 融合。</p>
<p>为了帮助您使用自己的源，Yocto 项目提供了一个 linux-yocto 自定义配方，该配方使用kernel.org源和 Yocto 项目 Linux 内核工具来管理内核元数据。poky您可以在Git 存储库 中找到此配方： meta-skeleton/recipes-kernel/linux/linux-yocto-custom.bb。</p>
<p>以下是一些可用于处理自己的资源的基本步骤：</p>
<p>创建内核配方的副本：将 linux-yocto-custom.bb配方复制到您的层并给它一个有意义的名称。该名称应包括您正在使用的 Yocto Linux 内核的版本（例如linux-yocto-myproject_4.12.bb，其中“4.12”是您将使用的 Linux 内核的基本版本）。</p>
<p>为您的补丁创建一个目录：在您的层内的同一目录中，创建一个匹配的目录来存储您的补丁和配置文件（例如linux-yocto-myproject）。</p>
<p>确保您有配置：确保您的层中有 defconfig文件或配置片段文件。使用linux-yocto-custom.bb配方时，必须指定配置。如果您没有defconfig文件，则可以运行以下命令：</p>
<p>$ make defconfig
运行命令后，将生成的.config文件files作为“defconfig”复制到层中的目录，然后将其添加到配方中的 SRC_URI变量中。</p>
<p>运行该命令会生成内核定义的体系结构的默认配置。但是，不能保证此配置对您的用例有效，或者您的主板甚至会启动。对于非 x86 架构尤其如此。make defconfig</p>
<p>要使用非 x86defconfig文件，您需要更具体并找到与您的电路板匹配的文件（即对于 arm，您查看 arch/arm/configs并使用作为电路板最佳起点的文件）。</p>
<p>编辑配方：根据您的项目编辑配方中的以下变量：</p>
<p>SRC_URI： SRC_URI应该指定一个使用受支持的 Git 提取器协议之一的 Git 存储库（即file、git、http等）。SRC_URI变量还应该指定一个defconfig文件或一些配置片段文件。骨架配方提供了一个示例SRC_URI作为语法参考。</p>
<p>LINUX_VERSION：您正在使用的 Linux 内核版本（例如“4.12”）。</p>
<p>LINUX_VERSION_EXTENSION：命令CONFIG_LOCALVERSION可见uname</p>
<p>SRCREV：您要构建的提交 ID。</p>
<p>PR：像对待任何其他配方一样对待这个变量。增加变量以向 OpenEmbedded 构建系统指示配方已更改。</p>
<p>PV：默认的PV 分配通常就足够了。它将 LINUX_VERSION与源自SRCPV 变量的源代码控制管理器 (SCM) 修订版相结合。组合结果是一个具有以下形式的字符串：</p>
<p>3.19.11+git1+68a635bf8dfb64b02263c1ac80c948647cc76d5f_1+218bd8d2022b9852c60d32f0d770931e3cf343e2
虽然冗长，但PV中的额外冗长有助于确保您使用的是您打算构建的确切来源。</p>
<p>COMPATIBLE_MACHINE：新配方支持的机器列表。示例配方中的此变量默认设置为仅匹配空字符串“(^$)”的正则表达式。此默认设置会触发显式构建失败。您必须更改它以匹配您的新配方支持的机器列表。例如，要支持qemux86和qemux86-64机器，请使用以下形式：</p>
<p>COMPATIBLE_MACHINE = “qemux86|qemux86-64”
根据需要自定义您的配方：根据需要为您的配方提供进一步的自定义，就像您自定义现有的 linux-yocto 配方一样。有关信息，请参阅“修改现有配方”部分。</p>
<p>2.10使用树外模块
本节描述了在目标上构建树外模块的步骤，并描述了如何在构建中合并树外模块。</p>
<p>2.10.1在目标上构建树外模块
虽然传统的 Yocto 项目开发模型会将内核模块作为正常构建过程的一部分包含在内，但您可能会发现在目标上构建模块很有用。如果您的目标系统有足够的能力和强大的能力来处理必要的编译，则可能会出现这种情况。但是，在决定在您的目标上进行构建之前，您应该考虑从构建主机使用适当的交叉开发环境的好处。</p>
<p>如果您希望能够在目标上构建树外模块，则需要在运行 SDK 映像的目标上执行一些步骤。简而言之，该kernel-dev软件包默认安装在所有*.sdk图像上，并且该kernel-devsrc软件包安装在许多*.sdk图像上。但是，在尝试在运行该映像的目标上构建树外模块之前，您需要创建一些脚本。</p>
<p>在尝试构建树外模块之前，您需要以 root 身份在目标上，并且需要切换到/usr/src/kernel 目录。接下来，make脚本：</p>
<p># cd /usr/src/kernel
# make scripts
由于所有 SDK 映像配方都包含dev-pkgs，因此这些 kernel-dev包将作为 SDK 映像的一部分安装，并且这些kernel-devsrc包将作为适用的 SDK 映像的一部分安装。SDK 在构建树外模块时使用脚本。切换到该目录并创建脚本后，您应该能够在目标上构建树外模块。</p>
<p>2.10.2合并树外模块
虽然使用集成到 Linux 内核源代码中的源代码总是更可取，但如果您需要外部内核模块，该 hello-mod.bb配方可作为模板提供，您可以从中创建自己的树外 Linux 内核模块配方。</p>
<p>此模板配方位于pokyYocto 项目的 Git 存储库中： meta-skeleton/recipes-kernel/hello-mod/hello-mod_0.1.bb。</p>
<p>开始时，将这个配方复制到您的层并给它一个有意义的名称（例如mymodule_1.0.bb）。在同一目录中，创建一个名为的新目录files，您可以在其中存储任何源文件、补丁或其他构建模块所需的文件，这些文件不包含源代码。最后，根据模块的需要更新配方。通常，您需要设置以下变量：</p>
<p>描述</p>
<p>执照*</p>
<p>SRC_URI</p>
<p>光伏</p>
<p>根据模块源使用的构建系统，您可能需要进行一些调整。例如，一个典型的模块Makefile 看起来很像hello-mod模板提供的那个：</p>
<p>obj-m := hello.o</p>
<p>SRC := $(shell pwd)</p>
<dl class="simple">
<dt>all:</dt><dd><p>$(MAKE) -C $(KERNEL_SRC) M=$(SRC)</p>
</dd>
<dt>modules_install:</dt><dd><p>$(MAKE) -C $(KERNEL_SRC) M=$(SRC) modules_install</p>
</dd>
</dl>
<p>…
这里要注意的重点是KERNEL_SRC变量。模块类将此变量和 KERNEL_PATH变量设置为 具有必要的 ${STAGING_KERNEL_DIR}Linux 内核构建信息以构建模块。如果您的模块Makefile使用不同的变量，您可能希望覆盖 do_compile步骤，或创建一个补丁以Makefile使用更典型的 KERNEL_SRC或KERNEL_PATH变量。</p>
<p>准备好食谱后，您可能希望在图像中包含该模块。为此，请参阅 Yocto 项目参考手册中有关以下变量的文档，并为您的机器配置文件适当地设置其中一个：</p>
<p>MACHINE_ESSENTIAL_EXTRA_RDEPENDS</p>
<p>MACHINE_ESSENTIAL_EXTRA_RR推荐</p>
<p>MACHINE_EXTRA_RDEPENDS</p>
<p>MACHINE_EXTRA_RR推荐</p>
<p>引导通常不需要模块，并且可以从某些构建配置中排除。以下允许最大的灵活性：</p>
<p>MACHINE_EXTRA_RRECOMMENDS += “kernel-module-mymodule”
该值是通过将不带.ko扩展名的模块文件名附加到字符串“kernel-module-”而得出的。</p>
<p>因为该变量是 RRECOMMENDS而不是 RDEPENDS变量，所以如果此模块不可包含在映像中，则构建不会失败。</p>
<p>2.11检查变更和提交
使用内核时的一个常见问题是：“对这棵树应用了哪些更改？” 您可以使用 Git 检查或搜索内核树，而不是跨目录使用“grep”来查看发生了什么变化。使用 Git 是查看树中发生了什么变化的有效方法。</p>
<p>2.11.1内核发生了什么变化？
以下是一些示例，展示了如何使用 Git 命令来检查更改。这些示例绝不是查看变化的唯一方法。</p>
<p>笔记</p>
<p>在以下示例中，除非您提供提交范围，否则kernel.org 历史将与 Yocto Project 内核更改混合。您可以使用来自内核树的分支名称作为 Git 命令的上下提交标记来形成范围。您可以通过 Web 界面查看位于https://git.yoctoproject.org/cgit/cgit.cgi/的 Yocto 项目源存储库的分支名称。</p>
<p>要查看完整范围的更改，请使用该命令并指定分支的提交范围 ( commit commit )。git whatchanged..</p>
<p>这是一个查看内核emenlow 分支中发生了什么变化的示例。linux-yocto-3.19下限提交范围是与standard/base分支关联的提交，而上限提交范围是与standard/emenlow 分支关联的提交。</p>
<p>$ git whatchanged origin/standard/base..origin/standard/emenlow
简而言之，一行更改摘要使用以下命令：git log</p>
<p>$ git log –oneline origin/standard/base..origin/standard/emenlow
使用此命令查看更改的代码差异：</p>
<p>$ git diff origin/standard/base..origin/standard/emenlow
使用此命令查看提交日志消息和文本差异：</p>
<p>$ git show origin/standard/base..origin/standard/emenlow
使用此命令为每个更改创建单独的补丁。这是一个为每个提交创建补丁文件并将它们放置在您的Documents目录中的示例：</p>
<p>$ git format-patch -o $HOME/Documents origin/standard/base..origin/standard/emenlow
2.11.2显示特定特征或分支变化
Yocto 项目内核树中的标签将更改划分为重要功能或分支。 tag 命令显示基于标记的更改。这是一个显示更改的示例：git showsystemtap</p>
<p>$ git show systemtap
您可以使用 tag 命令来显示包含特定功能的分支。此命令显示包含该功能的分支：git branch –containssystemtap</p>
<p>$ git branch –contains systemtap
2.12添加配方空间内核特性
您可以通过使用KERNEL_FEATURES 变量并在SRC_URI语句中指定功能的文件路径 来在配方空间中添加内核功能 。当您使用此方法添加功能时，OpenEmbedded 构建系统会检查以确保这些功能存在。如果这些功能不存在，则构建停止。内核功能是为配置和修补内核而处理的最后一个元素。因此，以这种方式添加特性是一种强制存在和启用特定特性的方法，而无需对任何其他层添加到 SRC_URI语句的内容进行全面审核。.scc</p>
<p>您可以通过将特性作为 KERNEL_FEATURES变量的一部分提供该特性并提供特性 .scc文件的路径来添加内核特性，该路径相对于内核元数据的根目录。OpenEmbedded 构建系统在SRC_URI语句上搜索所有形式的内核元数据， 无论元数据是在“内核缓存”、系统内核元数据还是配方空间元数据（即内核配方的一部分）中。有关其他信息，请参阅“内核元数据位置”部分。</p>
<p>当您在SRC_URI.scc语句中指定功能文件时 ，OpenEmbedded 构建系统将该 文件的目录及其所有子目录添加到内核功能搜索路径。由于搜索子目录，您可以在SRC_URI语句中引用单个文件来引用多个内核功能。.scc.scc</p>
<p>考虑以下将“test.scc”功能添加到构建的示例。</p>
<p>创建功能文件：创建一个.scc文件并找到它，就像您在SRC_URI语句.cfg中指定的任何其他补丁文件、文件或提取器项目一样。</p>
<p>笔记</p>
<p>您必须.scc以与添加文件相同的方式将文件的目录添加到 fetcher 的搜索路径中 .patch。</p>
<p>.scc您可以在包含您要添加的文件的目录下创建其他文件。在构建过程中搜索所有子目录作为潜在的功能目录。</p>
<p>继续该示例，假设您要添加的“test.scc”功能test.scc在以下目录中有一个文件：</p>
<p>my_recipe
|
+-linux-yocto</p>
<blockquote>
<div><div class="line-block">
<div class="line"><br /></div>
</div>
<p>+-test.cfg
+-test.scc</p>
</div></blockquote>
<p>在此示例中，该 linux-yocto目录同时具有功能test.scc文件和类似名称的配置片段文件test.cfg。</p>
<p>将功能文件添加到 SRC_URI：将.scc文件添加到配方的SRC_URI语句：</p>
<p>SRC_URI:append = ” <a class="reference external" href="file://test.scc">file://test.scc</a>”
路径前的前导空格很重要，因为路径附加到现有路径。</p>
<p>将功能指定为内核功能：使用 KERNEL_FEATURES语句将功能指定为内核功能：</p>
<p>KERNEL_FEATURES:append = ” test.scc”
OpenEmbedded 构建系统在构建内核时处理内核特性。</p>
<p>笔记</p>
<p>如果“test.scc”下包含其他功能，则它们的目录相对于包含该test.scc 文件的目录。</p>
<p>3使用高级元数据 ( yocto-kernel-cache)
3.1概述
除了支持配置片段和补丁之外，Yocto Project 内核工具还支持丰富的 元数据，您可以使用这些元数据来定义复杂的策略和板级支持包 (BSP) 支持。元数据和管理它的工具的目的是帮助您管理用于支持多种 BSP 和 Linux 内核类型的配置和源的复杂性。</p>
<p>内核元数据存在于许多地方。Yocto 项目源存储库中的一个区域 是yocto-kernel-cacheGit 存储库。您可以在Yocto Project Source Repositories的“Yocto Linux Kernel”标题下找到该存储 库。</p>
<p>内核开发工具（“kern-tools”）也可在 yocto-kernel-toolsGit 存储库中“Yocto Linux 内核”标题下的 Yocto 项目源存储库中获得。构建这些工具的配方meta/recipes-kernel/kern-tools/kern-tools-native_git.bb位于源目录（例如 poky）中。</p>
<p>3.2在配方中使用内核元数据
正如介绍中提到的，Yocto 项目包含内核元数据，它位于yocto-kernel-cacheGit 存储库中。此元数据定义了与相应 BSP 的 linux-yocto 配方中的定义相对应的板级支持包 (BSP)。BSP 由内核策略和启用的特定于硬件的功能的聚合组成。BSP 可能会受到 linux-yocto 配方的影响。</p>
<p>笔记</p>
<p>包含内核元数据（例如从linux-yocto.inc文件继承）的 Linux 内核配方被称为“linux-yocto 风格”配方。</p>
<p>每个 linux-yocto 风格的配方都必须定义 KMACHINE变量。该变量通常设置为与BitBake使用的MACHINE变量相同的值。但是，在某些情况下，变量可能会引用MACHINE的底层平台。</p>
<p>如果使用相同的 BSP 描述构建多个 BSP，则它们可以重用相同的KMACHINE名称。多个基于 Corei7 的 BSP 可以为 KMACHINE 共享相同的“intel-corei7-64”值。重要的是要认识到KMACHINE仅用于内核映射，而MACHINE 是 BSP 层中的机器类型。然而，即使有这种区别，这两个变量也可以保持相同的值。有关详细信息，请参阅“ BSP 说明”部分。</p>
<p>每个 linux-yocto 风格的配方还必须指明用于构建 Linux 内核的 Linux 内核源代码库分支。必须设置KBRANCH变量 以指示分支。</p>
<p>笔记</p>
<p>您可以使用KBRANCH值来定义替代分支，通常使用机器覆盖，如下meta-yocto-bsp层所示：</p>
<p>KBRANCH:edgerouter = “standard/edgerouter”
linux-yocto 风格的配方可以选择定义以下变量：</p>
<p>KERNEL_FEATURES</p>
<p>LINUX_KERNEL_TYPE</p>
<p>LINUX_KERNEL_TYPE 定义了用于组装配置的内核类型。如果您未指定LINUX_KERNEL_TYPE，则默认为“标准”。与KMACHINE一起， LINUX_KERNEL_TYPE定义了内核工具使用的搜索参数，以在内核元数据中查找适当的描述，以构建源和配置。linux-yocto 配方定义了“standard”、“tiny”和“preempt-rt”内核类型。有关内核类型的更多信息，请参阅“内核类型”部分。</p>
<p>在构建期间，kern-tools 搜索与从配方传入的KMACHINE和LINUX_KERNEL_TYPE 变量最匹配的 BSP 描述文件。这些工具使用他们找到的与这两个变量匹配的第一个 BSP 描述。如果工具找不到匹配项，则会发出警告。</p>
<p>这些工具首先搜索KMACHINE，然后 搜索LINUX_KERNEL_TYPE。如果工具找不到部分匹配，它们将使用 KBRANCH 中的源和SRC_URI中指定的任何配置。</p>
<p>您可以使用 KERNEL_FEATURES变量来包含KMACHINE和 LINUX_KERNEL_TYPE变量组合 尚未包含的功能（配置片段、补丁或两者） 。例如，要包含指定为“features/netfilter/netfilter.scc”的功能，请指定：</p>
<p>KERNEL_FEATURES += “features/netfilter/netfilter.scc”
要为机器包含一个名为“cfg/sound.scc”的功能qemux86，请指定：</p>
<p>KERNEL_FEATURES:append:qemux86 = ” cfg/sound.scc”
KERNEL_FEATURES中条目的值取决于它们在内核元数据本身中的位置。此处的示例取自 yocto-kernel-cache存储库。此存储库的每个分支都包含顶层的“features”和“cfg”子目录。有关详细信息，请参阅“内核元数据语法”部分。</p>
<p>3.3内核元数据语法
内核元数据由三种主要类型的文件组成：scc 1描述文件、配置片段和补丁。这些 scc文件定义变量并包括或以其他方式引用三种文件类型中的任何一种。描述文件用于将所有类型的内核元数据聚合成最终描述为特定机器量身定制的 Linux 内核所需的源和配置。</p>
<p>描述scc文件用于定义两种基本类型的内核元数据：</p>
<p>特征</p>
<p>板级支持包 (BSP)</p>
<p>功能以补丁和配置片段的形式将源聚合到一个模块化的可重用单元中。您可以使用特性来实现概念上独立的内核元数据描述，例如纯配置片段、简单补丁、复杂特性和内核类型。内核类型定义要在 BSP 中重用的一般内核特性和策略。</p>
<p>BSP 定义特定于硬件的特性，并将它们与内核类型聚合，以形成对将要组装和构建的内容的最终描述。</p>
<p>虽然内核元数据语法不强制对配置片段、补丁、功能或内核类型进行任何逻辑分离，但最佳实践要求对这些元数据类型进行逻辑分离。建议使用以下元数据文件层次结构：</p>
<dl class="simple">
<dt>base/</dt><dd><p>bsp/
cfg/
features/
ktypes/
patches/</p>
</dd>
</dl>
<p>该bsp目录包含BSP 描述。其余目录都包含“功能”。bsp与结构的其余部分分开有助于概念化预期用途。</p>
<p>使用这些指南来帮助将您的scc描述文件放置在结构中：</p>
<p>如果您的文件仅包含配置片段，请将文件放在cfg目录中。</p>
<p>如果您的文件仅包含源代码修复，请将文件放在 patches目录中。</p>
<p>如果您的文件封装了主要功能，通常结合源和配置，请将文件放在features目录中。</p>
<p>如果您的文件聚合了非硬件配置和补丁以定义要跨多个 BSP 重用的基本内核策略或主要内核类型，请将文件放在ktypes目录中。</p>
<p>这些区别很容易变得模糊——尤其是当树外特征随着时间的推移慢慢向上游合并时。另外，请记住，描述文件的放置方式是纯粹的逻辑组织，对内核元数据的功能没有影响。没有影响，因为就内核工具而言，所有cfg, features,patches和, 都包含“功能”。ktypes</p>
<p>内核元数据文件中使用的路径是相对于基础的， 如果您在 recipe-space中创建元数据，则为FILESEXTRAPATHS ；如果您在 Recipe-Space 之外 创建 元数据，则为 yocto-kernel-cache的顶层 。</p>
<p>1
scc代表系列配置控制，但在工具的当前实施中，命名的重要性不如过去。将scc文件视为描述文件。</p>
<p>3.3.1配置
内核元数据的最简单单元是仅配置功能。.cfg此功能由配置片段文件 ( )中的一个或多个 Linux 内核配置参数和.scc 描述该片段的文件组成。</p>
<p>例如，考虑与内核一起使用的对称多处理 (SMP) 片段，该片段linux-yocto-4.12在配方空间（即yocto-kernel-cache）之外定义。此元数据包含两个文件：smp.scc和smp.cfg. 您可以在Git 存储库的分支 cfg目录中找到这些文件 ：yocto-4.12yocto-kernel-cache</p>
<dl>
<dt>cfg/smp.scc:</dt><dd><p>define KFEATURE_DESCRIPTION “Enable SMP for 32 bit builds”
define KFEATURE_COMPATIBILITY all</p>
<p>kconf hardware smp.cfg</p>
</dd>
<dt>cfg/smp.cfg:</dt><dd><p>CONFIG_SMP=y
CONFIG_SCHED_SMT=y
# Increase default NR_CPUS from 8 to 64 so that platform with
# more than 8 processors can be all activated at boot time
CONFIG_NR_CPUS=64
# The following is needed when setting NR_CPUS to something
# greater than 8 on x86 architectures, it should be automatically
# disregarded by Kconfig when using a different arch
CONFIG_X86_BIGSMP=y</p>
</dd>
</dl>
<p>您可以在“创建配置片段”部分找到有关配置片段文件的一般信息。</p>
<p>在smp.scc文件中， KFEATURE_DESCRIPTION 语句提供了片段的简短描述。更高级别的内核工具使用此描述。</p>
<p>同样在smp.scc文件中，该kconf命令包括文件中的实际配置片段.scc，并且“硬件”关键字将片段标识为硬件启用，而不是使用“非硬件”关键字的一般策略。区分是为了配置验证工具的好处，如果硬件片段覆盖了非硬件片段设置的策略，则会向您发出警告。</p>
<p>笔记</p>
<p>描述文件可以包含多个kconf语句，每个片段一个。</p>
<p>如“验证配置”部分所述，您可以使用以下 BitBake 命令来审核您的配置：</p>
<p>$ bitbake linux-yocto -c kernel_configcheck -f
3.3.2补丁
补丁描述与配置片段描述非常相似，在上一节中进行了描述。但是，这些描述不是.cfg文件，而是与源补丁（即.patch文件）一起使用。</p>
<p>一个典型的补丁包括一个描述文件和补丁本身。例如，考虑在配方空间（即）linux-yocto-4.12 之外定义的与内核 一起使用的构建补丁。yocto-kernel-cache此元数据由几个文件组成： build.scc和一组*.patch文件。您可以在Git 存储库的分支 patches/build目录中找到这些文件。yocto-4.12yocto-kernel-cache</p>
<p>以下清单显示了build.scc文件和文件的一部分 modpost-mask-trivial-warnings.patch：</p>
<dl>
<dt>patches/build/build.scc:</dt><dd><p>patch arm-serialize-build-targets.patch
patch powerpc-serialize-image-targets.patch
patch kbuild-exclude-meta-directory-from-distclean-processi.patch</p>
<p># applied by kgit
# patch kbuild-add-meta-files-to-the-ignore-li.patch</p>
<p>patch modpost-mask-trivial-warnings.patch
patch menuconfig-check-lxdiaglog.sh-Allow-specification-of.patch</p>
</dd>
<dt>patches/build/modpost-mask-trivial-warnings.patch:</dt><dd><p>From bd48931bc142bdd104668f3a062a1f22600aae61 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker &lt;<a class="reference external" href="mailto:paul&#46;gortmaker&#37;&#52;&#48;windriver&#46;com">paul<span>&#46;</span>gortmaker<span>&#64;</span>windriver<span>&#46;</span>com</a>&gt;
Date: Sun, 25 Jan 2009 17:58:09 -0500
Subject: [PATCH] modpost: mask trivial warnings</p>
<dl>
<dt>Newer HOSTCC will complain about various stdio fcns because</dt><dd><blockquote>
<div><p>.</p>
</div></blockquote>
<p>char <a href="#id83"><span class="problematic" id="id84">*</span></a>dump_write = NULL, <a href="#id85"><span class="problematic" id="id86">*</span></a>files_source = NULL;
int opt;</p>
</dd>
</dl>
<p>–
2.10.1</p>
<p>generated by cgit v0.10.2 at 2017-09-28 15:23:23 (GMT)</p>
</dd>
</dl>
<p>描述文件可以包含多个补丁语句，其中每个语句处理一个补丁。在示例build.scc文件中，目录中的五个补丁有五个补丁语句。</p>
<p>您可以使用或 命令创建典型.patch文件。有关如何创建补丁的信息，请参阅“使用 devtool 修补内核”和“使用传统内核开发来修补内核”部分。diff -Nurpgit format-patch</p>
<p>3.3.3特点
功能是复杂的内核元数据类型，由配置片段、补丁和可能的其他功能描述文件组成。例如，考虑以下通用列表：</p>
<dl>
<dt>features/myfeature.scc</dt><dd><p>define KFEATURE_DESCRIPTION “Enable myfeature”</p>
<p>patch 0001-myfeature-core.patch
patch 0002-myfeature-interface.patch</p>
<p>include cfg/myfeature_dependency.scc
kconf non-hardware myfeature.cfg</p>
</dd>
</dl>
<p>此示例显示如何使用patch和kconf命令以及如何在命令中包含附加功能描述文件 include。</p>
<p>通常，特性没有配置片段那么精细，并且比配置片段和补丁更有可能成为您想要在Linux 内核配方的KERNEL_FEATURES变量中指定的事物类型。请参阅手册前面的“在配方中使用内核元数据”部分。</p>
<p>3.3.4内核类型
内核类型通过将非硬件配置片段与您在构建特定类型的 Linux 内核（例如实时内核）时要使用的补丁程序聚合来定义高级内核策略。从语法上讲，内核类型与“特性”部分中描述的特性没有什么不同。内核配方中的 LINUX_KERNEL_TYPE 变量选择内核类型。例如，在 中linux-yocto_4.12.bb找到的内核配方中 poky/meta/recipes-kernel/linux，一个 require指令包含该poky/meta/recipes-kernel/linux/linux-yocto.inc文件，该文件具有以下定义默认内核类型的语句：</p>
<p>LINUX_KERNEL_TYPE ??= “standard”
另一个例子是实时内核（即 linux-yocto-rt_4.12.bb）。这个内核配方直接设置内核类型如下：</p>
<p>LINUX_KERNEL_TYPE = “preempt-rt”
笔记</p>
<p>您可以在Yocto 项目源代码库meta/recipes-kernel/linux的目录中找到内核配方 （例如）。有关详细信息，请参阅“在配方中使用内核元数据”部分。poky/meta/recipes-kernel/linux/linux-yocto_4.12.bb</p>
<p>Linux Yocto 内核支持三种内核类型（“standard”、“tiny”和“preempt-rt”）：</p>
<p>“标准”：包括 Yocto 项目 linux-yocto 内核配方的通用 Linux 内核策略。除其他外，此策略包括支持哪些文件系统、网络选项、核心内核功能以及调试和跟踪选项。</p>
<p>“preempt-rt”：应用PREEMPT_RT构建实时 Linux 内核所需的补丁和配置选项。这种内核类型继承自“标准”内核类型。</p>
<p>“tiny”：定义了一个最低限度的配置，旨在作为非常小的 Linux 内核的基础。“小”内核类型独立于“标准”配置。尽管“微型”内核类型目前不包括任何源代码更改，但它可能会在未来发生。</p>
<p>对于任何给定的内核类型，元数据由.scc（例如 standard.scc）定义。这是该standard.scc 文件的部分列表，可在Git 存储库的ktypes/standard目录中 找到：yocto-kernel-cache</p>
<p># Include this kernel type fragment to get the standard features and
# configuration values.</p>
<p># Note: if only the features are desired, but not the configuration
#       then this should be included as:
#             include ktypes/standard/standard.scc nocfg
#       if no chained configuration is desired, include it as:
#             include ktypes/standard/standard.scc nocfg inherit</p>
<p>include ktypes/base/base.scc
branch standard</p>
<p>kconf non-hardware standard.cfg</p>
<dl class="simple">
<dt>include features/kgdb/kgdb.scc</dt><dd><p>.</p>
</dd>
</dl>
<p>include cfg/net/ip6_nf.scc
include cfg/net/bridge.scc</p>
<p>include cfg/systemd.scc</p>
<p>include features/rfkill/rfkill.scc
与任何.scc文件一样，内核类型定义可以 使用命令聚合其他.scc文件。这些定义还可以分别使用 和命令include直接拉入配置片段和补丁。kconfpatch</p>
<p>笔记</p>
<p>.scc 创建内核类型文件不是绝对必要的。Board Support Package (BSP) 文件可以使用define KTYPE myktype行隐式定义内核类型。有关详细信息，请参阅“ BSP 说明”部分。</p>
<p>3.3.5 BSP 说明
BSP 描述（即*.scc文件）将内核类型与特定于硬件的特性结合起来。特定于硬件的元数据通常在 BSP 层中独立定义，然后与每种支持的内核类型聚合。</p>
<p>笔记</p>
<p>对于 Yocto 项目支持的 BSP，BSP 描述文件位于Yocto 项目源代码库 中“Yocto Linux Kernel”标题下组织 bsp的存储库目录中。yocto-kernel-cache</p>
<p>本节概述 BSP 描述结构、聚合概念，并提供使用 Yocto 项目（即 BeagleBone Board）支持的 BSP 的详细示例。有关 BSP 层文件层次结构的完整信息，请参阅Yocto Project Board Support Package Developer’s Guide。</p>
<p>3.3.5.1描述概述
为简单起见，请考虑 BeagleBone 板的以下根 BSP 层描述文件。这些文件采用结构和命名约定以保持一致性。该文件的命名约定如下：</p>
<p>bsp_root_name-kernel_type.scc
以下是 Yocto 项目支持的 BeagleBone Board BSP 的一些根层 BSP 文件名示例：</p>
<p>beaglebone-standard.scc
beaglebone-preempt-rt.scc
每个文件使用根名称（即“beaglebone”）BSP 名称后跟内核类型。</p>
<p>检查beaglebone-standard.scc文件：</p>
<p>define KMACHINE beaglebone
define KTYPE standard
define KARCH arm</p>
<p>include ktypes/standard/standard.scc
branch beaglebone</p>
<p>include beaglebone.scc</p>
<p># default policy for standard kernels
include features/latencytop/latencytop.scc
include features/profiling/profiling.scc
每个顶级 BSP 描述文件都应该定义KMACHINE、 KTYPE和 KARCH变量。这些变量允许 OpenEmbedded 构建系统将描述识别为满足正在构建的配方设置的标准。这个例子支持“标准”内核和“arm”架构的“beaglebone”机器。</p>
<p>请注意， KTYPE变量和内核类型描述文件之间没有硬链接。因此，如果您的内核元数据中没有定义内核类型，那么您只需确保 内核配方中的LINUX_KERNEL_TYPE变量和 BSP 描述文件中的 KTYPE 变量匹配。</p>
<p>要将内核策略与硬件配置分开，您需要包含内核类型 ( ktype)，例如“标准”。在前面的示例中，这是通过以下方式完成的：</p>
<p>include ktypes/standard/standard.scc
该文件汇总了构成标准内核策略的所有配置片段、补丁和功能。有关详细信息，请参阅“内核类型”部分。</p>
<p>要为mybsp聚合特定于内核的常见配置和功能，请使用以下命令：</p>
<p>include mybsp.scc
您可以在 BeagleBone 示例中看到以下内容：</p>
<p>include beaglebone.scc
有关如何将完整.config文件分解为各种配置片段的信息，请参阅“创建配置片段”部分。</p>
<p>最后，如果您有任何特定于硬件但不在*.scc文件中的配置，您可以将它们包括在内，如下所示：</p>
<p>kconf hardware mybsp-extra.cfg
BeagleBone 示例不包括这些类型的配置。但是，马耳他 32 位主板可以（“mti-malta32”）。这是mti-malta32-le-standard.scc文件：</p>
<p>define KMACHINE mti-malta32-le
define KMACHINE qemumipsel
define KTYPE standard
define KARCH mips</p>
<p>include ktypes/standard/standard.scc
branch mti-malta32</p>
<p>include mti-malta32.scc
kconf hardware mti-malta32-le.cfg
3.3.5.2示例
许多现实世界的例子更复杂。与任何其他.scc文件一样，BSP 描述可以聚合特征。考虑给定(ie ) 的linux-yocto-4.4分支 的 Minnow BSP 定义：yocto-kernel-cacheyocto-kernel-cache/bsp/minnow/minnow.scc</p>
<p>笔记</p>
<p>虽然 Minnow Board BSP 未使用，但元数据仍然存在，此处仅作为示例使用。</p>
<p>include cfg/x86.scc
include features/eg20t/eg20t.scc
include cfg/dmaengine.scc
include features/power/intel.scc
include cfg/efi.scc
include features/usb/ehci-hcd.scc
include features/usb/ohci-hcd.scc
include features/usb/usb-gadgets.scc
include features/usb/touchscreen-composite.scc
include cfg/timer/hpet.scc
include features/leds/leds.scc
include features/spi/spidev.scc
include features/i2c/i2cdev.scc
include features/mei/mei-txe.scc</p>
<p># Earlyprintk and port debug requires 8250
kconf hardware cfg/8250.cfg</p>
<p>kconf hardware minnow.cfg
kconf hardware minnow-dev.cfg
描述文件包括一个特定于 Minnow BSP的minnow.scc硬件配置片段 ( minnow.cfg) 以及几个更通用的配置片段和启用机器上硬件的功能。然后，该minnow.scc描述文件被包含在三个“minnow”描述文件中的每一个中，用于支持的内核类型（即“standard”、“preempt-rt”和“tiny”）。考虑“标准”内核类型（即 minnow-standard.scc）的“minnow”描述：</p>
<p>define KMACHINE minnow
define KTYPE standard
define KARCH i386</p>
<p>include ktypes/standard</p>
<p>include minnow.scc</p>
<p># Extra minnow configs above the minimal defined in minnow.scc
include cfg/efi-ext.scc
include features/media/media-all.scc
include features/sound/snd_hda_intel.scc</p>
<p># The following should really be in standard.scc
# USB live-image support
include cfg/usb-mass-storage.scc
include cfg/boot-live.scc</p>
<p># Basic profiling
include features/latencytop/latencytop.scc
include features/profiling/profiling.scc</p>
<p># Requested drivers that don’t have an existing scc
kconf hardware minnow-drivers-extra.cfg
include文件中间的命令包括minnow.scc定义所有内核类型通用的 BSP 的所有启用硬件的描述。使用此命令可显着减少重复。</p>
<p>现在考虑“tiny”内核类型（即 minnow-tiny.scc）的“minnow”描述：</p>
<p>define KMACHINE minnow
define KTYPE tiny
define KARCH i386</p>
<p>include ktypes/tiny</p>
<p>include minnow.scc
如您所料，“微小”描述包含的内容要少得多。事实上，它只包括由“tiny”内核类型定义的最小策略和引导机器所需的硬件特定配置，以及基本“minnow”描述文件中定义的系统最基本功能。</p>
<p>再次注意三个关键变量： KMACHINE、 KTYPE和 KARCH。在这些变量中，只有 KTYPE已更改为指定“微小”内核类型。</p>
<p>3.4内核元数据位置
内核元数据总是存在于内核树之外，要么在内核配方（配方空间）中定义，要么在配方之外。您选择在哪里定义元数据取决于您想要做什么以及您打算如何工作。无论您在何处定义内核元数据，所使用的语法都同样适用。</p>
<p>如果您不熟悉 Linux 内核并且只希望应用其他人提供的配置和可能的几个补丁，则建议使用配方空间方法。如果您正在使用不受控制的 Linux 内核源代码，或者您只是不想自己维护 Linux 内核 Git 存储库，则此方法也是一种好方法。有关如何在配方空间中定义内核元数据的部分信息，请参阅“修改现有配方”部分。</p>
<p>相反，如果您正在积极开发内核并且已经在维护自己的 Linux 内核 Git 存储库，您可能会发现使用保存在配方空间之外的内核元数据更方便。在这方面使用元数据可以使 Linux 内核的迭代开发在 BitBake 环境之外更加高效。</p>
<p>3.4.1配方空间元数据
当存储在配方空间中时，内核元数据文件驻留在FILESEXTRAPATHS下的目录层次结构中。对于 linux-yocto 配方或通过将 meta-skeleton/recipes-kernel/linux/linux-yocto-custom.bb 复制 到您的层并对其进行修改而派生的 Linux 内核配方，FILESEXTRAPATHS通常设置为 ${THISDIR }/${PN}。有关详细信息，请参阅“修改现有配方”部分。</p>
<p>这是一个示例，它显示了存储在 BSP 层内的配方空间中的内核元数据的普通树：</p>
<p>meta-my_bsp_layer/
<a href="#id87"><span class="problematic" id="id88">`</span></a>– recipes-kernel</p>
<blockquote>
<div><dl class="simple">
<dt><a href="#id89"><span class="problematic" id="id90">`</span></a>– linux</dt><dd><dl class="simple">
<dt><a href="#id91"><span class="problematic" id="id92">`</span></a>– linux-yocto</dt><dd><p><a href="#id93"><span class="problematic" id="id94">|</span></a>– bsp-standard.scc
<a href="#id95"><span class="problematic" id="id96">|</span></a>– bsp.cfg
<a href="#id97"><span class="problematic" id="id98">`</span></a>– standard.cfg</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>当元数据存储在配方空间中时，您必须采取措施确保 BitBake 拥有必要的信息来决定要获取哪些文件以及何时需要再次获取这些文件。只需指定SRC_URI.scc上的文件 。BitBake 解析它们并获取文件中由 、或命令引用的任何文件。因此，当更改SRC_URI 中未明确列出的文件的内容时 ，有必要增加配方PR值。.sccincludepatchkconf</p>
<p>如果 BSP 描述在配方空间中，则不能简单地 <a href="#id99"><span class="problematic" id="id100">*</span></a>.scc在SRC_URI语句中列出。您需要使用内核附加文件中的以下形式：</p>
<dl class="simple">
<dt>SRC_URI:append:myplatform = ” </dt><dd><p><a class="reference external" href="file://myplatform;type=kmeta;destsuffix=myplatform">file://myplatform;type=kmeta;destsuffix=myplatform</a> “</p>
</dd>
</dl>
<p>3.4.2配方空间外的元数据
当存储在配方空间之外时，内核元数据文件驻留在单独的存储库中。OpenEmbedded 构建系统通过SRC_URI变量将元数据作为“type=kmeta”存储库添加到构建中 。例如，考虑内核配方中的以下SRC_URI语句 ：linux-yocto_4.12.bb</p>
<dl class="simple">
<dt>SRC_URI = “git://git.yoctoproject.org/linux-yocto-4.12.git;name=machine;branch=${KBRANCH}; </dt><dd><p>git://git.yoctoproject.org/yocto-kernel-cache;type=kmeta;name=meta;branch=yocto-4.12;destsuffix=${KMETA}”</p>
</dd>
</dl>
<p>${KMETA}，在这种情况下，仅用于命名 Git 提取器放置元数据的目录。这种行为与配方中使用的任何多存储库SRC_URI语句没有什么不同（例如，参见上一节）。</p>
<p>您可以将内核元数据保存在“内核缓存”中，这是一个包含配置片段的目录。与保存在配方空间之外的任何元数据一样，您只需使用带有“type=kmeta”属性的SRC_URI语句。这样做会使内核元数据在配置阶段可用。</p>
<p>如果您修改元数据，您一定不要忘记更新内核配方中的SRCREV 语句。特别是，您需要更新 SRCREV_meta变量以匹配KMETA您希望使用的分支中的提交。更改这些分支中的数据而不更新 SRCREV语句以匹配将导致构建获取较旧的提交。</p>
<p>3.5组织你的资源
许多基于配方的linux-yocto-custom.bb配方使用只有一个分支的 Linux 内核源代码。这种类型的存储库结构非常适合支持单台机器和架构的线性开发。但是，如果您使用多个板和架构，则具有多个分支的内核源存储库更有效。例如，假设您需要一系列补丁才能启动一块板。有时，这些补丁正在进行中或根本上是错误的，但它们对于特定的板仍然是必需的。在这些情况下，您很可能不希望在您构建的每个内核中都包含这些补丁（即，将补丁作为默认分支的一部分）。正是这样的情况导致在 Linux 内核源 Git 存储库中使用多个分支。</p>
<p>以下是存储库组织策略，可最大限度地重用源代码、消除冗余以及对更改进行逻辑排序。本节介绍以下情况的策略：</p>
<p>将补丁封装在特性描述中，仅包含适用板的BSP描述中的补丁。</p>
<p>在您的内核源存储库中创建一个机器分支并仅在该分支上应用补丁。</p>
<p>在您的内核源代码库中创建一个功能分支，并在需要时将该分支合并到您的 BSP 中。</p>
<p>您采用的方法完全取决于您，并且取决于最适合您的开发模型的方法。</p>
<p>3.5.1封装补丁
如果您正在重用来自外部树的补丁并且没有在补丁上工作，您可能会发现封装的功能是合适的。在这种情况下，您不需要在源存储库中创建任何分支。相反，您只需获取所需的静态补丁并将它们封装在功能描述中。一旦您有了功能描述，您只需将其包含在“ BSP 描述”部分中描述的 BSP 描述中。</p>
<p>您可以在“补丁”和“ BSP 描述”部分找到有关如何创建补丁和 BSP 描述的信息。</p>
<p>3.5.2机器分支
当您要支持多台机器和架构时，或者您正在积极地进行板载支持时，基于单个机器在存储库中创建分支会更有效。拥有机器分支允许公共源代码保留在开发分支中，而特定于机器的任何功能都存储在适当的机器分支中。这种组织方法使您无需不断地将补丁重新集成到功能中。</p>
<p>一旦你有了一个新的分支，你可以设置你的内核元数据以几种不同的方式使用这个分支。在配方中，您可以将新分支指定为用于板的KBRANCH ，如下所示：</p>
<p>KBRANCH = “mynewbranch”
另一种方法是使用branchBSP 描述中的命令：</p>
<dl>
<dt>mybsp.scc:</dt><dd><p>define KMACHINE mybsp
define KTYPE standard
define KARCH i386
include standard.scc</p>
<p>branch mynewbranch</p>
<p>include mybsp-hw.scc</p>
</dd>
</dl>
<p>如果您发现自己有许多分支，您可能会考虑使用类似于 Yocto Linux Kernel Git 存储库使用的分层分支系统：</p>
<p>common/kernel_type/machine
如果您有两种内核类型，例如“标准”和“小型”，三台机器和通用 as mydir，您的 Git 存储库中的分支可能如下所示：</p>
<p>mydir/base
mydir/standard/base
mydir/standard/machine_a
mydir/standard/machine_b
mydir/standard/machine_c
mydir/small/base
mydir/small/machine_a
这个组织可以帮助澄清分支机构的关系。在这种情况下，mydir/standard/machine_a包括mydir/base 和中的所有内容mydir/standard/base。“标准”和“小”分支添加特定于那些出于某种原因不适用于其他分支的内核类型的源代码。</p>
<p>笔记</p>
<p>“基本”分支是 Git 在文件系统内部管理其数据的方式的产物：Git 不允许您使用 mydir/standard，mydir/standard/machine_a因为它必须创建一个名为“标准”的文件和目录。</p>
<p>3.5.3特征分支
当您积极开发新功能时，将该功能作为一个分支而不是作为一组必须定期更新的补丁来工作会更有效率。Yocto Project Linux 内核工具通过命令提供了此功能。git merge</p>
<p>要将功能分支合并到 BSP 中，请在任何命令之后插入命令：git mergebranch</p>
<dl>
<dt>mybsp.scc:</dt><dd><p>define KMACHINE mybsp
define KTYPE standard
define KARCH i386
include standard.scc</p>
<p>branch mynewbranch
git merge myfeature</p>
<p>include mybsp-hw.scc</p>
</dd>
</dl>
<p>3.6 SCC 描述文件参考
本节简要介绍可在 SCC 描述文件 ( .scc) 中使用的命令：</p>
<p>branch [ref]${KTYPE}：使用当前签出的分支创建相对于当前分支的新分支（通常为），如果指定，则为“ref”。</p>
<p>define：定义变量，例如 KMACHINE、 KTYPE、 KARCH和 KFEATURE_DESCRIPTION。</p>
<p>include SCC_FILE：在当前文件中包含一个 SCC 文件。该文件被解析，就好像您已内联插入它一样。</p>
<p>kconf [hardware|non-hardware] CFG_FILE：将配置片段排队以合并到最终的 Linux.config文件中。</p>
<p>git merge GIT_BRANCH：将特征分支合并到当前分支。</p>
<p>patch PATCH_FILE：将补丁应用到当前 Git 分支。</p>
<p>4高级内核概念
4.1 Yocto 项目内核开发与维护
与其他内核一样，可通过 Yocto 项目（Yocto Linux 内核）获得的内核基于来自 <a class="reference external" href="https://www.kernel">https://www.kernel</a>.org的 Linux 内核版本。kernel.org在主要的 Linux 内核开发周期开始时，Yocto 项目团队会根据发布时间、最终上游版本的预期发布时间和 Yocto 项目功能要求等因素来选择 Linux 内核。通常，选择的 Linux 内核处于 Linux 社区开发的最后阶段。换句话说，Linux 内核处于候选版本或“rc”阶段，尚未达到最终版本。但是，由于处于外部开发的最后阶段，团队知道kernel.org最终版本显然会在 Yocto 项目开发窗口的早期阶段。</p>
<p>这种平衡允许 Yocto 项目团队尽可能提供最新的 Yocto Linux 内核，同时仍然确保团队有一个稳定的官方 Linux 内核版本基准版本。</p>
<p>如前所述，Yocto Linux 内核的最终来源是从kernel.org. 除了来自 的基础内核之外kernel.org，可用的 Yocto Linux 内核还包含重要的新主线开发、非主线开发（当没有替代方案时）、板级支持包 (BSP) 开发和自定义功能。这些新增功能产生了一个商业发布的 Yocto Project Linux 内核，可满足特定嵌入式设计人员对目标硬件的需求。</p>
<p>您可以在https://git.yoctoproject.org/cgit/cgit.cgi/的Yocto 项目源代码库中找到 Yocto Linux 内核的 Web 界面 。如果您查看界面，您将在左侧看到一组名为“Yocto Linux Kernel”的 Git 存储库。在该组中，您会发现一些开发并包含在 Yocto 项目版本中的 Linux Yocto 内核：</p>
<p>linux-yocto-4.1：与 Yocto Project Release 2.0 一起使用的稳定 Yocto Project 内核。该内核基于 Linux 4.1 发布的内核。</p>
<p>linux-yocto-4.4：与 Yocto Project Release 2.1 一起使用的稳定 Yocto Project 内核。该内核基于 Linux 4.4 发布的内核。</p>
<p>linux-yocto-4.6：与任何 Yocto 项目版本无关的临时内核。</p>
<p>linux-yocto-4.8：与 Yocto Project Release 2.2 一起使用的稳定 yocto Project 内核。</p>
<p>linux-yocto-4.9：与 Yocto Project Release 2.3 一起使用的稳定 Yocto Project 内核。该内核基于 Linux 4.9 发布的内核。</p>
<p>linux-yocto-4.10：与 Yocto Project Release 2.3 一起使用的默认稳定 Yocto Project 内核。该内核基于 Linux 4.10 发布的内核。</p>
<p>linux-yocto-4.12：与 Yocto Project Release 2.4 一起使用的默认稳定 Yocto Project 内核。该内核基于 Linux 4.12 发布的内核。</p>
<p>yocto-kernel-cache：包含 linux-yocto 内核树的linux-yocto-cache补丁和配置。在使用 linux-yocto 内核时，此存储库很有用。有关此“高级内核元数据”的更多信息，请参阅“使用高级元数据 (yocto-kernel-cache) ”一章。</p>
<p>linux-yocto-dev：基于可用的最新上游候选版本的开发内核。</p>
<p>笔记</p>
<p>Yocto Linux 内核的长期支持计划 (LTSI) 如下：</p>
<p>对于 Yocto Project 版本 1.7、1.8 和 2.0，LTSI 内核是 linux-yocto-3.14.</p>
<p>对于 Yocto Project 版本 2.1、2.2 和 2.3，LTSI 内核是 linux-yocto-4.1.</p>
<p>对于 Yocto Project 2.4 版，LTSI 内核是 linux-yocto-4.9</p>
<p>linux-yocto-4.4是一个 LTS 内核。</p>
<p>一旦 Yocto Linux 内核正式发布，Yocto 项目团队就会进入他们的下一个开发周期，或向上修订 (uprev) 周期，同时仍继续对已发布的内核进行维护。重要的是要注意，将功能开发包含在上游的最可持续和最稳定的方式是通过内核升级过程。从各种内核版本向后移植数百个单独的修复和次要功能是不可持续的，并且很容易影响质量。</p>
<p>在升级周期中，Yocto 项目团队使用对 Linux 内核开发、BSP 支持和发布时间的持续分析来选择可能的最佳kernel.orgLinux 内核版本，作为后续 Yocto Linux 内核开发的基础。该团队持续监控 Linux 社区内核开发，以寻找感兴趣的重要功能。如果大型功能具有显着优势，该团队确实会考虑向后移植大型功能。用户或社区需求还可以在升级周期期间触发 Yocto 项目基线内核中的向后移植或新功能的创建。</p>
<p>一般来说，每一个新的 Linux 内核都会增加功能并引入新的错误。这些后果是上游 Linux 内核开发的基本属性，由 Yocto 项目团队的 Yocto Linux 内核开发策略管理。Yocto 项目团队的政策是不将次要功能向后移植到已发布的 Yocto Linux 内核。他们只考虑向后移植重大的技术跳跃——而且，这是在完整的差距分析之后完成的。采用此策略的原因是，从不断发展的 Linux 内核向后移植任何中小型更改很容易造成不匹配、不兼容和非常细微的错误。</p>
<p>本节中描述的策略产生了一个稳定和尖端的 Yocto Linux 内核，它混合了现有 Linux 内核特性的前向端口和重要且关键的新功能。通过 Yocto 项目将 Linux 内核功能向前移植到 Yocto Linux 内核中可以被认为是“微升级”。许多“微升级”产生了一个 Yocto Linux 内核版本，其中混合了重要的新主线、非主线、BSP 开发和功能集成。这个 Yocto Linux 内核提供了对新功能的洞察，并允许在内核上进行集中测试，从而防止在选择下一个主要升级版本时出现意外。这些尖端 Yocto Linux 内核的质量正在不断发展，这些内核用于前沿特性和 BSP 开发。</p>
<p>4.2 Yocto Linux 内核架构和分支策略
如前所述，Yocto 项目的一个关键目标是为开发人员提供一个内核，该内核具有对用户可见的清晰且连续的历史。所使用的架构和机制，尤其是分支策略，以类似于kernel.org.</p>
<p>您可以将 Yocto Linux 内核视为由基线 Linux 内核组成，该内核具有在基线之上逻辑结构的附加功能。这些功能通过 Yocto 项目团队使用源代码管理器 (SCM) Git 实施的分支策略进行标记和组织。</p>
<p>笔记</p>
<p>Git 显然是满足本节所述的 Yocto Linux 内核组织和结构目标的 SCM。Git 不仅是用于 Linux 内核开发的 SCM，kernel.org 而且 Git 继续流行并支持许多不同的工作流程、前端和管理技术。</p>
<p>您可以在https://git-scm.com/doc找到有关 Git 的文档。您还可以在 Yocto 项目概述和概念手册的“ Git ”部分中了解 Git，因为它适用于 Yocto 项目。后一个参考提供了 Git 的概述，并提供了一组最小的 Git 命令，允许您使用 Git 正常工作。您可以尽可能多地或尽可能少地使用 Git 提供的功能来完成您的项目所需。您不必成为“Git 专家”就可以将它与 Yocto 项目一起使用。</p>
<p>使用 Git 的标记和分支功能，Yocto 项目团队在不再共享功能并因此需要隔离的点创建内核分支。例如，特定于板的不兼容性将需要不同的功能，并且需要一个分支来分离这些功能。同样，对于特定的内核功能，使用相同的分支策略。</p>
<p>这种“树状”体系结构产生的结构具有针对特定功能、单个内核类型或内核类型子集组织的特性。因此，用户能够查看添加的功能以及构成这些功能的提交。除了能够查看添加的功能外，用户还可以查看构成基准 Linux 内核的历史。</p>
<p>这种策略的另一个结果是不必在树内部两次存储相同的特征。相反，内核团队存储了将特性应用到相关内核类型所需的独特差异。</p>
<p>笔记</p>
<p>Yocto 项目团队努力将特性放在树中，以便所有板和内核类型尽可能共享特性。但是，在开发周期或合并大型功能时，团队不能始终遵循这种做法。在这些情况下，团队使用孤立的分支来合并功能。</p>
<p>BSP 特定代码添加的处理方式与内核特定添加类似。某些 BSP 仅在给定某些内核类型时才有意义。因此，对于这些类型，团队会在该内核类型的末尾为该内核类型支持的所有 BSP 创建分支。从创建 BSP 分支的工具的角度来看，BSP 确实与功能没有什么不同。因此，相同的分支策略适用于 BSP，就像它适用于内核功能一样。同样，团队不会两次存储 BSP，而是只存储 BSP 跨受支持的多个内核的唯一差异。</p>
<p>虽然这种策略可能会导致树具有大量分支，但重要的是要认识到，从开发人员的角度来看，有一条线性路径从基线 kernel.org穿过一组选定的特征并以它们的 BSP 结束- 特定的提交。换句话说，内核的划分是透明的，与开发人员日常无关。从开发者的角度来看，这条路径就是开发分支。开发人员根本不需要知道任何其他分支的存在。当然，如果一个人决定探索它们，那么在树上放置这些分支是有意义的。例如，两个 BSP 在提交级别或逐行代码diff级别之间的比较现在是一个微不足道的操作。</p>
<p>下图显示了概念性 Yocto Linux 内核。</p>
<p>kernel-architecture-overview.png</p>
<p>在插图中，“Kernel.org 分支点”标记了创建 Yocto Linux 内核的特定位置（或 Linux 内核版本）。从树中的这一点开始，特征和差异被组织和标记。</p>
<p>“Yocto Project Baseline Kernel”包含每个内核类型和 BSP 通用的功能，这些功能在树中进一步组织。以这种方式将这些共同特征放置在树中意味着不必沿着树结构的各个分支复制特征。</p>
<p>在“Yocto Project Baseline Kernel”中，分支点代表各个板级支持包 (BSP) 以及实时内核的特定功能。该图通过三个特定于 BSP 的分支和一个实时内核分支来表示这一点。每个分支都代表 BSP 或实时 Yocto Linux 内核的一些独特功能。</p>
<p>在这个示例结构中，“Real-time (rt) Kernel”分支具有所有实时 Yocto Linux 内核的通用特性，并包含更多用于各个 BSP 特定实时内核的分支。该图以三个分支为例。当它们应用于给定的 BSP 时，每个分支都指向相应实时内核的特定、独特功能。</p>
<p>生成的树结构为开发人员提供了一条清晰的标记（或分支）路径，从所有实际目的来看，它是任何给定需求集所需的 Yocto Linux 内核。</p>
<p>笔记</p>
<p>请记住，该图并未考虑所有受支持的 Yocto Linux 内核，而是仅出于概念目的显示了一个通用内核。另请记住，此结构表示 Yocto 项目源存储库 ，这些存储库要么在构建期间从其中提取，要么在构建之前通过克隆特定内核的 Git 存储库或通过下载和解压缩 tarball 建立在主机开发系统上。</p>
<p>将内核作为结构化树使用遵循公认的社区最佳实践。特别是，产品附带的内核应该被视为“上游源”，并被视为一系列历史和记录的修改（提交）。这些修改代表了 Yocto Project 内核开发团队所做的开发和稳定工作。</p>
<p>由于提交仅在产品生命周期中的重要发布点更改，因此开发人员可以处理从已发布的 Yocto Project Linux 内核中的最后一个相关提交创建的分支。如前所述，该结构对开发人员是透明的，因为在克隆和构建内核之后内核树仍处于此状态。</p>
<p>4.3内核构建文件层次结构
所有可用内核源代码的上游存储是一回事，而在主机开发系统上表示和使用代码是另一回事。从概念上讲，您可以将内核源存储库视为所有受支持的 Yocto Linux 内核所需的所有源文件。作为开发人员，您只对正在使用的内核的源文件感兴趣。此外，您需要它们在您的主机系统上可用。</p>
<p>内核源代码可通过多种不同方式在您的主机系统上获得：</p>
<p>使用 Yocto 项目提供的 devtool: devtool时访问的文件是修改内核的首选方法。请参阅“内核修改工作流程”部分。</p>
<p>克隆存储库：如果您一直在内核中工作，您可能希望建立自己的 Yocto Linux 内核树的本地 Git 存储库。有关如何克隆 Yocto Linux 内核 Git 存储库的信息，请参阅“准备构建主机以在内核上工作”部分。</p>
<p>来自构建的临时源文件：如果您只需要使用传统的 BitBake 工作流程（即不使用devtool.</p>
<p>使用 BitBake 构建的临时内核源文件具有特定的层次结构。当您在开发系统上构建内核时，构建所需的所有文件都取自 SRC_URI变量指向的源存储库，并收集在一个临时工作区，随后用于创建唯一内核。因此，从某种意义上说，该进程构建了一个特定于您的内核的本地源代码树，从中生成新的内核映像。</p>
<p>下图显示了使用 Bitbake 构建内核时在主机系统上创建的临时文件结构。此 构建目录包含构建期间使用的所有源文件。</p>
<p>kernel-overview-2-generic.png
同样，有关 Yocto 项目内核架构及其分支策略的更多信息，请参阅“ Yocto Linux 内核架构和分支策略”部分。您还可以参考“使用 devtool 修补内核”和“使用传统内核开发来修补内核”部分以获取修改内核的详细示例。</p>
<p>4.4确定内核配置审计阶段的硬件和非硬件特性
本节描述了大多数开发人员可以忽略的内核配置审计阶段的一部分。有关内核配置（包括menuconfig、defconfig文件和配置片段）的一般信息，请参阅“配置内核”部分。</p>
<p>在审计阶段的这一部分，将最终 .config文件的内容与系统指定的片段进行比较。这些片段可以是系统片段、发行版片段或用户指定的配置元素。无论其来源如何，如果最终内核配置中未包含特定选项，OpenEmbedded 构建系统都会警告用户。</p>
<p>默认情况下，为了不让用户收到配置警告，系统只报告缺少的“硬件”选项，因为它们可能导致启动失败或指示重要硬件不可用。</p>
<p>为了确定给定选项是“硬件”还是“非硬件”，内核元数据yocto-kernel-cache包含将单个或一组选项分类为硬件或非硬件的文件。为了更好地展示这一点，请考虑 yocto-kernel-cache包含以下文件的情况：</p>
<p>yocto-kernel-cache/features/drm-psb/hardware.cfg
yocto-kernel-cache/features/kgdb/hardware.cfg
yocto-kernel-cache/ktypes/base/hardware.cfg
yocto-kernel-cache/bsp/mti-malta32/hardware.cfg
yocto-kernel-cache/bsp/qemu-ppc32/hardware.cfg
yocto-kernel-cache/bsp/qemuarma9/hardware.cfg
yocto-kernel-cache/bsp/mti-malta64/hardware.cfg
yocto-kernel-cache/bsp/arm-versatile-926ejs/hardware.cfg
yocto-kernel-cache/bsp/common-pc/hardware.cfg
yocto-kernel-cache/bsp/common-pc-64/hardware.cfg
yocto-kernel-cache/features/rfkill/non-hardware.cfg
yocto-kernel-cache/ktypes/base/non-hardware.cfg
yocto-kernel-cache/features/aufs/non-hardware.kcf
yocto-kernel-cache/features/ocf/non-hardware.kcf
yocto-kernel-cache/ktypes/base/non-hardware.kcf
yocto-kernel-cache/ktypes/base/hardware.kcf
yocto-kernel-cache/bsp/qemu-ppc32/hardware.kcf
以下是各种文件的解释：</p>
<p>hardware.kcf：指定仅包含硬件选项的内核 Kconfig 文件列表。</p>
<p>non-hardware.kcf：指定仅包含非硬件选项的内核 Kconfig 文件列表。</p>
<p>hardware.cfg: 指定作为硬件的内核CONFIG_选项列表，无论它们是否在由硬件或非硬件 Kconfig 文件（即 hardware.kcf或non-hardware.kcf）指定的 Kconfig 文件中。</p>
<p>non-hardware.cfg: 指定非硬件内核CONFIG_选项的列表，无论它们是否在由硬件或非硬件 Kconfig 文件指定的 Kconfig 文件中（即hardware.kcf或non-hardware.kcf）。</p>
<p>这是一个使用的具体示例 kernel-cache/bsp/mti-malta32/hardware.cfg：</p>
<p>CONFIG_SERIAL_8250
CONFIG_SERIAL_8250_CONSOLE
CONFIG_SERIAL_8250_NR_UARTS
CONFIG_SERIAL_8250_PCI
CONFIG_SERIAL_CORE
CONFIG_SERIAL_CORE_CONSOLE
CONFIG_VGA_ARB
内核配置审计会自动检测这些文件（因此名称必须与此处讨论的完全相同），并在生成有关最终 .config文件的警告时将它们用作输入。</p>
<p>用户指定的内核元数据存储库或配方空间功能可以使用这些相同的文件将在其 .cfg文件中找到的选项分类为硬件或非硬件，以防止 OpenEmbedded 构建系统在选项出现时产生错误或警告不在最终.config文件中。</p>
<p>5内核维护
5.1树构建
本节描述 Yocto Project 内核源存储库的构建，由 Yocto Project 团队完成，以创建 Yocto Linux 内核存储库。这些内核存储库位于https://git.yoctoproject.org/cgit/cgit.cgi/的“Yocto Linux 内核”标题下，并作为 Yocto 项目版本的一部分提供。团队通过为产品中的每个 BSP 和功能编译和执行一组功能描述来创建这些存储库。这些特性描述列出了在 Yocto Linux 内核中找到的所有必要的补丁、配置、分支、标签和特性划分。因此，构建了 Yocto Project Linux 内核存储库（或树）和随附的元数据 yocto-kernel-cache。</p>
<p>这些存储库的存在允许您访问和克隆特定的 Yocto Project Linux 内核存储库，并使用它来基于其配置和功能构建映像。</p>
<p>yocto-kernel-cache您可以在 Yocto Project Linux 内核源代码库和Git 树的任何克隆中找到用于描述 Yocto Project Linux 内核中所有有效特性和 BSP 的文件。例如，以下命令克隆 Yocto Project 基线 Linux 内核，该内核从linux.org版本 4.12 和 yocto-kernel-cache包含内核元数据存储的 .</p>
<p>$ git clone git://git.yoctoproject.org/linux-yocto-4.12
$ git clone git://git.yoctoproject.org/linux-kernel-cache
有关如何设置 Yocto Project Linux 内核文件的本地 Git 存储库的更多信息，请参阅“准备构建主机以在内核上工作”部分。</p>
<p>在本地计算机上克隆内核 Git 存储库和元数据缓存后，您可以使用以下 Git 命令发现存储库中可用的分支：</p>
<p>$ git branch -a
签出分支允许您使用特定的 Yocto Linux 内核。例如，以下命令检查 Yocto Linux 内核存储库的“standard/beagleboard”分支和存储库的“yocto-4.12”分支yocto-kernel-cache：</p>
<p>$ cd ~/linux-yocto-4.12
$ git checkout -b my-kernel-4.12 remotes/origin/standard/beagleboard
$ cd ~/linux-kernel-cache
$ git checkout -b my-4.12-metadata remotes/origin/yocto-4.12
笔记</p>
<p>存储库中的分支yocto-kernel-cache对应于 Yocto Linux 内核版本（例如“yocto-4.12”、“yocto-4.10”、“yocto-4.9”等）。</p>
<p>签出并切换到适当的分支后，您可以看到用于为特定板构建特定 Yocto Linux 内核的所有内核源文件的快照。</p>
<p>要查看特定 Yocto Linux 内核的功能和配置，您需要检查yocto-kernel-cacheGit 存储库。如前所述，yocto-kernel-cache存储库中的分支对应于 Yocto Linux 内核版本（例如yocto-4.12）。.scc分支包含和.cfg 文件形式的描述。</p>
<p>但是，您应该意识到，浏览本地 yocto-kernel-cache存储库以获取功能描述和补丁并不是确定特定内核分支中的内容的有效方法。相反，您应该直接使用 Git 来发现分支中的更改。使用 Git 是检查内核更改的一种有效且灵活的方法。</p>
<p>笔记</p>
<p>从头开始重建完整的内核树是仅由 Yocto 项目团队在积极的开发周期中采取的行动。当您创建内核 Git 存储库的克隆时，您只是使其有效地用于构建和开发。</p>
<p>以下步骤描述了当 Yocto 项目团队构建 Yocto 项目内核源 Git 存储库（或树）时会发生什么，该存储库位于https://git.yoctoproject.org/cgit/cgit.cgi/，并引入了新的顶层内核功能或 BSP。以下操作有效地提供元数据并创建包含新功能、补丁或 BSP 的树：</p>
<p>将功能传递给 OpenEmbedded 构建系统：将顶级内核功能传递给内核构建子系统。通常，此功能是特定内核类型的 BSP。</p>
<p>定位功能：通过搜索这些系统目录可以找到描述顶级功能的文件：</p>
<p>in-tree kernel-cache 目录，位于 Yocto Project Source Repositories 中“Yocto Linux Kernel”标题下组织 的yocto-kernel-cache存储库中。</p>
<p>内核配方中的SRC_URI语句指向的区域。</p>
<p>对于典型的构建，搜索的目标是.scc文件中的功能描述，其名称遵循以下格式（例如 beaglebone-standard.sccand beaglebone-preempt-rt.scc）：</p>
<p>bsp_root_name-kernel_type.scc
扩展特性：一旦定位，特性描述要么扩展为一个简单的动作脚本，要么扩展为一个现有的等效脚本，该脚本已经是随附内核的一部分。</p>
<p>附加附加功能：附加功能附加到顶级功能描述。这些特性可以来自配方中的 KERNEL_FEATURES 变量。</p>
<p>定位、扩展和附加每个功能：每个额外的功能都被定位、扩展并附加到脚本中，如第三步中所述。</p>
<p>执行脚本：执行脚本以在存储库的适当目录中 生成文件 .scc和文件。这些文件是对需要应用到基本 Git 存储库以完全创建新 BSP 或功能的源（构建）分支的所有分支、标签、补丁和配置的描述。.cfgyocto-kernel-cache</p>
<p>克隆基础存储库：克隆基础存储库，并将yocto-kernel-cache目录中列出的操作应用于树。</p>
<p>执行清理： Git 存储库留下了所需的分支，并已执行任何所需的分支、修补和标记。</p>
<p>内核树和缓存已准备好供开发人员使用，可以在本地克隆、配置并内置到特定于某些目标硬件的 Yocto 项目内核中。</p>
<p>笔记</p>
<p>生成的yocto-kernel-cache存储库会添加到 Yocto Project 版本附带的内核中。任何附加组件和配置数据都将应用于现有分支的末尾。在https://git.yoctoproject.org/cgit/cgit.cgi/的官方 Yocto Project 内核存储库中找到的完整存储库生成是所有支持的板和配置的组合。</p>
<p>Yocto 项目团队使用的技术是灵活的，允许将不可变的历史与特定于部署的附加补丁无缝混合。对内核的任何添加都将成为分支的集成部分。</p>
<p>您在https://git.yoctoproject.org/cgit/cgit.cgi/上看到的完整内核树是通过对所有有效 BSP 重复上述步骤生成的。最终结果是一个分支的、干净的历史树，它构成了给定版本的内核。您可以在yocto-kernel-toolskgit-scc存储库中看到负责此 操作的脚本 ( ) 。</p>
<p>用于构建完整内核树的步骤与 BitBake 在构建内核映像时使用的步骤相同。</p>
<p>5.2构建策略
将 Yocto Linux 内核存储库和缓存存储库 ( yocto-kernel-cache) 克隆到开发系统后，您可以考虑内核开发的编译阶段，即构建内核映像。在编译开始之前，构建过程会验证一些先决条件：</p>
<p>SRC_URI指向内核 Git 存储库。</p>
<p>yocto-kernel-cache 存储库中存在带有元数据的 BSP 构建分支。该分支基于 Yocto Linux 内核版本，并在 yocto-kernel-cache/bsp目录下分组配置和功能。例如，假设 linux-yocto_4.12内核的 BeagleBone 板的功能和配置位于存储库的以下区域 yocto-kernel-cache：yocto-kernel-cache/bsp/beaglebone</p>
<p>笔记</p>
<p>在前面的示例中，“yocto-4.12”分支在存储库中被签出yocto-kernel-cache。</p>
<p>OpenEmbedded 构建系统确保在尝试编译之前满足这些条件。但是，确实存在其他方法，例如引导 BSP。</p>
<p>在构建内核之前，构建过程会验证树并通过处理.scc文件中功能描述指定的所有配置“片段”来配置内核。随着功能的编译，相关的内核配置片段会按照编译顺序记录在一系列目录中。这些片段被迁移、预处理并以文件lkc形式作为原始输入传递给 Linux 内核配置子系统 ( ) .config。使用lkc自己的内部依赖约束对该信息进行最终处理，并生成.config在编译期间使用的最终文件。</p>
<p>使用板的架构和板模板中的其他相关值，启动内核编译并生成内核映像。</p>
<p>配置内核后您会注意到的另一件事是，构建过程会生成一个与内核的本地 Git 源存储库树分开的构建树。此构建树的名称使用以下形式，其中${MACHINE}是机器的元数据名称 (BSP)，“kernel_type”是 Yocto 项目支持的内核类型之一（例如“标准”）：</p>
<p>linux-${MACHINE}-kernel_type-build
kernel.org树中的现有支持实现了此默认功能。</p>
<p>这种行为意味着为特定机器或 BSP 生成的所有文件现在都在构建树目录中。文件包括最终.config文件、所有.o文件、.a文件等。由于每台机器或 BSP 在其自己的 Git 存储库分支中都有自己独立的 构建目录，因此您可以轻松地在不同的构建之间切换。</p>
<p>6内核开发常见问题
6.1常见问题及解决方案
以下是一些常见问题的解决方案。</p>
<p>6.1.1如何使用自己的Linux内核.config文件？
有关信息，请参阅“更改配置”部分。</p>
<p>6.1.2如何创建配置片段？
答：有关信息，请参阅“创建配置片段”部分。</p>
<p>6.1.3如何使用自己的 Linux 内核源代码？
有关信息，请参阅“使用您自己的资源”部分。</p>
<p>6.1.4如何在根文件系统上安装/不安装内核映像？
内核映像（例如vmlinuz）由 kernel-image软件包提供。图像配方取决于kernel-base. 要指定内核映像是否安装在生成的根文件系统中，请覆盖RDEPENDS:${KERNEL_PACKAGE_NAME}-base以包含或不包含“kernel-image”。有关如何使用附加文件覆盖元数据的信息，请参阅Yocto 项目开发任务手册中的“使用图层附加其他图层元数据”部分。</p>
<p>6.1.5如何安装特定的内核模块？
Linux 内核模块是单独打包的。要确保特定内核模块包含在映像中，请将其包含在适当的机器RRECOMMENDS变量中。这些其他变量对于安装特定模块很有用： - MACHINE_ESSENTIAL_EXTRA_RDEPENDS - MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS - MACHINE_EXTRA_RDEPENDS - MACHINE_EXTRA_RRECOMMENDS</p>
<p>例如，在qemux86.conf文件中设置以下内容以包含内核模块以及为 机器ab123构建的映像：qemux86</p>
<p>MACHINE_EXTRA_RRECOMMENDS += “kernel-module-ab123”
有关更多信息，请参阅“合并树外模块”部分。</p>
<p>6.1.6如何更改 Linux 内核命令行？
Linux 内核命令行通常在机器配置中使用APPEND变量指定。例如，您可以添加一些有用的调试信息，执行以下操作：</p>
<p>APPEND += “printk.time=y initcall_debug debug”</p>
<p>1 Yocto 项目分析和跟踪手册
1.1简介
Yocto 捆绑了许多跟踪和分析工具——这个“HOWTO”描述了它们的基本用法，并通过示例展示了如何使用它们来检查应用程序和系统行为。</p>
<p>所提供的工具大部分是完全开放的，并且它们自己的文档非常好和/或广泛，可用于解决您在 Linux 中可能遇到的任何问题。描述特定工具的每个部分都有指向该工具的文档和网站的链接。</p>
<p>本“HOWTO”的目的是在通用“向下钻取”方法的背景下，提供一组常见且普遍有用的跟踪和分析习语及其在每个工具中的应用（视情况而定）。应用于解决大量（90%？）的问题。如需有关更高级用法和问题的帮助，请参阅为每个工具列出的文档和/或网站。</p>
<p>本“HOWTO”的最后一部分是真实世界示例的集合，随着我们使用这些工具解决更多问题，我们将不断添加这些示例 - 随时将您自己的示例添加到列表中！</p>
<p>1.2一般设置
大多数工具仅在“sdk”映像或在将“tools-profile”添加到 local.conf 后构建的映像中可用。因此，为了能够访问此处描述的所有工具，请首先构建并启动一个“sdk”映像，例如</p>
<p>$ bitbake core-image-sato-sdk
或者通过将“工具配置文件”添加到 local.conf 中的 EXTRA_IMAGE_FEATURES 行：</p>
<p>EXTRA_IMAGE_FEATURES = “debug-tweaks tools-profile”
如果您使用 ‘tools-profile’ 方法，则无需构建 sdk 映像 - 跟踪和分析工具也将包含在非 sdk 映像中，例如：</p>
<p>$ bitbake core-image-sato
笔记</p>
<p>默认情况下，Yocto 构建系统会从它打包的二进制文件中去除符号，这使得某些工具难以使用。</p>
<p>您可以通过在构建映像时将 INHIBIT_PACKAGE_STRIP 变量设置为“1”来防止这种情况local.conf发生：</p>
<p>INHIBIT_PACKAGE_STRIP = “1”
上述设置将显着增加图像的大小。</p>
<p>如果您已经构建了一个剥离的映像，您可以生成调试包 (xxx-dbg)，您可以根据需要手动安装它。</p>
<p>要为包生成调试信息，您可以将 dbg-pkgs 添加到 local.conf 中的 EXTRA_IMAGE_FEATURES。例如：</p>
<p>EXTRA_IMAGE_FEATURES = “debug-tweaks tools-profile dbg-pkgs”
此外，为了生成正确类型的调试信息，我们还需要在文件中设置PACKAGE_DEBUG_SPLIT_STYLElocal.conf：</p>
<p>PACKAGE_DEBUG_SPLIT_STYLE = ‘debug-file-directory’</p>
<p>2 Linux 跟踪和分析工具的总体架构
2.1跟踪和分析工具的架构
看到一个涵盖“总体架构”的部分似乎是一个随机的跟踪工具集合，这些工具共同构成了 Linux 跟踪和分析空间，这似乎令人惊讶。然而，事实是，近年来，这组看似完全不同的工具已经开始集中在一组“核心”基础机制上：</p>
<p>静态跟踪点</p>
<p>动态跟踪点</p>
<p>探针</p>
<p>长袍</p>
<p>perf_events 子系统</p>
<p>调试文件</p>
<p>把它绑在一起</p>
<p>与其在这里列举每个工具如何使用这些通用机制，不如在文本框内记录每个工具在文本过程中出现的具体用法。</p>
<p>3每个 Yocto 跟踪工具的基本用法（附示例）</p>
<p>本章介绍每个跟踪工具的基本使用示例。</p>
<p>3.1性能
‘perf’ 工具是与 Linux 内核捆绑在一起的分析和跟踪工具。</p>
<p>不要让它是内核的一部分这一事实欺骗您认为它仅用于跟踪和分析内核 - 您确实可以使用它来跟踪和分析内核，但您也可以使用它来单独分析特定应用程序（有或没有内核上下文），您还可以使用它同时跟踪和分析系统上的内核和所有应用程序，以获得系统范围内正在发生的事情的视图。</p>
<p>在许多方面，perf 旨在成为当今 Linux 中可用的所有跟踪和分析工具的超集，包括本 HOWTO 中涵盖的所有其他工具。在过去的几年中，perf 包含了其他工具的许多功能，同时，这些其他工具已经删除了它们以前的大部分功能，并将其替换为对 perf 现在实现的等效功能的调用子系统。推断表明，在某些时候，那些其他工具将变得完全多余并消失；在那之前，我们将在这些页面中介绍这些其他工具，并且在许多情况下展示如何在 perf 和其他似乎有用的工具中完成相同的事情。</p>
<p>以下内容详细介绍了您可能希望应用该工具的一些最常见方式；完整的文档可以在工具本身或 perf(1)的手册页中找到。</p>
<p>3.1.1性能设置
对于本节，我们假设您已经执行了“常规设置”部分中概述的基本设置。</p>
<p>特别是，如果您在local.conf文件中分析使用以下内容构建的图像，您将从 perf 中获得最大的收益：</p>
<p>INHIBIT_PACKAGE_STRIP = “1”
perf 大部分时间都在目标系统上运行。您可以存档配置文件数据并将其复制到主机进行分析，但对于本文档的其余部分，我们假设您已 ssh 到主机并将在目标上运行 perf 命令。</p>
<p>3.1.2基本性能使用
perf 工具几乎是自我记录的。要提醒自己可用的命令，只需键入“perf”，它将显示基本用法以及可用的 perf 子命令：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf</p>
<p>usage: perf [–version] [–help] COMMAND [ARGS]</p>
<dl class="simple">
<dt>The most commonly used perf commands are:</dt><dd><p>annotate        Read perf.data (created by perf record) and display annotated code
archive         Create archive with object files with build-ids found in perf.data file
bench           General framework for benchmark suites
buildid-cache   Manage build-id cache.
buildid-list    List the buildids in a perf.data file
diff            Read two perf.data files and display the differential profile
evlist          List the event names in a perf.data file
inject          Filter to augment the events stream with additional information
kmem            Tool to trace/measure kernel memory(slab) properties
kvm             Tool to trace/measure kvm guest os
list            List all symbolic event types
lock            Analyze lock events
probe           Define new dynamic tracepoints
record          Run a command and record its profile into perf.data
report          Read perf.data (created by perf record) and display the profile
sched           Tool to trace/measure scheduler properties (latencies)
script          Read perf.data (created by perf record) and display trace output
stat            Run a command and gather performance counter statistics
test            Runs sanity tests.
timechart       Tool to visualize total system behavior during a workload
top             System profiling tool.</p>
</dd>
</dl>
<p>See ‘perf help COMMAND’ for more information on a specific command.
3.1.2.1使用 perf 做 Basic Profiling
作为一个简单的测试用例，我们将分析一个相当大的文件的“wget”，这是一个最有趣的用例，因为它同时具有文件和网络 I/O 方面，至少在标准 Yocto 图像的情况下，它是作为 BusyBox 的一部分实现，因此我们用来分析它的方法可以以非常类似于 Yocto 中支持的整个 BusyBox 小程序的方式使用。</p>
<dl class="simple">
<dt><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# rm linux-2.6.19.2.tar.bz2; </dt><dd><p>wget <a class="reference external" href="https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2">https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2</a></p>
</dd>
</dl>
<p>获取有关特定工作负载情况的一些基本整体数据的最快和最简单的方法是使用“perf stat”对其进行分析。’perf stat’ 基本上使用一些默认计数器进行配置，并在运行结束时显示总计数：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf stat wget <a class="reference external" href="https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2">https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2</a>
Connecting to downloads.yoctoproject.org (140.211.169.59:80)
linux-2.6.19.2.tar.b 100% <a href="#id151"><span class="problematic" id="id152">|***************************************************|</span></a> 41727k  0:00:00 ETA</p>
<p>Performance counter stats for ‘wget <a class="reference external" href="https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2">https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2</a>’:</p>
<blockquote>
<div><blockquote>
<div><dl>
<dt>4597.223902 task-clock                #    0.077 CPUs utilized</dt><dd><blockquote>
<div><dl>
<dt>23568 context-switches          #    0.005 M/sec</dt><dd><blockquote>
<div><p>68 CPU-migrations            #    0.015 K/sec</p>
</div></blockquote>
<p>241 page-faults               #    0.052 K/sec</p>
</dd>
</dl>
</div></blockquote>
<p>3045817293 cycles                    #    0.663 GHz</p>
</dd>
</dl>
</div></blockquote>
<p>&lt;not supported&gt; stalled-cycles-frontend
&lt;not supported&gt; stalled-cycles-backend</p>
<blockquote>
<div><blockquote>
<div><p>858909167 instructions              #    0.28  insns per cycle
165441165 branches                  #   35.987 M/sec</p>
<blockquote>
<div><p>19550329 branch-misses             #   11.82% of all branches</p>
</div></blockquote>
</div></blockquote>
<p>59.836627620 seconds time elapsed</p>
</div></blockquote>
</div></blockquote>
<p>很多时候，这种头脑简单的测试并不会产生太大的兴趣，但有时确实会产生兴趣（参见 Real-world Yocto bug (slow loop-mounted write speed)）。</p>
<p>另外，请注意，“perf stat”不限于一组固定的计数器 - 基本上，“perf list”输出中列出的任何事件都可以通过“perf stat”进行统计。例如，假设我们想要查看与内核内存分配/释放以及缓存命中和未命中相关的所有事件的摘要：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf stat -e kmem:* -e cache-references -e cache-misses wget https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2
Connecting to downloads.yoctoproject.org (140.211.169.59:80)
linux-2.6.19.2.tar.b 100% <a href="#id153"><span class="problematic" id="id154">|***************************************************|</span></a> 41727k  0:00:00 ETA</p>
<p>Performance counter stats for ‘wget <a class="reference external" href="https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2">https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2</a>’:</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>5566 kmem:kmalloc</p>
</div></blockquote>
<dl>
<dt>125517 kmem:kmem_cache_alloc</dt><dd><blockquote>
<div><p>0 kmem:kmalloc_node
0 kmem:kmem_cache_alloc_node</p>
</div></blockquote>
<p>34401 kmem:kfree
69920 kmem:kmem_cache_free</p>
<blockquote>
<div><dl class="simple">
<dt>133 kmem:mm_page_free</dt><dd><p>41 kmem:mm_page_free_batched</p>
</dd>
</dl>
</div></blockquote>
<p>11502 kmem:mm_page_alloc
11375 kmem:mm_page_alloc_zone_locked</p>
<blockquote>
<div><p>0 kmem:mm_page_pcpu_drain
0 kmem:mm_page_alloc_extfrag</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>66848602 cache-references</dt><dd><p>2917740 cache-misses              #    4.365 % of all cache refs</p>
</dd>
</dl>
</div></blockquote>
<p>44.831023415 seconds time elapsed</p>
</div></blockquote>
<p>因此，“perf stat”为我们提供了一种非常简单的方法来快速了解一组事件可能发生的情况，但通常我们需要更多细节才能以我们可以理解的方式了解正在发生的事情以有用的方式行动。</p>
<p>为了深入了解下一级的细节，我们可以使用“perf record”/“perf report”，它将收集分析数据并使用基于交互式文本的 UI（或者如果我们指定 –stdio 以’性能报告’）。</p>
<p>作为我们第一次尝试分析此工作负载，我们将简单地运行“性能记录”，将我们想要分析的工作负载交给它（“性能记录”之后的所有内容以及我们提供的任何性能选项 - 这里没有 - 将在新外壳）。perf 收集样本，直到进程退出并将它们记录在当前工作目录中名为“perf.data”的文件中。</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf record wget <a class="reference external" href="https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2">https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2</a></p>
<p>Connecting to downloads.yoctoproject.org (140.211.169.59:80)
linux-2.6.19.2.tar.b 100% <a href="#id155"><span class="problematic" id="id156">|************************************************|</span></a> 41727k  0:00:00 ETA
[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.176 MB perf.data (~7700 samples) ]
要在“基于文本的 UI”(tui) 中查看结果，只需运行“perf report”，它将读取当前工作目录中的 perf.data 文件并在交互式 UI 中显示结果：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf report</p>
<p>perf-wget-flat-stripped.png</p>
<p>上面的屏幕截图显示了一个“平面”配置文件，每个“桶”对应于在分析运行期间分析的函数的一个条目，从最流行到最少排序（perf 也可以选择以各种顺序和键进行排序仅在某个阈值以上显示条目等等 - 有关详细信息，请参阅 perf 文档）。请注意，这包括用户空间函数（包含 [.] 的条目）和进程的内核函数（包含 [k] 的条目）。（perf 具有命令行修饰符，可用于将分析限制为内核或用户空间等）。</p>
<p>另请注意，上面的报告显示了“busybox”的条目，它是在 Yocto 中实现“wget”的可执行文件，但该条目中没有有用的函数名称，而是显示了一个不太友好的十六进制值。以下步骤将展示如何解决该问题。</p>
<p>然而，在我们这样做之前，让我们尝试运行一个不同的配置文件，它显示一些更有趣的东西。新配置文件与前一个配置文件的唯一区别是我们将添加 -g 选项，它不仅会记录采样函数的地址，还会记录采样函数的整个调用链：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf record -g wget <a class="reference external" href="https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2">https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2</a>
Connecting to downloads.yoctoproject.org (140.211.169.59:80)
linux-2.6.19.2.tar.b 100% <a href="#id157"><span class="problematic" id="id158">|************************************************|</span></a> 41727k  0:00:00 ETA
[ perf record: Woken up 3 times to write data ]
[ perf record: Captured and wrote 0.652 MB perf.data (~28476 samples) ]</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf report
perf-wget-g-copy-to-user-expanded-stripped.png</p>
<p>使用调用图视图，我们实际上不仅可以看到哪些函数花费的时间最多，而且我们还可以看到这些函数如何被调用的摘要，并了解程序如何与进程中的内核交互。</p>
<p>请注意，上面屏幕截图中的每个条目现在在左侧都包含一个“+”。这意味着我们可以扩展条目并深入到输入该条目的调用链中。在其中任何一个上按“enter”将展开调用链（您也可以按“E”同时展开它们，或者按“C”将它们全部折叠）。</p>
<p>在上面的屏幕截图中，我们一直切换__copy_to_user_ll()条目和几个子节点。这让我们可以看到哪些调用链对分析__copy_to_user_ll()功能做出了贡献，占总分析的 1.77%。</p>
<p>作为对这些调用链的一些背景解释，请考虑一下当您运行 wget 以在网络上获取文件时在较高级别上发生的情况。基本上发生的情况是数据通过网络连接（套接字）进入内核并传递给用户空间程序“wget”（它实际上是 BusyBox 的一部分，但现在这并不重要），它将缓冲区内核传递给它并将其写入磁盘文件以保存它。</p>
<p>我们在上面的调用堆栈中看到的这个过程的一部分是内核将它从套接字读取的数据向下传递给 wget 的部分，即复制到用户。</p>
<p>另请注意，这里还有一个十六进制值显示在调用堆栈中的情况，这里是扩展sys_clock_gettime() 函数。稍后我们将看到它解析为busybox中的用户空间函数调用</p>
<p>perf-wget-g-copy-from-user-expanded-stripped.png</p>
<p>上面的屏幕截图显示了数据旅程的另一半——从 wget 程序的用户空间缓冲区到磁盘。为了将缓冲区保存到磁盘，wget 程序发出 a write(2)，它对copy-from-user内核执行 a ，然后内核通过一些迂回的路径（可能也存在于配置文件数据中的某处）进行处理，以将其安全地保存到磁盘。</p>
<p>现在我们已经了解了配置文件数据的基本布局以及如何从中提取有用信息的基础知识，让我们回到手头的任务，看看我们是否可以对时间花在哪里有一些基本的了解我们正在分析的程序 wget。请记住，wget 实际上是作为 BusyBox 中的小程序实现的，因此虽然进程名称是“wget”，但我们真正感兴趣的可执行文件是 BusyBox。因此，让我们展开包含 BusyBox 的第一个条目：</p>
<p>perf-wget-busybox-expanded-stripped.png</p>
<p>同样，在我们展开之前，我们看到函数被标记为十六进制值，而不是与大多数内核条目一样的符号。扩展 BusyBox 条目并没有让它变得更好。</p>
<p>问题是 perf 找不到busybox 二进制文件的符号信息，这实际上是被 Yocto 构建系统剥离的。</p>
<p>一种解决方法是在local.conf构建映像时将以下内容放入文件中：</p>
<p>INHIBIT_PACKAGE_STRIP = “1”
但是，我们已经有了一个剥离了二进制文件的图像，那么我们可以做些什么来获得性能来解析符号呢？基本上我们需要为 BusyBox 包安装 debuginfo。</p>
<p>要为图像中的包生成调试信息，我们可以添加 dbg-pkgs到EXTRA_IMAGE_FEATURES中local.conf。例如：</p>
<p>EXTRA_IMAGE_FEATURES = “debug-tweaks tools-profile dbg-pkgs”
另外，为了生成perf能理解的debuginfo的类型，我们还需要 在文件中设置PACKAGE_DEBUG_SPLIT_STYLElocal.conf：</p>
<p>PACKAGE_DEBUG_SPLIT_STYLE = ‘debug-file-directory’
完成后，我们可以为 BusyBox 安装调试信息。构建后的调试包可以在 build/tmp/deploy/rpm/<a href="#id101"><span class="problematic" id="id102">*</span></a>主机系统中找到。找到busybox-dbg-…rpm 文件并将其复制到目标。例如：</p>
<p>[<a class="reference external" href="mailto:trz&#37;&#52;&#48;empanada">trz<span>&#64;</span>empanada</a> core2]$ scp /home/trz/yocto/crownbay-tracing-dbg/build/tmp/deploy/rpm/core2_32/busybox-dbg-1.20.2-r2.core2_32.rpm <a class="reference external" href="mailto:root&#37;&#52;&#48;192&#46;168&#46;1&#46;31">root<span>&#64;</span>192<span>&#46;</span>168<span>&#46;</span>1<span>&#46;</span>31</a>:
busybox-dbg-1.20.2-r2.core2_32.rpm                     100% 1826KB   1.8MB/s   00:01
现在在目标上安装调试 rpm：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# rpm -i busybox-dbg-1.20.2-r2.core2_32.rpm
现在安装了 debuginfo，我们看到 BusyBox 条目现在象征性地显示了它们的功能：</p>
<p>perf-wget-busybox-debuginfo.png</p>
<hr class="docutils" />
<p>作为跟踪的一部分，让我们使用不同的计数器尝试另一个配置文件，而不是默认的“循环”。</p>
<p>Linux 中的跟踪和分析基础设施已经统一，允许我们使用具有完全不同的计数器集的相同工具，而不仅仅是传统工具必须限制自己使用的标准硬件计数器（当然传统工具也可以利用他们现在可用的扩展可能性，并且在某些情况下，如前所述）。</p>
<p>我们可以通过“perf list”获取可用于分析工作负载的可用事件列表：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf list</p>
<dl>
<dt>List of pre-defined events (to be used in -e):</dt><dd><p>cpu-cycles OR cycles                               [Hardware event]
stalled-cycles-frontend OR idle-cycles-frontend    [Hardware event]
stalled-cycles-backend OR idle-cycles-backend      [Hardware event]
instructions                                       [Hardware event]
cache-references                                   [Hardware event]
cache-misses                                       [Hardware event]
branch-instructions OR branches                    [Hardware event]
branch-misses                                      [Hardware event]
bus-cycles                                         [Hardware event]
ref-cycles                                         [Hardware event]</p>
<p>cpu-clock                                          [Software event]
task-clock                                         [Software event]
page-faults OR faults                              [Software event]
minor-faults                                       [Software event]
major-faults                                       [Software event]
context-switches OR cs                             [Software event]
cpu-migrations OR migrations                       [Software event]
alignment-faults                                   [Software event]
emulation-faults                                   [Software event]</p>
<p>L1-dcache-loads                                    [Hardware cache event]
L1-dcache-load-misses                              [Hardware cache event]
L1-dcache-prefetch-misses                          [Hardware cache event]
L1-icache-loads                                    [Hardware cache event]
L1-icache-load-misses                              [Hardware cache event]
.
.
.
rNNN                                               [Raw hardware event descriptor]
cpu/t1=v1[,t2=v2,t3 …]/modifier                  [Raw hardware event descriptor]</p>
<blockquote>
<div><p>(see ‘perf list –help’ on how to encode it)</p>
</div></blockquote>
<p>mem:&lt;addr&gt;[:access]                                [Hardware breakpoint]</p>
<p>sunrpc:rpc_call_status                             [Tracepoint event]
sunrpc:rpc_bind_status                             [Tracepoint event]
sunrpc:rpc_connect_status                          [Tracepoint event]
sunrpc:rpc_task_begin                              [Tracepoint event]
skb:kfree_skb                                      [Tracepoint event]
skb:consume_skb                                    [Tracepoint event]
skb:skb_copy_datagram_iovec                        [Tracepoint event]
net:net_dev_xmit                                   [Tracepoint event]
net:net_dev_queue                                  [Tracepoint event]
net:netif_receive_skb                              [Tracepoint event]
net:netif_rx                                       [Tracepoint event]
napi:napi_poll                                     [Tracepoint event]
sock:sock_rcvqueue_full                            [Tracepoint event]
sock:sock_exceed_buf_limit                         [Tracepoint event]
udp:udp_fail_queue_rcv_skb                         [Tracepoint event]
hda:hda_send_cmd                                   [Tracepoint event]
hda:hda_get_response                               [Tracepoint event]
hda:hda_bus_reset                                  [Tracepoint event]
scsi:scsi_dispatch_cmd_start                       [Tracepoint event]
scsi:scsi_dispatch_cmd_error                       [Tracepoint event]
scsi:scsi_eh_wakeup                                [Tracepoint event]
drm:drm_vblank_event                               [Tracepoint event]
drm:drm_vblank_event_queued                        [Tracepoint event]
drm:drm_vblank_event_delivered                     [Tracepoint event]
random:mix_pool_bytes                              [Tracepoint event]
random:mix_pool_bytes_nolock                       [Tracepoint event]
random:credit_entropy_bits                         [Tracepoint event]
gpio:gpio_direction                                [Tracepoint event]
gpio:gpio_value                                    [Tracepoint event]
block:block_rq_abort                               [Tracepoint event]
block:block_rq_requeue                             [Tracepoint event]
block:block_rq_issue                               [Tracepoint event]
block:block_bio_bounce                             [Tracepoint event]
block:block_bio_complete                           [Tracepoint event]
block:block_bio_backmerge                          [Tracepoint event]
.
.
writeback:writeback_wake_thread                    [Tracepoint event]
writeback:writeback_wake_forker_thread             [Tracepoint event]
writeback:writeback_bdi_register                   [Tracepoint event]
.
.
writeback:writeback_single_inode_requeue           [Tracepoint event]
writeback:writeback_single_inode                   [Tracepoint event]
kmem:kmalloc                                       [Tracepoint event]
kmem:kmem_cache_alloc                              [Tracepoint event]
kmem:mm_page_alloc                                 [Tracepoint event]
kmem:mm_page_alloc_zone_locked                     [Tracepoint event]
kmem:mm_page_pcpu_drain                            [Tracepoint event]
kmem:mm_page_alloc_extfrag                         [Tracepoint event]
vmscan:mm_vmscan_kswapd_sleep                      [Tracepoint event]
vmscan:mm_vmscan_kswapd_wake                       [Tracepoint event]
vmscan:mm_vmscan_wakeup_kswapd                     [Tracepoint event]
vmscan:mm_vmscan_direct_reclaim_begin              [Tracepoint event]
.
.
module:module_get                                  [Tracepoint event]
module:module_put                                  [Tracepoint event]
module:module_request                              [Tracepoint event]
sched:sched_kthread_stop                           [Tracepoint event]
sched:sched_wakeup                                 [Tracepoint event]
sched:sched_wakeup_new                             [Tracepoint event]
sched:sched_process_fork                           [Tracepoint event]
sched:sched_process_exec                           [Tracepoint event]
sched:sched_stat_runtime                           [Tracepoint event]
rcu:rcu_utilization                                [Tracepoint event]
workqueue:workqueue_queue_work                     [Tracepoint event]
workqueue:workqueue_execute_end                    [Tracepoint event]
signal:signal_generate                             [Tracepoint event]
signal:signal_deliver                              [Tracepoint event]
timer:timer_init                                   [Tracepoint event]
timer:timer_start                                  [Tracepoint event]
timer:hrtimer_cancel                               [Tracepoint event]
timer:itimer_state                                 [Tracepoint event]
timer:itimer_expire                                [Tracepoint event]
irq:irq_handler_entry                              [Tracepoint event]
irq:irq_handler_exit                               [Tracepoint event]
irq:softirq_entry                                  [Tracepoint event]
irq:softirq_exit                                   [Tracepoint event]
irq:softirq_raise                                  [Tracepoint event]
printk:console                                     [Tracepoint event]
task:task_newtask                                  [Tracepoint event]
task:task_rename                                   [Tracepoint event]
syscalls:sys_enter_socketcall                      [Tracepoint event]
syscalls:sys_exit_socketcall                       [Tracepoint event]
.
.
.
syscalls:sys_enter_unshare                         [Tracepoint event]
syscalls:sys_exit_unshare                          [Tracepoint event]
raw_syscalls:sys_enter                             [Tracepoint event]
raw_syscalls:sys_exit                              [Tracepoint event]</p>
</dd>
</dl>
<p>把它绑在一起</p>
<p>这些与跟踪事件子系统定义的事件集完全相同，并由 ftrace/tracecmd/kernelshark 作为 /sys/kernel/debug/tracing/events 中的文件公开，由 SystemTap 作为 kernel.trace(“tracepoint_name”) 和（部分) 由 LTTng 访问。</p>
<p>在查看此工作负载时，我们只会对其中的一个子集感兴趣，因此让我们选择最可能的子系统（由 Tracepoint 事件中冒号前的字符串标识）并仅使用那些通配符子系统运行“性能统计” ：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf stat -e skb:* -e net:* -e napi:* -e sched:* -e workqueue:* -e irq:* -e syscalls:* wget https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2
Performance counter stats for ‘wget https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2’:</p>
<blockquote>
<div><blockquote>
<div><dl>
<dt>23323 skb:kfree_skb</dt><dd><p>0 skb:consume_skb</p>
</dd>
<dt>49897 skb:skb_copy_datagram_iovec</dt><dd><p>6217 net:net_dev_xmit
6217 net:net_dev_queue
7962 net:netif_receive_skb</p>
<blockquote>
<div><p>2 net:netif_rx</p>
</div></blockquote>
<dl>
<dt>8340 napi:napi_poll</dt><dd><p>0 sched:sched_kthread_stop
0 sched:sched_kthread_stop_ret</p>
</dd>
<dt>3749 sched:sched_wakeup</dt><dd><blockquote>
<div><p>0 sched:sched_wakeup_new
0 sched:sched_switch</p>
</div></blockquote>
<dl class="simple">
<dt>29 sched:sched_migrate_task</dt><dd><p>0 sched:sched_process_free
1 sched:sched_process_exit
0 sched:sched_wait_task
0 sched:sched_process_wait
0 sched:sched_process_fork
1 sched:sched_process_exec
0 sched:sched_stat_wait</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>2106519415641 sched:sched_stat_sleep</dt><dd><blockquote>
<div><blockquote>
<div><blockquote>
<div><p>0 sched:sched_stat_iowait</p>
</div></blockquote>
<p>147453613 sched:sched_stat_blocked</p>
</div></blockquote>
<dl>
<dt>12903026955 sched:sched_stat_runtime</dt><dd><blockquote>
<div><blockquote>
<div><p>0 sched:sched_pi_setprio</p>
</div></blockquote>
<p>3574 workqueue:workqueue_queue_work
3574 workqueue:workqueue_activate_work</p>
<blockquote>
<div><p>0 workqueue:workqueue_execute_start
0 workqueue:workqueue_execute_end</p>
</div></blockquote>
</div></blockquote>
<p>16631 irq:irq_handler_entry
16631 irq:irq_handler_exit
28521 irq:softirq_entry
28521 irq:softirq_exit
28728 irq:softirq_raise</p>
<blockquote>
<div><blockquote>
<div><p>1 syscalls:sys_enter_sendmmsg
1 syscalls:sys_exit_sendmmsg
0 syscalls:sys_enter_recvmmsg
0 syscalls:sys_exit_recvmmsg</p>
</div></blockquote>
<p>14 syscalls:sys_enter_socketcall
14 syscalls:sys_exit_socketcall</p>
<blockquote>
<div><p>.</p>
</div></blockquote>
</div></blockquote>
<p>16965 syscalls:sys_enter_read
16965 syscalls:sys_exit_read
12854 syscalls:sys_enter_write
12854 syscalls:sys_exit_write</p>
<blockquote>
<div><p>.</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>58.029710972 seconds time elapsed</p>
</dd>
</dl>
</div></blockquote>
<p>让我们选择其中一个跟踪点并告诉 perf 使用它作为采样事件进行配置：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf record -g -e sched:sched_wakeup wget https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2
../_images/sched-wakeup-profile.png
上面的屏幕截图显示了使用 sched:sched_switch 跟踪点运行配置文件的结果，它显示了到 sched_wakeup 的各种路径的相对成本（请注意，sched_wakeup 是跟踪点的名称 - 它实际上是在 ttwu_do_wakeup() 内部定义的，它解释了配置文件中实际显示的函数名称：</p>
<dl>
<dt>/*</dt><dd><ul class="simple">
<li><p>Mark the task runnable and perform wakeup-preemption.</p></li>
</ul>
<p><a href="#id103"><span class="problematic" id="id104">*</span></a>/</p>
</dd>
</dl>
<p>static void
ttwu_do_wakeup(struct rq <a href="#id105"><span class="problematic" id="id106">*</span></a>rq, struct task_struct <a href="#id107"><span class="problematic" id="id108">*</span></a>p, int wake_flags)
{</p>
<blockquote>
<div><p>trace_sched_wakeup(p, true);
.
.
.</p>
</div></blockquote>
<p>}
上面展开并显示了一些更有趣的调用链，基本上是一些网络接收路径，可能最终会在网络数据准备好时唤醒 wget (busybox)。</p>
<p>请注意，因为跟踪点通常用于跟踪，所以跟踪点的默认采样周期为 1，即跟踪点 perf 将在每个事件发生时进行采样（可以使用 -c 选项更改）。这与硬件计数器（例如用于正常分析的默认“周期”硬件计数器）形成对比，其中采样周期要高得多（以千计），因为分析应该具有尽可能低的开销，并且每个周期的采样都会贵得令人望而却步。</p>
<p>3.1.2.2使用 perf 做 Basic Tracing
分析是解决许多问题或获得工作负载或整个系统的高级视图的好工具。然而，正如与之相关的最突出的词“采样”所暗示的那样，根据定义，它是一个近似值。一方面，它可以廉价地拍摄系统中正在发生的事情的代表性图片，但另一方面，当数据表明需要更深入地“潜入”以发现真正的事情时，这种廉价性会限制其效用继续。在这种情况下，查看实际情况的唯一方法是能够查看（或更智能地总结）进入由粗粒度分析数据暴露的更高级别行为的各个步骤。</p>
<p>作为一个具体的例子，我们可以跟踪我们认为可能适用于我们工作负载的所有事件：</p>
<dl class="simple">
<dt><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf record -g -e skb:* -e net:* -e napi:* -e sched:sched_switch -e sched:sched_wakeup -e irq:*</dt><dd><p>-e syscalls:sys_enter_read -e syscalls:sys_exit_read -e syscalls:sys_enter_write -e syscalls:sys_exit_write
wget https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2</p>
</dd>
</dl>
<p>我们可以使用不带参数的“perf script”查看原始跟踪输出：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf script</p>
<blockquote>
<div><p>perf  1262 [000] 11624.857082: sys_exit_read: 0x0
perf  1262 [000] 11624.857193: sched_wakeup: comm=migration/0 pid=6 prio=0 success=1 target_cpu=000
wget  1262 [001] 11624.858021: softirq_raise: vec=1 [action=TIMER]
wget  1262 [001] 11624.858074: softirq_entry: vec=1 [action=TIMER]
wget  1262 [001] 11624.858081: softirq_exit: vec=1 [action=TIMER]
wget  1262 [001] 11624.858166: sys_enter_read: fd: 0x0003, buf: 0xbf82c940, count: 0x0200
wget  1262 [001] 11624.858177: sys_exit_read: 0x200
wget  1262 [001] 11624.858878: kfree_skb: skbaddr=0xeb248d80 protocol=0 location=0xc15a5308
wget  1262 [001] 11624.858945: kfree_skb: skbaddr=0xeb248000 protocol=0 location=0xc15a5308
wget  1262 [001] 11624.859020: softirq_raise: vec=1 [action=TIMER]
wget  1262 [001] 11624.859076: softirq_entry: vec=1 [action=TIMER]
wget  1262 [001] 11624.859083: softirq_exit: vec=1 [action=TIMER]
wget  1262 [001] 11624.859167: sys_enter_read: fd: 0x0003, buf: 0xb7720000, count: 0x0400
wget  1262 [001] 11624.859192: sys_exit_read: 0x1d7
wget  1262 [001] 11624.859228: sys_enter_read: fd: 0x0003, buf: 0xb7720000, count: 0x0400
wget  1262 [001] 11624.859233: sys_exit_read: 0x0
wget  1262 [001] 11624.859573: sys_enter_read: fd: 0x0003, buf: 0xbf82c580, count: 0x0200
wget  1262 [001] 11624.859584: sys_exit_read: 0x200
wget  1262 [001] 11624.859864: sys_enter_read: fd: 0x0003, buf: 0xb7720000, count: 0x0400
wget  1262 [001] 11624.859888: sys_exit_read: 0x400
wget  1262 [001] 11624.859935: sys_enter_read: fd: 0x0003, buf: 0xb7720000, count: 0x0400
wget  1262 [001] 11624.859944: sys_exit_read: 0x400</p>
</div></blockquote>
<p>这为我们提供了与这些事件相关的在工作负载中发生的事件的详细时间戳序列。</p>
<p>在许多方面，分析可以被视为跟踪的一个子集 - 从理论上讲，如果您有一组足以捕获工作负载的所有重要方面的跟踪事件，您可以得出分析运行可以得到的任何结果或视图.</p>
<p>传统分析的另一个方面是，虽然在许多方面都很强大，但它受到底层数据粒度的限制。分析工具提供了各种排序和呈现样本数据的方法，这使得它更加有用并且更适合用户实验，但最终它不能以开放式的方式用于提取不存在的数据由于从概念上讲，其中大部分已被丢弃。</p>
<p>然而，完整的详细跟踪数据确实提供了以无限多种方式操作和呈现在跟踪运行期间收集的信息的机会。</p>
<p>另一种看待它的方式是，“原始”计数器可以通过多种方式单独使用来生成有趣的输出。要获得比简单计数更复杂的东西，需要一些额外的逻辑，这通常是针对手头的问题的。例如，如果我们想使用一个“计数器”来映射一个进程在处理器上运行的时间和它实际运行的时间之间的时间差值，我们不会期望这样的计数器它自己存在，但我们可以派生一个叫做“wakeup_latency”的方法，并使用它从跟踪数据中提取该指标的有用视图。同样，我们真的无法从标准分析工具中计算出系统上每个进程读取和写入的数据量，以及这些读取和写入中有多少完全失败。</p>
<p>幸运的是，有一种通用方法可以处理这些需求，称为“编程语言”。考虑到数据的特定格式，使编程语言易于应用于此类问题，这称为该数据和语言的“编程语言绑定”。Perf 支持两种编程语言绑定，一种用于 Python，一种用于 Perl。</p>
<p>把它绑在一起</p>
<p>用于操作和聚合跟踪数据的语言绑定当然不是一个新想法。第一个这样做的项目是 IBM 的 DProbes dpcc 编译器，这是一个 ANSI C 编译器，它针对在目标系统上的内核解释器上运行的低级汇编语言。这与 Sun 的 DTrace 所做的完全相似，只是 DTrace 为此目的发明了自己的语言。Systemtap 受到 DTrace 的极大启发，也创建了自己的一次性语言，但不是在内核解释器上运行产品，而是创建了一种基于编译器的精细机器，将其语言翻译成用 C 编写的内核模块。</p>
<p>现在我们在 perf.data 中有跟踪数据，我们可以使用“perf script -g”生成一个骨架脚本，其中包含我们记录的读/写进入/退出事件的处理程序：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf script -g python
generated Python script: perf-script.py
骨架脚本只是为 perf.data 文件中的每个事件类型创建一个 python 函数。每个函数的主体只打印事件名称及其参数。例如：</p>
<dl>
<dt>def net__netif_rx(event_name, context, common_cpu,</dt><dd><p>common_secs, common_nsecs, common_pid, common_comm,
skbaddr, len, name):</p>
<blockquote>
<div><dl class="simple">
<dt>print_header(event_name, common_cpu, common_secs, common_nsecs,</dt><dd><p>common_pid, common_comm)</p>
</dd>
</dl>
<p>print “skbaddr=%u, len=%u, name=%sn” % (skbaddr, len, name),</p>
</div></blockquote>
</dd>
</dl>
<p>我们可以直接运行该脚本来打印 perf.data 文件中包含的所有事件：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf script -s perf-script.py</p>
<p>in trace_begin
syscalls__sys_exit_read     0 11624.857082795     1262 perf                  nr=3, ret=0
sched__sched_wakeup      0 11624.857193498     1262 perf                  comm=migration/0, pid=6, prio=0,      success=1, target_cpu=0
irq__softirq_raise       1 11624.858021635     1262 wget                  vec=TIMER
irq__softirq_entry       1 11624.858074075     1262 wget                  vec=TIMER
irq__softirq_exit        1 11624.858081389     1262 wget                  vec=TIMER
syscalls__sys_enter_read     1 11624.858166434     1262 wget                  nr=3, fd=3, buf=3213019456,      count=512
syscalls__sys_exit_read     1 11624.858177924     1262 wget                  nr=3, ret=512
skb__kfree_skb           1 11624.858878188     1262 wget                  skbaddr=3945041280,           location=3243922184, protocol=0
skb__kfree_skb           1 11624.858945608     1262 wget                  skbaddr=3945037824,      location=3243922184, protocol=0
irq__softirq_raise       1 11624.859020942     1262 wget                  vec=TIMER
irq__softirq_entry       1 11624.859076935     1262 wget                  vec=TIMER
irq__softirq_exit        1 11624.859083469     1262 wget                  vec=TIMER
syscalls__sys_enter_read     1 11624.859167565     1262 wget                  nr=3, fd=3, buf=3077701632,      count=1024
syscalls__sys_exit_read     1 11624.859192533     1262 wget                  nr=3, ret=471
syscalls__sys_enter_read     1 11624.859228072     1262 wget                  nr=3, fd=3, buf=3077701632,      count=1024
syscalls__sys_exit_read     1 11624.859233707     1262 wget                  nr=3, ret=0
syscalls__sys_enter_read     1 11624.859573008     1262 wget                  nr=3, fd=3, buf=3213018496,      count=512
syscalls__sys_exit_read     1 11624.859584818     1262 wget                  nr=3, ret=512
syscalls__sys_enter_read     1 11624.859864562     1262 wget                  nr=3, fd=3, buf=3077701632,      count=1024
syscalls__sys_exit_read     1 11624.859888770     1262 wget                  nr=3, ret=1024
syscalls__sys_enter_read     1 11624.859935140     1262 wget                  nr=3, fd=3, buf=3077701632,      count=1024
syscalls__sys_exit_read     1 11624.859944032     1262 wget                  nr=3, ret=1024
这本身并不是很有用。毕竟，我们可以通过在与 perf.data 文件相同的目录中简单地运行不带参数的“perf 脚本”来完成几乎相同的事情。</p>
<p>然而，我们可以用我们想要的任何东西替换生成的函数体中的打印语句，从而使其无限地有用。</p>
<p>作为一个简单的例子，让我们将函数体中的 print 语句替换为一个简单的函数，该函数除了增加每个事件的计数之外什么都不做。当程序针对 perf.data 文件运行时，每次遇到特定事件时，都会增加该事件的计数。例如：</p>
<dl>
<dt>def net__netif_rx(event_name, context, common_cpu,</dt><dd><p>common_secs, common_nsecs, common_pid, common_comm,
skbaddr, len, name):</p>
<blockquote>
<div><p>inc_counts(event_name)</p>
</div></blockquote>
</dd>
</dl>
<p>生成的代码中的每个事件处理函数都被修改为执行此操作。为方便起见，我们定义了一个名为 inc_counts() 的通用函数，每个处理程序都会调用该函数；inc_counts() 使用 ‘counts’ 散列简单地计算每个事件的计数，这是一个专门的散列函数，执行类似 Perl 的自动生存，该功能对于处理跟踪中常用的各种多级聚合非常有用（参见 perf’s有关 Python 语言绑定的文档以获取详细信息）：</p>
<p>counts = autodict()</p>
<dl class="simple">
<dt>def inc_counts(event_name):</dt><dd><dl class="simple">
<dt>try:</dt><dd><p>counts[event_name] += 1</p>
</dd>
<dt>except TypeError:</dt><dd><p>counts[event_name] = 1</p>
</dd>
</dl>
</dd>
</dl>
<p>最后，在跟踪处理运行结束时，我们要打印所有每个事件计数的结果。为此，我们使用特殊的“trace_end()”函数：</p>
<dl class="simple">
<dt>def trace_end():</dt><dd><dl class="simple">
<dt>for event_name, count in counts.iteritems():</dt><dd><p>print “%-40s %10sn” % (event_name, count)</p>
</dd>
</dl>
</dd>
</dl>
<p>最终结果是跟踪中记录的所有事件的摘要：</p>
<p>skb__skb_copy_datagram_iovec                  13148
irq__softirq_entry                             4796
irq__irq_handler_exit                          3805
irq__softirq_exit                              4795
syscalls__sys_enter_write                      8990
net__net_dev_xmit                               652
skb__kfree_skb                                 4047
sched__sched_wakeup                            1155
irq__irq_handler_entry                         3804
irq__softirq_raise                             4799
net__net_dev_queue                              652
syscalls__sys_enter_read                      17599
net__netif_receive_skb                         1743
syscalls__sys_exit_read                       17598
net__netif_rx                                     2
napi__napi_poll                                1877
syscalls__sys_exit_write                       8990
请注意，这与我们从“perf stat”中获得的信息几乎完全相同，这在一定程度上支持了前面提到的想法，即给定正确类型的跟踪数据，可以从中得出更高级别的分析类型摘要.</p>
<p>有关使用“性能脚本”python 绑定的文档。</p>
<p>3.1.2.3系统范围的跟踪和分析
到目前为止的示例都集中在跟踪特定的程序或工作负载上——换句话说，每次分析运行都指定了要在命令行中分析的程序，例如“perf record wget …”。</p>
<p>在单独的 shell 中运行工作负载的同时运行系统范围的配置文件或跟踪也是可能的，并且在许多情况下更有趣。</p>
<p>要进行系统范围的分析或跟踪，通常使用 -a 标志来“执行记录”。</p>
<p>为了证明这一点，打开一个窗口并使用 -a 标志启动配置文件（按 Ctrl-C 停止跟踪）：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf record -g -a
^C[ perf record: Woken up 6 times to write data ]
[ perf record: Captured and wrote 1.400 MB perf.data (~61172 samples) ]
在另一个窗口中，运行 wget 测试：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# wget <a class="reference external" href="https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2">https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2</a>
Connecting to downloads.yoctoproject.org (140.211.169.59:80)
linux-2.6.19.2.tar.b 100% |*******************************| 41727k 0:00:00 ETA
在这里，我们不仅可以看到 wget 加载的条目，还可以看到系统上运行的其他进程的条目：</p>
<p>../_images/perf-systemwide.png
在上面的快照中，我们可以看到源自 libc 的调用链，以及来自 Xorg 的调用链，它表明我们在用户空间中使用了专有的 X 驱动程序（请注意扩展的 Xorg 调用链中存在“PVR”和一些其他无法解析的符号）。</p>
<p>另请注意，我们在上面的快照中同时具有内核和用户空间条目。我们还可以告诉 perf 专注于用户空间，但在记录配置文件时向“循环”硬件计数器提供一个修饰符，在本例中为“u”：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf record -g -a -e cycles:u
^C[ perf record: Woken up 2 times to write data ]
[ perf record: Captured and wrote 0.376 MB perf.data (~16443 samples) ]
../_images/perf-report-cycles-u.png
请注意，在上面的屏幕截图中，我们只看到用户空间条目 ([.])</p>
<p>最后，我们可以在叶节点上按“enter”并选择“Zoom into DSO”菜单项以仅显示与特定 DSO 关联的条目。在下面的屏幕截图中，我们放大了“libc”DSO，它显示了与 libc-xxx.so DSO 关联的所有条目。</p>
<p>../_images/perf-systemwide-libc.png
我们还可以使用系统范围的 -a 开关来进行系统范围的跟踪。在这里，我们将跟踪几个调度程序事件：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf record -a -e sched:sched_switch -e sched:sched_wakeup
^C[ perf record: Woken up 38 times to write data ]
[ perf record: Captured and wrote 9.780 MB perf.data (~427299 samples) ]
我们可以使用不带参数的“perf script”查看原始输出：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf script</p>
<blockquote>
<div><blockquote>
<div><p>perf  1383 [001]  6171.460045: sched_wakeup: comm=kworker/1:1 pid=21 prio=120 success=1 target_cpu=001
perf  1383 [001]  6171.460066: sched_switch: prev_comm=perf prev_pid=1383 prev_prio=120 prev_state=R+ ==&gt; next_comm=kworker/1:1 next_pid=21 next_prio=120</p>
</div></blockquote>
<dl class="simple">
<dt>kworker/1:1    21 [001]  6171.460093: sched_switch: prev_comm=kworker/1:1 prev_pid=21 prev_prio=120 prev_state=S ==&gt; next_comm=perf next_pid=1383 next_prio=120</dt><dd><p>swapper     0 [000]  6171.468063: sched_wakeup: comm=kworker/0:3 pid=1209 prio=120 success=1 target_cpu=000
swapper     0 [000]  6171.468107: sched_switch: prev_comm=swapper/0 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=kworker/0:3 next_pid=1209 next_prio=120</p>
</dd>
<dt>kworker/0:3  1209 [000]  6171.468143: sched_switch: prev_comm=kworker/0:3 prev_pid=1209 prev_prio=120 prev_state=S ==&gt; next_comm=swapper/0 next_pid=0 next_prio=120</dt><dd><p>perf  1383 [001]  6171.470039: sched_wakeup: comm=kworker/1:1 pid=21 prio=120 success=1 target_cpu=001
perf  1383 [001]  6171.470058: sched_switch: prev_comm=perf prev_pid=1383 prev_prio=120 prev_state=R+ ==&gt; next_comm=kworker/1:1 next_pid=21 next_prio=120</p>
</dd>
<dt>kworker/1:1    21 [001]  6171.470082: sched_switch: prev_comm=kworker/1:1 prev_pid=21 prev_prio=120 prev_state=S ==&gt; next_comm=perf next_pid=1383 next_prio=120</dt><dd><p>perf  1383 [001]  6171.480035: sched_wakeup: comm=kworker/1:1 pid=21 prio=120 success=1 target_cpu=001</p>
</dd>
</dl>
</div></blockquote>
<p>3.1.2.3.1过滤
请注意，有很多事件与我们感兴趣的事情没有任何关系，即安排“perf”本身进出或唤醒 perf 的事件。我们可以通过使用 ‘-filter’ 选项摆脱这些 - 对于我们使用 -e 指定的每个事件，我们可以在其后添加一个 -filter 以过滤掉包含具有特定值的字段的跟踪事件：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf record -a -e sched:sched_switch –filter ‘next_comm != perf &amp;&amp; prev_comm != perf’ -e sched:sched_wakeup –filter ‘comm != perf’
^C[ perf record: Woken up 38 times to write data ]
[ perf record: Captured and wrote 9.688 MB perf.data (~423279 samples) ]</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf script</p>
<blockquote>
<div><blockquote>
<div><p>swapper     0 [000]  7932.162180: sched_switch: prev_comm=swapper/0 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=kworker/0:3 next_pid=1209 next_prio=120</p>
</div></blockquote>
<dl>
<dt>kworker/0:3  1209 [000]  7932.162236: sched_switch: prev_comm=kworker/0:3 prev_pid=1209 prev_prio=120 prev_state=S ==&gt; next_comm=swapper/0 next_pid=0 next_prio=120</dt><dd><blockquote>
<div><p>perf  1407 [001]  7932.170048: sched_wakeup: comm=kworker/1:1 pid=21 prio=120 success=1 target_cpu=001
perf  1407 [001]  7932.180044: sched_wakeup: comm=kworker/1:1 pid=21 prio=120 success=1 target_cpu=001
perf  1407 [001]  7932.190038: sched_wakeup: comm=kworker/1:1 pid=21 prio=120 success=1 target_cpu=001
perf  1407 [001]  7932.200044: sched_wakeup: comm=kworker/1:1 pid=21 prio=120 success=1 target_cpu=001
perf  1407 [001]  7932.210044: sched_wakeup: comm=kworker/1:1 pid=21 prio=120 success=1 target_cpu=001
perf  1407 [001]  7932.220044: sched_wakeup: comm=kworker/1:1 pid=21 prio=120 success=1 target_cpu=001</p>
</div></blockquote>
<p>swapper     0 [001]  7932.230111: sched_wakeup: comm=kworker/1:1 pid=21 prio=120 success=1 target_cpu=001
swapper     0 [001]  7932.230146: sched_switch: prev_comm=swapper/1 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=kworker/1:1 next_pid=21 next_prio=120</p>
</dd>
<dt>kworker/1:1    21 [001]  7932.230205: sched_switch: prev_comm=kworker/1:1 prev_pid=21 prev_prio=120 prev_state=S ==&gt; next_comm=swapper/1 next_pid=0 next_prio=120</dt><dd><p>swapper     0 [000]  7932.326109: sched_wakeup: comm=kworker/0:3 pid=1209 prio=120 success=1 target_cpu=000
swapper     0 [000]  7932.326171: sched_switch: prev_comm=swapper/0 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=kworker/0:3 next_pid=1209 next_prio=120</p>
</dd>
</dl>
<p>kworker/0:3  1209 [000]  7932.326214: sched_switch: prev_comm=kworker/0:3 prev_pid=1209 prev_prio=120 prev_state=S ==&gt; next_comm=swapper/0 next_pid=0 next_prio=120</p>
</div></blockquote>
<p>在这种情况下，我们过滤掉了所有在其“comm”或“comm_prev”或“comm_next”字段中具有“perf”的事件。请注意，仍然为 perf 记录了事件，但请注意，这些事件没有过滤字段的“perf”值。从 perf 中完全过滤掉任何东西需要更多的工作，但为了演示如何使用过滤器，它已经足够接近了。</p>
<p>把它绑在一起</p>
<p>这些与跟踪事件子系统定义的事件过滤器完全相同。有关这些事件过滤器的更多讨论，请参阅 ftrace/tracecmd/kernelshark 部分。</p>
<p>把它绑在一起</p>
<p>这些事件过滤器由内核中的专用伪解释器实现，并且是性能设计中不可或缺的一部分，因为它与跟踪有关。基于内核的事件过滤器提供了一种机制来精确限制出现在用户空间中的事件流，在这种情况下，提供与真实编程语言的绑定以对事件流进行后处理是有意义的。这种架构允许在内核和用户空间之间进行智能和灵活的处理分区。将此与其他工具（如 SystemTap）进行对比，后者在内核中完成所有处理，因此需要一种特殊的项目定义语言来适应该设计或 LTTng，一切都被发送到用户空间，因此需要一个超高效的内核到用户空间的传输机制才能正常运行。虽然 perf 当然可以从传输设计的进步中受益，但它从根本上并不依赖于它们。基本上，如果您发现性能跟踪应用程序导致缓冲区 I/O 溢出，这可能意味着您没有充分利用内核过滤引擎。</p>
<p>3.1.2.4使用动态跟踪点
perf 不限于“perf list”列出的固定静态跟踪点集。用户还可以在内核的任何位置添加他们自己的“动态”跟踪点。例如，假设我们想在 do_fork() 上定义我们自己的跟踪点。我们可以使用 ‘perf probe’ perf 子命令来做到这一点：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf probe do_fork
Added new event:</p>
<blockquote>
<div><p>probe:do_fork        (on do_fork)</p>
</div></blockquote>
<p>You can now use it in all perf tools, such as:</p>
<blockquote>
<div><p>perf record -e probe:do_fork -aR sleep 1</p>
</div></blockquote>
<p>通过 ‘perf probe’ 添加一个新的跟踪点会产生一个事件，其中包含 /sys/kernel/debug/tracing/events 中的所有预期文件和格式，与静态跟踪点相同（如在跟踪事件子系统中更详细讨论的）部分：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:/sys/kernel/debug/tracing/events/probe/do_fork# ls -al
drwxr-xr-x    2 root     root             0 Oct 28 11:42 .
drwxr-xr-x    3 root     root             0 Oct 28 11:42 ..
-rw-r–r–    1 root     root             0 Oct 28 11:42 enable
-rw-r–r–    1 root     root             0 Oct 28 11:42 filter
-r–r–r–    1 root     root             0 Oct 28 11:42 format
-r–r–r–    1 root     root             0 Oct 28 11:42 id</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:/sys/kernel/debug/tracing/events/probe/do_fork# cat format
name: do_fork
ID: 944
format:</p>
<blockquote>
<div><p>field:unsigned short common_type;    offset:0;       size:2; signed:0;
field:unsigned char common_flags;    offset:2;       size:1; signed:0;
field:unsigned char common_preempt_count;    offset:3;       size:1; signed:0;
field:int common_pid;        offset:4;       size:4; signed:1;
field:int common_padding;    offset:8;       size:4; signed:1;</p>
<p>field:unsigned long __probe_ip;      offset:12;      size:4; signed:0;</p>
</div></blockquote>
<p>print fmt: “(%lx)”, REC-&gt;__probe_ip
我们可以列出当前存在的所有动态跟踪点：</p>
<dl class="simple">
<dt><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf probe -l</dt><dd><p>probe:do_fork (on do_fork)
probe:schedule (on schedule)</p>
</dd>
</dl>
<p>让我们记录系统范围（’sleep 30’ 是记录系统范围的技巧，但基本上什么都不做，然后在 30 秒后醒来）：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf record -g -a -e probe:do_fork sleep 30
[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.087 MB perf.data (~3812 samples) ]
使用 ‘perf script’ 我们可以看到每个触发的 do_fork 事件：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# perf script</p>
<p># ========
# captured on: Sun Oct 28 11:55:18 2012
# hostname : crownbay
# os release : 3.4.11-yocto-standard
# perf version : 3.4.11
# arch : i686
# nrcpus online : 2
# nrcpus avail : 2
# cpudesc : Intel(R) Atom(TM) CPU E660 &#64; 1.30GHz
# cpuid : GenuineIntel,6,38,1
# total memory : 1017184 kB
# cmdline : /usr/bin/perf record -g -a -e probe:do_fork sleep 30
# event : name = probe:do_fork, type = 2, config = 0x3b0, config1 = 0x0, config2 = 0x0, excl_usr = 0, excl_kern</p>
<blockquote>
<div><p>= 0, id = { 5, 6 }</p>
</div></blockquote>
<p># HEADER_CPU_TOPOLOGY info available, use -I to display
# ========
#</p>
<blockquote>
<div><p>matchbox-deskto  1197 [001] 34211.378318: do_fork: (c1028460)
matchbox-deskto  1295 [001] 34211.380388: do_fork: (c1028460)</p>
<blockquote>
<div><p>pcmanfm  1296 [000] 34211.632350: do_fork: (c1028460)
pcmanfm  1296 [000] 34211.639917: do_fork: (c1028460)</p>
</div></blockquote>
<p>matchbox-deskto  1197 [001] 34217.541603: do_fork: (c1028460)
matchbox-deskto  1299 [001] 34217.543584: do_fork: (c1028460)</p>
<blockquote>
<div><blockquote>
<div><p>gthumb  1300 [001] 34217.697451: do_fork: (c1028460)
gthumb  1300 [001] 34219.085734: do_fork: (c1028460)
gthumb  1300 [000] 34219.121351: do_fork: (c1028460)
gthumb  1300 [001] 34219.264551: do_fork: (c1028460)</p>
</div></blockquote>
<p>pcmanfm  1296 [000] 34219.590380: do_fork: (c1028460)</p>
</div></blockquote>
<p>matchbox-deskto  1197 [001] 34224.955965: do_fork: (c1028460)
matchbox-deskto  1306 [001] 34224.957972: do_fork: (c1028460)
matchbox-termin  1307 [000] 34225.038214: do_fork: (c1028460)
matchbox-termin  1307 [001] 34225.044218: do_fork: (c1028460)
matchbox-termin  1307 [000] 34225.046442: do_fork: (c1028460)
matchbox-deskto  1197 [001] 34237.112138: do_fork: (c1028460)
matchbox-deskto  1311 [001] 34237.114106: do_fork: (c1028460)</p>
<blockquote>
<div><p>gaku  1312 [000] 34237.202388: do_fork: (c1028460)</p>
</div></blockquote>
</div></blockquote>
<p>在同一个文件上使用“性能报告”，我们可以看到在这 30 秒内启动一些程序的调用图：</p>
<p>../_images/perf-probe-do_fork-profile.png
把它绑在一起</p>
<p>跟踪事件子系统以完全相同的方式容纳静态和动态跟踪点——就基础设施而言没有区别。有关跟踪事件子系统的更多详细信息，请参阅 ftrace 部分。</p>
<p>把它绑在一起</p>
<p>动态跟踪点由 kprobes 和 uprobes 在后台实现。kprobes 和 uprobes 也被 SystemTap 使用并且实际上是 SystemTap 的主要关注点。</p>
<p>3.1.3性能文档
可以在此处找到本节中讨论的命令的联机版本手册页：</p>
<p>“性能统计”手册页。</p>
<p>“性能记录”联机帮助页。</p>
<p>“性能报告”手册页。</p>
<p>‘ perf probe’ 联机帮助页。</p>
<p>“性能脚本”手册页。</p>
<p>有关使用“性能脚本”python 绑定的文档。</p>
<p>顶级perf(1) 联机帮助页。</p>
<p>通常，您应该能够通过 perf 本身调用手册页，例如“perf help”或“perf help record”。</p>
<p>要在目标上安装 perf 手册页，请按如下方式修改配置：</p>
<p>IMAGE_INSTALL:append = ” perf perf-doc”
DISTRO_FEATURES:append = ” api-documentation”
文本形式的手册页以及一些其他文件，例如一组示例，也可以在内核树的“perf”目录中找到：</p>
<p>tools/perf/Documentation
在 perf wiki 上还有一个不错的 perf 教程，它比我们在某些领域所做的更详细：Perf Tutorial</p>
<p>3.2 ftrace
“ftrace”字面意思是“ftrace 函数跟踪器”，但实际上这包括许多相关的跟踪器以及它们都使用的基础设施。</p>
<p>3.2.1 ftrace 设置
对于本节，我们假设您已经执行了“常规设置”部分中概述的基本设置。</p>
<p>ftrace、trace-cmd 和 kernelshark 在目标系统上运行，并且可以开箱即用 - 无需额外设置。对于本节的其余部分，我们假设您已经 ssh’ed 到主机并将在目标上运行 ftrace。kernelshark 是一个 GUI 应用程序，如果您对 ssh 使用“-X”选项，您可以让 kernelshark GUI 在目标上运行，但如果需要，可以在主机上远程显示。</p>
<p>3.2.2 ftrace的基本使用
‘ftrace’ 本质上指的是挂载的 debugfs 文件系统的 /tracing 目录中包含的所有内容（Yocto 遵循标准约定并将其挂载在 /sys/kernel/debug 中）。以下是在 Yocto 系统上的 /sys/kernel/debug/tracing 中找到的所有文件的列表：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:/sys/kernel/debug/tracing# ls
README                      kprobe_events               trace
available_events            kprobe_profile              trace_clock
available_filter_functions  options                     trace_marker
available_tracers           per_cpu                     trace_options
buffer_size_kb              printk_formats              trace_pipe
buffer_total_size_kb        saved_cmdlines              tracing_cpumask
current_tracer              set_event                   tracing_enabled
dyn_ftrace_total_info       set_ftrace_filter           tracing_on
enabled_functions           set_ftrace_notrace          tracing_thresh
events                      set_ftrace_pid
free_buffer                 set_graph_function
上面列出的文件用于各种目的——一些与跟踪器本身直接相关，另一些用于设置跟踪选项，还有一些在跟踪器生效时实际包含跟踪输出。有的功能从名字就能猜到，有的需要解释；无论如何，我们将介绍我们在下面看到的一些文件，但有关其他文件的解释，请参阅 ftrace 文档。</p>
<p>我们将从查看一些可用的内置跟踪器开始。</p>
<p>cat’ing ‘available_tracers’ 文件列出了一组可用的跟踪器：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:/sys/kernel/debug/tracing# cat available_tracers
blk function_graph function nop
“current_tracer”文件包含当前有效的跟踪器：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:/sys/kernel/debug/tracing# cat current_tracer
nop
上面的 current_tracer 列表显示“nop”跟踪器已生效，这只是另一种说法，即当前实际上没有任何跟踪器生效。</p>
<p>将可用跟踪器之一回显到 current_tracer 使指定的跟踪器成为当前跟踪器：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:/sys/kernel/debug/tracing# echo function &gt; current_tracer
<a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:/sys/kernel/debug/tracing# cat current_tracer
function
以上将当前跟踪器设置为“功能跟踪器”。该跟踪器跟踪内核中的每个函数调用，并将其作为“跟踪”文件的内容提供。读取“跟踪”文件列出了函数跟踪器已跟踪的当前缓冲函数调用：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:/sys/kernel/debug/tracing# cat trace | less</p>
<p># tracer: function
#
# entries-in-buffer/entries-written: 310629/766471   #P:8
#
#                              _—–=&gt; irqs-off
#                             / _—-=&gt; need-resched
#                            | / _—=&gt; hardirq/softirq
#                            || / _–=&gt; preempt-depth
#                            ||| /     delay
#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION
#              | |       |   ||||       |         |</p>
<blockquote>
<div><p>&lt;idle&gt;-0     [004] d..1   470.867169: ktime_get_real &lt;-intel_idle
&lt;idle&gt;-0     [004] d..1   470.867170: getnstimeofday &lt;-ktime_get_real
&lt;idle&gt;-0     [004] d..1   470.867171: ns_to_timeval &lt;-intel_idle
&lt;idle&gt;-0     [004] d..1   470.867171: ns_to_timespec &lt;-ns_to_timeval
&lt;idle&gt;-0     [004] d..1   470.867172: smp_apic_timer_interrupt &lt;-apic_timer_interrupt
&lt;idle&gt;-0     [004] d..1   470.867172: native_apic_mem_write &lt;-smp_apic_timer_interrupt
&lt;idle&gt;-0     [004] d..1   470.867172: irq_enter &lt;-smp_apic_timer_interrupt
&lt;idle&gt;-0     [004] d..1   470.867172: rcu_irq_enter &lt;-irq_enter
&lt;idle&gt;-0     [004] d..1   470.867173: rcu_idle_exit_common.isra.33 &lt;-rcu_irq_enter
&lt;idle&gt;-0     [004] d..1   470.867173: local_bh_disable &lt;-irq_enter
&lt;idle&gt;-0     [004] d..1   470.867173: add_preempt_count &lt;-local_bh_disable
&lt;idle&gt;-0     [004] d.s1   470.867174: tick_check_idle &lt;-irq_enter
&lt;idle&gt;-0     [004] d.s1   470.867174: tick_check_oneshot_broadcast &lt;-tick_check_idle
&lt;idle&gt;-0     [004] d.s1   470.867174: ktime_get &lt;-tick_check_idle
&lt;idle&gt;-0     [004] d.s1   470.867174: tick_nohz_stop_idle &lt;-tick_check_idle
&lt;idle&gt;-0     [004] d.s1   470.867175: update_ts_time_stats &lt;-tick_nohz_stop_idle
&lt;idle&gt;-0     [004] d.s1   470.867175: nr_iowait_cpu &lt;-update_ts_time_stats
&lt;idle&gt;-0     [004] d.s1   470.867175: tick_do_update_jiffies64 &lt;-tick_check_idle
&lt;idle&gt;-0     [004] d.s1   470.867175: _raw_spin_lock &lt;-tick_do_update_jiffies64
&lt;idle&gt;-0     [004] d.s1   470.867176: add_preempt_count &lt;-_raw_spin_lock
&lt;idle&gt;-0     [004] d.s2   470.867176: do_timer &lt;-tick_do_update_jiffies64
&lt;idle&gt;-0     [004] d.s2   470.867176: _raw_spin_lock &lt;-do_timer
&lt;idle&gt;-0     [004] d.s2   470.867176: add_preempt_count &lt;-_raw_spin_lock
&lt;idle&gt;-0     [004] d.s3   470.867177: ntp_tick_length &lt;-do_timer
&lt;idle&gt;-0     [004] d.s3   470.867177: _raw_spin_lock_irqsave &lt;-ntp_tick_length
.
.
.</p>
</div></blockquote>
<p>上面跟踪中的每一行都显示了给定 cpu 上内核中发生的事情，直至函数调用的详细程度。每个条目显示被调用的函数，然后是其调用者（在箭头之后）。</p>
<p>函数跟踪器可让您非常详细地了解内核在进行跟踪时正在做什么，并且是了解内核代码如何在动态意义上工作的好方法。</p>
<p>把它绑在一起</p>
<p>ftrace 函数跟踪器也可以从 perf 中获得，作为 ftrace:function 跟踪点。</p>
<p>跟踪调用链比它需要的要困难一些 - 幸运的是，有一个函数跟踪器的变体可以显式显示调用链，称为“function_graph”跟踪器：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:/sys/kernel/debug/tracing# echo function_graph &gt; current_tracer
<a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:/sys/kernel/debug/tracing# cat trace | less</p>
<blockquote>
<div><p>tracer: function_graph</p>
<p>CPU  DURATION                  FUNCTION CALLS
|     |   |                     |   |   |   |</p>
</div></blockquote>
<p>7)   0.046 us    |      pick_next_task_fair();
7)   0.043 us    |      pick_next_task_stop();
7)   0.042 us    |      pick_next_task_rt();
7)   0.032 us    |      pick_next_task_fair();
7)   0.030 us    |      pick_next_task_idle();
7)               |      _raw_spin_unlock_irq() {
7)   0.033 us    |        sub_preempt_count();
7)   0.258 us    |      }
7)   0.032 us    |      sub_preempt_count();
7) + 13.341 us   |    } /* __schedule <em>/
7)   0.095 us    |  } /</em> sub_preempt_count <a href="#id109"><span class="problematic" id="id110">*</span></a>/
7)               |  schedule() {
7)               |    __schedule() {
7)   0.060 us    |      add_preempt_count();
7)   0.044 us    |      rcu_note_context_switch();
7)               |      _raw_spin_lock_irq() {
7)   0.033 us    |        add_preempt_count();
7)   0.247 us    |      }
7)               |      idle_balance() {
7)               |        _raw_spin_unlock() {
7)   0.031 us    |          sub_preempt_count();
7)   0.246 us    |        }
7)               |        update_shares() {
7)   0.030 us    |          __rcu_read_lock();
7)   0.029 us    |          __rcu_read_unlock();
7)   0.484 us    |        }
7)   0.030 us    |        __rcu_read_lock();
7)               |        load_balance() {
7)               |          find_busiest_group() {
7)   0.031 us    |            idle_cpu();
7)   0.029 us    |            idle_cpu();
7)   0.035 us    |            idle_cpu();
7)   0.906 us    |          }
7)   1.141 us    |        }
7)   0.022 us    |        msecs_to_jiffies();
7)               |        load_balance() {
7)               |          find_busiest_group() {
7)   0.031 us    |            idle_cpu();
.
.
.
4)   0.062 us    |        msecs_to_jiffies();
4)   0.062 us    |        __rcu_read_unlock();
4)               |        _raw_spin_lock() {
4)   0.073 us    |          add_preempt_count();
4)   0.562 us    |        }
4) + 17.452 us   |      }
4)   0.108 us    |      put_prev_task_fair();
4)   0.102 us    |      pick_next_task_fair();
4)   0.084 us    |      pick_next_task_stop();
4)   0.075 us    |      pick_next_task_rt();
4)   0.062 us    |      pick_next_task_fair();
4)   0.066 us    |      pick_next_task_idle();
——————————————
4)   kworker-74   =&gt;    &lt;idle&gt;-0
——————————————</p>
<p>4)               |      finish_task_switch() {
4)               |        _raw_spin_unlock_irq() {
4)   0.100 us    |          sub_preempt_count();
4)   0.582 us    |        }
4)   1.105 us    |      }
4)   0.088 us    |      sub_preempt_count();
4) ! 100.066 us  |    }
.
.
.
3)               |  sys_ioctl() {
3)   0.083 us    |    fget_light();
3)               |    security_file_ioctl() {
3)   0.066 us    |      cap_file_ioctl();
3)   0.562 us    |    }
3)               |    do_vfs_ioctl() {
3)               |      drm_ioctl() {
3)   0.075 us    |        drm_ut_debug_printk();
3)               |        i915_gem_pwrite_ioctl() {
3)               |          i915_mutex_lock_interruptible() {
3)   0.070 us    |            mutex_lock_interruptible();
3)   0.570 us    |          }
3)               |          drm_gem_object_lookup() {
3)               |            _raw_spin_lock() {
3)   0.080 us    |              add_preempt_count();
3)   0.620 us    |            }
3)               |            _raw_spin_unlock() {
3)   0.085 us    |              sub_preempt_count();
3)   0.562 us    |            }
3)   2.149 us    |          }
3)   0.133 us    |          i915_gem_object_pin();
3)               |          i915_gem_object_set_to_gtt_domain() {
3)   0.065 us    |            i915_gem_object_flush_gpu_write_domain();
3)   0.065 us    |            i915_gem_object_wait_rendering();
3)   0.062 us    |            i915_gem_object_flush_cpu_write_domain();
3)   1.612 us    |          }
3)               |          i915_gem_object_put_fence() {
3)   0.097 us    |            i915_gem_object_flush_fence.constprop.36();
3)   0.645 us    |          }
3)   0.070 us    |          add_preempt_count();
3)   0.070 us    |          sub_preempt_count();
3)   0.073 us    |          i915_gem_object_unpin();
3)   0.068 us    |          mutex_unlock();
3)   9.924 us    |        }
3) + 11.236 us   |      }
3) + 11.770 us   |    }
3) + 13.784 us   |  }
3)               |  sys_ioctl() {
如您所见，function_graph 显示更容易理解。另请注意，除了函数调用和关联的大括号之外，其他事件（例如调度程序事件）也会显示在上下文中。事实上，您可以通过简单地启用这些事件，在下一节中描述的跟踪事件子系统中自由地包含任何可用的跟踪点，它们将出现在函数图显示的上下文中。理解内核动态的非常强大的工具。</p>
<p>另请注意，显示屏左侧有各种注释。例如，如果执行给定函数所花费的总时间高于某个阈值，则左侧会出现一个感叹号或加号。有关所有这些字段的详细信息，请参阅 ftrace 文档。</p>
<p>3.2.3 “跟踪事件”子系统
/sys/kernel/debug/tracing 目录中包含的一个特别重要的目录是“events”子目录，它包含系统中每个跟踪点的表示。列出 ‘events’ 子目录的内容，我们主要看到另一组子目录：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:/sys/kernel/debug/tracing# cd events
<a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:/sys/kernel/debug/tracing/events# ls -al
drwxr-xr-x   38 root     root             0 Nov 14 23:19 .
drwxr-xr-x    5 root     root             0 Nov 14 23:19 ..
drwxr-xr-x   19 root     root             0 Nov 14 23:19 block
drwxr-xr-x   32 root     root             0 Nov 14 23:19 btrfs
drwxr-xr-x    5 root     root             0 Nov 14 23:19 drm
-rw-r–r–    1 root     root             0 Nov 14 23:19 enable
drwxr-xr-x   40 root     root             0 Nov 14 23:19 ext3
drwxr-xr-x   79 root     root             0 Nov 14 23:19 ext4
drwxr-xr-x   14 root     root             0 Nov 14 23:19 ftrace
drwxr-xr-x    8 root     root             0 Nov 14 23:19 hda
-r–r–r–    1 root     root             0 Nov 14 23:19 header_event
-r–r–r–    1 root     root             0 Nov 14 23:19 header_page
drwxr-xr-x   25 root     root             0 Nov 14 23:19 i915
drwxr-xr-x    7 root     root             0 Nov 14 23:19 irq
drwxr-xr-x   12 root     root             0 Nov 14 23:19 jbd
drwxr-xr-x   14 root     root             0 Nov 14 23:19 jbd2
drwxr-xr-x   14 root     root             0 Nov 14 23:19 kmem
drwxr-xr-x    7 root     root             0 Nov 14 23:19 module
drwxr-xr-x    3 root     root             0 Nov 14 23:19 napi
drwxr-xr-x    6 root     root             0 Nov 14 23:19 net
drwxr-xr-x    3 root     root             0 Nov 14 23:19 oom
drwxr-xr-x   12 root     root             0 Nov 14 23:19 power
drwxr-xr-x    3 root     root             0 Nov 14 23:19 printk
drwxr-xr-x    8 root     root             0 Nov 14 23:19 random
drwxr-xr-x    4 root     root             0 Nov 14 23:19 raw_syscalls
drwxr-xr-x    3 root     root             0 Nov 14 23:19 rcu
drwxr-xr-x    6 root     root             0 Nov 14 23:19 rpm
drwxr-xr-x   20 root     root             0 Nov 14 23:19 sched
drwxr-xr-x    7 root     root             0 Nov 14 23:19 scsi
drwxr-xr-x    4 root     root             0 Nov 14 23:19 signal
drwxr-xr-x    5 root     root             0 Nov 14 23:19 skb
drwxr-xr-x    4 root     root             0 Nov 14 23:19 sock
drwxr-xr-x   10 root     root             0 Nov 14 23:19 sunrpc
drwxr-xr-x  538 root     root             0 Nov 14 23:19 syscalls
drwxr-xr-x    4 root     root             0 Nov 14 23:19 task
drwxr-xr-x   14 root     root             0 Nov 14 23:19 timer
drwxr-xr-x    3 root     root             0 Nov 14 23:19 udp
drwxr-xr-x   21 root     root             0 Nov 14 23:19 vmscan
drwxr-xr-x    3 root     root             0 Nov 14 23:19 vsyscall
drwxr-xr-x    6 root     root             0 Nov 14 23:19 workqueue
drwxr-xr-x   26 root     root             0 Nov 14 23:19 writeback
这些子目录中的每一个都对应一个“子系统”，并且又包含更多子目录，每个子目录最终都对应一个跟踪点。例如，这里是“kmem”子系统的内容：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:/sys/kernel/debug/tracing/events# cd kmem
<a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:/sys/kernel/debug/tracing/events/kmem# ls -al
drwxr-xr-x   14 root     root             0 Nov 14 23:19 .
drwxr-xr-x   38 root     root             0 Nov 14 23:19 ..
-rw-r–r–    1 root     root             0 Nov 14 23:19 enable
-rw-r–r–    1 root     root             0 Nov 14 23:19 filter
drwxr-xr-x    2 root     root             0 Nov 14 23:19 kfree
drwxr-xr-x    2 root     root             0 Nov 14 23:19 kmalloc
drwxr-xr-x    2 root     root             0 Nov 14 23:19 kmalloc_node
drwxr-xr-x    2 root     root             0 Nov 14 23:19 kmem_cache_alloc
drwxr-xr-x    2 root     root             0 Nov 14 23:19 kmem_cache_alloc_node
drwxr-xr-x    2 root     root             0 Nov 14 23:19 kmem_cache_free
drwxr-xr-x    2 root     root             0 Nov 14 23:19 mm_page_alloc
drwxr-xr-x    2 root     root             0 Nov 14 23:19 mm_page_alloc_extfrag
drwxr-xr-x    2 root     root             0 Nov 14 23:19 mm_page_alloc_zone_locked
drwxr-xr-x    2 root     root             0 Nov 14 23:19 mm_page_free
drwxr-xr-x    2 root     root             0 Nov 14 23:19 mm_page_free_batched
drwxr-xr-x    2 root     root             0 Nov 14 23:19 mm_page_pcpu_drain
让我们看看特定跟踪点的子目录中的内容，在本例中是 kmalloc 的子目录：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:/sys/kernel/debug/tracing/events/kmem# cd kmalloc
<a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:/sys/kernel/debug/tracing/events/kmem/kmalloc# ls -al
drwxr-xr-x    2 root     root             0 Nov 14 23:19 .
drwxr-xr-x   14 root     root             0 Nov 14 23:19 ..
-rw-r–r–    1 root     root             0 Nov 14 23:19 enable
-rw-r–r–    1 root     root             0 Nov 14 23:19 filter
-r–r–r–    1 root     root             0 Nov 14 23:19 format
-r–r–r–    1 root     root             0 Nov 14 23:19 id
跟踪点的“格式”文件描述了内存中的事件，现在各种跟踪工具使用这些跟踪点来解析事件并理解它，以及允许工具的“打印 fmt”字段像 ftrace 一样将事件显示为文本。以下是 kmalloc 事件的格式：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:/sys/kernel/debug/tracing/events/kmem/kmalloc# cat format
name: kmalloc
ID: 313
format:</p>
<blockquote>
<div><p>field:unsigned short common_type;    offset:0;       size:2; signed:0;
field:unsigned char common_flags;    offset:2;       size:1; signed:0;
field:unsigned char common_preempt_count;    offset:3;       size:1; signed:0;
field:int common_pid;        offset:4;       size:4; signed:1;
field:int common_padding;    offset:8;       size:4; signed:1;</p>
<p>field:unsigned long call_site;       offset:16;      size:8; signed:0;
field:const void * ptr;      offset:24;      size:8; signed:0;
field:size_t bytes_req;      offset:32;      size:8; signed:0;
field:size_t bytes_alloc;    offset:40;      size:8; signed:0;
field:gfp_t gfp_flags;       offset:48;      size:4; signed:0;</p>
</div></blockquote>
<p>print fmt: “call_site=%lx ptr=%p bytes_req=%zu bytes_alloc=%zu gfp_flags=%s”, REC-&gt;call_site, REC-&gt;ptr, REC-&gt;bytes_req, REC-&gt;bytes_alloc,
(REC-&gt;gfp_flags) ? __print_flags(REC-&gt;gfp_flags, “|”, {(unsigned long)(((( gfp_t)0x10u) | (( gfp_t)0x40u) | (( gfp_t)0x80u) | ((
gfp_t)0x20000u) | (( gfp_t)0x02u) | (( gfp_t)0x08u)) | (( gfp_t)0x4000u) | (( gfp_t)0x10000u) | (( gfp_t)0x1000u) | (( gfp_t)0x200u) | ((
gfp_t)0x400000u)), “GFP_TRANSHUGE”}, {(unsigned long)((( gfp_t)0x10u) | (( gfp_t)0x40u) | (( gfp_t)0x80u) | (( gfp_t)0x20000u) | ((
gfp_t)0x02u) | (( gfp_t)0x08u)), “GFP_HIGHUSER_MOVABLE”}, {(unsigned long)((( gfp_t)0x10u) | (( gfp_t)0x40u) | (( gfp_t)0x80u) | ((
gfp_t)0x20000u) | (( gfp_t)0x02u)), “GFP_HIGHUSER”}, {(unsigned long)((( gfp_t)0x10u) | (( gfp_t)0x40u) | (( gfp_t)0x80u) | ((
gfp_t)0x20000u)), “GFP_USER”}, {(unsigned long)((( gfp_t)0x10u) | (( gfp_t)0x40u) | (( gfp_t)0x80u) | (( gfp_t)0x80000u)), GFP_TEMPORARY”},
{(unsigned long)((( gfp_t)0x10u) | (( gfp_t)0x40u) | (( gfp_t)0x80u)), “GFP_KERNEL”}, {(unsigned long)((( gfp_t)0x10u) | (( gfp_t)0x40u)),
“GFP_NOFS”}, {(unsigned long)((( gfp_t)0x20u)), “GFP_ATOMIC”}, {(unsigned long)((( gfp_t)0x10u)), “GFP_NOIO”}, {(unsigned long)((
gfp_t)0x20u), “GFP_HIGH”}, {(unsigned long)(( gfp_t)0x10u), “GFP_WAIT”}, {(unsigned long)(( gfp_t)0x40u), “GFP_IO”}, {(unsigned long)((
gfp_t)0x100u), “GFP_COLD”}, {(unsigned long)(( gfp_t)0x200u), “GFP_NOWARN”}, {(unsigned long)(( gfp_t)0x400u), “GFP_REPEAT”}, {(unsigned
long)(( gfp_t)0x800u), “GFP_NOFAIL”}, {(unsigned long)(( gfp_t)0x1000u), “GFP_NORETRY”},      {(unsigned long)(( gfp_t)0x4000u), “GFP_COMP”},
{(unsigned long)(( gfp_t)0x8000u), “GFP_ZERO”}, {(unsigned long)(( gfp_t)0x10000u), “GFP_NOMEMALLOC”}, {(unsigned long)(( gfp_t)0x20000u),
“GFP_HARDWALL”}, {(unsigned long)(( gfp_t)0x40000u), “GFP_THISNODE”}, {(unsigned long)(( gfp_t)0x80000u), “GFP_RECLAIMABLE”}, {(unsigned
long)(( gfp_t)0x08u), “GFP_MOVABLE”}, {(unsigned long)(( gfp_t)0), “GFP_NOTRACK”}, {(unsigned long)(( gfp_t)0x400000u), “GFP_NO_KSWAPD”},
{(unsigned long)(( gfp_t)0x800000u), “GFP_OTHER_NODE”} ) : “GFP_NOWAIT”
跟踪点目录中的“启用”文件允许用户（或 trace-cmd 等工具）实际打开和关闭跟踪点。启用后，相应的跟踪点将开始出现在前面描述的 ftrace ‘trace’ 文件中。例如，这会打开 kmalloc 跟踪点：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:/sys/kernel/debug/tracing/events/kmem/kmalloc# echo 1 &gt; enable
目前，我们对功能跟踪器或其他可能有效的跟踪器不感兴趣，所以我们首先将其关闭，但如果这样做，我们仍然需要打开跟踪以查看事件输出缓冲区：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:/sys/kernel/debug/tracing# echo nop &gt; current_tracer
<a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:/sys/kernel/debug/tracing# echo 1 &gt; tracing_on
现在，如果我们查看 ‘trace’ 文件，除了刚刚打开的 kmalloc 事件，我们什么也看不到：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:/sys/kernel/debug/tracing# cat trace | less
# tracer: nop
#
# entries-in-buffer/entries-written: 1897/1897   #P:8
#
#                              _—–=&gt; irqs-off
#                             / _—-=&gt; need-resched
#                            | / _—=&gt; hardirq/softirq
#                            || / _–=&gt; preempt-depth
#                            ||| /     delay
#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION
#              | |       |   ||||       |         |</p>
<blockquote>
<div><dl class="simple">
<dt>dropbear-1465  [000] …1 18154.620753: kmalloc: call_site=ffffffff816650d4 ptr=ffff8800729c3000 bytes_req=2048 bytes_alloc=2048 gfp_flags=GFP_KERNEL</dt><dd><p>&lt;idle&gt;-0     [000] ..s3 18154.621640: kmalloc: call_site=ffffffff81619b36 ptr=ffff88006d555800 bytes_req=512 bytes_alloc=512 gfp_flags=GFP_ATOMIC
&lt;idle&gt;-0     [000] ..s3 18154.621656: kmalloc: call_site=ffffffff81619b36 ptr=ffff88006d555800 bytes_req=512 bytes_alloc=512 gfp_flags=GFP_ATOMIC</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>matchbox-termin-1361  [001] …1 18154.755472: kmalloc: call_site=ffffffff81614050 ptr=ffff88006d5f0e00 bytes_req=512 bytes_alloc=512 gfp_flags=GFP_KERNEL|GFP_REPEAT</dt><dd><p>Xorg-1264  [002] …1 18154.755581: kmalloc: call_site=ffffffff8141abe8 ptr=ffff8800734f4cc0 bytes_req=168 bytes_alloc=192 gfp_flags=GFP_KERNEL|GFP_NOWARN|GFP_NORETRY
Xorg-1264  [002] …1 18154.755583: kmalloc: call_site=ffffffff814192a3 ptr=ffff88001f822520 bytes_req=24 bytes_alloc=32 gfp_flags=GFP_KERNEL|GFP_ZERO
Xorg-1264  [002] …1 18154.755589: kmalloc: call_site=ffffffff81419edb ptr=ffff8800721a2f00 bytes_req=64 bytes_alloc=64 gfp_flags=GFP_KERNEL|GFP_ZERO</p>
</dd>
<dt>matchbox-termin-1361  [001] …1 18155.354594: kmalloc: call_site=ffffffff81614050 ptr=ffff88006db35400 bytes_req=576 bytes_alloc=1024 gfp_flags=GFP_KERNEL|GFP_REPEAT</dt><dd><blockquote>
<div><blockquote>
<div><p>Xorg-1264  [002] …1 18155.354703: kmalloc: call_site=ffffffff8141abe8 ptr=ffff8800734f4cc0 bytes_req=168 bytes_alloc=192 gfp_flags=GFP_KERNEL|GFP_NOWARN|GFP_NORETRY
Xorg-1264  [002] …1 18155.354705: kmalloc: call_site=ffffffff814192a3 ptr=ffff88001f822520 bytes_req=24 bytes_alloc=32 gfp_flags=GFP_KERNEL|GFP_ZERO
Xorg-1264  [002] …1 18155.354711: kmalloc: call_site=ffffffff81419edb ptr=ffff8800721a2f00 bytes_req=64 bytes_alloc=64 gfp_flags=GFP_KERNEL|GFP_ZERO</p>
</div></blockquote>
<p>&lt;idle&gt;-0     [000] ..s3 18155.673319: kmalloc: call_site=ffffffff81619b36 ptr=ffff88006d555800 bytes_req=512 bytes_alloc=512 gfp_flags=GFP_ATOMIC</p>
</div></blockquote>
<dl class="simple">
<dt>dropbear-1465  [000] …1 18155.673525: kmalloc: call_site=ffffffff816650d4 ptr=ffff8800729c3000 bytes_req=2048 bytes_alloc=2048 gfp_flags=GFP_KERNEL</dt><dd><p>&lt;idle&gt;-0     [000] ..s3 18155.674821: kmalloc: call_site=ffffffff81619b36 ptr=ffff88006d554800 bytes_req=512 bytes_alloc=512 gfp_flags=GFP_ATOMIC
&lt;idle&gt;-0     [000] ..s3 18155.793014: kmalloc: call_site=ffffffff81619b36 ptr=ffff88006d554800 bytes_req=512 bytes_alloc=512 gfp_flags=GFP_ATOMIC</p>
</dd>
<dt>dropbear-1465  [000] …1 18155.793219: kmalloc: call_site=ffffffff816650d4 ptr=ffff8800729c3000 bytes_req=2048 bytes_alloc=2048 gfp_flags=GFP_KERNEL</dt><dd><p>&lt;idle&gt;-0     [000] ..s3 18155.794147: kmalloc: call_site=ffffffff81619b36 ptr=ffff88006d555800 bytes_req=512 bytes_alloc=512 gfp_flags=GFP_ATOMIC
&lt;idle&gt;-0     [000] ..s3 18155.936705: kmalloc: call_site=ffffffff81619b36 ptr=ffff88006d555800 bytes_req=512 bytes_alloc=512 gfp_flags=GFP_ATOMIC</p>
</dd>
<dt>dropbear-1465  [000] …1 18155.936910: kmalloc: call_site=ffffffff816650d4 ptr=ffff8800729c3000 bytes_req=2048 bytes_alloc=2048 gfp_flags=GFP_KERNEL</dt><dd><p>&lt;idle&gt;-0     [000] ..s3 18155.937869: kmalloc: call_site=ffffffff81619b36 ptr=ffff88006d554800 bytes_req=512 bytes_alloc=512 gfp_flags=GFP_ATOMIC</p>
</dd>
</dl>
</dd>
<dt>matchbox-termin-1361  [001] …1 18155.953667: kmalloc: call_site=ffffffff81614050 ptr=ffff88006d5f2000 bytes_req=512 bytes_alloc=512 gfp_flags=GFP_KERNEL|GFP_REPEAT</dt><dd><blockquote>
<div><blockquote>
<div><p>Xorg-1264  [002] …1 18155.953775: kmalloc: call_site=ffffffff8141abe8 ptr=ffff8800734f4cc0 bytes_req=168 bytes_alloc=192 gfp_flags=GFP_KERNEL|GFP_NOWARN|GFP_NORETRY
Xorg-1264  [002] …1 18155.953777: kmalloc: call_site=ffffffff814192a3 ptr=ffff88001f822520 bytes_req=24 bytes_alloc=32 gfp_flags=GFP_KERNEL|GFP_ZERO
Xorg-1264  [002] …1 18155.953783: kmalloc: call_site=ffffffff81419edb ptr=ffff8800721a2f00 bytes_req=64 bytes_alloc=64 gfp_flags=GFP_KERNEL|GFP_ZERO</p>
</div></blockquote>
<p>&lt;idle&gt;-0     [000] ..s3 18156.176053: kmalloc: call_site=ffffffff81619b36 ptr=ffff88006d554800 bytes_req=512 bytes_alloc=512 gfp_flags=GFP_ATOMIC</p>
</div></blockquote>
<dl class="simple">
<dt>dropbear-1465  [000] …1 18156.176257: kmalloc: call_site=ffffffff816650d4 ptr=ffff8800729c3000 bytes_req=2048 bytes_alloc=2048 gfp_flags=GFP_KERNEL</dt><dd><p>&lt;idle&gt;-0     [000] ..s3 18156.177717: kmalloc: call_site=ffffffff81619b36 ptr=ffff88006d555800 bytes_req=512 bytes_alloc=512 gfp_flags=GFP_ATOMIC
&lt;idle&gt;-0     [000] ..s3 18156.399229: kmalloc: call_site=ffffffff81619b36 ptr=ffff88006d555800 bytes_req=512 bytes_alloc=512 gfp_flags=GFP_ATOMIC</p>
</dd>
<dt>dropbear-1465  [000] …1 18156.399434: kmalloc: call_site=ffffffff816650d4 ptr=ffff8800729c3000 bytes_http://rostedt.homelinux.com/kernelshark/req=2048 bytes_alloc=2048 gfp_flags=GFP_KERNEL</dt><dd><p>&lt;idle&gt;-0     [000] ..s3 18156.400660: kmalloc: call_site=ffffffff81619b36 ptr=ffff88006d554800 bytes_req=512 bytes_alloc=512 gfp_flags=GFP_ATOMIC</p>
</dd>
</dl>
</dd>
</dl>
<p>matchbox-termin-1361  [001] …1 18156.552800: kmalloc: call_site=ffffffff81614050 ptr=ffff88006db34800 bytes_req=576 bytes_alloc=1024 gfp_flags=GFP_KERNEL|GFP_REPEAT
要再次禁用 kmalloc 事件，我们需要将 0 发送到启用文件：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:/sys/kernel/debug/tracing/events/kmem/kmalloc# echo 0 &gt; enable
您可以启用任意数量的事件或完整的子系统（通过使用子系统目录中的“启用”文件），并通过启用尽可能多的适当跟踪点来获得系统中正在发生的事情的任意细粒度概念。</p>
<p>本 HOWTO 中描述的许多工具就是这样做的，包括下一节中的 trace-cmd 和 kernelshark。</p>
<p>把它绑在一起</p>
<p>这些跟踪点及其表示不仅被 ftrace 使用，而且被本文档中涵盖的许多其他工具使用，它们构成了 Linux 中可用的各种跟踪器的中心集成点。它们构成以下工具的中心部分：perf、lttng、ftrace、blktrace 和 SystemTap</p>
<p>把它绑在一起</p>
<p>最终，当前在 /sys/kernel/debug/tracing 中可用的所有特殊用途的跟踪器都将被删除并替换为基于“跟踪事件”子系统的等效跟踪器。</p>
<p>3.2.4 trace-cmd/kernelshark
trace-cmd 本质上是一个扩展的命令行“包装器”界面，它隐藏了 /sys/kernel/debug/tracing 中所有单个文件的详细信息，允许用户在 /sys/kernel/debug/tracing 中指定特定的特定事件/events/ 子目录并收集跟踪信息，避免直接处理这些细节。</p>
<p>作为最重要的另一层，kernelshark 提供了一个 GUI，允许用户使用直观的界面启动和停止跟踪并指定事件集，并将输出作为跟踪事件和每个 CPU 的图形显示查看。它直接使用“trace-cmd”作为完成所有工作的管道（并实际显示它使用的 trace-cmd 命令，我们将看到）。</p>
<p>要使用 kernelshark 启动跟踪，首先启动 kernelshark：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;sugarbay">root<span>&#64;</span>sugarbay</a>:~# kernelshark
然后通过从 kernelshark 菜单中选择来调出“Capture”对话框：</p>
<p>Capture | Record
这将显示以下对话框，允许您选择一个或多个事件（甚至一个或多个完整的子系统）进行跟踪：</p>
<p>../_images/kernelshark-choose-events.png
请注意，这些事件集与前面跟踪事件子系统部分中描述的事件集完全相同，实际上是 trace-cmd 为 kernelshark 获取它们的地方。</p>
<p>在上面的屏幕截图中，我们决定稍微探索一下图形子系统，因此选择跟踪“i915”和“drm”子系统中包含的所有跟踪点。</p>
<p>之后，我们可以使用对话框右下角的“运行”和“停止”按钮来开始和停止跟踪（跟踪开始后，相同的按钮将变成“停止”按钮）：</p>
<p>../_images/kernelshark-输出-显示.png
请注意，右侧窗格显示了用于运行跟踪的确切 trace-cmd 命令行，以及 trace-cmd 运行的结果。</p>
<p>一旦按下“停止”按钮，图形视图就会神奇地充满跟踪数据的彩色 per-cpu 显示，以及下面的详细事件列表：</p>
<p>../_images/kernelshark-i915-display.png
这是另一个示例，这次是跟踪“所有事件”产生的显示：</p>
<p>../_images/kernelshark-all.png
该工具非常不言自明，但有关浏览数据的更多详细信息，请参阅kernelshark 网站。</p>
<p>3.2.5 ftrace 文档
ftrace 的文档可以在内核文档目录中找到：</p>
<p>Documentation/trace/ftrace.txt
跟踪事件子系统的文档也可以在内核文档目录中找到：</p>
<p>Documentation/trace/events.txt
在 LWN 上有一系列关于使用 ftrace 和 trace-cmd 的精彩文章：</p>
<p>使用 Ftrace 调试内核 - 第 1 部分</p>
<p>使用 Ftrace 调试内核 - 第 2 部分</p>
<p>Ftrace 函数跟踪器的秘密</p>
<p>trace-cmd：Ftrace 的前端</p>
<p>这里有更详细的文档 kernelshark 用法： KernelShark</p>
<p>可以在 /sys/kernel/debug/tracing/README.</p>
<p>3.3 systemtap
SystemTap 是一个系统范围的基于脚本的跟踪和分析工具。</p>
<p>SystemTap 脚本是在内核中执行的类 C 程序，用于收集/打印/聚合从它们最终被调用的上下文中提取的数据。</p>
<p>例如，SystemTap 教程中的这个探针在系统 open()sa 文件上的任何进程每次都简单地打印一行。对于每一行，它打印打开文件的程序的可执行名称，以及它的 PID，以及它打开（或试图打开）的文件的名称，它从 open 系统调用的 argstr 中提取。</p>
<p>probe syscall.open
{</p>
<blockquote>
<div><p>printf (“%s(%d) open (%s)n”, execname(), pid(), argstr)</p>
</div></blockquote>
<p>}</p>
<p>probe timer.ms(4000) # after 4 seconds
{</p>
<blockquote>
<div><p>exit ()</p>
</div></blockquote>
<p>}
通常，要执行此探测，您只需在要探测的系统上安装 systemtap，然后直接在该系统上运行探测，例如假设包含上述文本的文件名为 trace_open.stp：</p>
<p># stap trace_open.stp
systemtap 在幕后运行这个探针是 1) 解析探针并将其转换为等效的“C”形式，2) 将“C”形式编译成内核模块，3) 将模块插入内核，这它，以及 4) 收集探针生成的数据并将其显示给用户。</p>
<p>为了完成步骤 1 和 2，“stap”程序需要访问内核构建系统，该系统生成了被探测系统正在运行的内核。对于典型的嵌入式系统（“目标”），不幸的是内核构建系统通常不是目标上运行的映像的一部分。但是，它通常在生成目标图像的“主机”系统上可用；在这种情况下，步骤 1 和 2 在主机系统上执行，步骤 3 和 4 在目标系统上执行，仅使用 systemtap ‘runtime’。</p>
<p>Yocto 中的 systemtap 支持假定仅在目标上运行第 3 步和第 4 步；可以在目标上执行所有操作，但本节仅假设典型的嵌入式用例。</p>
<p>因此，基本上为了在目标上运行 systemtap 脚本，您需要做的是 1) 在主机系统上，将探针编译成对目标有意义的内核模块，2) 将模块复制到目标系统上，然后3) 将模块插入目标内核，将其武装起来，以及 4) 收集探针生成的数据并将其显示给用户。</p>
<p>3.3.1 systemtap设置
这些是很多步骤和很多细节，但幸运的是 Yocto 包含一个名为“crosstap”的脚本，它将处理这些细节，允许您在远程目标上简单地执行一个 systemtap 脚本，并在必要时使用参数。</p>
<p>但是，为了从远程主机执行此操作，您需要有权访问您引导的映像的构建。如果您在主机上运行脚本而没有进行构建，“crosstap”脚本提供了有关如何执行此操作的详细信息：</p>
<p>$ crosstap <a class="reference external" href="mailto:root&#37;&#52;&#48;192&#46;168&#46;1&#46;88">root<span>&#64;</span>192<span>&#46;</span>168<span>&#46;</span>1<span>&#46;</span>88</a> trace_open.stp</p>
<p>Error: No target kernel build found.
Did you forget to create a local build of your image?</p>
<p>‘crosstap’ requires a local sdk build of the target system
(or a build that includes ‘tools-profile’) in order to build
kernel modules that can probe the target system.</p>
<dl>
<dt>Practically speaking, that means you need to do the following:</dt><dd><ul class="simple">
<li><p>If you’re running a pre-built image, download the release
and/or BSP tarballs used to build the image.</p></li>
<li><p>If you’re working from git sources, just clone the metadata
and BSP layers needed to build the image you’ll be booting.</p></li>
<li><p>Make sure you’re properly set up to build a new image (see
the BSP README and/or the widely available basic documentation
that discusses how to build images).</p></li>
<li><dl class="simple">
<dt>Build an -sdk version of the image e.g.:</dt><dd><p>$ bitbake core-image-sato-sdk</p>
</dd>
</dl>
</li>
</ul>
<p>OR
- Build a non-sdk image but include the profiling tools:</p>
<blockquote>
<div><dl class="simple">
<dt>[ edit local.conf and add ‘tools-profile’ to the end of</dt><dd><p>the EXTRA_IMAGE_FEATURES variable ]</p>
</dd>
</dl>
<p>$ bitbake core-image-sato</p>
</div></blockquote>
</dd>
</dl>
<p>Once you’ve build the image on the host system, you’re ready to
boot it (or the equivalent pre-built image) and use ‘crosstap’
to probe it (you need to source the environment as usual first):</p>
<blockquote>
<div><p>$ source oe-init-build-env
$ cd ~/my/systemtap/scripts
$ crosstap <a class="reference external" href="mailto:root&#37;&#52;&#48;192&#46;168&#46;1&#46;xxx">root<span>&#64;</span>192<span>&#46;</span>168<span>&#46;</span>1<span>&#46;</span>xxx</a> myscript.stp</p>
</div></blockquote>
<p>笔记</p>
<p>SystemTap 使用“crosstap”，假设您可以建立到远程目标的 ssh 连接。有关验证 ssh 连接的详细信息，请参阅 crosstap wiki 页面。此外，在 <a href="#id111"><span class="problematic" id="id112">*</span></a>-minimal 映像中默认不启用通过 ssh 进入目标系统的功能。</p>
<p>因此，基本上您需要做的是构建一个 SDK 映像或使用本手册“常规设置”部分中详细说明的“工具配置文件”的映像，然后启动生成的目标映像。</p>
<p>笔记</p>
<p>如果你有一个包含多台机器的构建目录，你需要在 local.conf 中选择你要连接的机器，并且该机器的构建目录中的内核必须与引导系统上的内核完全匹配，否则你会得到当您尝试调用脚本时，上面的“crosstap”消息。</p>
<p>3.3.2在目标上运行脚本
完成后，您应该能够在目标上运行 systemtap 脚本：</p>
<p>$ cd /path/to/yocto
$ source oe-init-build-env</p>
<p>### Shell environment set up for builds. ###</p>
<p>You can now run ‘bitbake &lt;target&gt;’</p>
<dl class="simple">
<dt>Common targets are:</dt><dd><p>core-image-minimal
core-image-sato
meta-toolchain
meta-ide-support</p>
</dd>
</dl>
<p>You can also run generated QEMU images with a command like ‘runqemu qemux86-64’
完成此操作后，您可以 cd 到包含脚本的任何目录并使用“crosstap”运行脚本：</p>
<p>$ cd /path/to/my/systemap/script
$ crosstap <a class="reference external" href="mailto:root&#37;&#52;&#48;192&#46;168&#46;7&#46;2">root<span>&#64;</span>192<span>&#46;</span>168<span>&#46;</span>7<span>&#46;</span>2</a> trace_open.stp
如果您在连接到目标时遇到错误，例如：</p>
<p>$ crosstap <a class="reference external" href="mailto:root&#37;&#52;&#48;192&#46;168&#46;7&#46;2">root<span>&#64;</span>192<span>&#46;</span>168<span>&#46;</span>7<span>&#46;</span>2</a> trace_open.stp
error establishing ssh connection on remote <a class="reference external" href="mailto:'root&#37;&#52;&#48;192&#46;168&#46;7&#46;2">‘root<span>&#64;</span>192<span>&#46;</span>168<span>&#46;</span>7<span>&#46;</span>2</a>’
尝试 ssh’ing 到目标，看看会发生什么：</p>
<p>$ ssh <a class="reference external" href="mailto:root&#37;&#52;&#48;192&#46;168&#46;7&#46;2">root<span>&#64;</span>192<span>&#46;</span>168<span>&#46;</span>7<span>&#46;</span>2</a>
很多时候，连接问题是由于指定了错误的 IP 地址或“主机密钥验证错误”造成的。</p>
<p>如果一切都按计划进行，您应该会看到类似这样的内容（出现提示时输入密码，如果设置为不使用密码，请按 Enter）：</p>
<p>$ crosstap <a class="reference external" href="mailto:root&#37;&#52;&#48;192&#46;168&#46;7&#46;2">root<span>&#64;</span>192<span>&#46;</span>168<span>&#46;</span>7<span>&#46;</span>2</a> trace_open.stp
<a class="reference external" href="mailto:root&#37;&#52;&#48;192&#46;168&#46;7&#46;2's">root<span>&#64;</span>192<span>&#46;</span>168<span>&#46;</span>7<span>&#46;</span>2’s</a> password:
matchbox-termin(1036) open (“/tmp/vte3FS2LW”, O_RDWR|O_CREAT|O_EXCL|O_LARGEFILE, 0600)
matchbox-termin(1036) open (“/tmp/vteJMC7LW”, O_RDWR|O_CREAT|O_EXCL|O_LARGEFILE, 0600)
3.3.3 systemtap 文档
SystemTap 语言参考可以在这里找到：SystemTap 语言参考</p>
<p>可以在此处找到指向其他 SystemTap 文档、教程和示例的链接：SystemTap 文档页面</p>
<p>3.4系统配置文件
Sysprof 是一个非常易于使用的系统范围的分析器，它由一个带有三个窗格和几个按钮的窗口组成，这些按钮允许您从一个位置开始、停止和查看配置文件。</p>
<p>3.4.1 Sysprof 设置
对于本节，我们假设您已经执行了“常规设置”部分中概述的基本设置。</p>
<p>Sysprof 是在目标系统上运行的基于 GUI 的应用程序。对于本文档的其余部分，我们假设您已通过 ssh 连接到主机并将在目标上运行 Sysprof（您可以使用 ‘-X’ 选项进行 ssh 并让 Sysprof GUI 在目标上运行，但在远程显示主机如果你愿意）。</p>
<p>3.4.2基本 Sysprof 使用
要开始分析系统，您只需按下“开始”按钮。要停止分析并开始在一个简单的步骤中查看配置文件数据，请按“配置文件”按钮。</p>
<p>按下配置文件按钮后，三个窗格将填满配置文件数据：</p>
<p>../_images/sysprof-copy-to-user.png
左窗格显示功能和进程的列表。选择其中一个会在右窗格中展开该功能，显示其所有被调用者。请注意，这种面向调用者的显示本质上与 perf 的默认面向被调用者的调用链显示相反。</p>
<p>在上面的屏幕截图中，我们关注__copy_to_user_ll()并查找调用链，我们可以看到调用者之一 __copy_to_user_ll是 sys_read() 以及它们之间的完整调用路径。请注意，这本质上是我们在本页 perf 部分中显示的 perf 显示中看到的相同信息的一部分。</p>
<p>../_images/sysprof-copy-from-user.png
同样，上面是用户复制调用链的 Sysprof 显示的快照。</p>
<p>最后，查看左下角的第三个 Sysprof 窗格，我们可以看到在左上角窗格中选择的特定函数的所有调用者的列表。在这种情况下，下部窗格显示所有调用者 __mark_inode_dirty：</p>
<p>../_images/sysprof-callers.png
双击这些功能之一将依次将焦点更改为所选功能，依此类推。</p>
<p>把它绑在一起</p>
<p>如果您喜欢 sysprof 的“面向呼叫者”显示，您也可以在其他工具中对其进行近似。例如，’perf report’ 有 -g (–call-graph) 选项，您可以尝试使用它；其中一个选项是“调用者”，用于基于调用者的反向调用图显示。</p>
<p>3.4.3 Sysprof 文档
Sysprof 似乎没有任何文档，但也许那是因为它非常不言自明。然而，Sysprof 网站在这里：Sysprof, System-wide Performance Profiler for Linux</p>
<p>3.5 LTTng（Linux Trace Toolkit，下一代）
3.5.1 LTTng 设置
对于本节，我们假设您已经执行了“常规设置”部分中概述的基本设置。LTTng 通过 ssh 连接到目标系统上运行。</p>
<p>3.5.2收集和查看痕迹
一旦您应用了上述提交并构建并启动了您的映像（您需要构建 core-image-sato-sdk 映像或使用“常规设置”部分中描述的其他方法之一），您就准备好了开始追踪。</p>
<p>3.5.2.1收集和查看目标上的踪迹（在外壳内）
首先，从主机 ssh 到目标：</p>
<p>$ ssh -l root 192.168.1.47
The authenticity of host ‘192.168.1.47 (192.168.1.47)’ can’t be established.
RSA key fingerprint is 23:bd:c8:b1:a8:71:52:00:ee:00:4f:64:9e:10:b9:7e.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added ‘192.168.1.47’ (RSA) to the list of known hosts.
root&#64;192.168.1.47’s password:
到达目标后，使用以下步骤创建跟踪：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# lttng create
Spawning a session daemon
Session auto-20121015-232120 created.
Traces will be written in /home/root/lttng-traces/auto-20121015-232120
启用您要跟踪的事件（在本例中为所有内核事件）：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# lttng enable-event –kernel –all
All kernel events are enabled in channel channel0
启动跟踪：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# lttng start
Tracing started for session auto-20121015-232120
然后在一段时间后或在运行您要跟踪的特定工作负载后停止跟踪：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# lttng stop
Tracing stopped for session auto-20121015-232120
您现在可以在目标上以文本形式查看跟踪：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# lttng view
[23:21:56.989270399] (+?.?????????) sys_geteuid: { 1 }, { }
[23:21:56.989278081] (+0.000007682) exit_syscall: { 1 }, { ret = 0 }
[23:21:56.989286043] (+0.000007962) sys_pipe: { 1 }, { fildes = 0xB77B9E8C }
[23:21:56.989321802] (+0.000035759) exit_syscall: { 1 }, { ret = 0 }
[23:21:56.989329345] (+0.000007543) sys_mmap_pgoff: { 1 }, { addr = 0x0, len = 10485760, prot = 3, flags = 131362, fd = 4294967295, pgoff = 0 }
[23:21:56.989351694] (+0.000022349) exit_syscall: { 1 }, { ret = -1247805440 }
[23:21:56.989432989] (+0.000081295) sys_clone: { 1 }, { clone_flags = 0x411, newsp = 0xB5EFFFE4, parent_tid = 0xFFFFFFFF, child_tid = 0x0 }
[23:21:56.989477129] (+0.000044140) sched_stat_runtime: { 1 }, { comm = “lttng-consumerd”, tid = 1193, runtime = 681660, vruntime = 43367983388 }
[23:21:56.989486697] (+0.000009568) sched_migrate_task: { 1 }, { comm = “lttng-consumerd”, tid = 1193, prio = 20, orig_cpu = 1, dest_cpu = 1 }
[23:21:56.989508418] (+0.000021721) hrtimer_init: { 1 }, { hrtimer = 3970832076, clockid = 1, mode = 1 }
[23:21:56.989770462] (+0.000262044) hrtimer_cancel: { 1 }, { hrtimer = 3993865440 }
[23:21:56.989771580] (+0.000001118) hrtimer_cancel: { 0 }, { hrtimer = 3993812192 }
[23:21:56.989776957] (+0.000005377) hrtimer_expire_entry: { 1 }, { hrtimer = 3993865440, now = 79815980007057, function = 3238465232 }
[23:21:56.989778145] (+0.000001188) hrtimer_expire_entry: { 0 }, { hrtimer = 3993812192, now = 79815980008174, function = 3238465232 }
[23:21:56.989791695] (+0.000013550) softirq_raise: { 1 }, { vec = 1 }
[23:21:56.989795396] (+0.000003701) softirq_raise: { 0 }, { vec = 1 }
[23:21:56.989800635] (+0.000005239) softirq_raise: { 0 }, { vec = 9 }
[23:21:56.989807130] (+0.000006495) sched_stat_runtime: { 1 }, { comm = “lttng-consumerd”, tid = 1193, runtime = 330710, vruntime = 43368314098 }
[23:21:56.989809993] (+0.000002863) sched_stat_runtime: { 0 }, { comm = “lttng-sessiond”, tid = 1181, runtime = 1015313, vruntime = 36976733240 }
[23:21:56.989818514] (+0.000008521) hrtimer_expire_exit: { 0 }, { hrtimer = 3993812192 }
[23:21:56.989819631] (+0.000001117) hrtimer_expire_exit: { 1 }, { hrtimer = 3993865440 }
[23:21:56.989821866] (+0.000002235) hrtimer_start: { 0 }, { hrtimer = 3993812192, function = 3238465232, expires = 79815981000000, softexpires = 79815981000000 }
[23:21:56.989822984] (+0.000001118) hrtimer_start: { 1 }, { hrtimer = 3993865440, function = 3238465232, expires = 79815981000000, softexpires = 79815981000000 }
[23:21:56.989832762] (+0.000009778) softirq_entry: { 1 }, { vec = 1 }
[23:21:56.989833879] (+0.000001117) softirq_entry: { 0 }, { vec = 1 }
[23:21:56.989838069] (+0.000004190) timer_cancel: { 1 }, { timer = 3993871956 }
[23:21:56.989839187] (+0.000001118) timer_cancel: { 0 }, { timer = 3993818708 }
[23:21:56.989841492] (+0.000002305) timer_expire_entry: { 1 }, { timer = 3993871956, now = 79515980, function = 3238277552 }
[23:21:56.989842819] (+0.000001327) timer_expire_entry: { 0 }, { timer = 3993818708, now = 79515980, function = 3238277552 }
[23:21:56.989854831] (+0.000012012) sched_stat_runtime: { 1 }, { comm = “lttng-consumerd”, tid = 1193, runtime = 49237, vruntime = 43368363335 }
[23:21:56.989855949] (+0.000001118) sched_stat_runtime: { 0 }, { comm = “lttng-sessiond”, tid = 1181, runtime = 45121, vruntime = 36976778361 }
[23:21:56.989861257] (+0.000005308) sched_stat_sleep: { 1 }, { comm = “kworker/1:1”, tid = 21, delay = 9451318 }
[23:21:56.989862374] (+0.000001117) sched_stat_sleep: { 0 }, { comm = “kworker/0:0”, tid = 4, delay = 9958820 }
[23:21:56.989868241] (+0.000005867) sched_wakeup: { 0 }, { comm = “kworker/0:0”, tid = 4, prio = 120, success = 1, target_cpu = 0 }
[23:21:56.989869358] (+0.000001117) sched_wakeup: { 1 }, { comm = “kworker/1:1”, tid = 21, prio = 120, success = 1, target_cpu = 1 }
[23:21:56.989877460] (+0.000008102) timer_expire_exit: { 1 }, { timer = 3993871956 }
[23:21:56.989878577] (+0.000001117) timer_expire_exit: { 0 }, { timer = 3993818708 }
.
.
.
您现在可以安全地销毁跟踪会话（请注意，这不会删除跟踪 - 它仍然存在于 ~/lttng-traces 中）：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# lttng destroy
Session auto-20121015-232120 destroyed at /home/root
请注意，跟踪保存在 ~/lttng-traces 目录下的 ‘lttng create’ 返回的同名目录中（请注意，您可以通过将自己的名称提供给 ‘lttng create’ 来更改它）：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# ls -al ~/lttng-traces
drwxrwx—    3 root     root          1024 Oct 15 23:21 .
drwxr-xr-x    5 root     root          1024 Oct 15 23:57 ..
drwxrwx—    3 root     root          1024 Oct 15 23:21 auto-20121015-232120
3.5.2.2收集和查看目标上的用户空间跟踪（在 shell 内）
对于 LTTng 用户空间跟踪，您需要有一个正确检测的用户空间程序。对于此示例，我们将使用由 lttng-ust 构建生成的“hello”测试程序。</p>
<p>‘hello’ 测试程序并没有通过 lttng-ust 构建安装在根文件系统上，所以我们需要手动复制它。首先 cd 进入包含 hello 可执行文件的构建目录：</p>
<p>$ cd build/tmp/work/core2_32-poky-linux/lttng-ust/2.0.5-r0/git/tests/hello/.libs
将其复制到目标机器：</p>
<p>$ scp hello <a class="reference external" href="mailto:root&#37;&#52;&#48;192&#46;168&#46;1&#46;20">root<span>&#64;</span>192<span>&#46;</span>168<span>&#46;</span>1<span>&#46;</span>20</a>:
您现在已经在目标上安装了检测的 lttng ‘hello world’ 测试程序，可以进行测试了。</p>
<p>首先，从主机 ssh 到目标：</p>
<p>$ ssh -l root 192.168.1.47
The authenticity of host ‘192.168.1.47 (192.168.1.47)’ can’t be established.
RSA key fingerprint is 23:bd:c8:b1:a8:71:52:00:ee:00:4f:64:9e:10:b9:7e.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added ‘192.168.1.47’ (RSA) to the list of known hosts.
root&#64;192.168.1.47’s password:
到达目标后，使用以下步骤创建跟踪：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# lttng create
Session auto-20190303-021943 created.
Traces will be written in /home/root/lttng-traces/auto-20190303-021943
启用您要跟踪的事件（在本例中为所有用户空间事件）：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# lttng enable-event –userspace –all
All UST events are enabled in channel channel0
启动跟踪：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# lttng start
Tracing started for session auto-20190303-021943
运行检测的 hello world 程序：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# ./hello
Hello, World!
Tracing… done.
然后在一段时间后或在运行您要跟踪的特定工作负载后停止跟踪：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# lttng stop
Tracing stopped for session auto-20190303-021943
您现在可以在目标上以文本形式查看跟踪：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# lttng view
[02:31:14.906146544] (+?.?????????) hello:1424 ust_tests_hello:tptest: { cpu_id = 1 }, { intfield = 0, intfield2 = 0x0, longfield = 0, netintfield = 0, netintfieldhex = 0x0, arrfield1 = [ [0] = 1, [1] = 2, [2] = 3 ], arrfield2 = “test”, _seqfield1_length = 4, seqfield1 = [ [0] = 116, [1] = 101, [2] = 115, [3] = 116 ], _seqfield2_length = 4,  seqfield2 = “test”, stringfield = “test”, floatfield = 2222, doublefield = 2, boolfield = 1 }
[02:31:14.906170360] (+0.000023816) hello:1424 ust_tests_hello:tptest: { cpu_id = 1 }, { intfield = 1, intfield2 = 0x1, longfield = 1, netintfield = 1, netintfieldhex = 0x1, arrfield1 = [ [0] = 1, [1] = 2, [2] = 3 ], arrfield2 = “test”, _seqfield1_length = 4, seqfield1 = [ [0] = 116, [1] = 101, [2] = 115, [3] = 116 ], _seqfield2_length = 4, seqfield2 = “test”, stringfield = “test”, floatfield = 2222, doublefield = 2, boolfield = 1 }
[02:31:14.906183140] (+0.000012780) hello:1424 ust_tests_hello:tptest: { cpu_id = 1 }, { intfield = 2, intfield2 = 0x2, longfield = 2, netintfield = 2, netintfieldhex = 0x2, arrfield1 = [ [0] = 1, [1] = 2, [2] = 3 ], arrfield2 = “test”, _seqfield1_length = 4, seqfield1 = [ [0] = 116, [1] = 101, [2] = 115, [3] = 116 ], _seqfield2_length = 4, seqfield2 = “test”, stringfield = “test”, floatfield = 2222, doublefield = 2, boolfield = 1 }
[02:31:14.906194385] (+0.000011245) hello:1424 ust_tests_hello:tptest: { cpu_id = 1 }, { intfield = 3, intfield2 = 0x3, longfield = 3, netintfield = 3, netintfieldhex = 0x3, arrfield1 = [ [0] = 1, [1] = 2, [2] = 3 ], arrfield2 = “test”, _seqfield1_length = 4, seqfield1 = [ [0] = 116, [1] = 101, [2] = 115, [3] = 116 ], _seqfield2_length = 4, seqfield2 = “test”, stringfield = “test”, floatfield = 2222, doublefield = 2, boolfield = 1 }
.
.
.
您现在可以安全地销毁跟踪会话（请注意，这不会删除跟踪 - 它仍然存在于 ~/lttng-traces 中）：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# lttng destroy
Session auto-20190303-021943 destroyed at /home/root
3.5.3 LTTng 文档
您可以在LTTng 文档站点上找到主要的 LTTng 文档。此站点上的文档适用于在 Linux 环境中工作并对高效软件跟踪感兴趣的中高级软件开发人员。</p>
<p>有关 LTTng 的一般信息，请访问LTTng 项目网站。您可以在此站点上找到一个“入门”链接，该链接将您带到 LTTng 快速入门。</p>
<p>3.6 blktrace
blktrace 是用于跟踪和报告低级磁盘 I/O 的工具。blktrace 提供等式的一半跟踪；它的输出可以通过管道传输到 blkparse 程序中，该程序以人类可读的形式呈现数据并进行一些基本分析：</p>
<p>3.6.1 blktrace 设置
对于本节，我们假设您已经执行了“常规设置”部分中概述的基本设置。</p>
<p>blktrace 是在目标系统上运行的应用程序。您可以在目标上运行整个 blktrace 和 blkparse 管道，或者您可以在目标上以“侦听”模式运行 blktrace，并让 blktrace 和 blkparse 收集和分析主机上的数据（请参阅下面的“远程使用 blktrace ”部分） . 对于本节的其余部分，我们假设您已经 ssh’ed 到主机并将在目标上运行 blkrace。</p>
<p>3.6.2基本 blktrace 使用
要记录跟踪，只需运行“blktrace”命令，为其指定要跟踪活动的块设备的名称：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# blktrace /dev/sdc
在另一个 shell 中，执行您要跟踪的工作负载。</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:/media/sdc# rm linux-2.6.19.2.tar.bz2; wget <a class="reference external" href="https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2">https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2</a>; sync
Connecting to downloads.yoctoproject.org (140.211.169.59:80)
linux-2.6.19.2.tar.b 100% |*******************************| 41727k 0:00:00 ETA
在 blktrace shell 中按 Ctrl-C 停止跟踪。它将显示记录了多少事件，以及每个 cpu 的文件大小（blktrace 记录每个 cpu 内核缓冲区中的跟踪，并简单地将它们转储到用户空间以便 blkparse 稍后合并和排序）。</p>
<dl class="simple">
<dt>^C=== sdc ===</dt><dd><p>CPU  0:                 7082 events,      332 KiB data
CPU  1:                 1578 events,       74 KiB data
Total:                  8660 events (dropped 0),      406 KiB data</p>
</dd>
</dl>
<p>如果您检查保存到磁盘的文件，您会看到多个文件，每个 CPU 一个，并且设备名称作为文件名的第一部分：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# ls -al
drwxr-xr-x    6 root     root          1024 Oct 27 22:39 .
drwxr-sr-x    4 root     root          1024 Oct 26 18:24 ..
-rw-r–r–    1 root     root        339938 Oct 27 22:40 sdc.blktrace.0
-rw-r–r–    1 root     root         75753 Oct 27 22:40 sdc.blktrace.1
要查看跟踪事件，只需在包含跟踪文件的目录中调用“blkparse”，为其提供构成文件名第一部分的设备名称：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# blkparse sdc</p>
<blockquote>
<div><p>8,32   1        1     0.000000000  1225  Q  WS 3417048 + 8 [jbd2/sdc-8]
8,32   1        2     0.000025213  1225  G  WS 3417048 + 8 [jbd2/sdc-8]
8,32   1        3     0.000033384  1225  P   N [jbd2/sdc-8]
8,32   1        4     0.000043301  1225  I  WS 3417048 + 8 [jbd2/sdc-8]
8,32   1        0     0.000057270     0  m   N cfq1225 insert_request
8,32   1        0     0.000064813     0  m   N cfq1225 add_to_rr
8,32   1        5     0.000076336  1225  U   N [jbd2/sdc-8] 1
8,32   1        0     0.000088559     0  m   N cfq workload slice:150
8,32   1        0     0.000097359     0  m   N cfq1225 set_active wl_prio:0 wl_type:1
8,32   1        0     0.000104063     0  m   N cfq1225 Not idling. st-&gt;count:1
8,32   1        0     0.000112584     0  m   N cfq1225 fifo=  (null)
8,32   1        0     0.000118730     0  m   N cfq1225 dispatch_insert
8,32   1        0     0.000127390     0  m   N cfq1225 dispatched a request
8,32   1        0     0.000133536     0  m   N cfq1225 activate rq, drv=1
8,32   1        6     0.000136889  1225  D  WS 3417048 + 8 [jbd2/sdc-8]
8,32   1        7     0.000360381  1225  Q  WS 3417056 + 8 [jbd2/sdc-8]
8,32   1        8     0.000377422  1225  G  WS 3417056 + 8 [jbd2/sdc-8]
8,32   1        9     0.000388876  1225  P   N [jbd2/sdc-8]
8,32   1       10     0.000397886  1225  Q  WS 3417064 + 8 [jbd2/sdc-8]
8,32   1       11     0.000404800  1225  M  WS 3417064 + 8 [jbd2/sdc-8]
8,32   1       12     0.000412343  1225  Q  WS 3417072 + 8 [jbd2/sdc-8]
8,32   1       13     0.000416533  1225  M  WS 3417072 + 8 [jbd2/sdc-8]
8,32   1       14     0.000422121  1225  Q  WS 3417080 + 8 [jbd2/sdc-8]
8,32   1       15     0.000425194  1225  M  WS 3417080 + 8 [jbd2/sdc-8]
8,32   1       16     0.000431968  1225  Q  WS 3417088 + 8 [jbd2/sdc-8]
8,32   1       17     0.000435251  1225  M  WS 3417088 + 8 [jbd2/sdc-8]
8,32   1       18     0.000440279  1225  Q  WS 3417096 + 8 [jbd2/sdc-8]
8,32   1       19     0.000443911  1225  M  WS 3417096 + 8 [jbd2/sdc-8]
8,32   1       20     0.000450336  1225  Q  WS 3417104 + 8 [jbd2/sdc-8]
8,32   1       21     0.000454038  1225  M  WS 3417104 + 8 [jbd2/sdc-8]
8,32   1       22     0.000462070  1225  Q  WS 3417112 + 8 [jbd2/sdc-8]
8,32   1       23     0.000465422  1225  M  WS 3417112 + 8 [jbd2/sdc-8]
8,32   1       24     0.000474222  1225  I  WS 3417056 + 64 [jbd2/sdc-8]
8,32   1        0     0.000483022     0  m   N cfq1225 insert_request
8,32   1       25     0.000489727  1225  U   N [jbd2/sdc-8] 1
8,32   1        0     0.000498457     0  m   N cfq1225 Not idling. st-&gt;count:1
8,32   1        0     0.000503765     0  m   N cfq1225 dispatch_insert
8,32   1        0     0.000512914     0  m   N cfq1225 dispatched a request
8,32   1        0     0.000518851     0  m   N cfq1225 activate rq, drv=2
.
.
.
8,32   0        0    58.515006138     0  m   N cfq3551 complete rqnoidle 1
8,32   0     2024    58.516603269     3  C  WS 3156992 + 16 [0]
8,32   0        0    58.516626736     0  m   N cfq3551 complete rqnoidle 1
8,32   0        0    58.516634558     0  m   N cfq3551 arm_idle: 8 group_idle: 0
8,32   0        0    58.516636933     0  m   N cfq schedule dispatch
8,32   1        0    58.516971613     0  m   N cfq3551 slice expired t=0
8,32   1        0    58.516982089     0  m   N cfq3551 sl_used=13 disp=6 charge=13 iops=0 sect=80
8,32   1        0    58.516985511     0  m   N cfq3551 del_from_rr
8,32   1        0    58.516990819     0  m   N cfq3551 put_queue</p>
</div></blockquote>
<dl class="simple">
<dt>CPU0 (sdc):</dt><dd><p>Reads Queued:           0,        0KiB       Writes Queued:         331,   26,284KiB
Read Dispatches:        0,        0KiB       Write Dispatches:      485,   40,484KiB
Reads Requeued:         0            Writes Requeued:         0
Reads Completed:        0,        0KiB       Writes Completed:      511,   41,000KiB
Read Merges:            0,        0KiB       Write Merges:           13,      160KiB
Read depth:             0            Write depth:             2
IO unplugs:            23            Timer unplugs:           0</p>
</dd>
<dt>CPU1 (sdc):</dt><dd><p>Reads Queued:           0,        0KiB       Writes Queued:         249,   15,800KiB
Read Dispatches:        0,        0KiB       Write Dispatches:       42,    1,600KiB
Reads Requeued:         0            Writes Requeued:         0
Reads Completed:        0,        0KiB       Writes Completed:       16,    1,084KiB
Read Merges:            0,        0KiB       Write Merges:           40,      276KiB
Read depth:             0            Write depth:             2
IO unplugs:            30            Timer unplugs:           1</p>
</dd>
<dt>Total (sdc):</dt><dd><p>Reads Queued:           0,        0KiB       Writes Queued:         580,   42,084KiB
Read Dispatches:        0,        0KiB       Write Dispatches:      527,   42,084KiB
Reads Requeued:         0            Writes Requeued:         0
Reads Completed:        0,        0KiB       Writes Completed:      527,   42,084KiB
Read Merges:            0,        0KiB       Write Merges:           53,      436KiB
IO unplugs:            53            Timer unplugs:           1</p>
</dd>
</dl>
<p>Throughput (R/W): 0KiB/s / 719KiB/s
Events (sdc): 6,592 entries
Skips: 0 forward (0 -   0.0%)
Input file sdc.blktrace.0 added
Input file sdc.blktrace.1 added
该报告显示在 blktrace 数据中发现的每个事件，以及运行期间整体块 I/O 流量的摘要。您可以查看 blkparse联机帮助页以了解跟踪列表中显示的每个字段的含义。</p>
<p>3.6.2.1直播模式
blktrace 和 blkparse 从一开始就被设计为能够在“管道模式”下一起运行，其中 blktrace 的标准输出可以直接输入 blkparse 的标准输入：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# blktrace /dev/sdc -o - | blkparse -i -
这使得长期跟踪会话能够在不向磁盘写入任何内容的情况下运行，并允许用户通过在屏幕上滚动查看跟踪输出或传递它来“实时”查找跟踪数据中的某些条件以及管道中的另一个程序，例如 grep，可用于识别和捕获感兴趣的条件。</p>
<p>实际上还有另一个 blktrace 命令将上述管道实现为单个命令，因此用户不必费心输入上述命令序列：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# btrace /dev/sdc
3.6.2.2远程使用 blktrace
因为 blktrace 跟踪块 I/O 并且同时通常将其跟踪数据写入块设备，并且通常因为使被跟踪的设备与跟踪器写入的设备相同并不是一个好主意，所以 blktrace 提供通过提供对通过网络发送所有跟踪数据的本机支持，一种在完全不干扰被跟踪设备的情况下进行跟踪的方法。</p>
<p>要让 blktrace 在此模式下运行，请使用 -l 选项在被跟踪的目标系统上启动 blktrace，以及要跟踪的设备：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:~# blktrace -l /dev/sdc
server: waiting for connections…
在主机系统上，使用 -h 选项连接到目标系统，同时将设备传递给它以进行跟踪：</p>
<p>$ blktrace -d /dev/sdc -h 192.168.1.43
blktrace: connecting to 192.168.1.43
blktrace: connected!
在目标系统上，您应该看到：</p>
<p>server: connection from 192.168.1.43
在另一个 shell 中，执行您要跟踪的工作负载。</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:/media/sdc# rm linux-2.6.19.2.tar.bz2; wget <a class="reference external" href="https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2">https://downloads.yoctoproject.org/mirror/sources/linux-2.6.19.2.tar.bz2</a>; sync
Connecting to downloads.yoctoproject.org (140.211.169.59:80)
linux-2.6.19.2.tar.b 100% |*******************************| 41727k 0:00:00 ETA
完成后，在主机系统上执行 Ctrl-C 以停止跟踪：</p>
<dl class="simple">
<dt>^C=== sdc ===</dt><dd><p>CPU  0:                 7691 events,      361 KiB data
CPU  1:                 4109 events,      193 KiB data
Total:                 11800 events (dropped 0),      554 KiB data</p>
</dd>
</dl>
<p>在目标系统上，您还应该看到刚刚结束的跟踪的跟踪摘要：</p>
<p>server: end of run for 192.168.1.43:sdc
=== sdc ===</p>
<blockquote>
<div><p>CPU  0:                 7691 events,      361 KiB data
CPU  1:                 4109 events,      193 KiB data
Total:                 11800 events (dropped 0),      554 KiB data</p>
</div></blockquote>
<p>主机上的 blktrace 实例会将目标输出保存在主机名时间戳目录中：</p>
<p>$ ls -al
drwxr-xr-x   10 root     root          1024 Oct 28 02:40 .
drwxr-sr-x    4 root     root          1024 Oct 26 18:24 ..
drwxr-xr-x    2 root     root          1024 Oct 28 02:40 192.168.1.43-2012-10-28-02:40:56
cd 进入该目录以查看输出文件：</p>
<p>$ ls -l
-rw-r–r–    1 root     root        369193 Oct 28 02:44 sdc.blktrace.0
-rw-r–r–    1 root     root        197278 Oct 28 02:44 sdc.blktrace.1
并使用设备名称在主机系统上运行 blkparse：</p>
<p>$ blkparse sdc</p>
<blockquote>
<div><p>8,32   1        1     0.000000000  1263  Q  RM 6016 + 8 [ls]
8,32   1        0     0.000036038     0  m   N cfq1263 alloced
8,32   1        2     0.000039390  1263  G  RM 6016 + 8 [ls]
8,32   1        3     0.000049168  1263  I  RM 6016 + 8 [ls]
8,32   1        0     0.000056152     0  m   N cfq1263 insert_request
8,32   1        0     0.000061600     0  m   N cfq1263 add_to_rr
8,32   1        0     0.000075498     0  m   N cfq workload slice:300
.
.
.
8,32   0        0   177.266385696     0  m   N cfq1267 arm_idle: 8 group_idle: 0
8,32   0        0   177.266388140     0  m   N cfq schedule dispatch
8,32   1        0   177.266679239     0  m   N cfq1267 slice expired t=0
8,32   1        0   177.266689297     0  m   N cfq1267 sl_used=9 disp=6 charge=9 iops=0 sect=56
8,32   1        0   177.266692649     0  m   N cfq1267 del_from_rr
8,32   1        0   177.266696560     0  m   N cfq1267 put_queue</p>
</div></blockquote>
<dl class="simple">
<dt>CPU0 (sdc):</dt><dd><p>Reads Queued:           0,        0KiB       Writes Queued:         270,   21,708KiB
Read Dispatches:       59,    2,628KiB       Write Dispatches:      495,   39,964KiB
Reads Requeued:         0            Writes Requeued:         0
Reads Completed:       90,    2,752KiB       Writes Completed:      543,   41,596KiB
Read Merges:            0,        0KiB       Write Merges:            9,      344KiB
Read depth:             2            Write depth:             2
IO unplugs:            20            Timer unplugs:           1</p>
</dd>
<dt>CPU1 (sdc):</dt><dd><p>Reads Queued:         688,    2,752KiB       Writes Queued:         381,   20,652KiB
Read Dispatches:       31,      124KiB       Write Dispatches:       59,    2,396KiB
Reads Requeued:         0            Writes Requeued:         0
Reads Completed:        0,        0KiB       Writes Completed:       11,      764KiB
Read Merges:          598,    2,392KiB       Write Merges:           88,      448KiB
Read depth:             2            Write depth:             2
IO unplugs:            52            Timer unplugs:           0</p>
</dd>
<dt>Total (sdc):</dt><dd><p>Reads Queued:         688,    2,752KiB       Writes Queued:         651,   42,360KiB
Read Dispatches:       90,    2,752KiB       Write Dispatches:      554,   42,360KiB
Reads Requeued:         0            Writes Requeued:         0
Reads Completed:       90,    2,752KiB       Writes Completed:      554,   42,360KiB
Read Merges:          598,    2,392KiB       Write Merges:           97,      792KiB
IO unplugs:            72            Timer unplugs:           1</p>
</dd>
</dl>
<p>Throughput (R/W): 15KiB/s / 238KiB/s
Events (sdc): 9,301 entries
Skips: 0 forward (0 -   0.0%)
您应该看到跟踪事件和摘要，就像您在目标上运行相同的命令一样。</p>
<p>3.6.2.3通过“ftrace”跟踪块 I/O
也可以仅 使用“跟踪事件”子系统来跟踪块 I/O ，如果您不想费心处理用户空间工具，这对于临时跟踪很有用。</p>
<p>要为给定设备启用跟踪，请使用 /sys/block/xxx/trace/enable，其中 xxx 是设备名称。例如，这将启用对 /dev/sdc 的跟踪：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:/sys/kernel/debug/tracing# echo 1 &gt; /sys/block/sdc/trace/enable
选择要跟踪的设备后，选择“blk”跟踪器将打开 blk 跟踪器：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:/sys/kernel/debug/tracing# cat available_tracers
blk function_graph function nop</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:/sys/kernel/debug/tracing# echo blk &gt; current_tracer
执行您感兴趣的工作负载：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:/sys/kernel/debug/tracing# cat /media/sdc/testfile.txt
并查看输出（请注意，我们使用 ‘trace_pipe’ 而不是 trace 来捕获此跟踪 - 这允许我们在管道上等待数据出现）：</p>
<dl class="simple">
<dt><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:/sys/kernel/debug/tracing# cat trace_pipe</dt><dd><p>cat-3587  [001] d..1  3023.276361:   8,32   Q   R 1699848 + 8 [cat]
cat-3587  [001] d..1  3023.276410:   8,32   m   N cfq3587 alloced
cat-3587  [001] d..1  3023.276415:   8,32   G   R 1699848 + 8 [cat]
cat-3587  [001] d..1  3023.276424:   8,32   P   N [cat]
cat-3587  [001] d..2  3023.276432:   8,32   I   R 1699848 + 8 [cat]
cat-3587  [001] d..1  3023.276439:   8,32   m   N cfq3587 insert_request
cat-3587  [001] d..1  3023.276445:   8,32   m   N cfq3587 add_to_rr
cat-3587  [001] d..2  3023.276454:   8,32   U   N [cat] 1
cat-3587  [001] d..1  3023.276464:   8,32   m   N cfq workload slice:150
cat-3587  [001] d..1  3023.276471:   8,32   m   N cfq3587 set_active wl_prio:0 wl_type:2
cat-3587  [001] d..1  3023.276478:   8,32   m   N cfq3587 fifo=  (null)
cat-3587  [001] d..1  3023.276483:   8,32   m   N cfq3587 dispatch_insert
cat-3587  [001] d..1  3023.276490:   8,32   m   N cfq3587 dispatched a request
cat-3587  [001] d..1  3023.276497:   8,32   m   N cfq3587 activate rq, drv=1
cat-3587  [001] d..2  3023.276500:   8,32   D   R 1699848 + 8 [cat]</p>
</dd>
</dl>
<p>这会关闭对指定设备的跟踪：</p>
<p><a class="reference external" href="mailto:root&#37;&#52;&#48;crownbay">root<span>&#64;</span>crownbay</a>:/sys/kernel/debug/tracing# echo 0 &gt; /sys/block/sdc/trace/enable
3.6.3 blktrace 文档
可以在此处找到本节中讨论的命令的联机版本手册页：</p>
<p><a class="reference external" href="https://linux.die.net/man/8/blktrace">https://linux.die.net/man/8/blktrace</a></p>
<p><a class="reference external" href="https://linux.die.net/man/1/blkparse">https://linux.die.net/man/1/blkparse</a></p>
<p><a class="reference external" href="https://linux.die.net/man/8/btrace">https://linux.die.net/man/8/btrace</a></p>
<p>上述手册页以及其他 blktrace 实用程序（btt、blkiomon 等）的手册页可以在 blktrace 工具 git repo 的 /doc 目录中找到：</p>
<p>$ git clone git://git.kernel.dk/blktrace.git</p>
<hr class="docutils" />
<p>4 个真实世界的例子</p>
<p>本章包含真实世界的示例。</p>
<p>4.1实时图像写入速度慢
在我们之前的一个版本 (denzil) 中，用户注意到启动实时映像和写入磁盘明显变慢。这包括引导本身，尤其是第一次引导，因为由于某些安装后脚本，首次引导往往会进行大量写入。</p>
<p>问题（和解决方案）是通过使用 Yocto 跟踪工具发现的，在本例中是“perf stat”、“perf script”、“perf record”和“perf report”。</p>
<p>在此处查看有关如何诊断和解决此错误的所有未加修饰的详细信息：Yocto Bug #3049</p>
<hr class="docutils" />
<p>Yocto 项目应用程序开发和可扩展软件开发工具包 (eSDK)</p>
<p>1简介
1.1 eSDK介绍
欢迎使用 Yocto 项目应用程序开发和可扩展软件开发工具包 (eSDK) 手册。本手册介绍了如何使用 Yocto Project 可扩展和标准 SDK 来开发应用程序和图像。</p>
<p>所有 SDK 均包含以下内容：</p>
<p>交叉开发工具链：此工具链包含编译器、调试器和各种相关工具。</p>
<p>库、标题和符号：库、标题和符号特定于映像（即它们与构建 SDK 的映像相匹配）。</p>
<p>环境设置脚本：该*.sh文件一旦获得源代码，就会通过定义变量和准备 SDK 使用来设置交叉开发环境。</p>
<p>此外，可扩展的 SDK 具有允许您轻松地将新应用程序和库添加到映像、修改现有组件的源、测试目标硬件上的更改以及轻松地将应用程序集成到OpenEmbedded 构建系统中的工具。</p>
<p>您可以使用 SDK 独立开发和测试注定要在某些目标机器上运行的代码。SDK 是完全独立的。二进制文件与它们自己的 . 副本链接 libc，这不会导致对目标系统的依赖。为了实现这一点，指向动态加载程序的指针在安装时配置，因为该路径不能动态更改。populate_sdk这就是对和populate_sdk_ext 档案进行包装的原因。</p>
<p>SDK 的另一个特点是，对于任何给定的架构，只生成一组交叉编译器工具链二进制文件。此功能利用了目标硬件可以 gcc作为一组编译器选项传递的事实。这些选项由环境脚本设置并包含在 CC和 LD等变量中。这减少了工具所需的空间。但是，请理解每个目标仍然需要自己的 sysroot，因为这些二进制文件是特定于目标的。</p>
<p>SDK 开发环境由以下部分组成：</p>
<p>自包含的 SDK，它是一个特定于架构的跨工具链和匹配的 sysroot（目标和本机），全部由 OpenEmbedded 构建系统（例如 SDK）构建。工具链和 sysroots 基于元数据 配置和扩展，允许您在主机上针对目标硬件进行交叉开发。此外，可扩展 SDK 包含该devtool功能。</p>
<p>Quick EMUlator (QEMU)，可让您模拟目标硬件。QEMU 实际上并不是 SDK 的一部分。您必须单独构建并包含此模拟器。然而，QEMU 在围绕 SDK 使用的开发过程中扮演着重要的角色。</p>
<p>1.1.1交叉开发工具链
交叉开发工具链由交叉编译器、交叉链接器和交叉调试器组成，用于为目标硬件开发用户空间应用程序；此外，可扩展的 SDK 带有内置devtool 功能。此工具链是通过运行 SDK 安装程序脚本或通过构建目录创建的，该目录基于您的目标设备的元数据配置或扩展。跨工具链与匹配的目标 sysroot 一起使用。</p>
<p>1.1.2系统根
本机和目标 sysroot 包含生成在目标架构上运行的二进制文件所需的头文件和库。目标 sysroot 基于 OpenEmbedded 构建系统构建的目标根文件系统映像，并使用与构建跨工具链相同的元数据配置。</p>
<p>1.1.3 QEMU 模拟器
QEMU 模拟器允许您在运行应用程序或映像时模拟您的硬件。QEMU 不是 SDK 的一部分，但如果您执行以下任一操作，它会自动安装并可用：</p>
<p>克隆pokyGit 存储库以创建 源目录并获取环境设置脚本。</p>
<p>下载了 Yocto Project 版本并将其解压缩以创建源目录并获取环境设置脚本。</p>
<p>安装了跨工具链 tarball 并获取了工具链的设置环境脚本。</p>
<p>1.2 SDK开发模式
从根本上说，SDK 适合以下开发过程：</p>
<p>sdk-environment.png</p>
<p>SDK 安装在任何机器上，可用于开发应用程序、图像和内核。QA 工程师或发布工程师甚至可以使用 SDK。基本概念是安装了 SDK 的机器不必与安装了 Yocto 项目的机器相关联。开发人员可以在他们的机器上独立编译和测试对象，然后，当对象准备好集成到图像中时，他们可以简单地将其提供给具有 Yocto 项目的机器。一旦对象可用，就可以使用 Yocto 项目重建图像以生成修改后的图像。</p>
<p>您只需要遵循以下一般步骤：</p>
<p>为您的目标硬件安装 SDK：有关如何安装 SDK 的信息，请参阅“安装 SDK ”部分。</p>
<p>下载或构建目标映像： Yocto 项目支持多种目标架构，并具有许多预构建的内核映像和根文件系统映像。</p>
<p>如果您要在硬件上开发应用程序，请转到 机器下载区域并选择目标机器区域，从中下载内核映像和根文件系统。此下载区域中可能包含多个文件，支持使用实际硬件进行开发。例如，该区域可能包含.hddimg将内核映像与文件系统、引导加载程序等组合在一起的文件。确保获取特定开发过程所需的文件。</p>
<p>如果您要开发您的应用程序，然后使用 QEMU 模拟器运行和测试它，请转到 机器/qemu下载区域。从这个区域，进入您的目标体系结构的目录（例如 qemux86_64，对于基于 Intel 的 64 位体系结构）。下载内核、根文件系统和进程所需的任何其他文件。</p>
<p>笔记</p>
<p>要在 QEMU 中使用根文件系统，您需要解压它。有关如何进行此提取的信息，请参阅“提取根文件系统”部分。</p>
<p>开发和测试您的应用程序：此时，您拥有开发应用程序的工具。如果需要单独安装和使用QEMU模拟器，可以到QEMU主页下载了解模拟器。有关在 Yocto 项目中使用 QEMU 的信息，请参阅 Yocto 项目开发任务手册中的“使用 Quick EMUlator (QEMU) ”一章。</p>
<p>本手册的其余部分介绍了如何使用可扩展和标准 SDK。附录形式的信息也描述了如何构建、安装和修改 SDK。</p>
<p>2使用可扩展 SDK
本章介绍可扩展 SDK 及其安装方法。信息涵盖了 SDK 的各个部分、如何安装它，并介绍了如何使用该devtool功能。可扩展的 SDK 使向映像添加新应用程序和库、修改现有组件的源代码、测试目标硬件上的更改以及轻松集成到 OpenEmbedded 构建系统的其余部分变得容易。</p>
<p>笔记</p>
<p>有关可扩展 SDK 与标准 SDK 支持的主要功能的并排比较，请参阅 简介部分。</p>
<p>除了通过 提供的功能外devtool，您还可以直接使用工具链，例如来自 Makefile 和 Autotools。有关详细信息，请参阅“直接使用 SDK 工具链”一章。</p>
<p>2.1为什么要使用Extensible SDK，里面有什么？
可扩展 SDK 提供了针对特定图像内容定制的交叉开发工具链和库。如果您希望获得工具链体验并辅以devtool为 Yocto 项目环境量身定制的强大命令集，您将使用可扩展 SDK。</p>
<p>安装的可扩展 SDK 由多个文件和目录组成。基本上，它包含一个 SDK 环境设置脚本、一些配置文件、一个内部构建系统和devtool 功能。</p>
<p>2.2安装可扩展SDK
您需要做的第一件事是通过运行安装脚本在构建主机上安装 SDK。<a href="#id113"><span class="problematic" id="id114">*</span></a>.sh</p>
<p>您可以从版本索引中的相应 工具链目录下载 tarball 安装程序，其中包括预构建的工具链、runqemu脚本、内部构建系统 和支持文件。工具链可分别用于带有目录的多个 32 位和 64 位体系结构。Yocto 项目提供的工具链基于 和图像，并包含适合针对该图像进行开发的库。devtoolx86_64core-image-satocore-image-minimal</p>
<p>tarball 安装程序脚本的名称是这样的，表示主机系统的字符串首先出现在文件名中，然后紧随其后的是表示目标体系结构的字符串。可扩展的 SDK 将字符串“-ext”作为名称的一部分。以下是一般形式：</p>
<p>poky-glibc-host_system-image_type-arch-toolchain-ext-release_version.sh</p>
<dl>
<dt>Where:</dt><dd><p>host_system is a string representing your development system:</p>
<blockquote>
<div><p>i686 or x86_64.</p>
</div></blockquote>
<p>image_type is the image for which the SDK was built:</p>
<blockquote>
<div><p>core-image-sato or core-image-minimal</p>
</div></blockquote>
<p>arch is a string representing the tuned target architecture:</p>
<blockquote>
<div><p>aarch64, armv5e, core2-64, i586, mips32r2, mips64, ppc7400, or cortexa8hf-neon</p>
</div></blockquote>
<p>release_version is a string representing the release number of the Yocto Project:</p>
<blockquote>
<div><p>3.4.2, 3.4.2+snapshot</p>
</div></blockquote>
</dd>
</dl>
<p>例如，以下 SDK 安装程序适用于 64 位开发主机系统和基于 SDKcore-image-sato并使用当前 3.4.2 快照的 i586 调整目标架构：</p>
<p>poky-glibc-x86_64-core-image-sato-i586-toolchain-ext-3.4.2.sh
笔记</p>
<p>作为下载 SDK 的替代方法，您可以构建 SDK 安装程序。有关构建安装程序的信息，请参阅 构建 SDK 安装程序 部分。</p>
<p>SDK 和工具链是自包含的，默认情况下安装poky_sdk在您的主目录中的文件夹中。运行安装程序时，您可以选择在任何位置安装可扩展 SDK。但是，由于在正常运行过程中需要将文件写入该目录下，因此您选择的安装位置对于需要使用 SDK 的用户必须是可写的。</p>
<p>以下命令显示了如何在给定 64 位 x86 开发主机系统和 64 位 x86 目标体系结构的工具链 tarball 的情况下运行安装程序。该示例假定 SDK 安装程序位于 ~/Downloads/并具有执行权限。</p>
<p>笔记</p>
<p>如果您对安装 SDK 的目录没有写入权限，安装程序会通知您并退出。对于这种情况，请在目录中设置适当的权限并再次运行安装程序。</p>
<p>$ ./Downloads/poky-glibc-x86_64-core-image-minimal-core2-64-toolchain-ext-2.5.sh
Poky (Yocto Project Reference Distro) Extensible SDK installer version 2.5
==========================================================================
Enter target directory for SDK (default: poky_sdk):
You are about to install the SDK to “/home/scottrif/poky_sdk”. Proceed [Y/n]? Y
Extracting SDK…………..done
Setting it up…
Extracting buildtools…
Preparing build system…
Parsing recipes: 100% <a href="#id159"><span class="problematic" id="id160">|##################################################################|</span></a> Time: 0:00:52
Initialising tasks: 100% <a href="#id161"><span class="problematic" id="id162">|###############################################################|</span></a> Time: 0:00:00
Checking sstate mirror object availability: 100% <a href="#id163"><span class="problematic" id="id164">|#######################################|</span></a> Time: 0:00:00
Loading cache: 100% <a href="#id165"><span class="problematic" id="id166">|####################################################################|</span></a> Time: 0:00:00
Initialising tasks: 100% <a href="#id167"><span class="problematic" id="id168">|###############################################################|</span></a> Time: 0:00:00
done
SDK has been successfully set up and is ready to be used.
Each time you wish to use the SDK in a new shell session, you need to source the environment setup script e.g.</p>
<blockquote>
<div><p>$ . /home/scottrif/poky_sdk/environment-setup-core2-64-poky-linux</p>
</div></blockquote>
<p>2.3运行可扩展 SDK 环境设置脚本
安装 SDK 后，必须先运行 SDK 环境设置脚本，然后才能实际使用 SDK。此安装脚本位于您在安装 SDK 时选择的目录中，该目录可以是默认poky_sdk目录，也可以是您在安装期间选择的目录。</p>
<p>在运行脚本之前，请确保它与您正在开发的体系结构相匹配。环境设置脚本以字符串“ ”开头，environment-setup并在其名称中包含调整后的目标架构。例如，以下命令将工作目录设置为安装 SDK 的位置，然后获取环境设置脚本。在此示例中，设置脚本适用于使用 i586 调整的基于 IA 的目标计算机：</p>
<p>$ cd /home/scottrif/poky_sdk
$ source environment-setup-core2-64-poky-linux
SDK environment now set up; additionally you may now run devtool to perform development tasks.
Run devtool –help for further details.
运行设置脚本定义了使用 SDK 所需的许多环境变量（例如CCPATH、 LD等 ）。如果您想查看脚本导出的所有环境变量，请检查安装文件本身。</p>
<p>2.4devtool在您的 SDK 工作流程中使用
可扩展 SDK 的基石是一个名为 devtool. 该工具提供了许多功能，可帮助您在可扩展 SDK 中构建、测试和打包软件，并可选择将其集成到由 OpenEmbedded 构建系统构建的映像中。</p>
<p>笔记</p>
<p>devtool 的使用不仅限于可扩展的 SDK。您可以使用 devtool 帮助您轻松开发构建输出必须是使用构建系统构建的映像的一部分的任何项目。</p>
<p>命令行的组织方式与Gitdevtool类似 ，每个函数都有许多子命令。您可以运行以查看所有命令。devtool –help</p>
<p>笔记</p>
<p>有关 devtool 的快速参考，请参阅 Yocto 项目参考手册中的“devtool 快速参考”。</p>
<p>三个devtool子命令提供了开发的入口点：</p>
<p>devtool add：协助添加要构建的新软件。</p>
<p>devtool modify：设置环境以使您能够修改现有组件的源。</p>
<p>devtool upgrade：更新现有配方，以便您可以为一组更新的源文件构建它。</p>
<p>与构建系统一样，“recipes”代表 devtool. 当您使用 时，会自动创建一个配方。使用 时，将使用指定的现有配方以确定从何处获取源代码以及如何修补它。在这两种情况下，都会设置一个环境，以便在您构建配方时使用您控制的源代码树，以便您可以根据需要对源代码进行更改。默认情况下，新配方和源代码进入 SDK 下的“工作区”目录。devtool adddevtool modify</p>
<p>本节的其余部分介绍、 和工作流程。devtool adddevtool modifydevtool upgrade</p>
<p>2.4.1用于添加应用devtool add
该命令根据现有源代码生成新配方。此命令利用了 许多命令使用的工作空间层结构层。该命令足够灵活，允许您将源代码提取到工作区或单独的本地 Git 存储库中，并使用不需要提取的现有代码。devtool adddevtool</p>
<p>根据您的特定场景，您使用的参数和选项会形成不同的组合。下图显示了您将与该 命令一起使用的常见开发流程：devtool adddevtool add</p>
<p>sdk-devtool-add-flow.png</p>
<p>生成新配方：流程的顶部显示了三个场景，您可以使用这些场景根据现有源代码生成配方。devtool add</p>
<p>在共享开发环境中，通常由其他开发人员负责源代码的各个领域。作为开发人员，您可能有兴趣在 Yocto 项目中使用该源代码作为开发的一部分。您所需要的只是访问代码、配方和工作的受控区域。</p>
<p>在该图中，三种可能的场景会输入到 工作流中：devtool add</p>
<p>Left：图中左边的场景代表了一种常见的情况，即本地不存在源代码，需要提取。在这种情况下，源代码被提取到默认工作区 - 您不希望文件位于工作区之外的某个特定位置。因此，您需要的一切都将位于工作区中：</p>
<p>$ devtool add recipe fetchuri
使用此命令，devtool将上游源文件提取到sources 文件夹内的本地 Git 存储库中。该命令然后在工作区中创建一个名为 recipe 的配方和一个相应的附加文件。如果您不提供配方，该命令会尝试确定配方名称。</p>
<p>Middle：图中中间的场景也代表了本地不存在源码的情况。在这种情况下，代码再次位于上游，需要提取到某个本地区域——这次是在默认工作区之外。</p>
<p>笔记</p>
<p>如果需要，devtool 总是在提取过程中在本地创建一个 Git 存储库。</p>
<p>此外，srctree在这种情况下，第一个位置参数标识命令将提取的代码定位到工作区之外的位置。您需要指定一个空目录：devtool add</p>
<p>$ devtool add recipe srctree fetchuri
总之，源代码是从 fetchuri 中提取并提取到srctree本地 Git 存储库定义的位置。</p>
<p>在工作区中，devtool创建一个名为 recipe 的配方以及关联的附加文件。</p>
<p>右：图中的右场景表示srctree先前已在 devtool工作区之外准备好的情况。</p>
<p>以下命令提供了一个新的配方名称并标识了现有的源代码树位置：</p>
<p>$ devtool add recipe srctree
该命令检查源代码并为代码创建一个名为 recipe 的配方，并将该配方放入工作区。</p>
<p>因为提取的源代码已经存在，devtool所以不会尝试将源代码重新定位到工作区中 - 只会将新配方放置在工作区中。</p>
<p>除了配方文件夹之外，该命令还创建一个关联的附加文件夹并*.bbappend在其中放置一个初始文件。</p>
<p>编辑配方：您可以使用打开环境变量定义的编辑器并修改文件：devtool edit-recipe$EDITOR</p>
<p>$ devtool edit-recipe recipe
在编辑器中，您可以对配方进行修改，以便在以后构建时生效。</p>
<p>构建配方或重建图像：您采取的下一步取决于您将如何处理新代码。</p>
<p>如果您最终需要将构建输出移动到目标硬件，请使用以下devtool命令：:;</p>
<p>$ devtool 构建配方</p>
<p>另一方面，如果您希望图像包含工作区中的配方包以便立即部署到设备上（例如，出于测试目的），您可以使用以下 命令：devtool build-image</p>
<p>$ devtool build-image image
部署构建输出：当您使用命令构建配方时，您可能想查看生成的构建输出是否在目标硬件上按预期工作。devtool build</p>
<p>笔记</p>
<p>此步骤假定您有一个先前构建的映像，该映像已经在 QEMU 中运行或在实际硬件上运行。此外，假设为了将映像部署到目标，SSH 安装在映像中，并且如果映像在真实硬件上运行，则您可以通过网络访问和从您的开发机器访问。</p>
<p>您可以使用以下 命令将构建输出部署到该目标硬件： $ devtool deploy-target recipe target 目标是作为 SSH 服务器运行的实时目标机器。devtool deploy-target</p>
<p>当然，您也可以使用该命令将构建的映像部署到实际硬件。但是， 不提供允许您将映像部署到实际硬件的特定命令。devtool build-imagedevtool</p>
<p>使用配方完成您的工作：该命令创建与本地 Git 存储库中的提交对应的任何补丁，将新配方移动到更永久的层，然后重置配方，以便正常构建配方而不是从工作区构建。devtool finish</p>
<p>$ devtool finish recipe layer
笔记</p>
<p>您想要转换为补丁的任何更改都必须提交到源代码树中的 Git 存储库。</p>
<p>如前所述，该命令将最终配方移动到其永久层。devtool finish</p>
<p>作为命令的最后一个过程，标准层和上游源的状态被恢复，以便您可以从这些区域而不是工作区构建配方。devtool finish</p>
<p>笔记</p>
<p>如果您决定不想继续您的工作，您可以使用 devtool reset 命令将其放回原处。如果您确实使用此命令，请意识到源代码树已被保留。</p>
<p>2.4.2用于修改现有组件的来源devtool modify
该命令准备处理现有代码的方式，这些代码已经具有用于构建软件的本地配方。该命令足够灵活，允许您从上游源中提取代码，指定现有配方，并跟踪和收集与代码相关联的其他开发人员的任何补丁文件。devtool modify</p>
<p>根据您的特定场景，您使用的参数和选项会形成不同的组合。 下图显示了该命令的常见开发流程：devtool modifydevtool modify</p>
<p>sdk-devtool-modify-flow.png</p>
<p>准备修改代码：流程的顶部显示了三个场景，您可以通过这些场景准备处理源文件。每个场景都假定以下内容：devtool modify</p>
<p>配方本地存在于devtool 工作区外部的层中。</p>
<p>源文件要么以未提取状态存在于上游，要么以先前提取的状态存在于本地。</p>
<p>典型情况是另一个开发人员创建了一个用于 Yocto 项目的层，并且他们的配方已经驻留在该层中。此外，它们的源代码在上游或本地都很容易获得。</p>
<p>左：图中左边的场景代表一种常见的情况，即本地不存在源代码，需要从上游源中提取。在这种情况下，源将被提取到默认devtool工作区位置。在这种情况下，配方位于工作区之外的自己的层中（即meta-层名）。</p>
<p>以下命令标识配方，并在默认情况下提取源文件：</p>
<p>$ devtool modify recipe
找到 devtool配方后，devtool使用配方的 SRC_URI语句来定位源代码和来自其他开发人员的任何本地补丁文件。</p>
<p>在这种情况下，没有srctree争论。因此，该命令的默认行为是将SRC_URI语句指向的源文件提取到本地 Git 结构中。此外，提取源的位置是工作空间内的默认区域。结果是该命令在工作空间内设置了源代码和附加文件，而配方仍保留在其原始位置。devtool modifydevtool</p>
<p>此外，如果您有任何非补丁本地文件（即在SRC_URI语句中不包括or的file://条目引用的文件），这些文件将被复制到新创建的源代码树下的文件夹中。在此处复制文件为您提供了一个方便的区域，您可以从中修改文件。您对这些文件所做的任何更改或添加都会在您下次构建软件时合并到构建中，就像您可能对源代码所做的其他更改一样。<em>.patch/</em>.diffoe-local-files</p>
<p>Middle : 图中中间的场景代表了源代码在本地也不存在的情况。在这种情况下，代码再次处于上游，需要提取到某个本地区域作为 Git 存储库。在这种情况下，配方再次是本地的，并且位于工作区之外的自己的层中。</p>
<p>以下命令告诉devtool要使用的配方，并且在这种情况下，识别存在于默认devtool 工作区之外的提取源文件的本地区域：</p>
<p>$ devtool modify recipe srctree
笔记</p>
<p>您不能使用 devtool 命令为 srctree 提供 URL。</p>
<p>与所有提取一样，该命令使用配方的SRC_URI 语句来定位源文件和任何相关的补丁文件。非补丁文件被复制到oe-local-files新创建的源代码树下的文件夹中。</p>
<p>找到文件后，该命令默认将它们提取到srctree.</p>
<p>在工作区中，devtool为配方创建一个附加文件。配方保留在其原始位置，但源文件被提取到您提供的位置srctree。</p>
<p>右：图中的右场景表示源树 ( srctree) 已作为先前提取的devtool 工作区之外的 Git 结构存在于本地的情况。在这个例子中，配方也存在于它自己层的本地其他地方。</p>
<p>以下命令告诉devtool要使用的配方，使用“-n”选项指示不需要提取源，并使用srctree指向先前提取的源文件：</p>
<p>$ devtool modify -n recipe srctree
如果oe-local-files子目录碰巧存在并且它包含非补丁文件，则使用这些文件。但是，如果子目录不存在并且您运行该 命令，则配方旁边可能存在的任何非补丁文件都将被删除，因为您似乎已删除了这些文件。devtool finishdevtool</p>
<p>命令完成后，它只会在工作区中为配方创建一个附加文件。配方和源代码保留在其原始位置。devtool modifydevtool</p>
<p>编辑源代码：一旦您使用了该命令，您就可以自由地对源文件进行更改。您可以使用任何您喜欢的编辑器来制作并保存您的源代码修改。devtool modify</p>
<p>构建配方或重建图像：您采取的下一步取决于您将如何处理新代码。</p>
<p>如果您最终需要将构建输出移动到目标硬件，请使用以下devtool命令：</p>
<p>$ devtool build recipe
另一方面，如果您希望映像包含工作区中的配方包以便立即部署到设备上（例如，出于测试目的），您可以使用 命令： $ devtool build-image imagedevtool build-image</p>
<p>部署构建输出：当您使用命令构建配方时，您可能想查看生成的构建输出是否在目标硬件上按预期工作。devtool build</p>
<p>笔记</p>
<p>此步骤假设您有一个先前构建的映像，该映像已经在 QEMU 中运行或在实际硬件上运行。此外，假设为了将映像部署到目标，SSH 安装在映像中，并且如果映像在真实硬件上运行，则您可以通过网络访问和从您的开发计算机访问。</p>
<p>您可以使用以下 命令将构建输出部署到该目标硬件：devtool deploy-target</p>
<p>$ devtool deploy-target recipe target
目标是作为 SSH 服务器运行的实时目标机器。</p>
<p>当然，您可以使用其他方法将使用命令构建的映像部署到实际硬件。 不提供将映像部署到实际硬件的特定命令。devtool build-imagedevtool</p>
<p>使用配方完成您的工作：该命令在本地 Git 存储库中创建与提交对应的任何补丁，更新配方以指向它们（或创建一个 文件以执行此操作，具体取决于指定的目标层），然后重置配方这样配方是正常构建的，而不是从工作区构建的。devtool finish.bbappend</p>
<p>$ devtool finish recipe layer
笔记</p>
<p>在您使用 devtool 完成命令之前，您必须在本地 Git 存储库中暂存并提交您想要转换为补丁的任何更改。</p>
<p>因为不需要移动配方， 要么更新原始层中的原始配方，要么命令在层提供的不同层中创建文件。您在目录中所做的任何工作都会在命令期间保存在配方旁边的原始文件中 。devtool finish.bbappendoe-local-filesdevtool finish</p>
<p>作为命令的最后一个过程，标准层和上游源的状态被恢复，以便您可以从这些区域而不是从工作区构建配方。devtool finish</p>
<p>笔记</p>
<p>如果您决定不想继续您的工作，您可以使用 devtool reset 命令将其放回原处。如果您确实使用此命令，请意识到源代码树已被保留。</p>
<p>2.4.3用于创建支持较新版本软件的配方版本devtool upgrade
该命令将现有配方升级到上游找到的更新版本。在软件的整个生命周期中，配方会不断地由其上游发布者进行版本升级。您可以使用工作流程来确保您用于构建的配方与上游对应的配方是最新的。devtool upgradedevtool upgrade</p>
<p>笔记</p>
<p>有几种方法可以用来升级配方—— 恰好是其中一种。您可以在 Yocto 项目开发任务手册的 升级配方部分中阅读有关升级配方的所有方法。devtool upgrade</p>
<p>该命令足够灵活，允许您指定源代码修订和版本控制方案，将代码提取到工作区层结构或从中提取代码，并使用Fetchers支持的任何源文件形式 。devtool upgradedevtool</p>
<p>下图显示了与该命令一起使用的常见开发流程 ：devtool upgrade</p>
<p>sdk-devtool-upgrade-flow.png</p>
<p>启动升级：流程的顶部显示了您使用该命令的典型场景。存在以下条件：devtool upgrade</p>
<p>配方存在于devtool 工作区外部的本地层中。</p>
<p>新版本的源文件存在于配方中SRC_URI指向的相同位置 （例如，名称中包含新版本号的 tarball，或作为上游 Git 存储库中的不同修订版）。</p>
<p>一种常见的情况是第三方软件已经过修订，因此已经升级。您可以访问的配方可能在您自己的层中。因此，您需要升级配方以使用较新版本的软件：</p>
<p>$ devtool upgrade -V version recipe
默认情况下，该命令将源代码提取到The Workspace Layer Structure中的目录中 。如果要将代码提取到任何其他位置，则需要使用命令提供位置参数，如下所示：devtool upgradesourcessrctree</p>
<p>$ devtool upgrade -V version recipe srctree
笔记</p>
<p>在此示例中，“-V”选项指定新版本。如果您不使用“-V”，该命令会将配方升级到最新版本。</p>
<p>如果配方中SRC_URI语句指向的源文件位于 Git 存储库中，则必须提供“-S”选项并指定软​​件的修订版。</p>
<p>一旦devtool找到配方，它就会使用SRC_URI变量来定位源代码和来自其他开发人员的任何本地补丁文件。结果是该命令在工作区中设置了源代码、新版本的配方和一个附加文件。</p>
<p>此外，如果您有任何非补丁本地文件（即在SRC_URI语句中不包括or的file://条目引用的文件），这些文件将被复制到 新创建的源代码树下的文件夹中。在此处复制文件为您提供了一个方便的区域，您可以从中修改文件。您对这些文件所做的任何更改或添加都会在您下次构建软件时合并到构建中，就像您可能对源代码所做的其他更改一样。<em>.patch/</em>.diffoe-local-files</p>
<p>解决升级造成的任何冲突：将软件升级到新版本后可能会发生冲突。如果您的配方在SRC_URI中指定了一些与新版本软件中所做的更改冲突的补丁文件，则会发生冲突。对于这种情况，您需要通过编辑源代码并遵循正常的冲突解决流程来解决冲突。git rebase</p>
<p>在进行下一步之前，请务必解决因使用更新或不同版本的软件而产生的任何此类冲突。</p>
<p>构建配方或重建图像：您采取的下一步取决于您将如何处理新代码。</p>
<p>如果您最终需要将构建输出移动到目标硬件，请使用以下devtool命令：</p>
<p>$ devtool build recipe
另一方面，如果您希望图像包含工作区中的配方包以便立即部署到设备上（例如，出于测试目的），您可以使用以下 命令：devtool build-image</p>
<p>$ devtool build-image image
部署构建输出：当您使用命令或构建配方时，您可能想查看生成的构建输出是否在目标硬件上按预期工作。devtool buildbitbake</p>
<p>笔记</p>
<p>此步骤假设您有一个先前构建的映像，该映像已经在 QEMU 中运行或在实际硬件上运行。此外，假设为了将映像部署到目标，SSH 安装在映像中，并且如果映像在真实硬件上运行，则您可以通过网络访问和从您的开发计算机访问。</p>
<p>您可以使用以下 命令将构建输出部署到该目标硬件： $ devtool deploy-target recipe target 目标是作为 SSH 服务器运行的实时目标机器。devtool deploy-target</p>
<p>当然，您也可以将使用该 命令构建的映像部署到实际硬件。但是， 不提供允许您执行此操作的特定命令。devtool build-imagedevtool</p>
<p>使用配方完成您的工作：该命令创建与本地 Git 存储库中的提交对应的任何补丁，将新配方移动到更永久的层，然后重置配方，以便正常构建配方而不是从工作区构建。devtool finish</p>
<p>您在目录中所做的任何工作都会在 命令oe-local-files期间保存在配方旁边的原始文件中。devtool finish</p>
<p>如果您指定与原始源相同的目标层，则在添加新版本之前删除旧版本的配方和相关文件。</p>
<p>$ devtool finish recipe layer
笔记</p>
<p>您想要转换为补丁的任何更改都必须提交到源代码树中的 Git 存储库。</p>
<p>作为命令的最后一个过程，标准层和上游源的状态被恢复，以便您可以从这些区域而不是工作区构建配方。devtool finish</p>
<p>笔记</p>
<p>如果您决定不想继续您的工作，您可以使用 devtool reset 命令将其放回原处。如果您确实使用此命令，请意识到源代码树已被保留。</p>
<p>2.5仔细观察devtool add
该命令会根据您随命令提供的源代码树自动创建配方。目前，该命令支持以下内容：devtool add</p>
<p>自动工具（autoconf和automake）</p>
<p>制作</p>
<p>斯康斯</p>
<p>qmake</p>
<p>清楚的Makefile</p>
<p>树外内核模块</p>
<p>二进制包（即“-b”选项）</p>
<p>Node.js 模块</p>
<p>Python 模块使用setuptools或distutils</p>
<p>除了二进制包之外，如何处理源树的决定是根据源树中存在的文件自动确定的。例如，如果CMakeLists.txt找到一个文件，则假定源代码树正在使用 CMake 并进行相应处理。</p>
<p>笔记</p>
<p>在大多数情况下，您需要编辑自动生成的配方以使其正确构建。通常，您将经历几个编辑和构建周期，直到配方成功构建。配方构建后，您可以使用可能的进一步迭代在目标设备上测试配方。</p>
<p>本节的其余部分涵盖有关如何生成部分配方的细节。</p>
<p>2.5.1名称和版本
如果您没有在命令行上指定名称和版本，则 使用源代码树中的各种元数据来尝试确定正在构建的软件的名称和版本。根据工具确定的内容，相应地设置创建的配方文件的名称。devtool adddevtool</p>
<p>如果devtool无法确定名称和版本，该命令将打印错误。对于这种情况，您必须重新运行命令并提供名称和版本，仅提供名称或版本作为命令行的一部分。</p>
<p>有时，从源代码树确定的名称或版本可能不正确。对于这种情况，您必须重置配方：</p>
<p>$ devtool reset -n recipename
运行命令后，您需要再次运行并提供名称或版本。devtool resetdevtool add</p>
<p>2.5.2依赖检测与映射
该命令尝试检测构建时依赖项并将它们映射到系统中的其他配方。在此映射期间，该命令将这些配方的名称填充为配方中 DEPENDS变量的一部分。如果无法映射依赖项，请在配方中放置注释以指示此类。无法映射依赖项可能是由于命名未被识别或依赖项根本不可用造成的。对于依赖项不可用的情况，您必须使用命令添加满足依赖项的附加配方。添加该配方后，您需要更新原始配方中的DEPENDS变量以包含新配方。devtool adddevtooldevtool add</p>
<p>如果您需要添加运行时依赖项，可以通过将以下内容添加到您的配方中来实现：</p>
<p>RDEPENDS:${PN} += “dependency1 dependency2 …”
笔记</p>
<p>devtool add 命令通常无法区分强制依赖项和可选依赖项。因此，某些检测到的依赖项实际上可能是可选的。如有疑问，请查阅配方正在构建的软件的文档或配置脚本以获取更多详细信息。在某些情况下，您可能会发现可以将依赖项替换为禁用传递给配置脚本的相关功能的选项。</p>
<p>2.5.3许可证检测
该命令尝试确定您添加的软件是否能够在通用的开源许可下分发。如果是这样，该命令会相应地设置 LICENSE值。您应该根据您正在构建的软件的文档或源文件仔细检查命令添加的值，并在必要时更新该LICENSE值。devtool add</p>
<p>该命令还将 LIC_FILES_CHKSUM 值设置为指向似乎与许可证相关的所有文件。意识到许可证声明经常出现在源文件顶部或文档中的注释中。在这种情况下，该命令无法识别那些许可声明。因此，您可能需要修改LIC_FILES_CHKSUM变量以指向其中的一个或多个注释（如果存在）。设置LIC_FILES_CHKSUM对于第三方软件尤为重要。如果您将来将配方升级到更新的上游版本，该机制会尝试确保正确的许可。检测到任何许可更改，您会收到一条错误消息，提示您再次检查许可文本。devtool add</p>
<p>如果该命令无法确定许可信息， 则将LICENSE值设置为“CLOSED”，并使 LIC_FILES_CHKSUM值未设置。即使设置不可能在所有情况下都是正确的，此行为也允许您继续开发。您应该检查您正在构建的软件的文档或源文件以确定实际的许可证。devtool adddevtool</p>
<p>2.5.4添加 Makefile-Only 软件
Make 本身的使用在专有软件和开源软件中都非常普遍。不幸的是，编写 Makefile 时通常没有考虑到交叉编译。因此，通常无法确保这些 Makefile 正确构建。例如，显式调用而不是使用 CC变量是很常见的。通常，在交叉编译环境中，是构建主机的编译器，并且交叉编译器的名称类似于 并且可能需要参数（例如，指向目标机器的相关 sysroot）。devtool addgccgccarm-poky-linux-gnueabi-gcc</p>
<p>在为 Makefile-only 软件编写配方时，请记住以下几点：</p>
<p>gcc您可能需要修补 Makefile 以使用变量而不是工具链中的硬编码工具，例如g++.</p>
<p>Make 运行的环境设置了各种编译的标准变量（例如CC、CXX等），其方式与 SDK 的环境设置脚本设置的环境类似。查看这些变量的一种简单方法是 在配方上运行命令，然后查看 . 在该文件的顶部，有一个设置的环境变量列表。您可以在 Makefile 中利用这些变量。devtool buildoe-logs/run.do_compile</p>
<p>如果 Makefile 使用“=”为变量设置默认值，则该默认值会覆盖环境中设置的值，这通常是不可取的。对于这种情况，您可以修补 Makefile 以便它使用“？=”运算符设置默认值，或者您也可以在make命令行上强制该值。要在命令行上强制使用该值，请将变量设置添加到 配方中的EXTRA_OEMAKE或 PACKAGECONFIG_CONFARGS 。这是使用EXTRA_OEMAKE的示例：</p>
<p>EXTRA_OEMAKE += “‘CC=${CC}’ ‘CXX=${CXX}’”
在上面的示例中，变量设置周围使用了单引号，因为值可能包含空格，因为所需的默认选项被传递给编译器。</p>
<p>Makefile 中的硬编码路径在交叉编译环境中通常会出现问题。尤其如此，因为这些硬编码路径通常指向构建主机上的位置，因此要么是只读的，要么会在交叉编译中引入污染，因为它们特定于构建主机而不是目标。修补 Makefile 以使用前缀变量或其他路径变量通常是处理这种情况的方法。</p>
<p>有时，Makefile 会运行特定于目标的命令，例如 ldconfig. 对于这种情况，您可能能够应用从 Makefile 中删除这些命令的补丁。</p>
<p>2.5.5添加原生工具
通常，您需要构建在构建主机而不是目标上运行的其他工具。您应该在运行时使用以下方法之一指示此要求：devtool add</p>
<p>指定配方的名称，使其以“-native”结尾。像这样指定名称会生成一个只为构建主机构建的配方。</p>
<p>使用命令指定“–also-native”选项 。指定此选项会创建一个仍然为目标构建的配方文件，但还会创建一个带有“-native”后缀的变体，该变体为构建主机构建。devtool add</p>
<p>笔记</p>
<p>如果您需要添加作为源代码树的一部分提供的工具，该工具为目标构建代码，您通常可以通过分别构建本机和目标部分而不是在同一个编译过程中来完成此操作。尽管使用“–also-native”选项实现这一点，但您可以仅使用一个配方文件添加该工具。</p>
<p>2.5.6添加 Node.js 模块
您可以使用该命令以两种不同的方式添加 Node.js 模块：1) 通过和，2) 从存储库或本地源。devtool addnpm</p>
<p>使用以下表单通过以下方式添加 Node.js 模块npm：</p>
<p>$ devtool add “npm://registry.npmjs.org;name=forever;version=0.15.1”
名称和版本参数是必需的。配方生成并指向锁定和收缩包装文件，以便根据第一次冻结为依赖项获取的版本。这也保存了在未来获取时验证的校验和。这些行为共同确保了构建的可重复性和完整性。</p>
<p>笔记</p>
<p>您必须在 URL 周围使用引号。不需要引号，但 shell 会考虑“; ” 作为多个命令之间的分隔符。因此，如果没有引号， 则不会收到其他部分，这会导致几个“找不到命令”错误。devtool adddevtool add</p>
<p>为了支持添加 Node.js 模块，nodejs您的 SDK 中必须包含配方。</p>
<p>如前所述，您还可以直接从存储库或本地源代码树中添加 Node.js 模块。要以这种方式添加模块， 请按以下形式使用：devtool add</p>
<p>$ devtool add <a class="reference external" href="https://github.com/diversario/node-ssdp">https://github.com/diversario/node-ssdp</a>
在此示例中，devtool 获取指定的 Git 存储库，将代码检测为 Node.js 代码，使用 获取依赖项npm，并相应地设置 SRC_URI。</p>
<p>2.6使用配方
使用命令构建配方时，典型的构建过程如下：devtool build</p>
<p>获取源</p>
<p>解压源码</p>
<p>配置源</p>
<p>编译源码</p>
<p>安装构建输出</p>
<p>打包安装的输出</p>
<p>对于工作区中的配方，由于源树已经准备好并且是持久的，因此禁用了获取和解包。这些构建步骤中的每一个都被定义为一个函数（任务），通常带有“<a href="#id169"><span class="problematic" id="id170">do_</span></a>”前缀（例如do_fetch、 do_unpack等）。这些函数通常是 shell 脚本，但也可以用 Python 编写。</p>
<p>如果您查看配方的内容，您会发现该配方不包含构建软件的完整说明。inherit相反，通用功能被封装在与指令一起继承的类中。这种技术让配方只描述正在构建的软件特定的东西。有一个基类被所有配方隐式继承，并提供大多数配方通常需要的功能。</p>
<p>本节的其余部分提供了在使用配方时有用的信息。</p>
<p>2.6.1查找日志和工作文件
在第一次运行该命令后，先前使用该命令创建的或使用该命令修改其源的配方包含在源树中创建的符号链接：devtool builddevtool adddevtool modify</p>
<p>oe-logs：此链接指向为每个构建步骤创建日志文件和运行脚本的目录。</p>
<p>oe-workdir：此链接指向配方的临时工作区。以下位置oe-workdir特别有用：</p>
<p>image/：包含在 do_install阶段安装的所有文件。在配方中，此目录由表达式 ${D}引用。</p>
<p>sysroot-destdir/：包含已安装在 do_install共享系统根目录中的文件子集。有关详细信息，请参阅“在配方之间共享文件”部分。</p>
<p>packages-split/：包含配方生成的每个包的子目录。有关详细信息，请参阅“包装”部分。</p>
<p>您可以使用这些链接来获取有关每个构建步骤所发生情况的更多信息。</p>
<p>2.6.2设置配置参数
如果您的配方正在构建的软件使用 GNU autoconf，则将一组固定的参数传递给它以启用交叉编译以及 配方中设置的EXTRA_OECONF或 PACKAGECONFIG_CONFARGS指定的任何额外内容 。如果您希望传递其他选项，请将它们添加到EXTRA_OECONF或PACKAGECONFIG_CONFARGS。其他受支持的构建工具具有类似的变量（例如 ，用于 CMake 的EXTRA_OECMAKE 、用于 Scons 的EXTRA_OESCONS 等）。如果您需要在make 命令行上传递任何内容，您可以使用EXTRA_OEMAKE或 PACKAGECONFIG_CONFARGS 变量来执行此操作。</p>
<p>您可以使用该命令来帮助您设置上一段中列出的参数。该命令确定传递的确切选项，并将它们与通过EXTRA_OECONF或 PACKAGECONFIG_CONFARGS指定的任何自定义参数一起显示给您。如果适用，该命令还会显示配置脚本的“–help”选项的输出作为参考。devtool configure-help</p>
<p>2.6.3配方之间共享文件
配方通常需要使用 Build Host上其他配方提供的文件。例如，链接到公共库的应用程序需要访问库本身及其关联的标头。在可扩展 SDK 中完成此访问的方式是通过 sysroot。每台正在为其构建 SDK 的“机器”都有一个 sysroot。实际上，这意味着目标机器有一个 sysroot，构建主机有一个 sysroot。</p>
<p>配方永远不应该将文件直接写入 sysroot。相反，应该在D目录中的do_install任务期间将文件安装到标准位置 。这些文件的一个子集会自动进入 sysroot。此限制的原因是进入 sysroot 的几乎所有文件都在清单中进行了编目，以确保以后可以在修改或删除配方时将其删除。因此，sysroot 能够不受陈旧文件的影响。${}</p>
<p>2.6.4包装
打包在可扩展 SDK 中并不总是特别相关。但是，如果您检查构建输出如何进入目标设备上的最终映像，则了解打包非常重要，因为映像的内容是根据包而不是配方表示的。</p>
<p>在do_package 任务期间，在 do_install任务期间安装的文件被拆分为一个主包，该主包的名称几乎总是与配方相同，并分为几个其他包。之所以存在这种分离，是因为并非所有已安装的文件在每个图像中都有用。例如，您可能不需要在生产映像中安装任何文档。因此，对于每个配方，文档文件都被分成一个-doc包。包含可选模块或插件的打包软件的配方也可能会进行额外的包拆分。</p>
<p>构建配方后，您可以通过查看目录来查看文件的去向，该oe-workdir/packages-split目录包含每个包的子目录。除了一些高级案例， PACKAGES和 FILES变量控制拆分。PACKAGES变量列出了要生成的所有包，而FILES变量通过使用覆盖指定包来指定要包含在每个包中的文件。例如，FILES:${PN}指定要进入主包的文件（即主包与配方具有相同的名称，而 ${PN}计算为配方名称）。PACKAGES值的顺序很重要。对于每个安装的文件，第一个包FILES值匹配的文件是文件所在的包。PACKAGES和 FILES变量都有默认值。因此，您可能会发现您甚至不需要在配方中设置这些变量，除非配方正在构建的软件将文件安装到非标准位置。</p>
<p>2.7将目标设备恢复到原始状态
如果您使用该命令将配方的构建输出写入目标，并且您正在处理系统的现有组件，那么您可能会发现自己需要恢复在运行该 命令之前存在的原始文件. 由于该 命令会备份它覆盖的所有文件，因此您可以使用该 命令恢复这些文件并删除配方部署的任何其他文件。考虑以下示例：devtool deploy-targetdevtool deploy-targetdevtool deploy-targetdevtool undeploy-target</p>
<p>$ devtool undeploy-target lighttpd <a class="reference external" href="mailto:root&#37;&#52;&#48;192&#46;168&#46;7&#46;2">root<span>&#64;</span>192<span>&#46;</span>168<span>&#46;</span>7<span>&#46;</span>2</a>
如果您部署了多个应用程序，您可以使用“-a”选项将它们全部删除，从而将目标设备恢复到其原始状态：</p>
<p>$ devtool undeploy-target -a <a class="reference external" href="mailto:root&#37;&#52;&#48;192&#46;168&#46;7&#46;2">root<span>&#64;</span>192<span>&#46;</span>168<span>&#46;</span>7<span>&#46;</span>2</a>
有关部署到目标的文件以及任何备份文件的信息都存储在目标本身上。当然，这种存储需要目标机器上的一些额外空间。</p>
<p>笔记</p>
<p>devtool deploy-target 和 devtool undeploy-target 命令当前不与目标设备上的任何包管理系统（例如 RPM 或 OPKG）交互。因此，您不应在目标设备上混合使用 devtool 部署目标和包管理器操作。这样做可能会导致一组文件发生冲突。</p>
<p>2.8将附加项安装到可扩展 SDK 中
开箱即用的可扩展 SDK 通常只附带少量工具和库。最小的 SDK 开始时大部分是空的，然后按需填充。有时您必须在 SDK 中显式安装额外的项目。如果您需要这些额外的项目，您可以先使用命令搜索这些项目。例如，假设您需要链接到 libGL，但您不确定哪个配方提供了 libGL。您可以使用以下命令进行查找：devtool search</p>
<p>$ devtool search libGL mesa
OpenGL API 的免费实现一旦你知道了配方（即mesa在这个例子中），你可以安装它：</p>
<p>$ devtool sdk-install mesa
默认情况下，该命令假定该项目可从您的 SDK 提供商处以预构建的形式获得。如果该项目不可用并且可以从源代码构建项目，则可以添加“-s”选项，如下所示：devtool sdk-install</p>
<p>$ devtool sdk-install -s mesa
重要的是要记住，从源代码构建项目比安装预构建的工件花费的时间要长得多。此外，如果没有要添加到 SDK 的项目的配方，则必须改为使用命令添加项目。devtool add</p>
<p>2.9对已安装的可扩展 SDK 应用更新
如果您正在使用偶尔更新的已安装可扩展 SDK（例如第三方 SDK），那么您需要手动将更新“下拉”到已安装的 SDK 中。</p>
<p>要更新已安装的 SDK，请devtool按以下方式使用：</p>
<p>$ devtool sdk-update
前面的命令假定您的 SDK 提供商已通过SDK_UPDATE_URL 变量为您设置了默认更新 URL，如“安装后提供可扩展 SDK 的更新”部分所述。如果 SDK 提供者没有设置该默认 URL，您需要自己在命令中指定，如下所示： $ devtool sdk-update path_to_update_directory</p>
<p>笔记</p>
<p>该 URL 需要专门指向已发布的 SDK，而不是您要下载和安装的 SDK 安装程序。</p>
<p>2.10创建带有附加组件的衍生 SDK
您可能需要生成一个包含您自己的自定义库的 SDK。一个很好的例子是，如果您是一个供应商，其客户使用您的 SDK 来构建他们自己的平台特定软件，而这些客户需要具有自定义库的 SDK。在这种情况下，您可以按照以下步骤相当容易地根据当前安装的 SDK 生成衍生 SDK：</p>
<p>如有必要，安装一个可扩展的 SDK，作为衍生 SDK 的基础。</p>
<p>为 SDK 获取环境脚本。</p>
<p>使用该 命令添加所需的额外库或其他组件。devtool add</p>
<p>运行命令。devtool build-sdk</p>
<p>前面的步骤将配方添加到工作区并构建一个新的 SDK 安装程序，其中包含这些配方和生成的二进制工件。配方在构建的衍生 SDK 中进入它们自己的单独层，这使工作空间保持清洁，并为用户添加自己的配方做好准备。</p>
<p>3使用标准 SDK
本章介绍标准 SDK 及其安装方法。信息包括标准 SDK 的独特安装和设置方面。</p>
<p>笔记</p>
<p>有关标准 SDK 与可扩展 SDK 支持的主要功能的并排比较，请参阅“简介”部分。</p>
<p>您可以使用标准 SDK 处理基于 Makefile 和 Autotools 的项目。有关详细信息，请参阅“直接使用 SDK 工具链”一章。</p>
<p>3.1为什么要使用标准 SDK，里面有什么？
标准 SDK 提供了针对特定图像内容定制的交叉开发工具链和库。与提供内部构建系统和功能的可扩展 SDK 相比，如果您想要更传统的工具链体验，您将使用标准 SDK devtool。</p>
<p>安装的标准 SDK 包含多个文件和目录。基本上，它包含一个 SDK 环境设置脚本、一些配置文件以及主机和目标根文件系统以支持使用。您可以在“已安装的标准 SDK 目录结构”部分查看目录结构。</p>
<p>3.2安装 SDK
您需要做的第一件事是通过运行安装脚本在构建主机上安装 SDK。<a href="#id115"><span class="problematic" id="id116">*</span></a>.sh</p>
<p>您可以从版本索引中的相应工具链目录下载 tarball 安装程序，其中包括预构建的工具链、runqemu脚本和支持文件。工具链可分别用于带有目录的多个 32 位和 64 位体系结构。Yocto 项目提供的工具链基于 和图像，并包含适用于针对相应图像进行开发的库。x86_64core-image-satocore-image-minimal</p>
<p>tarball 安装程序脚本的名称是这样的，表示主机系统的字符串首先出现在文件名中，然后紧随其后的是表示目标体系结构的字符串。</p>
<p>poky-glibc-host_system-image_type-arch-toolchain-release_version.sh</p>
<dl>
<dt>Where:</dt><dd><p>host_system is a string representing your development system:</p>
<blockquote>
<div><p>i686 or x86_64.</p>
</div></blockquote>
<p>image_type is the image for which the SDK was built:</p>
<blockquote>
<div><p>core-image-minimal or core-image-sato.</p>
</div></blockquote>
<p>arch is a string representing the tuned target architecture:</p>
<blockquote>
<div><p>aarch64, armv5e, core2-64, i586, mips32r2, mips64, ppc7400, or cortexa8hf-neon.</p>
</div></blockquote>
<p>release_version is a string representing the release number of the Yocto Project:</p>
<blockquote>
<div><p>3.4.2, 3.4.2+snapshot</p>
</div></blockquote>
</dd>
</dl>
<p>例如，以下 SDK 安装程序适用于 64 位开发主机系统和基于 SDKcore-image-sato并使用当前 DISTRO 快照的 i586 调整目标架构：</p>
<p>poky-glibc-x86_64-core-image-sato-i586-toolchain-DISTRO.sh
笔记</p>
<p>作为下载 SDK 的替代方法，您可以构建 SDK 安装程序。有关构建安装程序的信息，请参阅“构建 SDK 安装程序”部分。</p>
<p>SDK 和工具链是自包含的，默认情况下安装poky_sdk在您的主目录中的文件夹中。运行安装程序时，您可以选择在任何位置安装可扩展 SDK。但是，由于在正常运行过程中需要将文件写入该目录下，因此您选择的安装位置对于需要使用 SDK 的用户必须是可写的。</p>
<p>以下命令显示了如何在给定 64 位 x86 开发主机系统和 64 位 x86 目标体系结构的工具链 tarball 的情况下运行安装程序。该示例假定 SDK 安装程序位于 ~/Downloads/并具有执行权限。</p>
<p>笔记</p>
<p>如果您对安装 SDK 的目录没有写入权限，安装程序会通知您并退出。对于这种情况，请在目录中设置适当的权限并再次运行安装程序。</p>
<p>$ ./Downloads/poky-glibc-x86_64-core-image-sato-i586-toolchain-3.4.2.sh
Poky (Yocto Project Reference Distro) SDK installer version 3.4.2
===============================================================
Enter target directory for SDK (default: /opt/poky/3.4.2):
You are about to install the SDK to “/opt/poky/3.4.2”. Proceed [Y/n]? Y
Extracting SDK…………………………………. …………………………done
Setting it up…done
SDK has been successfully set up and is ready to be used.
Each time you wish to use the SDK in a new shell session, you need to source the environment setup script e.g.</p>
<blockquote>
<div><p>$ . /opt/poky/3.4.2/environment-setup-i586-poky-linux</p>
</div></blockquote>
<p>同样，请参考“已安装的标准 SDK 目录结构”部分以获取有关已安装 SDK 的结果目录结构的更多详细信息。</p>
<p>3.3运行 SDK 环境设置脚本
安装 SDK 后，必须先运行 SDK 环境设置脚本，然后才能实际使用 SDK。此安装脚本位于您在安装 SDK 时选择的目录中，该目录可以是默认/opt/poky/3.4.2目录，也可以是您在安装期间选择的目录。</p>
<p>在运行脚本之前，请确保它与您正在开发的体系结构相匹配。环境设置脚本以字符串“ ”开头，environment-setup并在其名称中包含调整后的目标架构。例如，以下命令将工作目录设置为安装 SDK 的位置，然后获取环境设置脚本。在此示例中，设置脚本适用于使用 i586 调整的基于 IA 的目标计算机：</p>
<p>$ source /opt/poky/3.4.2/environment-setup-i586-poky-linux
运行设置脚本时，定义的环境变量与运行可扩展 SDK 的设置脚本时相同。有关详细信息，请参阅“已安装的可扩展 SDK 目录结构”部分。</p>
<p>4直接使用 SDK 工具链
您可以将 SDK 工具链直接用于 Makefile 和基于 Autotools 的项目。</p>
<p>4.1基于 Autotools 的项目
一旦您安装了合适的 The Cross-Development Toolchain ，使用基于GNU Autotools 的工作流程（在OpenEmbedded 构建系统 之外） 开发项目非常容易。</p>
<p>下图展示了一个简单的 Autotools 工作流程。</p>
<p>sdk-autotools-flow.png
按照以下步骤创建一个简单的基于 Autotools 的“Hello World”项目：</p>
<p>笔记</p>
<p>有关 GNU Autotools 工作流程的更多信息，请参阅 GNOME 开发人员站点上的相同示例。</p>
<p>创建一个工作目录并填充它：为您的项目创建一个干净的目录，然后将该目录作为您的工作位置。</p>
<p>$ mkdir $HOME/helloworld
$ cd $HOME/helloworld
设置目录后，用流所需的文件填充它。您需要一个项目源文件、一个帮助配置的文件、一个帮助创建 Makefile 的文件和一个 README 文件： 分别hello.c是 、configure.ac、Makefile.am和README。</p>
<p>使用以下命令创建一个空的 README 文件，这是 GNU 编码标准所要求的：</p>
<p>$ touch README
创建其余三个文件，如下所示：</p>
<p>hello.c：</p>
<p>#include &lt;stdio.h&gt;</p>
<dl>
<dt>main()</dt><dd><dl class="simple">
<dt>{</dt><dd><p>printf(“Hello World!n”);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>configure.ac：</p>
<p>AC_INIT(hello,0.1)
AM_INIT_AUTOMAKE([foreign])
AC_PROG_CC
AC_CONFIG_FILES(Makefile)
AC_OUTPUT
Makefile.am：</p>
<p>bin_PROGRAMS = hello
hello_SOURCES = hello.c
获取跨工具链环境设置文件：如手册前面所述，安装跨工具链会在安装 SDK 的目录中创建跨工具链环境设置脚本。在您可以使用这些工具来开发您的项目之前，您必须获取此设置脚本。该脚本以字符串“environment-setup”开头，包含机器架构，后跟字符串“poky-linux”。对于此示例，该命令从使用 32 位 Intel x86 架构和 3.4.2 Yocto 项目版本的默认 SDK 安装目录获取脚本：</p>
<p>$ source /opt/poky/3.4.2/environment-setup-i586-poky-linux
创建配置脚本：使用autoreconf命令生成configure脚本。</p>
<p>$ autoreconf
该autoreconf 工具负责运行其他 Autotools，例如aclocal、 autoconf和automake.</p>
<p>笔记</p>
<p>如果您从运行的 中得到错误configure.ac，autoreconf 表明缺少文件，您可以使用“-i”选项，以确保将缺少的辅助文件复制到构建主机。</p>
<p>交叉编译项目：此命令使用交叉编译器编译项目。CONFIGURE_FLAGS 环境变量为 GNU 配置提供了最少的参数：</p>
<p>$ ./configure ${CONFIGURE_FLAGS}
对于基于 Autotools 的项目，您只需将适当的主机选项传递给configure.sh. 您使用的主机选项源自安装交叉工具链的目录中的环境设置脚本的名称。例如，使用 GNU EABI 的基于 ARM 的目标的主机选项是 armv5te-poky-linux-gnueabi. 您会注意到脚本的名称是environment-setup-armv5te-poky-linux-gnueabi. 因此，以下命令可用于更新您的项目并使用适当的跨工具链工具重新构建它：</p>
<p>$ ./configure –host=armv5te-poky-linux-gnueabi –with-libtool-sysroot=sysroot_dir
制作并安装项目：这两个命令生成项目并将其安装到目标目录中：</p>
<p>$ make
$ make install DESTDIR=./tmp
笔记</p>
<p>要了解在运行跨工具链环境设置脚本时建立的环境变量以及 Makefile 如何使用或覆盖它们，请参阅 基于 Makefile 的项目部分。</p>
<p>下一个命令是验证项目安装的简单方法。运行该命令将打印二进制文件可以运行的体系结构。该架构应该与安装的跨工具链支持的架构相同。</p>
<p>$ file ./tmp/usr/local/bin/hello
执行您的项目：要执行该项目，您需要在目标硬件上运行它。如果您的目标硬件恰好是您的构建主机，您可以按如下方式运行该项目：</p>
<p>$ ./tmp/usr/local/bin/hello
正如预期的那样，该项目显示“Hello World！” 信息。</p>
<p>4.2基于 Makefile 的项目
简单的基于 Makefile 的项目使用运行跨工具链环境设置脚本时建立的跨工具链环境变量并与之交互。环境变量受一般make规则的约束。</p>
<p>本节介绍一个简单的 Makefile 开发流程，并提供一个示例，让您了解如何在开发过程中使用跨工具链环境变量和 Makefile 变量。</p>
<p>sdk-makefile-flow.png</p>
<p>本节的重点是解释以下三种有关可变行为的情况：</p>
<p>案例 1 - Makefile 中未设置变量映射到 SDK 设置脚本中设置的等效环境变量：由于未在 中专门设置匹配变量Makefile，因此变量根据环境设置脚本保留其值。</p>
<p>案例 2 - 在从 SDK 设置脚本映射到等效环境变量的 Makefile 中设置了变量：在构建期间专门设置匹配变量会Makefile导致变量的环境设置被覆盖。在这种情况下，将Makefile 使用您在 中设置的变量。</p>
<p>案例 3 - 使用从 SDK 设置脚本映射到等效环境变量Makefile的命令行设置变量：从命令行 执行会导致环境变量被覆盖。在这种情况下，使用命令行内容。</p>
<p>笔记</p>
<p>无论您如何设置变量，如果您将“-e”选项与 一起使用make，SDK 设置脚本中的变量优先：</p>
<p>$ make -e target
本节的其余部分提供了一个简单的 Makefile 示例来演示这些可变行为。</p>
<p>在运行安装脚本之前，不会为 SDK 建立新的 shell 环境变量。例如，以下命令显示编译器变量（即 CC）的空值。</p>
<p>$ echo ${CC}</p>
<p>$
使用当前 3.4.2 Yocto Project 版本为 64 位构建主机和 i586 调整的目标架构运行 SDK 设置脚本，core-image-sato然后回显该变量显示通过脚本建立的值：</p>
<p>$ source /opt/poky/3.4.2/environment-setup-i586-poky-linux
$ echo ${CC}
i586-poky-linux-gcc -m32 -march=i586 –sysroot=/opt/poky/3.4.2/sysroots/i586-poky-linux
为了说明变量的使用，请完成这个简单的“Hello World！” 例子：</p>
<p>创建一个工作目录并填充它：为您的项目创建一个干净的目录，然后将该目录作为您的工作位置。</p>
<p>$ mkdir $HOME/helloworld
$ cd $HOME/helloworld
设置目录后，用流所需的文件填充它。您需要一个main.c从中调用函数的 module.h文件、一个包含标题的文件以及一个module.c定义您的函数的文件。</p>
<p>创建三个文件如下：</p>
<p>main.c：</p>
<p>#include “module.h”
void sample_func();
int main()
{</p>
<blockquote>
<div><p>sample_func();
return 0;</p>
</div></blockquote>
<p>}
module.h：</p>
<p>#include &lt;stdio.h&gt;
void sample_func();
module.c：</p>
<p>#include “module.h”
void sample_func()
{</p>
<blockquote>
<div><p>printf(“Hello World!”);
printf(“n”);</p>
</div></blockquote>
<p>}
获取跨工具链环境设置文件：如手册前面所述，安装跨工具链会在安装 SDK 的目录中创建跨工具链环境设置脚本。在您可以使用这些工具来开发您的项目之前，您必须获取此设置脚本。该脚本以字符串“environment-setup”开头，包含机器架构，后跟字符串“poky-linux”。对于此示例，该命令从使用 32 位 Intel x86 架构和 Honister Yocto 项目版本的默认 SDK 安装目录获取脚本：</p>
<p>$ source /opt/poky/3.4.2/environment-setup-i586-poky-linux
创建 Makefile：对于本例，Makefile 包含两行可用于设置CC变量的行。一行与运行 SDK 环境设置脚本时设置的值相同，另一行将CC设置为“gcc”，即构建主机上的默认 GNU 编译器：</p>
<p># CC=i586-poky-linux-gcc -m32 -march=i586 –sysroot=/opt/poky/2.5/sysroots/i586-poky-linux
# CC=”gcc”
all: main.o module.o</p>
<blockquote>
<div><p>${CC} main.o module.o -o target_bin</p>
</div></blockquote>
<dl class="simple">
<dt>main.o: main.c module.h</dt><dd><p>${CC} -I . -c main.c</p>
</dd>
<dt>module.o: module.c</dt><dd><p>module.h ${CC} -I . -c module.c</p>
</dd>
<dt>clean:</dt><dd><p>rm -rf <a href="#id117"><span class="problematic" id="id118">*</span></a>.o
rm target_bin</p>
</dd>
</dl>
<p>制作项目：使用make命令创建二进制输出文件。由于 Makefile 中已注释掉变量，因此CC使用的值是运行 SDK 环境设置文件时设置的值：</p>
<p>$ make
i586-poky-linux-gcc -m32 -march=i586 –sysroot=/opt/poky/2.5/sysroots/i586-poky-linux -I . -c main.c
i586-poky-linux-gcc -m32 -march=i586 –sysroot=/opt/poky/2.5/sysroots/i586-poky-linux -I . -c module.c
i586-poky-linux-gcc -m32 -march=i586 –sysroot=/opt/poky/2.5/sysroots/i586-poky-linux main.o module.o -o target_bin
从上一条命令的结果可以看出，使用的编译器是通过 setup 脚本中定义的CC 变量建立的编译器。</p>
<p>您可以通过取消注释 Makefile 中的行并再次运行，使用与 Makefile 中设置的相同变量覆盖CC环境变量。make</p>
<p>$ make clean
rm -rf <a href="#id119"><span class="problematic" id="id120">*</span></a>.o
rm target_bin
#
# Edit the Makefile by uncommenting the line that sets CC to “gcc”
#
$ make
gcc -I . -c main.c
gcc -I . -c module.c
gcc main.o module.o -o target_bin
如上例所示，没有使用跨工具链编译器。而是使用默认编译器。</p>
<p>下一个案例展示了如何通过在命令行中提供变量来覆盖变量。进入 Makefile 并重新插入注释字符，以便运行make使用已建立的 SDK 编译器。但是，当您运行时make，请使用命令行参数将CC设置为“gcc”：</p>
<p>$ make clean
rm -rf <a href="#id121"><span class="problematic" id="id122">*</span></a>.o
rm target_bin
#
# Edit the Makefile to comment out the line setting CC to “gcc”
#
$ make
i586-poky-linux-gcc  -m32 -march=i586 –sysroot=/opt/poky/2.5/sysroots/i586-poky-linux -I . -c main.c
i586-poky-linux-gcc  -m32 -march=i586 –sysroot=/opt/poky/2.5/sysroots/i586-poky-linux -I . -c module.c
i586-poky-linux-gcc  -m32 -march=i586 –sysroot=/opt/poky/2.5/sysroots/i586-poky-linux main.o module.o -o target_bin
$ make clean
rm -rf <a href="#id123"><span class="problematic" id="id124">*</span></a>.o
rm target_bin
$ make CC=”gcc”
gcc -I . -c main.c
gcc -I . -c module.c
gcc main.o module.o -o target_bin
在前一种情况下，命令行参数会覆盖 SDK 环境变量。</p>
<p>在最后一种情况下，再次编辑 Makefile 以使用“gcc”编译器，然后在make命令行上使用“-e”选项：</p>
<p>$ make clean
rm -rf <a href="#id125"><span class="problematic" id="id126">*</span></a>.o
rm target_bin
#
# Edit the Makefile to use “gcc”
#
$ make
gcc -I . -c main.c
gcc -I . -c module.c
gcc main.o module.o -o target_bin
$ make clean
rm -rf <a href="#id127"><span class="problematic" id="id128">*</span></a>.o
rm target_bin
$ make -e
i586-poky-linux-gcc  -m32 -march=i586 –sysroot=/opt/poky/2.5/sysroots/i586-poky-linux -I . -c main.c
i586-poky-linux-gcc  -m32 -march=i586 –sysroot=/opt/poky/2.5/sysroots/i586-poky-linux -I . -c module.c
i586-poky-linux-gcc  -m32 -march=i586 –sysroot=/opt/poky/2.5/sysroots/i586-poky-linux main.o module.o -o target_bin
在前一种情况下，“-e”选项强制make使用 SDK 环境变量，而不考虑 Makefile 中的值。</p>
<p>执行您的项目：要执行项目（即target_bin），请使用以下命令：</p>
<p>$ ./target_bin
Hello World!
笔记</p>
<p>如果您使用跨工具链编译器构建 target_bin 并且您的构建主机的架构与目标机器的架构不同，您需要在目标设备上运行您的项目。</p>
<p>正如预期的那样，该项目显示“Hello World！” 信息。</p>
<p>6自定义可扩展 SDK
本附录描述了您可以应用于可扩展 SDK 的自定义。</p>
<p>6.1配置可扩展SDK
可扩展 SDK 主要由生成它的 OpenEmbedded 构建系统的预配置副本组成。因此，SDK 的配置是使用该构建系统和下表中显示的过滤器派生的。当这些过滤器存在时，OpenEmbedded 构建系统将它们应用于local.conf和auto.conf：</p>
<p>值以“/”开头的变量被排除在外，因为假设这些值是可能特定于Build Host的路径。</p>
<p>SDK_LOCAL_CONF_BLACKLIST中列出的变量 被排除在外。这些变量不允许从 OpenEmbedded 构建系统配置进入可扩展 SDK 配置。通常，这些变量特定于运行构建系统的机器，并且作为可扩展 SDK 配置的一部分可能会出现问题。</p>
<p>有关默认排除的变量列表，请参阅 Yocto 项目参考手册词汇表中的 SDK_LOCAL_CONF_BLACKLIST 。</p>
<p>包含在 SDK_LOCAL_CONF_WHITELIST 中列出的变量。在SDK_LOCAL_CONF_WHITELIST的值中包含一个变量 会覆盖前两个过滤器中的任何一个。默认值为空白。</p>
<p>SDK_INHERIT_BLACKLIST中列出的 使用INHERIT全局继承 的类 被禁用。使用SDK_INHERIT_BLACKLIST禁用这些类是禁用 SDK 上下文中有问题或不必要的类的典型方法。默认值禁用 buildhistory 和icecc类。</p>
<p>此外， 的内容（conf/sdk-extra.conf如果存在）会附加到conf/local.conf生成的 SDK 的末尾，而不进行任何过滤。sdk-extra.conf如果您只想为 SDK 而不是用于创建 SDK 的 OpenEmbedded 构建系统设置变量值，该文件特别有用。</p>
<p>6.2调整可扩展 SDK 以适合您的构建主机的设置
在大多数情况下，可扩展 SDK 默认值应该适用于Build Host的设置。但是，在某些情况下，您可能会考虑进行调整：</p>
<p>如果您的 SDK 配置使用 INHERIT变量继承了其他类，并且您不需要或不希望在 SDK 中启用这些类，则可以通过将它们添加到SDK_INHERIT_BLACKLIST 变量来禁用它们，如上一节所述。</p>
<p>笔记</p>
<p>SDK_INHERIT_BLACKLIST 的默认值是使用“?=”运算符设置的。因此，您需要使用“=”运算符定义整个列表，或者需要使用“:append”或“+=”运算符附加一个值。您可以在 BitBake 用户手册的“基本语法”部分了解更多关于这些运算符的信息。</p>
<p>如果您有向标准构建流程添加额外任务的类或配方（即任务在配方构建时执行，而不是被显式调用），那么您需要执行以下操作之一：</p>
<p>在确保任务是共享状态任务（即任务的输出被保存到共享状态缓存并可以从共享状态缓存中恢复）或确保任务能够从共享状态任务的任务中快速生成后，添加任务名称改为 SDK_RECRDEP_TASKS的值。</p>
<p>如果任务由类添加并且您不需要该类在可扩展 SDK 中提供的功能，则禁用这些任务。要禁用任务，请将类添加到SDK_INHERIT_BLACKLIST 变量中，如上一节所述。</p>
<p>通常，您希望设置一个共享状态镜像，以便 SDK 的用户可以在安装后向 SDK 添加其他项目，而无需从源代码构建项目。有关信息，请参阅“提供其他可安装的可扩展 SDK 内容”部分。</p>
<p>如果您希望 SDK 的用户能够轻松更新 SDK，则需要设置 SDK_UPDATE_URL 变量。有关详细信息，请参阅“安装后为可扩展 SDK 提供更新”部分。</p>
<p>如果您调整了出现在 COREBASE中的文件和目录列表（通过 启用的层bblayers.conf除外），那么您必须在 COREBASE_FILES中列出这些文件，以便将文件复制到 SDK 中。</p>
<p>如果您的 OpenEmbedded 构建系统设置使用oe-init-build-env以外的不同环境设置脚本 ，则必须将 OE_INIT_ENV_SCRIPT设置 为指向您使用的环境设置脚本。</p>
<p>笔记</p>
<p>您还必须在用于 COREBASE_FILES变量的值中反映此更改，如前所述。</p>
<p>6.3更改可扩展 SDK 安装程序标题
您可以通过设置SDK_TITLE变量然后重新构建SDK 安装程序来更改 SDK 安装程序的显示标题 。有关如何构建 SDK 安装程序的信息，请参阅“构建 SDK 安装程序”部分。</p>
<p>默认情况下，此标题在设置时派生自 DISTRO_NAME。如果未设置DISTRO_NAME变量，则标题派生自DISTRO变量。</p>
<p>populate_sdk_base 类定义SDK_TITLE变量的 默认值如下：</p>
<p>SDK_TITLE ??= “${&#64;d.getVar(‘DISTRO_NAME’) or d.getVar(‘DISTRO’)} SDK”
虽然有几种方法可以更改此变量，但一种有效的方法是在您的发行版的配置文件中设置该变量。这样做会创建一个适用于您的发行版的 SDK 安装程序标题。例如，假设您有自己的发行版层，名为“meta-mydistro”，并且您使用的文件层次结构类型与默认的“poky”发行版相同。如果是这样，您可以 使用以下形式更新文件中的SDK_TITLE变量 ：~/meta-mydistro/conf/distro/mydistro.conf</p>
<p>SDK_TITLE = “your_title”
6.4安装后提供可扩展 SDK 的更新
当您对配置或元数据进行更改时，如果您希望这些更改反映在已安装的 SDK 中，则需要执行其他步骤。这些步骤使任何使用已安装 SDK 的人都可以使用以下 命令更新已安装的 SDK：devtool sdk-update</p>
<p>创建一个可以通过 HTTP 或 HTTPS 共享的目录。您可以通过在云中设置 Web 服务器（例如Apache HTTP 服务器或 Nginx服务器）来托管目录来实现此目的。此目录必须包含已发布的 SDK。</p>
<p>将 SDK_UPDATE_URL 变量设置为指向相应的 HTTP 或 HTTPS URL。设置此变量会导致构建的任何 SDK 默认使用该 URL，因此，用户不必将 URL 传递给 命令，如“将更新应用到已安装的可扩展 SDK ”部分中所述。devtool sdk-update</p>
<p>正常构建可扩展 SDK（即使用 imagename 命令）。bitbake -c populate_sdk_ext</p>
<p>使用以下命令发布 SDK：</p>
<p>$ oe-publish-sdk some_path/sdk-installer.sh path_to_shared_http_directory
每次使用要通过更新机制提供的更改重新构建 SDK 时，都必须重复此步骤。</p>
<p>完成上述步骤后，现有已安装 SDK 的用户只需运行即可检索和应用最新更新。有关详细信息，请参阅“对已安装的可扩展 SDK 应用更新”部分。devtool sdk-update</p>
<p>6.5更改默认 SDK 安装目录
为可扩展 SDK 构建安装程序时，SDK 的默认安装目录基于 populate_sdk_base类中的DISTRO和 SDKEXTPATH变量， 如下所示：</p>
<p>SDKEXTPATH ??= “~/${&#64;d.getVar(‘DISTRO’)}_sdk”
您可以通过专门设置SDKEXTPATH变量来更改此默认安装目录 。</p>
<p>虽然有多种设置此变量的方法，但最有意义的方法是在您的发行版的配置文件中设置该变量。这样做会创建一个适用于您的发行版的 SDK 安装程序默认目录。例如，假设您有自己的发行版层，名为“meta-mydistro”，并且您使用的文件层次结构类型与默认的“poky”发行版相同。如果是这样，您可以 使用以下形式更新文件中的SDKEXTPATH变量 ：~/meta-mydistro/conf/distro/mydistro.conf</p>
<p>SDKEXTPATH = “some_path_for_your_installed_sdk”
构建安装程序后，运行它会提示用户接受 some_path_for_your_installed_sdk 目录作为安装可扩展 SDK 的默认位置。</p>
<p>6.6提供额外的可安装可扩展 SDK 内容
如果您希望您构建的可扩展 SDK 的用户能够将项目添加到 SDK，而无需用户从源代码构建项目，您需要做一些事情：</p>
<p>确保您希望用户能够安装的其他项目已经构建：</p>
<p>明确地构建项目。您可以使用一个或多个依赖于其他配方列表的“元”配方。</p>
<p>构建“世界”目标并 EXCLUDE_FROM_WORLD:pn-为您不想构建的配方设置配方名称。有关其他信息，请参阅 EXCLUDE_FROM_WORLD 变量。</p>
<p>公开sstate-cache构建生成的目录。通常，您可以通过Apache HTTP 服务器或 Nginx服务器公开此目录。</p>
<p>设置适当的配置，以便生成的 SDK 知道如何找到配置。您需要设置的变量是 SSTATE_MIRRORS：</p>
<p>SSTATE_MIRRORS = “<a class="reference external" href="file://.*">file://.*</a> <a class="reference external" href="https://example.com/some_path/sstate-cache/PATH">https://example.com/some_path/sstate-cache/PATH</a>”
您可以在两个不同的位置设置SSTATE_MIRRORS变量：</p>
<p>如果您设置的镜像值适用于实际构建 SDK 的 OpenEmbedded 构建系统和 SDK 本身（即镜像可在两个地方访问，否则它将在 OpenEmbedded 构建系统端快速失败，并且它的内容不会干扰构建），然后您可以在您的local.conf或自定义发行版配置文件中设置变量。然后，您可以通过添加以下内容将变量传递给 SDK：</p>
<p>SDK_LOCAL_CONF_WHITELIST = “SSTATE_MIRRORS”
或者，如果您只想为 SDK 单独设置SSTATE_MIRRORS 变量的值， 请在您的构建目录conf/sdk-extra.conf或任何层中创建一个文件 ，并将您的SSTATE_MIRRORS设置放在该文件中。</p>
<p>笔记</p>
<p>如果您对设置SSTATE_MIRRORS时使用哪种方法有任何疑问，第二个选项是最安全的选项</p>
<p>6.7最小化可扩展 SDK 安装程序下载的大小
默认情况下，可扩展 SDK 为重建构建 SDK 的图像所需的一切捆绑共享状态工件。此捆绑可能会生成一个千兆字节或更大大小的 SDK 安装程序文件。如果此文件的大小导致问题，您可以通过在配置中设置以下内容来构建一个足够安装并提供访问权限的 SDK ：devtool command</p>
<p>SDK_EXT_TYPE = “minimal”
将 SDK_EXT_TYPE设置为“minimal”会生成一个大小约为 35 MB 的 SDK 安装程序，可以快速下载和安装。但是，您需要意识到，最小安装程序不会安装任何开箱即用的库或工具。这些库和工具必须“即时”安装，或者通过您使用devtool或显式使用 命令执行的操作来安装。devtool sdk-install</p>
<p>在大多数情况下，在构建最小 SDK 时，您还需要启用有关系统生成的更广泛的包的信息。需要这种更广泛的信息尤其正确，以便能够有效地将它在源树中发现的依赖关系映射到适当的配方。此外，该信息使命令能够返回有用的结果。devtool adddevtool search</p>
<p>为了促进更广泛的信息，您需要设置以下内容：</p>
<p>SDK_INCLUDE_PKGDATA = “1”
有关其他信息，请参阅SDK_INCLUDE_PKGDATA变量。</p>
<p>如图所示设置SDK_INCLUDE_PKGDATA变量会导致构建“世界”目标，以便其中包含的所有配方的信息都可用。提供这些配方会显着增加构建时间，并将 SDK 安装程序的大小增加 30-80 MB，具体取决于您的配置中包含多少配方。</p>
<p>您可以将EXCLUDE_FROM_WORLD:pn-recipename 用于要排除的食谱。但是，如果您想向 SDK 提供其他项目，则假定您需要构建“世界”目标。因此，在大多数情况下，为“世界”构建不应代表过多的开销。</p>
<p>笔记</p>
<p>如果将 SDK_EXT_TYPE 设置为“minimal”，则必须提供共享状态镜像，以便可以根据需要安装项目。有关详细信息，请参阅 提供其他可安装的可扩展 SDK 内容 部分。</p>
<p>您可以通过将SDK_INCLUDE_TOOLCHAIN 变量设置为“1”来明确控制在构建 SDK 时是否包含工具链 。特别是，当您将SDK_EXT_TYPE设置为“minimal”（默认情况下不包括工具链）时，包含工具链很有用。此外，如果您正在构建一个小型 SDK 以与 IDE 或其他一些您不想采取额外步骤来安装工具链的工具一起使用，这也很有帮助。</p>
<p>7自定义标准 SDK
本附录介绍了可应用于标准 SDK 的自定义。</p>
<p>7.1向标准 SDK 添加单个包
当您使用 构建标准 SDK时，生成的 SDK 中包含一组默认包。TOOLCHAIN_HOST_TASK 和 TOOLCHAIN_TARGET_TASK 变量控制添加到 SDK 的包集。bitbake -c populate_sdk</p>
<p>如果要将单个包添加到在主机上运行的工具链中，只需将这些包添加到TOOLCHAIN_HOST_TASK变量即可。同样，如果要将包添加到作为在目标上运行的工具链的一部分的默认集，请将包添加到 TOOLCHAIN_TARGET_TASK变量。</p>
<p>7.2将 API 文档添加到标准 SDK
您可以通过将“api-documentation”添加到DISTRO_FEATURES 变量中来包含 API 文档以及标准 SDK 提供的任何其他文档 ：构建文档，然后将其包含在标准 SDK 中。</p>
<hr class="docutils" />
<p>测试环境：<a class="reference external" href="https://docs.yoctoproject.org/test-manual/index.html">https://docs.yoctoproject.org/test-manual/index.html</a></p>
<p>BitBake 最初是 OpenEmbedded 项目的一部分。它的灵感来自于 Gentoo Linux 发行版使用的 Portage 包管理系统。2004 年，OpenEmbedded 项目被拆分为两个不同的部分：</p>
<p>BitBake，一个通用的任务执行器</p>
<p>OpenEmbedded，BitBake 使用的元数据集</p>
<p>今天，BitBake 是基于 OpenEmbedded 的项目的主要构建工具，例如 Yocto 项目。</p>
<p>BitBake 文档可以在这里找到。：<a class="reference external" href="https://docs.yoctoproject.org/bitbake/index.html">https://docs.yoctoproject.org/bitbake/index.html</a></p>
<hr class="docutils" />
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Rachel.Sun.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>