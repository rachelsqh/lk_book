<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>linux 内核通知/通信机制 &mdash; Rachel&#39;s E-book 1.0 documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="linux 内核竞争处理" href="lock.html" />
    <link rel="prev" title="linux 内核模块原理分析" href="module.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Rachel's E-book
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../os_base/index.html">linux 操作系统概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lk_devel/index.html">linux 内核开发基础</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">linux 内核基础代码分析</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="base_arch.html">linux 内核代码目录结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="module.html">linux 内核模块原理分析</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">linux 内核通知/通信机制</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ipi">核间通信:IPI</a></li>
<li class="toctree-l3"><a class="reference internal" href="#irq-work">irq work</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">等待队列（进程/线程)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">工作队列</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id5">基础</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">总结(个人理解）</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#linux-softirq">linux 软中断：softirq</a></li>
<li class="toctree-l3"><a class="reference internal" href="#notifier">notifier通知链</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lock.html">linux 内核竞争处理</a></li>
<li class="toctree-l2"><a class="reference internal" href="hook.html">linux 内核hook</a></li>
<li class="toctree-l2"><a class="reference internal" href="kexec.html">linux 加载ELF 内核文件：kexec</a></li>
<li class="toctree-l2"><a class="reference internal" href="struct.html">linux 内核基础算法</a></li>
<li class="toctree-l2"><a class="reference internal" href="umh.html">第一个应用进程及umh</a></li>
<li class="toctree-l2"><a class="reference internal" href="extable.html">异常表:extable</a></li>
<li class="toctree-l2"><a class="reference internal" href="jump_label.html">jump_label</a></li>
<li class="toctree-l2"><a class="reference internal" href="x86.html">x86架构部分</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../yocto_kernel.html">yocto uboot与内核模块、内核开发总结</a></li>
<li class="toctree-l1"><a class="reference internal" href="../uboot.html">uboot理解</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver.html">设备驱动(待修正）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gitlab.html">基于gitlab的项目管理(待修正)</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Rachel's E-book</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">linux 内核基础代码分析</a> &raquo;</li>
      <li>linux 内核通知/通信机制</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/lk_code/notifier.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="linux">
<h1>linux 内核通知/通信机制<a class="headerlink" href="#linux" title="Permalink to this headline">¶</a></h1>
<div class="section" id="ipi">
<h2>核间通信:IPI<a class="headerlink" href="#ipi" title="Permalink to this headline">¶</a></h2>
<p>触发本CPU或单个或几个或全部CPU的某个中断向量。
x86-64中断向量总结为：</p>
<iframe src="./x86-64_vec.html" height="345px" width="100%"></iframe><div class="literal-block-wrapper docutils container" id="id9">
<div class="code-block-caption"><span class="caption-text">ipi通信实现代码</span><a class="headerlink" href="#id9" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173</pre></div></td><td class="code"><div class="highlight"><pre><span></span>arch/x86/kernel/apic/ipi.c
*
 * Send a &#39;reschedule&#39; IPI to another CPU. It goes straight through and
 * wastes no time serializing anything. Worst case is that we lose a
 * reschedule ...
 */
void native_smp_send_reschedule(int cpu)
{
        if (unlikely(cpu_is_offline(cpu))) {
                WARN(1, &quot;sched: Unexpected reschedule of offline CPU#%d!\n&quot;, cpu);
                return;
        }
        apic-&gt;send_IPI(cpu, RESCHEDULE_VECTOR);
}

void native_send_call_func_single_ipi(int cpu)
{
        apic-&gt;send_IPI(cpu, CALL_FUNCTION_SINGLE_VECTOR);
}

void native_send_call_func_ipi(const struct cpumask *mask)
{
        if (static_branch_likely(&amp;apic_use_ipi_shorthand)) {
                unsigned int cpu = smp_processor_id();

                if (!cpumask_or_equal(mask, cpumask_of(cpu), cpu_online_mask))
                        goto sendmask;

                if (cpumask_test_cpu(cpu, mask))
                        apic-&gt;send_IPI_all(CALL_FUNCTION_VECTOR);
                else if (num_online_cpus() &gt; 1)
                        apic-&gt;send_IPI_allbutself(CALL_FUNCTION_VECTOR);
                return;
        }

sendmask:
        apic-&gt;send_IPI_mask(mask, CALL_FUNCTION_VECTOR);
}


void __default_send_IPI_shortcut(unsigned int shortcut, int vector)
{
        /*
         * Subtle. In the case of the &#39;never do double writes&#39; workaround
         * we have to lock out interrupts to be safe.  As we don&#39;t care
         * of the value read we use an atomic rmw access to avoid costly
         * cli/sti.  Otherwise we use an even cheaper single atomic write
         * to the APIC.
         */
        unsigned int cfg;

        /*
         * Wait for idle.
         */
        if (unlikely(vector == NMI_VECTOR))
                safe_apic_wait_icr_idle();
        else
                __xapic_wait_icr_idle();

        /*
         * No need to touch the target chip field. Also the destination
         * mode is ignored when a shorthand is used.
         */
        cfg = __prepare_ICR(shortcut, vector, 0);

        /*
         * Send the IPI. The write to APIC_ICR fires this off.
         */
        native_apic_mem_write(APIC_ICR, cfg);
}

/*
 * This is used to send an IPI with no shorthand notation (the destination is
 * specified in bits 56 to 63 of the ICR).
 */
void __default_send_IPI_dest_field(unsigned int mask, int vector, unsigned int dest)
{
        unsigned long cfg;

        /*
         * Wait for idle.
         */
        if (unlikely(vector == NMI_VECTOR))
                safe_apic_wait_icr_idle();
        else
                __xapic_wait_icr_idle();

        /*
         * prepare target chip field
         */
        cfg = __prepare_ICR2(mask);
        native_apic_mem_write(APIC_ICR2, cfg);

        /*
         * program the ICR
         */
        cfg = __prepare_ICR(0, vector, dest);

        /*
         * Send the IPI. The write to APIC_ICR fires this off.
         */
        native_apic_mem_write(APIC_ICR, cfg);
}

void default_send_IPI_single_phys(int cpu, int vector)
{
        unsigned long flags;

        local_irq_save(flags);
        __default_send_IPI_dest_field(per_cpu(x86_cpu_to_apicid, cpu),
                                      vector, APIC_DEST_PHYSICAL);
        local_irq_restore(flags);
}

void default_send_IPI_mask_sequence_phys(const struct cpumask *mask, int vector)
{
        unsigned long query_cpu;
        unsigned long flags;

        /*
         * Hack. The clustered APIC addressing mode doesn&#39;t allow us to send
         * to an arbitrary mask, so I do a unicast to each CPU instead.
         * - mbligh
         */
        local_irq_save(flags);
        for_each_cpu(query_cpu, mask) {
                __default_send_IPI_dest_field(per_cpu(x86_cpu_to_apicid,
                                query_cpu), vector, APIC_DEST_PHYSICAL);
        }
        local_irq_restore(flags);
}

void default_send_IPI_mask_allbutself_phys(const struct cpumask *mask,
                                                 int vector)
{
        unsigned int this_cpu = smp_processor_id();
        unsigned int query_cpu;
        unsigned long flags;

        /* See Hack comment above */

        local_irq_save(flags);
        for_each_cpu(query_cpu, mask) {
                if (query_cpu == this_cpu)
                        continue;
                __default_send_IPI_dest_field(per_cpu(x86_cpu_to_apicid,
                                 query_cpu), vector, APIC_DEST_PHYSICAL);
        }
        local_irq_restore(flags);
}

/*
 * Helper function for APICs which insist on cpumasks
 */
void default_send_IPI_single(int cpu, int vector)
{
        apic-&gt;send_IPI_mask(cpumask_of(cpu), vector);
}

void default_send_IPI_allbutself(int vector)
{
        __default_send_IPI_shortcut(APIC_DEST_ALLBUT, vector);
}

void default_send_IPI_all(int vector)
{
        __default_send_IPI_shortcut(APIC_DEST_ALLINC, vector);
}

void default_send_IPI_self(int vector)
{
        __default_send_IPI_shortcut(APIC_DEST_SELF, vector);
}
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="irq-work">
<h2>irq work<a class="headerlink" href="#irq-work" title="Permalink to this headline">¶</a></h2>
<p>提供一个框架，用于从 hardirq 上下文中排队和运行回调.就是一种在硬件中断上下文中运行任务的途径。</p>
<div class="literal-block-wrapper docutils container" id="id10">
<div class="code-block-caption"><span class="caption-text">irq work实现</span><a class="headerlink" href="#id10" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="nf">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="nc">llist_head</span><span class="p">,</span> <span class="n">raised_list</span><span class="p">);</span>
<span class="k">static</span> <span class="nf">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="nc">llist_head</span><span class="p">,</span> <span class="n">lazy_list</span><span class="p">);</span>

<span class="cm">/* Enqueue on current CPU, work must already be claimed and preempt disabled */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__irq_work_queue_local</span><span class="p">(</span><span class="k">struct</span> <span class="nc">irq_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
        <span class="cm">/* If the work is &quot;lazy&quot;, handle it from next tick if any */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">a_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IRQ_WORK_LAZY</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">llist_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">llist</span><span class="p">,</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lazy_list</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
                    <span class="n">tick_nohz_tick_stopped</span><span class="p">())</span>
                        <span class="n">arch_irq_work_raise</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">llist_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">llist</span><span class="p">,</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">raised_list</span><span class="p">)))</span>
                        <span class="n">arch_irq_work_raise</span><span class="p">();</span><span class="cm">/* apic-&gt;send_IPI_self(IRQ_WORK_VECTOR):触发：irq_work中断向量：0xf6  */</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Enqueue the irq work @work on the current CPU */</span>
<span class="kt">bool</span> <span class="n">irq_work_queue</span><span class="p">(</span><span class="k">struct</span> <span class="nc">irq_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
        <span class="cm">/* Only queue if not already pending */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irq_work_claim</span><span class="p">(</span><span class="n">work</span><span class="p">))</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="cm">/* Queue the entry and raise the IPI if needed. */</span>
        <span class="n">preempt_disable</span><span class="p">();</span>
        <span class="n">__irq_work_queue_local</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
        <span class="n">preempt_enable</span><span class="p">();</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">irq_work_queue</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">irq_work_single</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="nc">irq_work</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

        <span class="cm">/*</span>
<span class="cm">         * Clear the PENDING bit, after this point the @work can be re-used.</span>
<span class="cm">         * The PENDING bit acts as a lock, and we own it, so we can clear it</span>
<span class="cm">         * without atomic ops.</span>
<span class="cm">         */</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">a_flags</span><span class="p">);</span>
        <span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IRQ_WORK_PENDING</span><span class="p">;</span>
        <span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">a_flags</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

        <span class="cm">/*</span>
<span class="cm">         * See irq_work_claim().</span>
<span class="cm">         */</span>
        <span class="n">smp_mb</span><span class="p">();</span>

        <span class="n">lockdep_irq_work_enter</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
        <span class="n">work</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">work</span><span class="p">);</span><span class="cm">/* 运行中断函数 */</span>
        <span class="n">lockdep_irq_work_exit</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

        <span class="cm">/*</span>
<span class="cm">         * Clear the BUSY bit, if set, and return to the free state if no-one</span>
<span class="cm">         * else claimed it meanwhile.</span>
<span class="cm">         */</span>
        <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">atomic_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">a_flags</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IRQ_WORK_BUSY</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">irq_work_run_list</span><span class="p">(</span><span class="k">struct</span> <span class="nc">llist_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="nc">irq_work</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">llist_node</span> <span class="o">*</span><span class="n">llnode</span><span class="p">;</span>

        <span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">llist_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span>
                <span class="k">return</span><span class="p">;</span>

        <span class="n">llnode</span> <span class="o">=</span> <span class="n">llist_del_all</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
        <span class="n">llist_for_each_entry_safe</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">llnode</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">llist</span><span class="p">)</span>
                <span class="n">irq_work_single</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * hotplug calls this through:</span>
<span class="cm"> *  hotplug_cfd() -&gt; flush_smp_call_function_queue()</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">irq_work_run</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">irq_work_run_list</span><span class="p">(</span><span class="n">this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">raised_list</span><span class="p">));</span>
        <span class="n">irq_work_run_list</span><span class="p">(</span><span class="n">this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lazy_list</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">irq_work_run</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</div>
<ul class="simple">
<li><p>重要结构：</p></li>
</ul>
<div class="literal-block-wrapper docutils container" id="id11">
<div class="code-block-caption"><span class="caption-text">irq work实现</span><a class="headerlink" href="#id11" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="p">{</span>
        <span class="n">CSD_FLAG_LOCK</span>           <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>

        <span class="n">IRQ_WORK_PENDING</span>        <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
        <span class="n">IRQ_WORK_BUSY</span>           <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
        <span class="n">IRQ_WORK_LAZY</span>           <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span> <span class="cm">/* No IPI, wait for tick */</span>
        <span class="n">IRQ_WORK_HARD_IRQ</span>       <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span> <span class="cm">/* IRQ context on PREEMPT_RT */</span>

        <span class="n">IRQ_WORK_CLAIMED</span>        <span class="o">=</span> <span class="p">(</span><span class="n">IRQ_WORK_PENDING</span> <span class="o">|</span> <span class="n">IRQ_WORK_BUSY</span><span class="p">),</span>

        <span class="n">CSD_TYPE_ASYNC</span>          <span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
        <span class="n">CSD_TYPE_SYNC</span>           <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
        <span class="n">CSD_TYPE_IRQ_WORK</span>       <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
        <span class="n">CSD_TYPE_TTWU</span>           <span class="o">=</span> <span class="mh">0x30</span><span class="p">,</span>

        <span class="n">CSD_FLAG_TYPE_MASK</span>      <span class="o">=</span> <span class="mh">0xF0</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * struct __call_single_node is the primary type on</span>
<span class="cm"> * smp.c:call_single_queue.</span>
<span class="cm"> *</span>
<span class="cm"> * flush_smp_call_function_queue() only reads the type from</span>
<span class="cm"> * __call_single_node::u_flags as a regular load, the above</span>
<span class="cm"> * (anonymous) enum defines all the bits of this word.</span>
<span class="cm"> *</span>
<span class="cm"> * Other bits are not modified until the type is known.</span>
<span class="cm"> *</span>
<span class="cm"> * CSD_TYPE_SYNC/ASYNC:</span>
<span class="cm"> *      struct {</span>
<span class="cm"> *              struct llist_node node;</span>
<span class="cm"> *              unsigned int flags;</span>
<span class="cm"> *              smp_call_func_t func;</span>
<span class="cm"> *              void *info;</span>
<span class="cm"> *      };</span>
<span class="cm"> *</span>
<span class="cm"> * CSD_TYPE_IRQ_WORK:</span>
<span class="cm"> *      struct {</span>
<span class="cm"> *              struct llist_node node;</span>
<span class="cm"> *              atomic_t flags;</span>
<span class="cm"> *              void (*func)(struct irq_work *);</span>
<span class="cm"> *      };</span>
<span class="cm"> *</span>
<span class="cm"> * CSD_TYPE_TTWU:</span>
<span class="cm"> *      struct {</span>
<span class="cm"> *              struct llist_node node;</span>
<span class="cm"> *              unsigned int flags;</span>
<span class="cm"> *      };</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="nc">__call_single_node</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="nc">llist_node</span>       <span class="n">llist</span><span class="p">;</span>
        <span class="k">union</span> <span class="p">{</span>
                <span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">u_flags</span><span class="p">;</span>
                <span class="n">atomic_t</span>        <span class="n">a_flags</span><span class="p">;</span>
        <span class="p">};</span>
<span class="cp">#ifdef CONFIG_64BIT</span>
        <span class="n">u16</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>



<span class="cm">/*</span>
<span class="cm"> * An entry can be in one of four states:</span>
<span class="cm"> *</span>
<span class="cm"> * free      NULL, 0 -&gt; {claimed}       : free to be used</span>
<span class="cm"> * claimed   NULL, 3 -&gt; {pending}       : claimed to be enqueued</span>
<span class="cm"> * pending   next, 3 -&gt; {busy}          : queued, pending callback</span>
<span class="cm"> * busy      NULL, 2 -&gt; {free, claimed} : callback in progress, can be claimed</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="nc">irq_work</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="nc">__call_single_node</span> <span class="n">node</span><span class="p">;</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">irq_work</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
</div>
<ul class="simple">
<li><p>通常流程：</p></li>
</ul>
<dl class="simple">
<dt>sysvec_irq_work ==&gt; irq_work_run;//irq_work_vetor: 0xf6:</dt><dd><p>arch_irq_work_raise(void): apic-&gt;send_IPI_self(IRQ_WORK_VECTOR);</p>
</dd>
<dt>bool irq_work_queue(struct irq_work <a href="#id1"><span class="problematic" id="id2">*</span></a>work) -&gt;__irq_work_queue_local(work); -&gt; arch_irq_work_raise(void)-&gt; apic-&gt;send_IPI_self(IRQ_WORK_VECTOR):</dt><dd><dl class="simple">
<dt>-&gt; sysvec_irq_work -&gt; irq_work_run:</dt><dd><ol class="arabic simple">
<li><p>irq_work_run_list(this_cpu_ptr(&amp;raised_list));</p></li>
<li><p>irq_work_run_list(this_cpu_ptr(&amp;lazy_list));</p></li>
</ol>
</dd>
</dl>
</dd>
</dl>
<ul class="simple">
<li><p>irq work 处理：向量IRQ_WORK_VECTOR处理函数</p></li>
</ul>
<div class="literal-block-wrapper docutils container" id="id12">
<div class="code-block-caption"><span class="caption-text">irq work异常处理</span><a class="headerlink" href="#id12" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#ifdef CONFIG_X86_LOCAL_APIC</span>
<span class="n">DEFINE_IDTENTRY_SYSVEC</span><span class="p">(</span><span class="n">sysvec_irq_work</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">ack_APIC_irq</span><span class="p">();</span>
        <span class="n">trace_irq_work_entry</span><span class="p">(</span><span class="n">IRQ_WORK_VECTOR</span><span class="p">);</span>
        <span class="n">inc_irq_stat</span><span class="p">(</span><span class="n">apic_irq_work_irqs</span><span class="p">);</span>
        <span class="n">irq_work_run</span><span class="p">();</span><span class="cm">/* 运行列表 */</span>
        <span class="n">trace_irq_work_exit</span><span class="p">(</span><span class="n">IRQ_WORK_VECTOR</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">arch_irq_work_raise</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="cm">/* 触发irq work */</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arch_irq_work_has_interrupt</span><span class="p">())</span>
                <span class="k">return</span><span class="p">;</span>

        <span class="n">apic</span><span class="o">-&gt;</span><span class="n">send_IPI_self</span><span class="p">(</span><span class="n">IRQ_WORK_VECTOR</span><span class="p">);</span>
        <span class="n">apic_wait_icr_idle</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
</div>
<ul class="simple">
<li><p>特例：mpcfd_dying_cpu –&gt; irq_work_run;</p></li>
<li><p>编程：</p></li>
</ul>
<div class="literal-block-wrapper docutils container" id="id13">
<div class="code-block-caption"><span class="caption-text">irq work实现</span><a class="headerlink" href="#id13" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="n">late_wakeup_func</span><span class="p">(</span><span class="k">struct</span> <span class="nc">irq_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="nc">irq_work</span><span class="p">,</span> <span class="n">late_wakeup_work</span><span class="p">)</span> <span class="o">=</span>
        <span class="n">IRQ_WORK_INIT</span><span class="p">(</span><span class="n">late_wakeup_func</span><span class="p">);</span>


<span class="n">irq_work_queue</span><span class="p">(</span><span class="n">this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">late_wakeup_work</span><span class="p">));</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="id3">
<h2>等待队列（进程/线程)<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>include/linux/wait.h
kernel/sched/wait.c
进程等待队列:用于同步</p>
<p>进程A调用wait_event(wq, condition)就是向等待队列头中添加等待队列项wait_queue_t，该该等待队列项中的成员变量private记录当前进程，其成员变量func记录唤醒回调函数，然后调用schedule()使当前进程进入休眠状态。
进程B调用wake_up(wq)会遍历整个等待列表wq中的每一项wait_queue_t，依次调用每一项的唤醒函数try_to_wake_up()。这个过程会将private记录的进程加入rq运行队列，并设置进程状态为TASK_RUNNING。
进程A被唤醒后只执行如下检测：
检查condition是否为true，满足条件则跳出循环，再把wait_queue_t从wq队列中移除；
检测该进程task的成员thread_info-&gt;flags是否被设置TIF_SIGPENDING，被设置则说明有待处理的信号，则跳出循环，再把wait_queue_t从wq队列中移除；
否则，继续调用schedule()再次进入休眠等待状态，如果wait_queue_t不在wq队列，则再次加入wq队列。</p>
<p>等待队列原理上一个进程运行到某个点，发现调价不满足，然后就将自己挂到一个等待队列结构的链表上，根据结构是不可中断或可中断唤醒两种模式进程将当前进程的状态设置为可中断睡眠或不可中断睡眠，然后调用调度函数将自己换出：唤醒时，唤醒主题针对等得队列结构上的进程列表中的进程进行操作，在操作函数中设置相应进程状态。</p>
<p>TASK_INTERRUPTIBLE是针对某个特定事件和特定资源，设置进程睡眠。当内核发送信号给该进程，告知特定事件发生，该进程会被置为TASK_RUNNING，之后调度器会在合适的时间运行它。
TASK_UNINTERRUPTIBLE是进程主动睡眠，它们不会被外部信号唤醒，只能有内核亲自唤醒该进程。
这两个参数的应用场景也有差异，在一些应用中，如与用户有交互的进程，那么它就应该要接收一些特定信号，如ctl+C，举个例子，sysfs中，如果要去获得某个锁，那么就建议使用interrupt版的锁，记得判定返回值。
而在另一些场景中，如读写硬件寄存器时，就需要uninterrupt类型的信号，因为它只期望两种结果，一个是硬件及时返回后，将其唤醒，另一个就是超时后，进程需要自己唤醒自己。</p>
<p>进程为了等待某个事件/条件满足将自己加入某个等待队列，进程将自身设置为某个睡眠状态，条件满足时对因为本条件而进入睡眠状态的进程进行唤醒。</p>
<p>人与进程就这么相似，可以认为世界只有自己，可高度稍微一上升，进程也只是一蝼蚁。</p>
<ul>
<li><p>结构：</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id14">
<div class="code-block-caption"><span class="caption-text">等待队列结构</span><a class="headerlink" href="#id14" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="k">typedef</span> <span class="k">struct</span> <span class="nc">wait_queue_entry</span> <span class="n">wait_queue_entry_t</span><span class="p">;</span>

     <span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">wait_queue_func_t</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
     <span class="kt">int</span> <span class="nf">default_wake_function</span><span class="p">(</span><span class="k">struct</span> <span class="nc">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>

     <span class="cm">/* wait_queue_entry::flags */</span>
     <span class="cp">#define WQ_FLAG_EXCLUSIVE       0x01</span>
     <span class="cp">#define WQ_FLAG_WOKEN           0x02</span>
     <span class="cp">#define WQ_FLAG_BOOKMARK        0x04</span>
     <span class="cp">#define WQ_FLAG_CUSTOM          0x08</span>
     <span class="cp">#define WQ_FLAG_DONE            0x10</span>
     <span class="cp">#define WQ_FLAG_PRIORITY        0x20</span>

     <span class="cm">/*</span>
<span class="cm">      * A single wait-queue entry structure:</span>
<span class="cm">      */</span>
     <span class="k">struct</span> <span class="nc">wait_queue_entry</span> <span class="p">{</span>
             <span class="kt">unsigned</span> <span class="kt">int</span>            <span class="n">flags</span><span class="p">;</span>
             <span class="kt">void</span>                    <span class="o">*</span><span class="n">private</span><span class="p">;</span>
             <span class="n">wait_queue_func_t</span>       <span class="n">func</span><span class="p">;</span>
             <span class="k">struct</span> <span class="nc">list_head</span>        <span class="n">entry</span><span class="p">;</span>
     <span class="p">};</span>

     <span class="k">struct</span> <span class="nc">wait_queue_head</span> <span class="p">{</span>
             <span class="n">spinlock_t</span>              <span class="n">lock</span><span class="p">;</span>
             <span class="k">struct</span> <span class="nc">list_head</span>        <span class="n">head</span><span class="p">;</span>
     <span class="p">};</span>
     <span class="k">typedef</span> <span class="k">struct</span> <span class="nc">wait_queue_head</span> <span class="n">wait_queue_head_t</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</li>
<li><p>简单睡眠等待：</p>
<blockquote>
<div><p>#define wait_event(wq_head, condition)                                          do {                                                                            </p>
<blockquote>
<div><p>might_sleep();                                                          if (condition)                                                          </p>
<blockquote>
<div><p>break;                                                          </p>
</div></blockquote>
<p>__wait_event(wq_head, condition);                                       </p>
</div></blockquote>
<p>} while (0)</p>
<p>static wait_queue_head_t shutdown_wq;</p>
<p>init_waitqueue_head(&amp;shutdown_wq);</p>
<dl class="simple">
<dt>wait_event(shutdown_wq,</dt><dd><p>atomic_read(&amp;n_rcu_scale_writer_finished) &gt;= nrealwriters);</p>
</dd>
</dl>
<p>wake_up(&amp;shutdown_wq); –&gt; __wake_up() –&gt;__wake_up_common_lock();–&gt; __wake_up_common();</p>
</div></blockquote>
</li>
<li><p>等待队列分类总结</p></li>
</ul>
</div>
<div class="section" id="id4">
<h2>工作队列<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>kernel/workqueue.c - 使用共享工作池的通用异步执行</p>
<p>这部分很有难度，自己的理解也很有限：</p>
<p>有很多情况需要异步流程执行上下文，而工作队列 (wq) API 是此类情况最常用的机制。当需要这样的异步执行上下文时，将描述要执行哪个函数的工作项放在队列中。一个独立的线程充当异步执行上下文。队列称为workqueue，线程称为worker。当工作队列上有工作项时，工作人员一个接一个地执行与工作项相关的功能。当工作队列上没有工作项时，工作人员将变得空闲。当一个新的工作项进入队列时，worker 再次开始执行。</p>
<div class="section" id="id5">
<h3>基础<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>并发管理工作队列 (cmwq) 是 wq 的重新实现，重点关注以下目标。</p>
<p>保持与原始工作队列 API 的兼容性。</p>
<p>使用所有 wq 共享的 per-CPU 统一工作池来按需提供灵活的并发级别，而不会浪费大量资源。</p>
<p>自动调节工作池和并发级别，使 API 用户无需担心这些细节。</p>
<ul class="simple">
<li><p>原理</p></li>
</ul>
<p>为了简化函数的异步执行，引入了一个新的抽象，工作项。</p>
<p>工作项是一个简单的结构，它包含一个指向要异步执行的函数的指针。每当驱动程序或子系统想要异步执行一个函数时，它必须设置一个指向该函数的工作项并将该工作项排队到工作队列中。</p>
<p>特殊用途的线程，称为工作线程，一个接一个地执行队列外的功能。如果没有工作排队，工作线程将变为空闲状态。这些工作线程在所谓的工作池中进行管理。</p>
<p>cmwq 设计区分了子系统和驱动程序在其上排队工作项的面向用户的工作队列和管理工作池和处理排队工作项的后端机制。</p>
<p>有两个工作池，一个用于正常工作项目，另一个用于高优先级工作项目，用于每个可能的 CPU 和一些额外的工作池来服务在未绑定工作队列上排队的工作项目 - 这些后备池的数量是动态的。</p>
<p>子系统和驱动程序可以通过他们认为合适的特殊工作队列 API 函数来创建和排队工作项。他们可以通过在他们放置工作项的工作队列上设置标志来影响工作项执行方式的某些方面。这些标志包括 CPU 位置、并发限制、优先级等。要获得详细的概述，请参阅下面的 API 描述 alloc_workqueue()。</p>
<p>当工作项入队到工作队列时，根据队列参数和工作队列属性确定目标工作池，并附加到工作池的共享工作列表中。例如，除非特别重写，否则绑定工作队列的工作项将在与运行发行者的 CPU 相关联的正常或高优先级工作池的工作列表中排队。</p>
<p>对于任何工作池实现，管理并发级别（有多少执行上下文处于活动状态）都是一个重要问题。cmwq 尝试将并发性保持在最低但足够的水平。最大限度地节省资源并且足够，因为系统被充分利用。</p>
<p>每个绑定到实际 CPU 的工作池通过挂钩到调度程序来实现并发管理。每当活跃的工作人员醒来或睡觉时，工作人员池都会收到通知，并跟踪当前可运行的工作人员的数量。通常，工作项不会占用 CPU 并消耗很多周期。这意味着保持足够的并发性以防止工作处理停止应该是最佳的。只要 CPU 上有一个或多个可运行的 worker，worker-pool 就不会开始执行新的工作，但是，当最后一个运行的 worker 进入睡眠状态时，它会立即调度一个新的 worker，以便 CPU 不会当有待处理的工作项时，不要闲着。这允许在不损失执行带宽的情况下使用最少数量的工作人员。</p>
<p>除了 kthreads 的内存空间之外，保持空闲工作人员不会花费其他成本，因此 cmwq 在杀死空闲工作人员之前会保留一段时间。</p>
<p>对于未绑定的工作队列，后备池的数量是动态的。可以使用为未绑定的工作队列分配自定义属性， apply_workqueue_attrs()并且工作队列将自动创建与属性匹配的后备工作池。调节并发级别的责任在用户身上。还有一个标志来标记一个绑定的 wq 以忽略并发管理。有关详细信息，请参阅 API 部分。</p>
<p>前向进度保证依赖于在需要更多执行上下文时可以创建工作人员，而这反过来又通过使用救援工作人员来保证。所有可能在处理内存回收的代码路径上使用的工作项都需要在 wq 上排队，这些 wq 有一个为在内存压力下执行而保留的救援工作人员。否则，等待执行上下文释放的工作池可能会死锁。</p>
<ul>
<li><dl>
<dt>api</dt><dd><ul class="simple">
<li><p>alloc_workqueue()分配一个 wq。原始 create_*workqueue()功能已弃用并计划删除。 alloc_workqueue()接受三个参数-&#64;name和 . 是 wq 的名称，如果有的话，也用作救援线程的名称。&#64;flags&#64;max_active&#64;name</p></li>
</ul>
<p>wq 不再管理执行资源，而是用作向前进度保证、刷新和工作项属性的域。&#64;flags 并&#64;max_active控制如何为工作项分配执行资源、计划和执行。</p>
<p>flags
WQ_UNBOUND
排队到未绑定 wq 的工作项由特殊的工作池提供服务，这些工作池托管未绑定到任何特定 CPU 的工作人员。这使得 wq 表现为一个没有并发管理的简单执行上下文提供者。未绑定的工作池尝试尽快开始执行工作项。未绑定 wq 牺牲了局部性，但对以下情况很有用。</p>
<p>预计并发级别要求会有很大的波动，并且使用绑定 wq 最终可能会在发行者通过不同的 CPU 跳跃时在不同的 CPU 上创建大量大部分未使用的工作人员。</p>
<p>系统调度程序可以更好地管理长时间运行的 CPU 密集型工作负载。</p>
<p>WQ_FREEZABLE
一个可冻结的 wq 参与系统挂起操作的冻结阶段。wq 上的工作项被耗尽，并且在解冻之前没有新的工作项开始执行。</p>
<p>WQ_MEM_RECLAIM
所有可能在内存回收路径中使用的 wq 都必须 设置此标志。无论内存压力如何，都保证 wq 具有至少一个执行上下文。</p>
<p>WQ_HIGHPRI
highpri wq 的工作项排队到目标 cpu 的 highpri 工作池。Highpri 工作池由具有较高 nice 级别的工作线程提供服务。</p>
<p>请注意，正常和高优先级工作池不会相互交互。每个都维护其单独的工作人员池并在其工作人员之间实施并发管理。</p>
<p>WQ_CPU_INTENSIVE
CPU 密集型 wq 的工作项对并发级别没有贡献。换句话说，可运行的 CPU 密集型工作项不会阻止同一工作池中的其他工作项开始执行。这对于预计会占用 CPU 周期的绑定工作项很有用，因此它们的执行由系统调度程序调节。</p>
<p>尽管 CPU 密集型工作项对并发级别没有贡献，但它们的执行开始仍受并发管理的约束，并且可运行的非 CPU 密集型工作项可能会延迟 CPU 密集型工作项的执行。</p>
<p>这个标志对于未绑定的 wq 是没有意义的。</p>
<ul class="simple">
<li><p>max_active</p></li>
</ul>
<p>&#64;max_active确定每个 CPU 可以分配给 wq 的工作项的最大执行上下文数。例如，&#64;max_active16 个，每个 CPU 最多可以同时执行 wq 的 16 个工作项。</p>
<p>目前，对于绑定的 wq，最大限制为&#64;max_active512，指定 0 时使用的默认值为 256。对于未绑定的 wq，限制高于 512 和 4 * num_possible_cpus()。这些值选择得足够高，这样它们就不是限制因素，同时在失控情况下提供保护。</p>
<p>wq 的活跃工作项的数量通常由 wq 的用户来调节，更具体地说，由用户可以同时排队的工作项的数量来调节。除非特别需要限制活动工作项的数量，否则建议指定“0”。</p>
<p>一些用户依赖于 ST wq 的严格执行顺序。&#64;max_active1 和的组合WQ_UNBOUND用于实现此行为。这种 wq 上的工作项总是排队到未绑定的工作池中，并且在任何给定时间只有一个工作项可以处于活动状态，从而实现与 ST wq 相同的排序属性。</p>
<p>在当前实现中，上述配置仅保证给定 NUMA 节点内的 ST 行为。相反alloc_ordered_queue()应该用于实现系统范围的 ST 行为。</p>
</dd>
</dl>
</li>
<li><dl>
<dt>示例：</dt><dd><p>以下示例执行场景试图说明 cmwq 在不同配置下的行为方式。</p>
<p>工作项 w0、w1、w2 排队到同一 CPU 上的绑定 wq q0。w0 将 CPU 烧 5 毫秒，然后休眠 10 毫秒，然后在完成之前再次将 CPU 烧 5 毫秒。w1 和 w2 烧 CPU 5ms 然后休眠 10ms。</p>
<p>忽略所有其他任务、工作和处理开销，并假设简单的 FIFO 调度，以下是原始 wq 的可能事件序列的一个高度简化版本。</p>
<div class="literal-block-wrapper docutils container" id="id15">
<div class="code-block-caption"><span class="caption-text">softirq基础结构</span><a class="headerlink" href="#id15" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="n">TIME</span> <span class="n">IN</span> <span class="n">MSECS</span>  <span class="n">EVENT</span>
     <span class="mi">0</span>              <span class="n">w0</span> <span class="n">starts</span> <span class="n">and</span> <span class="n">burns</span> <span class="n">CPU</span>
     <span class="mi">5</span>              <span class="n">w0</span> <span class="n">sleeps</span>
     <span class="mi">15</span>             <span class="n">w0</span> <span class="n">wakes</span> <span class="n">up</span> <span class="n">and</span> <span class="n">burns</span> <span class="n">CPU</span>
     <span class="mi">20</span>             <span class="n">w0</span> <span class="n">finishes</span>
     <span class="mi">20</span>             <span class="n">w1</span> <span class="n">starts</span> <span class="n">and</span> <span class="n">burns</span> <span class="n">CPU</span>
     <span class="mi">25</span>             <span class="n">w1</span> <span class="n">sleeps</span>
     <span class="mi">35</span>             <span class="n">w1</span> <span class="n">wakes</span> <span class="n">up</span> <span class="n">and</span> <span class="n">finishes</span>
     <span class="mi">35</span>             <span class="n">w2</span> <span class="n">starts</span> <span class="n">and</span> <span class="n">burns</span> <span class="n">CPU</span>
     <span class="mi">40</span>             <span class="n">w2</span> <span class="n">sleeps</span>
     <span class="mi">50</span>             <span class="n">w2</span> <span class="n">wakes</span> <span class="n">up</span> <span class="n">and</span> <span class="n">finishes</span>
</pre></div>
</td></tr></table></div>
</div>
<p>如果 cmwq &#64;max_active&gt;= 3，</p>
</dd>
</dl>
</li>
</ul>
<p>。。。。。。</p>
<ul>
<li><dl>
<dt>指导方针</dt><dd><p>1.WQ_MEM_RECLAIM如果 wq 可以处理在内存回收期间使用的工作项，请不要忘记使用。每个带有 WQ_MEM_RECLAIMset 的 wq 都有一个为其保留的执行上下文。如果在内存回收期间使用的多个工作项之间存在依赖关系，则应将它们排队以将 wq 每个与 WQ_MEM_RECLAIM.</p>
<p>2.除非需要严格排序，否则不需要使用 ST wq。</p>
<p>3.除非有特殊需要，否则建议使用 0 表示 &#64;max_active。在大多数用例中，并发级别通常保持在默认限制以下。</p>
<p>4.wq 用作前向进度保证（WQ_MEM_RECLAIM、刷新和工作项属性）的域。工作项不参与内存回收并且不需要作为一组工作项的一部分进行刷新，并且不需要任何特殊属性，都可以使用系统wq之一。使用专用wq和系统wq在执行特性上没有区别。</p>
<p>5.除非预计工作项会消耗大量 CPU 周期，否则使用绑定的 wq 通常是有益的，因为 wq 操作和工作项执行的局部性水平会提高。</p>
</dd>
</dl>
</li>
<li><p>调试</p></li>
</ul>
<p>因为工作功能是由通用工作线程执行的，所以需要一些技巧来了解行为不端的工作队列用户。</p>
<p>工作线程在进程列表中显示为：</p>
<p>root      5671  0.0  0.0      0     0 ?        S    12:07   0:00 [kworker/0:1]
root      5672  0.0  0.0      0     0 ?        S    12:07   0:00 [kworker/1:2]
root      5673  0.0  0.0      0     0 ?        S    12:12   0:00 [kworker/0:0]
root      5674  0.0  0.0      0     0 ?        S    12:13   0:00 [kworker/1:0]
如果 kworkers 发疯了（使用过多的 cpu），有两种可能的问题：</p>
<blockquote>
<div><p>1.快速连续安排的事情</p>
<p>2.消耗大量 CPU 周期的单个工作项</p>
</div></blockquote>
<p>第一个可以使用跟踪来跟踪：</p>
<p>$ echo workqueue:workqueue_queue_work &gt; /sys/kernel/debug/tracing/set_event
$ cat /sys/kernel/debug/tracing/trace_pipe &gt; out.txt
(wait a few secs)
^C</p>
<p>如果某些东西在工作队列中忙于循环，它将主导输出，并且可以使用工作项功能确定违规者。</p>
<p>对于第二种类型的问题，应该可以只检查有问题的工作线程的堆栈跟踪。</p>
<p>$ cat /proc/THE_OFFENDING_KWORKER/stack</p>
<ul class="simple">
<li><p>非重入条件</p></li>
</ul>
<p>如果在工作项排队后满足以下条件，Workqueue 保证工作项不能重入：</p>
<blockquote>
<div><p>1.功函数没有改变。</p>
<p>2.没有人将工作项排队到另一个工作队列。</p>
<p>3.工作项尚未重新启动。</p>
</div></blockquote>
<p>换句话说，如果上述条件成立，则保证工作项在任何给定时间最多由系统范围内的一个工作人员执行。</p>
<p>请注意，在 self 函数中将工作项重新排队（到同一个队列）不会破坏这些条件，因此这样做是安全的。否则，在破坏功函数内部的条件时需要小心。</p>
</div>
<div class="section" id="id6">
<h3>总结(个人理解）<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>应用场景</p></li>
<li><p>实现原理</p></li>
<li><p>参考：<a class="reference external" href="https://www.kernel.org/doc/html/latest/core-api/workqueue.html">https://www.kernel.org/doc/html/latest/core-api/workqueue.html</a></p></li>
</ul>
</div>
</div>
<div class="section" id="linux-softirq">
<h2>linux 软中断：softirq<a class="headerlink" href="#linux-softirq" title="Permalink to this headline">¶</a></h2>
<p>我们看的是线程化的下半部。</p>
<p>软中断：在硬件中断处理程序结束时调用的的句柄</p>
<div class="literal-block-wrapper docutils container" id="id16">
<div class="code-block-caption"><span class="caption-text">softirq基础结构</span><a class="headerlink" href="#id16" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="cm">/* PLEASE, avoid to allocate new softirqs, if you need not _really_ high</span>
<span class="cm">     frequency threaded job scheduling. For almost all the purposes</span>
<span class="cm">     tasklets are more than enough. F.e. all serial device BHs et</span>
<span class="cm">     al. should be converted to tasklets, not to softirqs.</span>
<span class="cm">     */</span>
     <span class="cm">/* 所有的软中断向量，数字越小优先级越高 */</span>
     <span class="k">enum</span>
     <span class="p">{</span>
             <span class="n">HI_SOFTIRQ</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
             <span class="n">TIMER_SOFTIRQ</span><span class="p">,</span>
             <span class="n">NET_TX_SOFTIRQ</span><span class="p">,</span>
             <span class="n">NET_RX_SOFTIRQ</span><span class="p">,</span>
             <span class="n">BLOCK_SOFTIRQ</span><span class="p">,</span>
             <span class="n">IRQ_POLL_SOFTIRQ</span><span class="p">,</span>
             <span class="n">TASKLET_SOFTIRQ</span><span class="p">,</span>
             <span class="n">SCHED_SOFTIRQ</span><span class="p">,</span>
             <span class="n">HRTIMER_SOFTIRQ</span><span class="p">,</span>
             <span class="n">RCU_SOFTIRQ</span><span class="p">,</span>    <span class="cm">/* Preferable RCU should always be the last softirq */</span>

             <span class="n">NR_SOFTIRQS</span>
     <span class="p">};</span>

     <span class="k">struct</span> <span class="nc">softirq_action</span>
     <span class="p">{</span>
             <span class="kt">void</span>    <span class="p">(</span><span class="o">*</span><span class="n">action</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">softirq_action</span> <span class="o">*</span><span class="p">);</span>
     <span class="p">};</span>
     <span class="k">static</span> <span class="k">struct</span> <span class="nc">softirq_action</span> <span class="n">softirq_vec</span><span class="p">[</span><span class="n">NR_SOFTIRQS</span><span class="p">]</span> <span class="n">__cacheline_aligned_in_smp</span><span class="p">;</span>

     <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="nc">task_struct</span> <span class="o">*</span><span class="p">,</span> <span class="n">ksoftirqd</span><span class="p">);</span>

     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">softirq_to_name</span><span class="p">[</span><span class="n">NR_SOFTIRQS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
             <span class="s">&quot;HI&quot;</span><span class="p">,</span> <span class="s">&quot;TIMER&quot;</span><span class="p">,</span> <span class="s">&quot;NET_TX&quot;</span><span class="p">,</span> <span class="s">&quot;NET_RX&quot;</span><span class="p">,</span> <span class="s">&quot;BLOCK&quot;</span><span class="p">,</span> <span class="s">&quot;IRQ_POLL&quot;</span><span class="p">,</span>
             <span class="s">&quot;TASKLET&quot;</span><span class="p">,</span> <span class="s">&quot;SCHED&quot;</span><span class="p">,</span> <span class="s">&quot;HRTIMER&quot;</span><span class="p">,</span> <span class="s">&quot;RCU&quot;</span>
     <span class="p">};</span>
</pre></div>
</td></tr></table></div>
</div>
<p>初始化流程：start_kernel–&gt;softirq_init() –&gt;early_initcall(spawn_ksoftirqd)</p>
<p>可以理解为所有软中断通过softirq_action进行组织，数组的每个成员指向处理某类事件的处理函数。函数在不同的CPU上是可重入的。每个CPU上运行的软中断处理线程负责处理本CPU上产生的事件。处理完挂起的事件后内核线程就调度出去。在特定时机唤醒内核线程。内核线程继续检查是否有挂起的事件，周而复始。这个时机在下文中进一步解释。唤醒则参考wakeup_softirqd函数。可考虑比较不同版本内核处理方式上的差异。此时关注内核线程优先级问题。</p>
<p>static struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;</p>
<p>DEFINE_PER_CPU(struct task_struct <a href="#id7"><span class="problematic" id="id8">*</span></a>, ksoftirqd);</p>
<p>1.softirq_init()</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id17">
<div class="code-block-caption"><span class="caption-text">struct_task –&gt; mm</span><a class="headerlink" href="#id17" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">:</span><span class="nl">linenos</span><span class="p">:</span>

<span class="cm">/* Tasklets --- multithreaded analogue of BHs.</span>

<span class="cm">This API is deprecated. Please consider using threaded IRQs instead:</span>
<span class="cm">https://lore.kernel.org/lkml/20200716081538.2sivhkj4hcyrusem@linutronix.de</span>

<span class="cm">Main feature differing them of generic softirqs: tasklet</span>
<span class="cm">is running only on one CPU simultaneously.//与通用软中断不同的主要特点：tasklet只同时在一个 CPU 上运行。</span>

<span class="cm">Main feature differing them of BHs: different tasklets</span>
<span class="cm">may be run simultaneously on different CPUs.//与 BH 不同的主要特征：不同的 tasklet</span>
<span class="cm">可以在不同的 CPU 上同时运行。</span>

<span class="cm">Properties:</span>
<span class="cm">* If tasklet_schedule() is called, then tasklet is guaranteed</span>
<span class="cm"> to be executed on some cpu at least once after this.</span>
<span class="cm">* If the tasklet is already scheduled, but its execution is still not</span>
<span class="cm">  started, it will be executed only once.</span>
<span class="cm">* If this tasklet is already running on another CPU (or schedule is called</span>
<span class="cm"> from tasklet itself), it is rescheduled for later.</span>
<span class="cm">* Tasklet is strictly serialized wrt itself, but not</span>
<span class="cm"> wrt another tasklets. If client needs some intertask synchronization,</span>
<span class="cm"> he makes it with spinlocks.//Tasklet 是严格序列化的 wrt 本身，但不是 wrt 另一个 tasklets。如果客户端需要一些任务间同步，他会使用自旋锁来实现。</span>
<span class="cm">Tasklet shì yángé xùliè huà de wrt</span>
<span class="cm">*/</span>

<span class="k">struct</span> <span class="nc">tasklet_struct</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="nc">tasklet_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>
        <span class="n">atomic_t</span> <span class="n">count</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">use_callback</span><span class="p">;</span>
        <span class="k">union</span> <span class="p">{</span>
                <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
                <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">tasklet_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">);</span>
        <span class="p">};</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Tasklets</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="nc">tasklet_head</span> <span class="p">{</span><span class="c1">//tasklet_struct组织方式</span>
        <span class="k">struct</span> <span class="nc">tasklet_struct</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">tasklet_struct</span> <span class="o">**</span><span class="n">tail</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="nf">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="nc">tasklet_head</span><span class="p">,</span> <span class="n">tasklet_vec</span><span class="p">);</span>
<span class="k">static</span> <span class="nf">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="nc">tasklet_head</span><span class="p">,</span> <span class="n">tasklet_hi_vec</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="n">softirq_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

        <span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">per_cpu</span><span class="p">(</span><span class="n">tasklet_vec</span><span class="p">,</span> <span class="n">cpu</span><span class="p">).</span><span class="n">tail</span> <span class="o">=</span>
                        <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">tasklet_vec</span><span class="p">,</span> <span class="n">cpu</span><span class="p">).</span><span class="n">head</span><span class="p">;</span>
                <span class="n">per_cpu</span><span class="p">(</span><span class="n">tasklet_hi_vec</span><span class="p">,</span> <span class="n">cpu</span><span class="p">).</span><span class="n">tail</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">tasklet_hi_vec</span><span class="p">,</span> <span class="n">cpu</span><span class="p">).</span><span class="n">head</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">open_softirq</span><span class="p">(</span><span class="n">TASKLET_SOFTIRQ</span><span class="p">,</span> <span class="n">tasklet_action</span><span class="p">);</span><span class="c1">// softirq_vec[TASKLET_SOFTIRQ] = tasklet_action;初始化tasklet_action,具体操作参考下文描述；</span>
        <span class="n">open_softirq</span><span class="p">(</span><span class="n">HI_SOFTIRQ</span><span class="p">,</span> <span class="n">tasklet_hi_action</span><span class="p">);</span> <span class="c1">// softirq_vec[HI_SOFTIRQ] = tasklet_hi_action;初始化tasklet_hi_action,具体操作参考下文描述；</span>


<span class="p">}</span>
</pre></div>
</div>
</div>
</div></blockquote>
<ol class="arabic" start="2">
<li><p>spawn_ksoftirqd()：在内核初始化初期为每一个CPU新建内核线程ksoftirqd</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id18">
<div class="code-block-caption"><span class="caption-text">处理软终端的内核线程：每个CPU一个</span><a class="headerlink" href="#id18" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">struct</span> <span class="nc">smp_hotplug_thread</span> <span class="n">softirq_threads</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">store</span>                  <span class="o">=</span> <span class="o">&amp;</span><span class="n">ksoftirqd</span><span class="p">,</span><span class="c1">//每个CPU存储struct task指针</span>
        <span class="p">.</span><span class="n">thread_should_run</span>      <span class="o">=</span> <span class="n">ksoftirqd_should_run</span><span class="p">,</span> <span class="c1">//判断句柄</span>
        <span class="p">.</span><span class="n">thread_fn</span>              <span class="o">=</span> <span class="n">run_ksoftirqd</span><span class="p">,</span><span class="c1">//处理每个CPU上的软中断</span>
        <span class="p">.</span><span class="n">thread_comm</span>            <span class="o">=</span> <span class="s">&quot;ksoftirqd/%u&quot;</span><span class="p">,</span><span class="c1">//每个CPU运行的处理软中断的内核线程名字格式</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="n">spawn_ksoftirqd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">cpuhp_setup_state_nocalls</span><span class="p">(</span><span class="n">CPUHP_SOFTIRQ_DEAD</span><span class="p">,</span> <span class="s">&quot;softirq:dead&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
                          <span class="n">takeover_tasklets</span><span class="p">);</span> <span class="c1">//cpu:CPUHP_SOFTIRQ_DEAD状态回调函数。</span>
        <span class="n">BUG_ON</span><span class="p">(</span><span class="n">smpboot_register_percpu_thread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">softirq_threads</span><span class="p">));</span><span class="c1">//</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_initcall</span><span class="p">(</span><span class="n">spawn_ksoftirqd</span><span class="p">);</span><span class="c1">//新建内核线程时机</span>
</pre></div>
</td></tr></table></div>
</div>
<p>我们看正常运行系统负责处理软中断的内核线程（当前硬件：八核）：</p>
<div class="literal-block-wrapper docutils container" id="id19">
<div class="code-block-caption"><span class="caption-text">每个CPU运行一个处理软中断的线程</span><a class="headerlink" href="#id19" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span>root@rachel:/usr/src/linux-source-5.14/kernel# ps -aux|grep ksoft
root          12  0.0  0.0      0     0 ?        S     2021   0:21 [ksoftirqd/0]
root          18  0.0  0.0      0     0 ?        S     2021   0:03 [ksoftirqd/1]
root          23  0.0  0.0      0     0 ?        S     2021   0:00 [ksoftirqd/2]
root          28  0.0  0.0      0     0 ?        S     2021   0:00 [ksoftirqd/3]
root          33  0.0  0.0      0     0 ?        S     2021   0:01 [ksoftirqd/4]
root          38  0.0  0.0      0     0 ?        S     2021   0:01 [ksoftirqd/5]
root          43  0.0  0.0      0     0 ?        S     2021   7:52 [ksoftirqd/6]
root          48  0.0  0.0      0     0 ?        S     2021   0:02 [ksoftirqd/7]
</pre></div>
</td></tr></table></div>
</div>
<p>到目前为止，初始化就完成了，我们看其运行周期：</p>
</div></blockquote>
</li>
</ol>
<ul>
<li><p>软中断运行点：</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id20">
<div class="code-block-caption"><span class="caption-text">ksoftirqd线程唤醒时机</span><a class="headerlink" href="#id20" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">* we cannot loop indefinitely here to avoid userspace starvation,</span>
<span class="cm">* but we also don&#39;t want to introduce a worst case 1/HZ latency</span>
<span class="cm">* to the pending events, so lets the scheduler to balance</span>
<span class="cm">* the softirq load for us.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">wakeup_softirqd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
     <span class="cm">/* Interrupts are disabled: no need to stop preemption */</span>
     <span class="k">struct</span> <span class="nc">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">ksoftirqd</span><span class="p">);</span>

     <span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="p">)</span>
             <span class="n">wake_up_process</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</li>
<li><p>__do_softirq –&gt; wakeup_softirqd:具体唤醒时间点:</p>
<blockquote>
<div><ul class="simple">
<li><p>具体场景：irq_exit_rcu(void) –&gt;__irq_exit_rcu –&gt;invoke_softirq() –&gt;wakeup_softirqd / __do_softirq_</p></li>
<li><p>具体场景：irq_exit(void) –&gt;__irq_exit_rcu –&gt;invoke_softirq() –&gt;wakeup_softirqd / __do_softirq_</p></li>
<li><p>具体场景：raise_softirq_irqoff –&gt; wakeup_softirqd</p></li>
<li><p>具体场景：raise_softirq –&gt; raise_softirq_irqoff –&gt; wakeup_softirqd</p></li>
<li><p>具体场景： __local_bh_enable_ip –&gt; wakeup_softirqd</p></li>
</ul>
</div></blockquote>
</li>
<li><p>为某类软中断初始化处理句柄：</p>
<blockquote>
<div><blockquote>
<div><p>open_softirq(NET_TX_SOFTIRQ, net_tx_action);</p>
<div class="literal-block-wrapper docutils container" id="id21">
<div class="code-block-caption"><span class="caption-text">struct_task –&gt; mm</span><a class="headerlink" href="#id21" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">open_softirq</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">action</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">softirq_action</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
     <span class="n">softirq_vec</span><span class="p">[</span><span class="n">nr</span><span class="p">].</span><span class="n">action</span> <span class="o">=</span> <span class="n">action</span><span class="p">;</span>
<span class="hll"><span class="p">}</span>
</span></pre></div>
</td></tr></table></div>
</div>
<p>每个类型的软中断有一个hook，怎么处理，怎么组织这类事件则在这个hook中处理。</p>
<p>我们以net_tx_action为例，看下其代码：</p>
</div></blockquote>
<div class="literal-block-wrapper docutils container" id="id22">
<div class="code-block-caption"><span class="caption-text">net_tx_action分析</span><a class="headerlink" href="#id22" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">__latent_entropy</span> <span class="kt">void</span> <span class="n">net_tx_action</span><span class="p">(</span><span class="k">struct</span> <span class="nc">softirq_action</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="nc">softnet_data</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">softnet_data</span><span class="p">);</span>
<span class="hll">
</span><span class="hll">        <span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">completion_queue</span><span class="p">)</span> <span class="p">{</span>
</span>                <span class="k">struct</span> <span class="nc">sk_buff</span> <span class="o">*</span><span class="n">clist</span><span class="p">;</span>

                <span class="n">local_irq_disable</span><span class="p">();</span>
                <span class="n">clist</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">completion_queue</span><span class="p">;</span>
                <span class="n">sd</span><span class="o">-&gt;</span><span class="n">completion_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="n">local_irq_enable</span><span class="p">();</span>

                <span class="k">while</span> <span class="p">(</span><span class="n">clist</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">struct</span> <span class="nc">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">clist</span><span class="p">;</span>

                        <span class="n">clist</span> <span class="o">=</span> <span class="n">clist</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

                        <span class="n">WARN_ON</span><span class="p">(</span><span class="n">refcount_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">));</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">get_kfree_skb_cb</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">reason</span> <span class="o">==</span> <span class="n">SKB_REASON_CONSUMED</span><span class="p">))</span>
                                <span class="n">trace_consume_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
                        <span class="k">else</span>
                                <span class="nf">trace_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">net_tx_action</span><span class="p">);</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">fclone</span> <span class="o">!=</span> <span class="n">SKB_FCLONE_UNAVAILABLE</span><span class="p">)</span>
                                <span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
                        <span class="k">else</span>
                                <span class="nf">__kfree_skb_defer</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
                <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="nc">Qdisc</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

                <span class="n">local_irq_disable</span><span class="p">();</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue</span><span class="p">;</span>
                <span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue_tailp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue</span><span class="p">;</span>
                <span class="n">local_irq_enable</span><span class="p">();</span>

                <span class="n">rcu_read_lock</span><span class="p">();</span>

                <span class="k">while</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">struct</span> <span class="nc">Qdisc</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
                        <span class="n">spinlock_t</span> <span class="o">*</span><span class="n">root_lock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

                        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next_sched</span><span class="p">;</span>

                        <span class="cm">/* We need to make sure head-&gt;next_sched is read</span>
<span class="cm">                         * before clearing __QDISC_STATE_SCHED</span>
<span class="cm">                         */</span>
                        <span class="n">smp_mb__before_atomic</span><span class="p">();</span>

                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TCQ_F_NOLOCK</span><span class="p">))</span> <span class="p">{</span>
                                <span class="n">root_lock</span> <span class="o">=</span> <span class="n">qdisc_lock</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
                                <span class="n">spin_lock</span><span class="p">(</span><span class="n">root_lock</span><span class="p">);</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__QDISC_STATE_DEACTIVATED</span><span class="p">,</span>
                                             <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)))</span> <span class="p">{</span>
                                <span class="cm">/* There is a synchronize_net() between</span>
<span class="cm">                                 * STATE_DEACTIVATED flag being set and</span>
<span class="cm">                                 * qdisc_reset()/some_qdisc_is_busy() in</span>
<span class="cm">                                 * dev_deactivate(), so we can safely bail out</span>
<span class="cm">                                 * early here to avoid data race between</span>
<span class="cm">                                 * qdisc_deactivate() and some_qdisc_is_busy()</span>
<span class="cm">                                 * for lockless qdisc.</span>
<span class="cm">                                 */</span>
                                <span class="n">clear_bit</span><span class="p">(</span><span class="n">__QDISC_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
                                <span class="k">continue</span><span class="p">;</span>
                        <span class="p">}</span>

                        <span class="n">clear_bit</span><span class="p">(</span><span class="n">__QDISC_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
                        <span class="n">qdisc_run</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">root_lock</span><span class="p">)</span>
                                <span class="n">spin_unlock</span><span class="p">(</span><span class="n">root_lock</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="n">rcu_read_unlock</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">xfrm_dev_backlog</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</li>
<li><p>软中断处理的任务：</p>
<blockquote>
<div><ul class="simple">
<li><p>kernel/softirq.c:open_softirq(TASKLET_SOFTIRQ, tasklet_action);// softirq_vec[TASKLET_SOFTIRQ] = tasklet_action;</p></li>
<li><p>kernel/softirq.c:open_softirq(HI_SOFTIRQ, tasklet_hi_action); // softirq_vec[HI_SOFTIRQ] = tasklet_hi_action;</p></li>
<li><p>kernel/time/timer.c:2024:      open_softirq(TIMER_SOFTIRQ, run_timer_softirq);</p></li>
<li><p>kernel/time/hrtimer.c:2165:    open_softirq(HRTIMER_SOFTIRQ, hrtimer_run_softirq);</p></li>
<li><p>kernel/rcu/tiny.c:222: open_softirq(RCU_SOFTIRQ, rcu_process_callbacks) + kernel/rcu/tree.c:4757:                open_softirq(RCU_SOFTIRQ, rcu_core_si);</p></li>
<li><p>kernel/sched/fair.c:11578:     open_softirq(SCHED_SOFTIRQ, run_rebalance_domains);</p></li>
<li><p>net/core/dev.c:11718:       open_softirq(NET_TX_SOFTIRQ, net_tx_action);</p></li>
<li><p>net/core/dev.c:11719:       open_softirq(NET_RX_SOFTIRQ, net_rx_action);</p></li>
<li><p>block/blk-mq.c:4018:    open_softirq(BLOCK_SOFTIRQ, blk_done_softirq);</p></li>
<li><p>lib/irq_poll.c:210:     open_softirq(IRQ_POLL_SOFTIRQ, irq_poll_softirq);</p></li>
</ul>
</div></blockquote>
</li>
<li><dl class="simple">
<dt>总结：</dt><dd><ul class="simple">
<li><p>软中断与irq work差别: 软中断在内核线程上线文中执行，irq work在硬件中断上下文中执行；</p></li>
<li><p>每个软中断任务同一时刻只能在一个CPU上运行。</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="notifier">
<h2>notifier通知链<a class="headerlink" href="#notifier" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p>应用场景描述:管理通知链的例程，用于将状态更改传递给任何感兴趣的例程。 对某个状态感兴趣的例程则可以将自己的状态处理hook注册到对应通知链上。</p></li>
<li><dl>
<dt>通知链分类</dt><dd><ul class="simple">
<li><p>原子通知链：在中断/原子上下文中运行回调。回调例程中不允许阻塞。</p></li>
<li><p>可阻塞通知链：运行在进程上下文，回调例程中允许阻塞。</p></li>
<li><p>原始通知链：对回调例程的调用、注册、注销没有限制，由调用者提供加锁和保护。</p></li>
<li><p>SRCU通知链：阻塞通知链的一种变体，具有相同的限制。</p></li>
</ul>
<p>可以从原子上下文调用atomic_notifier_chain_register()，但只能从进程上下文调用blocking_notifier_chain_register()和srcu_notifier_chain_register()，这个规则同样适用于对应的注销函数。
不能在通知链中调用atomic_notifier_chain_unregister(), blocking_notifier_chain_unregister()和srcu_notifier_chain_unregister()函数。</p>
<p>SRCU通知链是阻塞通知链的变体。用SRCU（Sleepable Read-Copy Update）代替rw信号量作为链的保护方式。srcu_notifier_call_chain()有很低的开销：no cache bounces and no memory barriers.当链会被非常频繁地调用但 notifier_blocks 很少被删除时，应该使用 SRCU 通知链。</p>
</dd>
</dl>
</li>
<li><p>结构</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id23">
<div class="code-block-caption"><span class="caption-text">notifier相关结构</span><a class="headerlink" href="#id23" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">notifier_block</span><span class="p">;</span>

<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">notifier_fn_t</span><span class="p">)(</span><span class="k">struct</span> <span class="nc">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span>
                <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="k">struct</span> <span class="nc">notifier_block</span> <span class="p">{</span>
        <span class="n">notifier_fn_t</span> <span class="n">notifier_call</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">notifier_block</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">priority</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">atomic_notifier_head</span> <span class="p">{</span>
        <span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">notifier_block</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">blocking_notifier_head</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="nc">rw_semaphore</span> <span class="n">rwsem</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">notifier_block</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">raw_notifier_head</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="nc">notifier_block</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">srcu_notifier_head</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="nc">mutex</span> <span class="n">mutex</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">srcu_struct</span> <span class="n">srcu</span><span class="p">;</span>
        <span class="k">struct</span> <span class="nc">notifier_block</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</li>
<li><p>通知链声明：</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id24">
<div class="code-block-caption"><span class="caption-text">通知链初始化</span><a class="headerlink" href="#id24" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#define ATOMIC_NOTIFIER_HEAD(name)      。。。。。。</span>
<span class="cp">#define BLOCKING_NOTIFIER_HEAD(name)    。。。。。。</span>
<span class="cp">#define RAW_NOTIFIER_HEAD(name)         。。。。。。</span>
<span class="cp">#define SRCU_NOTIFIER_HEAD(name)        。。。。。。</span>
<span class="cp">#define SRCU_NOTIFIER_HEAD_STATIC(name)         。。。。。。</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</li>
<li><p>导出符号</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id25">
<div class="code-block-caption"><span class="caption-text">导出函数</span><a class="headerlink" href="#id25" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">atomic_notifier_chain_register</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">atomic_notifier_chain_unregister</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">atomic_notifier_call_chain_robust</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">atomic_notifier_call_chain</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blocking_notifier_chain_register</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blocking_notifier_chain_unregister</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blocking_notifier_call_chain_robust</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">blocking_notifier_call_chain</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">raw_notifier_chain_register</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">raw_notifier_chain_unregister</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">raw_notifier_call_chain_robust</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">raw_notifier_call_chain</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">srcu_notifier_chain_register</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">srcu_notifier_chain_unregister</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">srcu_notifier_call_chain</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">srcu_init_notifier_head</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">register_die_notifier</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unregister_die_notifier</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</li>
<li><p>常用通知链总结</p>
<blockquote>
<div><p>到目前为止已声明的通知程序。 可以想象随着时间的推移会有更多的链（例如笔记本电脑电源重置链、重启链（清理设备单元）、设备 [un]mount 链、模块加载/卸载链、内存不足链、screenblank 链（用于插入 模块化screenblankers）VC开关链（用于可加载内核svgalib VC开关助手）等……
- CPU 通知器在 include/linux/cpu.h 中定义。
- netdevice 通知器在 include/linux/netdevice.h 中定义
- 重启通知在 include/linux/reboot.h 中定义。
- 休眠和挂起事件在 include/linux/suspend.h 中定义。
- 虚拟终端事件在 include/linux/vt.h 中定义。
- arch/x86/kernel/cpu/mce/core.c:BLOCKING_NOTIFIER_HEAD(x86_mce_decoder_chain);
- arch/x86/kernel/cpu/mce/dev-mcelog.c:BLOCKING_NOTIFIER_HEAD(mce_injector_chain);
- arch/x86/platform/intel/iosf_mbi.c:BLOCKING_NOTIFIER_HEAD(iosf_mbi_pmic_bus_access_notifier);
- kernel/notifier.c:15:BLOCKING_NOTIFIER_HEAD(reboot_notifier_list);
- kernel/notifier.c:533:static ATOMIC_NOTIFIER_HEAD(die_chain);
- kernel/panic.c:70:ATOMIC_NOTIFIER_HEAD(panic_notifier_list);
- kernel/power/main.c:69:static BLOCKING_NOTIFIER_HEAD(pm_chain_head);
- kernel/power/qos.c:444:        BLOCKING_INIT_NOTIFIER_HEAD(c-&gt;notifiers);
- kernel/power/qos.c:453:        BLOCKING_INIT_NOTIFIER_HEAD(c-&gt;notifiers);
- kernel/profile.c:138:static BLOCKING_NOTIFIER_HEAD(task_exit_notifier);
- kernel/profile.c:139:static ATOMIC_NOTIFIER_HEAD(task_free_notifier);
- kernel/profile.c:140:static BLOCKING_NOTIFIER_HEAD(munmap_notifier);
- kernel/reboot.c:142:static ATOMIC_NOTIFIER_HEAD(restart_handler_list);
- kernel/time/timekeeping.c:649:static RAW_NOTIFIER_HEAD(pvclock_gtod_chain);
- kernel/tracepoint.c:577:static BLOCKING_NOTIFIER_HEAD(tracepoint_notify_list);
- mm/oom_kill.c:1025:static BLOCKING_NOTIFIER_HEAD(oom_notify_list);
- mm/vmalloc.c:780:static BLOCKING_NOTIFIER_HEAD(vmap_notify_list);
- crypto/api.c:30:BLOCKING_NOTIFIER_HEAD(crypto_chain);
- crypto/fips.c:19:ATOMIC_NOTIFIER_HEAD(fips_fail_notif_chain);
- security/security.c:74:static BLOCKING_NOTIFIER_HEAD(blocking_lsm_notifier_chain);</p>
</div></blockquote>
</li>
<li><p>通知链举例：reboot通知链接总结</p>
<blockquote>
<div><img alt="../_images/notifier_reboot.svg" class="align-center" src="../_images/notifier_reboot.svg" /></div></blockquote>
</li>
</ul>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="module.html" class="btn btn-neutral float-left" title="linux 内核模块原理分析" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lock.html" class="btn btn-neutral float-right" title="linux 内核竞争处理" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Rachel.Sun.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>