<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Compile-time stack metadata validation &mdash; Rachel&#39;s E-book 1.0 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="linux 进程管理" href="../kernel_ps/index.html" />
    <link rel="prev" title="bug/panic分析与总结" href="bug_panic.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> Rachel's E-book
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../os_base/index.html">linux 操作系统架构分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lk_devel/index.html">linux 内核开发</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">linux 内核代码分析</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">linux 内核基础</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="lock.html">linux 竞争与一致性问题处理</a></li>
<li class="toctree-l3"><a class="reference internal" href="extable.html">linux 异常表:extable</a></li>
<li class="toctree-l3"><a class="reference internal" href="jump_label.html">linux :jump_label 分析</a></li>
<li class="toctree-l3"><a class="reference internal" href="kexec_elf.html">linux 加载ELF 内核文件：kexec</a></li>
<li class="toctree-l3"><a class="reference internal" href="irq/index.html">linux 中断架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="resource.html">linux 资源管理: resource</a></li>
<li class="toctree-l3"><a class="reference internal" href="notifier.html">linux 内核通知链: notifier</a></li>
<li class="toctree-l3"><a class="reference internal" href="workqueue.html">linux 工作队列: workqueue</a></li>
<li class="toctree-l3"><a class="reference internal" href="signal.html">linux 信号:signal</a></li>
<li class="toctree-l3"><a class="reference internal" href="kallsyms.html">linux 内核符号:kallsyms + 导出符号</a></li>
<li class="toctree-l3"><a class="reference internal" href="module.html">linux 内核模块实现原理分析</a></li>
<li class="toctree-l3"><a class="reference internal" href="seccomp.html">linux 沙箱:seccomp</a></li>
<li class="toctree-l3"><a class="reference internal" href="trace/index.html">linux 内核跟踪调试代码架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="lk_sec/index.html">linux 内核安全架构分析</a></li>
<li class="toctree-l3"><a class="reference internal" href="func_injection.html">linux fail_function分析:基于函数的错误注入</a></li>
<li class="toctree-l3"><a class="reference internal" href="sysctl.html">linux 通用linux系统控制接口:sysctl</a></li>
<li class="toctree-l3"><a class="reference internal" href="sys.html">linux 系统级接口：sys</a></li>
<li class="toctree-l3"><a class="reference internal" href="static_call.html">linux static_call 分析</a></li>
<li class="toctree-l3"><a class="reference internal" href="stacktrace.html">linux 栈跟踪管理：unwind_{frame,guess,orc},stacktrace</a></li>
<li class="toctree-l3"><a class="reference internal" href="stackleak.html">linux stackleak</a></li>
<li class="toctree-l3"><a class="reference internal" href="printk.html">linux printk实现原理</a></li>
<li class="toctree-l3"><a class="reference internal" href="rcu.html">linux rcu原理分析</a></li>
<li class="toctree-l3"><a class="reference internal" href="kcsan.html">linux KCSAN分析</a></li>
<li class="toctree-l3"><a class="reference internal" href="power.html">linux 电源管理:power</a></li>
<li class="toctree-l3"><a class="reference internal" href="softirq.html">linux 软中断：softirq</a></li>
<li class="toctree-l3"><a class="reference internal" href="syscall.html">linux 系统调用原理</a></li>
<li class="toctree-l3"><a class="reference internal" href="alg_base.html">linux 基础算法总结</a></li>
<li class="toctree-l3"><a class="reference internal" href="bug_panic.html">bug/panic分析与总结</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Compile-time stack metadata validation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#why-do-we-need-stack-metadata-validation">Why do we need stack metadata validation?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rules">Rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#objtool-warnings">Objtool warnings</a></li>
<li class="toctree-l4"><a class="reference internal" href="#adding-exceptions">Adding exceptions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kernel_ps/index.html">linux 进程管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kernel_mem/index.html">linux 内存管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kernel_fs/index.html">linux 文件系统分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kernel_cpu/index.html">linux CPU管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kernel_driver/index.html">linux 驱动架构分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lk_net/index.html">linux 内核网络代码分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kernel_virt/index.html">linux 内核虚拟化技术</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kobject.html">kobject理解</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../os_sec/index.html">linux 操作系统安全</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../my_os/index.html">从零开始写一个系统（KVM）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../csxj/index.html">处世悬镜</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Rachel's E-book</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">linux 内核代码分析</a> &raquo;</li>
          <li><a href="index.html">linux 内核基础</a> &raquo;</li>
      <li>Compile-time stack metadata validation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/lk_code/kernel_base/stack-validation.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="compile-time-stack-metadata-validation">
<h1>Compile-time stack metadata validation<a class="headerlink" href="#compile-time-stack-metadata-validation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The kernel CONFIG_STACK_VALIDATION option enables a host tool named
objtool which runs at compile time.  It has a “check” subcommand which
analyzes every .o file and ensures the validity of its stack metadata.
It enforces a set of rules on asm code and C inline assembly code so
that stack traces can be reliable.</p>
<p>For each function, it recursively follows all possible code paths and
validates the correct frame pointer state at each instruction.</p>
<p>It also follows code paths involving special sections, like
.altinstructions, __jump_table, and __ex_table, which can add
alternative execution paths to a given instruction (or set of
instructions).  Similarly, it knows how to follow switch statements, for
which gcc sometimes uses jump tables.</p>
<p>(Objtool also has an ‘orc generate’ subcommand which generates debuginfo
for the ORC unwinder.  See Documentation/x86/orc-unwinder.rst in the
kernel tree for more details.)</p>
</div>
<div class="section" id="why-do-we-need-stack-metadata-validation">
<h2>Why do we need stack metadata validation?<a class="headerlink" href="#why-do-we-need-stack-metadata-validation" title="Permalink to this headline">¶</a></h2>
<p>Here are some of the benefits of validating stack metadata:</p>
<ol class="loweralpha">
<li><p>More reliable stack traces for frame pointer enabled kernels</p>
<p>Frame pointers are used for debugging purposes.  They allow runtime
code and debug tools to be able to walk the stack to determine the
chain of function call sites that led to the currently executing
code.</p>
<p>For some architectures, frame pointers are enabled by
CONFIG_FRAME_POINTER.  For some other architectures they may be
required by the ABI (sometimes referred to as “backchain pointers”).</p>
<p>For C code, gcc automatically generates instructions for setting up
frame pointers when the -fno-omit-frame-pointer option is used.</p>
<p>But for asm code, the frame setup instructions have to be written by
hand, which most people don’t do.  So the end result is that
CONFIG_FRAME_POINTER is honored for C code but not for most asm code.</p>
<p>For stack traces based on frame pointers to be reliable, all
functions which call other functions must first create a stack frame
and update the frame pointer.  If a first function doesn’t properly
create a stack frame before calling a second function, the <em>caller</em>
of the first function will be skipped on the stack trace.</p>
<p>For example, consider the following example backtrace with frame
pointers enabled:</p>
<blockquote>
<div><p>[&lt;ffffffff81812584&gt;] dump_stack+0x4b/0x63
[&lt;ffffffff812d6dc2&gt;] cmdline_proc_show+0x12/0x30
[&lt;ffffffff8127f568&gt;] seq_read+0x108/0x3e0
[&lt;ffffffff812cce62&gt;] proc_reg_read+0x42/0x70
[&lt;ffffffff81256197&gt;] __vfs_read+0x37/0x100
[&lt;ffffffff81256b16&gt;] vfs_read+0x86/0x130
[&lt;ffffffff81257898&gt;] SyS_read+0x58/0xd0
[&lt;ffffffff8181c1f2&gt;] entry_SYSCALL_64_fastpath+0x12/0x76</p>
</div></blockquote>
<p>It correctly shows that the caller of cmdline_proc_show() is
seq_read().</p>
<p>If we remove the frame pointer logic from cmdline_proc_show() by
replacing the frame pointer related instructions with nops, here’s
what it looks like instead:</p>
<blockquote>
<div><p>[&lt;ffffffff81812584&gt;] dump_stack+0x4b/0x63
[&lt;ffffffff812d6dc2&gt;] cmdline_proc_show+0x12/0x30
[&lt;ffffffff812cce62&gt;] proc_reg_read+0x42/0x70
[&lt;ffffffff81256197&gt;] __vfs_read+0x37/0x100
[&lt;ffffffff81256b16&gt;] vfs_read+0x86/0x130
[&lt;ffffffff81257898&gt;] SyS_read+0x58/0xd0
[&lt;ffffffff8181c1f2&gt;] entry_SYSCALL_64_fastpath+0x12/0x76</p>
</div></blockquote>
<p>Notice that cmdline_proc_show()’s caller, seq_read(), has been
skipped.  Instead the stack trace seems to show that
cmdline_proc_show() was called by proc_reg_read().</p>
<p>The benefit of objtool here is that because it ensures that <em>all</em>
functions honor CONFIG_FRAME_POINTER, no functions will ever[*] be
skipped on a stack trace.</p>
<dl class="simple">
<dt>[*] unless an interrupt or exception has occurred at the very</dt><dd><p>beginning of a function before the stack frame has been created,
or at the very end of the function after the stack frame has been
destroyed.  This is an inherent limitation of frame pointers.</p>
</dd>
</dl>
</li>
<li><p>ORC (Oops Rewind Capability) unwind table generation</p>
<p>An alternative to frame pointers and DWARF, ORC unwind data can be
used to walk the stack.  Unlike frame pointers, ORC data is out of
band.  So it doesn’t affect runtime performance and it can be
reliable even when interrupts or exceptions are involved.</p>
<p>For more details, see Documentation/x86/orc-unwinder.rst.</p>
</li>
<li><p>Higher live patching compatibility rate</p>
<p>Livepatch has an optional “consistency model”, which is needed for
more complex patches.  In order for the consistency model to work,
stack traces need to be reliable (or an unreliable condition needs to
be detectable).  Objtool makes that possible.</p>
<p>For more details, see the livepatch documentation in the Linux kernel
source tree at Documentation/livepatch/livepatch.rst.</p>
</li>
</ol>
</div>
<div class="section" id="rules">
<h2>Rules<a class="headerlink" href="#rules" title="Permalink to this headline">¶</a></h2>
<p>To achieve the validation, objtool enforces the following rules:</p>
<ol class="arabic">
<li><p>Each callable function must be annotated as such with the ELF
function type.  In asm code, this is typically done using the
ENTRY/ENDPROC macros.  If objtool finds a return instruction
outside of a function, it flags an error since that usually indicates
callable code which should be annotated accordingly.</p>
<p>This rule is needed so that objtool can properly identify each
callable function in order to analyze its stack metadata.</p>
</li>
<li><p>Conversely, each section of code which is <em>not</em> callable should <em>not</em>
be annotated as an ELF function.  The ENDPROC macro shouldn’t be used
in this case.</p>
<p>This rule is needed so that objtool can ignore non-callable code.
Such code doesn’t have to follow any of the other rules.</p>
</li>
<li><p>Each callable function which calls another function must have the
correct frame pointer logic, if required by CONFIG_FRAME_POINTER or
the architecture’s back chain rules.  This can by done in asm code
with the FRAME_BEGIN/FRAME_END macros.</p>
<p>This rule ensures that frame pointer based stack traces will work as
designed.  If function A doesn’t create a stack frame before calling
function B, the _caller_ of function A will be skipped on the stack
trace.</p>
</li>
<li><p>Dynamic jumps and jumps to undefined symbols are only allowed if:</p>
<ol class="loweralpha simple">
<li><p>the jump is part of a switch statement; or</p></li>
<li><p>the jump matches sibling call semantics and the frame pointer has
the same value it had on function entry.</p></li>
</ol>
<p>This rule is needed so that objtool can reliably analyze all of a
function’s code paths.  If a function jumps to code in another file,
and it’s not a sibling call, objtool has no way to follow the jump
because it only analyzes a single file at a time.</p>
</li>
<li><p>A callable function may not execute kernel entry/exit instructions.
The only code which needs such instructions is kernel entry code,
which shouldn’t be be in callable functions anyway.</p>
<p>This rule is just a sanity check to ensure that callable functions
return normally.</p>
</li>
</ol>
</div>
<div class="section" id="objtool-warnings">
<h2>Objtool warnings<a class="headerlink" href="#objtool-warnings" title="Permalink to this headline">¶</a></h2>
<p>For asm files, if you’re getting an error which doesn’t make sense,
first make sure that the affected code follows the above rules.</p>
<p>For C files, the common culprits are inline asm statements and calls to
“noreturn” functions.  See below for more details.</p>
<p>Another possible cause for errors in C code is if the Makefile removes
-fno-omit-frame-pointer or adds -fomit-frame-pointer to the gcc options.</p>
<p>Here are some examples of common warnings reported by objtool, what
they mean, and suggestions for how to fix them.</p>
<ol class="arabic">
<li><p>file.o: warning: objtool: func()+0x128: call without frame pointer save/setup</p>
<p>The func() function made a function call without first saving and/or
updating the frame pointer, and CONFIG_FRAME_POINTER is enabled.</p>
<p>If the error is for an asm file, and func() is indeed a callable
function, add proper frame pointer logic using the FRAME_BEGIN and
FRAME_END macros.  Otherwise, if it’s not a callable function, remove
its ELF function annotation by changing ENDPROC to END, and instead
use the manual unwind hint macros in asm/unwind_hints.h.</p>
<p>If it’s a GCC-compiled .c file, the error may be because the function
uses an inline asm() statement which has a “call” instruction.  An
asm() statement with a call instruction must declare the use of the
stack pointer in its output operand.  On x86_64, this means adding
the ASM_CALL_CONSTRAINT as an output constraint:</p>
<blockquote>
<div><p>asm volatile(“call func” : ASM_CALL_CONSTRAINT);</p>
</div></blockquote>
<p>Otherwise the stack frame may not get created before the call.</p>
</li>
<li><p>file.o: warning: objtool: .text+0x53: unreachable instruction</p>
<p>Objtool couldn’t find a code path to reach the instruction.</p>
<p>If the error is for an asm file, and the instruction is inside (or
reachable from) a callable function, the function should be annotated
with the ENTRY/ENDPROC macros (ENDPROC is the important one).
Otherwise, the code should probably be annotated with the unwind hint
macros in asm/unwind_hints.h so objtool and the unwinder can know the
stack state associated with the code.</p>
<p>If you’re 100% sure the code won’t affect stack traces, or if you’re
a just a bad person, you can tell objtool to ignore it.  See the
“Adding exceptions” section below.</p>
<p>If it’s not actually in a callable function (e.g. kernel entry code),
change ENDPROC to END.</p>
</li>
</ol>
<ol class="arabic" start="4">
<li><p>file.o: warning: objtool: func(): can’t find starting instruction
or
file.o: warning: objtool: func()+0x11dd: can’t decode instruction</p>
<p>Does the file have data in a text section?  If so, that can confuse
objtool’s instruction decoder.  Move the data to a more appropriate
section like .data or .rodata.</p>
</li>
<li><p>file.o: warning: objtool: func()+0x6: unsupported instruction in callable function</p>
<p>This is a kernel entry/exit instruction like sysenter or iret.  Such
instructions aren’t allowed in a callable function, and are most
likely part of the kernel entry code.  They should usually not have
the callable function annotation (ENDPROC) and should always be
annotated with the unwind hint macros in asm/unwind_hints.h.</p>
</li>
<li><p>file.o: warning: objtool: func()+0x26: sibling call from callable instruction with modified stack frame</p>
<p>This is a dynamic jump or a jump to an undefined symbol.  Objtool
assumed it’s a sibling call and detected that the frame pointer
wasn’t first restored to its original state.</p>
<p>If it’s not really a sibling call, you may need to move the
destination code to the local file.</p>
<p>If the instruction is not actually in a callable function (e.g.
kernel entry code), change ENDPROC to END and annotate manually with
the unwind hint macros in asm/unwind_hints.h.</p>
</li>
<li><p>file: warning: objtool: func()+0x5c: stack state mismatch</p>
<p>The instruction’s frame pointer state is inconsistent, depending on
which execution path was taken to reach the instruction.</p>
<p>Make sure that, when CONFIG_FRAME_POINTER is enabled, the function
pushes and sets up the frame pointer (for x86_64, this means rbp) at
the beginning of the function and pops it at the end of the function.
Also make sure that no other code in the function touches the frame
pointer.</p>
<p>Another possibility is that the code has some asm or inline asm which
does some unusual things to the stack or the frame pointer.  In such
cases it’s probably appropriate to use the unwind hint macros in
asm/unwind_hints.h.</p>
</li>
<li><p>file.o: warning: objtool: funcA() falls through to next function funcB()</p>
<p>This means that funcA() doesn’t end with a return instruction or an
unconditional jump, and that objtool has determined that the function
can fall through into the next function.  There could be different
reasons for this:</p>
<ol class="arabic simple">
<li><p>funcA()’s last instruction is a call to a “noreturn” function like
panic().  In this case the noreturn function needs to be added to
objtool’s hard-coded global_noreturns array.  Feel free to bug the
objtool maintainer, or you can submit a patch.</p></li>
<li><p>funcA() uses the unreachable() annotation in a section of code
that is actually reachable.</p></li>
<li><p>If funcA() calls an inline function, the object code for funcA()
might be corrupt due to a gcc bug.  For more details, see:
<a class="reference external" href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70646">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70646</a></p></li>
</ol>
</li>
<li><p>file.o: warning: objtool: funcA() call to funcB() with UACCESS enabled</p>
<p>This means that an unexpected call to a non-whitelisted function exists
outside of arch-specific guards.
X86: SMAP (stac/clac): __uaccess_begin()/__uaccess_end()
ARM: PAN: uaccess_enable()/uaccess_disable()</p>
<p>These functions should be called to denote a minimal critical section around
access to __user variables. See also: <a class="reference external" href="https://lwn.net/Articles/517475/">https://lwn.net/Articles/517475/</a></p>
<p>The intention of the warning is to prevent calls to funcB() from eventually
calling schedule(), potentially leaking the AC flags state, and not
restoring them correctly.</p>
<p>It also helps verify that there are no unexpected calls to funcB() which may
access user space pages with protections against doing so disabled.</p>
<p>To fix, either:
1) remove explicit calls to funcB() from funcA().
2) add the correct guards before and after calls to low level functions like</p>
<blockquote>
<div><p>__get_user_size()/__put_user_size().</p>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>add funcB to uaccess_safe_builtin whitelist in tools/objtool/check.c, if
funcB obviously does not call schedule(), and is marked notrace (since
function tracing inserts additional calls, which is not obvious from the
sources).</p></li>
</ol>
</li>
<li><p>file.o: warning: func()+0x5c: stack layout conflict in alternatives</p>
<p>This means that in the use of the alternative() or ALTERNATIVE()
macro, the code paths have conflicting modifications to the stack.
The problem is that there is only one ORC unwind table, which means
that the ORC unwind entries must be consistent for all possible
instruction boundaries regardless of which code has been patched.
This limitation can be overcome by massaging the alternatives with
NOPs to shift the stack changes around so they no longer conflict.</p>
</li>
<li><p>file.o: warning: unannotated intra-function call</p></li>
</ol>
<blockquote>
<div><p>This warning means that a direct call is done to a destination which
is not at the beginning of a function. If this is a legit call, you
can remove this warning by putting the ANNOTATE_INTRA_FUNCTION_CALL
directive right before the call.</p>
</div></blockquote>
<p>If the error doesn’t seem to make sense, it could be a bug in objtool.
Feel free to ask the objtool maintainer for help.</p>
</div>
<div class="section" id="adding-exceptions">
<h2>Adding exceptions<a class="headerlink" href="#adding-exceptions" title="Permalink to this headline">¶</a></h2>
<p>If you _really_ need objtool to ignore something, and are 100% sure
that it won’t affect kernel stack traces, you can tell objtool to
ignore it:</p>
<ul>
<li><p>To skip validation of a function, use the STACK_FRAME_NON_STANDARD
macro.</p></li>
<li><p>To skip validation of a file, add</p>
<blockquote>
<div><p>OBJECT_FILES_NON_STANDARD_filename.o := y</p>
</div></blockquote>
<p>to the Makefile.</p>
</li>
<li><p>To skip validation of a directory, add</p>
<blockquote>
<div><p>OBJECT_FILES_NON_STANDARD := y</p>
</div></blockquote>
<p>to the Makefile.</p>
</li>
</ul>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="bug_panic.html" class="btn btn-neutral float-left" title="bug/panic分析与总结" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../kernel_ps/index.html" class="btn btn-neutral float-right" title="linux 进程管理" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Rachel.Sun.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>