<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mm_struct 结构分析： &mdash; Rachel&#39;s E-book 1.0 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="vm_area_struct 结构分析：" href="vma.html" />
    <link rel="prev" title="内存在进程中的表示" href="new_task.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> Rachel's E-book
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../os_base/index.html">linux 操作系统架构分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lk_devel/index.html">linux 内核开发</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">linux 内核代码分析</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../kernel_base/index.html">linux 内核基础</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kernel_ps/index.html">linux 进程管理</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">linux 内存管理</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="new_task.html">内存在进程中的表示</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">mm_struct 结构分析：</a></li>
<li class="toctree-l3"><a class="reference internal" href="vma.html">vm_area_struct 结构分析：</a></li>
<li class="toctree-l3"><a class="reference internal" href="mmap.html">mmap来理解vma及硬件页关联：</a></li>
<li class="toctree-l3"><a class="reference internal" href="pf.html">缺页中断：看硬件映射</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_mmap.html">物理页面管理机制：slab/slub/…</a></li>
<li class="toctree-l3"><a class="reference internal" href="x86_mm.html">x86架构级内存管理总结</a></li>
<li class="toctree-l3"><a class="reference internal" href="mm_sec.html">内存安全机制：</a></li>
<li class="toctree-l3"><a class="reference internal" href="mm_acct.html">内存统计信息</a></li>
<li class="toctree-l3"><a class="reference internal" href="swap.html">swap:交换内存：</a></li>
<li class="toctree-l3"><a class="reference internal" href="mm_perf.html">内存性能测试方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="mm_misc.html">其他内存相关：</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kernel_fs/index.html">linux 文件系统分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kernel_cpu/index.html">linux CPU管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kernel_driver/index.html">linux 驱动架构分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lk_net/index.html">linux 内核网络代码分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kernel_virt/index.html">linux 内核虚拟化技术</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kobject.html">kobject理解</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../os_sec/index.html">linux 操作系统安全</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../my_os/index.html">从零开始写一个系统（KVM）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../csxj/index.html">处世悬镜</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Rachel's E-book</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">linux 内核代码分析</a> &raquo;</li>
          <li><a href="index.html">linux 内存管理</a> &raquo;</li>
      <li>mm_struct 结构分析：</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/lk_code/kernel_mem/mm_struct.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="mm-struct">
<h1>mm_struct 结构分析：<a class="headerlink" href="#mm-struct" title="Permalink to this headline">¶</a></h1>
<div class="literal-block-wrapper docutils container" id="id1">
<div class="code-block-caption"><span class="caption-text">struct_task –&gt; mm</span><a class="headerlink" href="#id1" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">mm_struct</span> <span class="p">{</span>
     <span class="k">struct</span> <span class="p">{</span>
             <span class="k">struct</span> <span class="nc">vm_area_struct</span> <span class="o">*</span><span class="n">mmap</span><span class="p">;</span>            <span class="cm">/* list of VMAs:应用内存空间 */</span>
<span class="hll">             <span class="k">struct</span> <span class="nc">rb_root</span> <span class="n">mm_rb</span><span class="p">;</span>
</span><span class="hll">             <span class="n">u64</span> <span class="n">vmacache_seqnum</span><span class="p">;</span>                   <span class="cm">/* per-thread vmacache */</span>
</span>     <span class="cp">#ifdef CONFIG_MMU</span>
             <span class="kt">unsigned</span> <span class="nf">long</span> <span class="p">(</span><span class="o">*</span><span class="n">get_unmapped_area</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
                             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
                             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
     <span class="cp">#endif</span>
             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmap_base</span><span class="p">;</span>        <span class="cm">/* base of mmap area */</span>
             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmap_legacy_base</span><span class="p">;</span> <span class="cm">/* base of mmap area in bottom-up allocations */</span>
     <span class="cp">#ifdef CONFIG_HAVE_ARCH_COMPAT_MMAP_BASES</span>
             <span class="cm">/* Base addresses for compatible mmap() */</span>
             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmap_compat_base</span><span class="p">;</span>
             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mmap_compat_legacy_base</span><span class="p">;</span>
     <span class="cp">#endif</span>
             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">task_size</span><span class="p">;</span>        <span class="cm">/* size of task vm space */</span>
             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">highest_vm_end</span><span class="p">;</span>   <span class="cm">/* highest vma end address */</span>
             <span class="n">pgd_t</span> <span class="o">*</span> <span class="n">pgd</span><span class="p">;</span>

     <span class="cp">#ifdef CONFIG_MEMBARRIER</span>
             <span class="cm">/**</span>
<span class="cm">              * @membarrier_state: Flags controlling membarrier behavior.</span>
<span class="cm">              *</span>
<span class="cm">              * This field is close to @pgd to hopefully fit in the same</span>
<span class="cm">              * cache-line, which needs to be touched by switch_mm().</span>
<span class="cm">              */</span>
             <span class="n">atomic_t</span> <span class="n">membarrier_state</span><span class="p">;</span>
     <span class="cp">#endif</span>

             <span class="cm">/**</span>
<span class="cm">              * @mm_users: The number of users including userspace.</span>
<span class="cm">              *</span>
<span class="cm">              * Use mmget()/mmget_not_zero()/mmput() to modify. When this</span>
<span class="cm">              * drops to 0 (i.e. when the task exits and there are no other</span>
<span class="cm">              * temporary reference holders), we also release a reference on</span>
<span class="cm">              * @mm_count (which may then free the &amp;struct mm_struct if</span>
<span class="cm">              * @mm_count also drops to 0).</span>
<span class="cm">              */</span>
             <span class="n">atomic_t</span> <span class="n">mm_users</span><span class="p">;</span>

             <span class="cm">/**</span>
<span class="cm">              * @mm_count: The number of references to &amp;struct mm_struct</span>
<span class="cm">              * (@mm_users count as 1).</span>
<span class="cm">              *</span>
<span class="cm">              * Use mmgrab()/mmdrop() to modify. When this drops to 0, the</span>
<span class="cm">              * &amp;struct mm_struct is freed.</span>
<span class="cm">              */</span>
             <span class="n">atomic_t</span> <span class="n">mm_count</span><span class="p">;</span>

     <span class="cp">#ifdef CONFIG_MMU</span>
             <span class="n">atomic_long_t</span> <span class="n">pgtables_bytes</span><span class="p">;</span>   <span class="cm">/* PTE page table pages */</span>
     <span class="cp">#endif</span>
             <span class="kt">int</span> <span class="n">map_count</span><span class="p">;</span>                  <span class="cm">/* number of VMAs */</span>

             <span class="n">spinlock_t</span> <span class="n">page_table_lock</span><span class="p">;</span> <span class="cm">/* Protects page tables and some</span>
<span class="cm">                                          * counters</span>
<span class="cm">                                          */</span>
             <span class="cm">/*</span>
<span class="cm">              * With some kernel config, the current mmap_lock&#39;s offset</span>
<span class="cm">              * inside &#39;mm_struct&#39; is at 0x120, which is very optimal, as</span>
<span class="cm">              * its two hot fields &#39;count&#39; and &#39;owner&#39; sit in 2 different</span>
<span class="cm">              * cachelines,  and when mmap_lock is highly contended, both</span>
<span class="cm">              * of the 2 fields will be accessed frequently, current layout</span>
<span class="cm">              * will help to reduce cache bouncing.</span>
<span class="cm">              *</span>
<span class="cm">              * So please be careful with adding new fields before</span>
<span class="cm">              * mmap_lock, which can easily push the 2 fields into one</span>
<span class="cm">              * cacheline.</span>
<span class="cm">              */</span>
             <span class="k">struct</span> <span class="nc">rw_semaphore</span> <span class="n">mmap_lock</span><span class="p">;</span>

             <span class="k">struct</span> <span class="nc">list_head</span> <span class="n">mmlist</span><span class="p">;</span> <span class="cm">/* List of maybe swapped mm&#39;s. These</span>
<span class="cm">                                       * are globally strung together off</span>
<span class="cm">                                       * init_mm.mmlist, and are protected</span>
<span class="cm">                                       * by mmlist_lock</span>
<span class="cm">                                       */</span>


             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hiwater_rss</span><span class="p">;</span> <span class="cm">/* High-watermark of RSS usage */</span>
             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hiwater_vm</span><span class="p">;</span>  <span class="cm">/* High-water virtual memory usage */</span>

             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_vm</span><span class="p">;</span>    <span class="cm">/* Total pages mapped */</span>
             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">locked_vm</span><span class="p">;</span>   <span class="cm">/* Pages that have PG_mlocked set */</span>
             <span class="n">atomic64_t</span>    <span class="n">pinned_vm</span><span class="p">;</span>   <span class="cm">/* Refcount permanently increased */</span>
             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data_vm</span><span class="p">;</span>     <span class="cm">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span>
             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exec_vm</span><span class="p">;</span>     <span class="cm">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span>
             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_vm</span><span class="p">;</span>    <span class="cm">/* VM_STACK */</span>
             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">def_flags</span><span class="p">;</span>

             <span class="cm">/**</span>
<span class="cm">              * @write_protect_seq: Locked when any thread is write</span>
<span class="cm">              * protecting pages mapped by this mm to enforce a later COW,</span>
<span class="cm">              * for instance during page table copying for fork().</span>
<span class="cm">              */</span>
             <span class="n">seqcount_t</span> <span class="n">write_protect_seq</span><span class="p">;</span>

             <span class="n">spinlock_t</span> <span class="n">arg_lock</span><span class="p">;</span> <span class="cm">/* protect the below fields */</span>

             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_code</span><span class="p">,</span> <span class="n">end_code</span><span class="p">,</span> <span class="n">start_data</span><span class="p">,</span> <span class="n">end_data</span><span class="p">;</span>
             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_brk</span><span class="p">,</span> <span class="n">brk</span><span class="p">,</span> <span class="n">start_stack</span><span class="p">;</span>
             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg_start</span><span class="p">,</span> <span class="n">arg_end</span><span class="p">,</span> <span class="n">env_start</span><span class="p">,</span> <span class="n">env_end</span><span class="p">;</span>

             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">saved_auxv</span><span class="p">[</span><span class="n">AT_VECTOR_SIZE</span><span class="p">];</span> <span class="cm">/* for /proc/PID/auxv */</span>

             <span class="cm">/*</span>
<span class="cm">              * Special counters, in some configurations protected by the</span>
<span class="cm">              * page_table_lock, in other configurations by being atomic.</span>
<span class="cm">              */</span>
             <span class="k">struct</span> <span class="nc">mm_rss_stat</span> <span class="n">rss_stat</span><span class="p">;</span>

             <span class="k">struct</span> <span class="nc">linux_binfmt</span> <span class="o">*</span><span class="n">binfmt</span><span class="p">;</span>

             <span class="cm">/* Architecture-specific MM context */</span>
             <span class="n">mm_context_t</span> <span class="n">context</span><span class="p">;</span>

             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* Must use atomic bitops to access */</span>

             <span class="k">struct</span> <span class="nc">core_state</span> <span class="o">*</span><span class="n">core_state</span><span class="p">;</span> <span class="cm">/* coredumping support */</span>

     <span class="cp">#ifdef CONFIG_AIO</span>
             <span class="n">spinlock_t</span>                      <span class="n">ioctx_lock</span><span class="p">;</span>
             <span class="k">struct</span> <span class="nc">kioctx_table</span> <span class="n">__rcu</span>       <span class="o">*</span><span class="n">ioctx_table</span><span class="p">;</span>
     <span class="cp">#endif</span>
     <span class="cp">#ifdef CONFIG_MEMCG</span>
             <span class="cm">/*</span>
<span class="cm">              * &quot;owner&quot; points to a task that is regarded as the canonical</span>
<span class="cm">              * user/owner of this mm. All of the following must be true in</span>
<span class="cm">              * order for it to be changed:</span>
<span class="cm">              *</span>
<span class="cm">              * current == mm-&gt;owner</span>
<span class="cm">              * current-&gt;mm != mm</span>
<span class="cm">              * new_owner-&gt;mm == mm</span>
<span class="cm">              * new_owner-&gt;alloc_lock is held</span>
<span class="cm">              */</span>
             <span class="k">struct</span> <span class="nc">task_struct</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
     <span class="cp">#endif</span>
             <span class="k">struct</span> <span class="nc">user_namespace</span> <span class="o">*</span><span class="n">user_ns</span><span class="p">;</span>

             <span class="cm">/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */</span>
             <span class="k">struct</span> <span class="nc">file</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">exe_file</span><span class="p">;</span>
     <span class="cp">#ifdef CONFIG_MMU_NOTIFIER</span>
             <span class="k">struct</span> <span class="nc">mmu_notifier_subscriptions</span> <span class="o">*</span><span class="n">notifier_subscriptions</span><span class="p">;</span>
     <span class="cp">#endif</span>
     <span class="cp">#if defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; !USE_SPLIT_PMD_PTLOCKS</span>
             <span class="n">pgtable_t</span> <span class="n">pmd_huge_pte</span><span class="p">;</span> <span class="cm">/* protected by page_table_lock */</span>
     <span class="cp">#endif</span>
     <span class="cp">#ifdef CONFIG_NUMA_BALANCING</span>
             <span class="cm">/*</span>
<span class="cm">              * numa_next_scan is the next time that the PTEs will be marked</span>
<span class="cm">              * pte_numa. NUMA hinting faults will gather statistics and</span>
<span class="cm">              * migrate pages to new nodes if necessary.</span>
<span class="cm">              */</span>
             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">numa_next_scan</span><span class="p">;</span>

             <span class="cm">/* Restart point for scanning and setting pte_numa */</span>
             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">numa_scan_offset</span><span class="p">;</span>

             <span class="cm">/* numa_scan_seq prevents two threads setting pte_numa */</span>
             <span class="kt">int</span> <span class="n">numa_scan_seq</span><span class="p">;</span>
     <span class="cp">#endif</span>
             <span class="cm">/*</span>
<span class="cm">              * An operation with batched TLB flushing is going on. Anything</span>
<span class="cm">              * that can move process memory needs to flush the TLB when</span>
<span class="cm">              * moving a PROT_NONE or PROT_NUMA mapped page.</span>
<span class="cm">              */</span>
             <span class="n">atomic_t</span> <span class="n">tlb_flush_pending</span><span class="p">;</span>
     <span class="cp">#ifdef CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH</span>
             <span class="cm">/* See flush_tlb_batched_pending() */</span>
             <span class="kt">bool</span> <span class="n">tlb_flush_batched</span><span class="p">;</span>
     <span class="cp">#endif</span>
             <span class="k">struct</span> <span class="nc">uprobes_state</span> <span class="n">uprobes_state</span><span class="p">;</span>
     <span class="cp">#ifdef CONFIG_HUGETLB_PAGE</span>
             <span class="n">atomic_long_t</span> <span class="n">hugetlb_usage</span><span class="p">;</span>
     <span class="cp">#endif</span>
             <span class="k">struct</span> <span class="nc">work_struct</span> <span class="n">async_put_work</span><span class="p">;</span>

     <span class="cp">#ifdef CONFIG_IOMMU_SUPPORT</span>
             <span class="n">u32</span> <span class="n">pasid</span><span class="p">;</span>
     <span class="cp">#endif</span>
             <span class="p">}</span> <span class="n">__randomize_layout</span><span class="p">;</span>  <span class="c1">//struct end</span>

     <span class="cm">/*</span>
<span class="cm">      * The mm_cpumask needs to be at the end of mm_struct, because it</span>
<span class="cm">      * is dynamically sized based on nr_cpu_ids.</span>
<span class="cm">      */</span>
     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu_bitmap</span><span class="p">[];</span>
 <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="new_task.html" class="btn btn-neutral float-left" title="内存在进程中的表示" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="vma.html" class="btn btn-neutral float-right" title="vm_area_struct 结构分析：" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Rachel.Sun.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>