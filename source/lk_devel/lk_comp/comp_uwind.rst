UWIND
------

DWARF 规范
^^^^^^^^^^



ORC
^^^^^^^
看看实现，就能理解了。



9. ORC放卷机
9.1。概述
内核 CONFIG_UNWINDER_ORC 选项启用 ORC 展开器，它在概念上类似于 DWARF 展开器。不同的是，ORC 数据的格式比 DWARF 简单得多，这反过来又使 ORC unwinder 更简单、更快。

ORC 数据由 objtool 生成的展开表组成。它们包含内核内 ORC 展开器使用的带外数据。Objtool 通过首先进行编译时堆栈元数据验证 (CONFIG_STACK_VALIDATION) 来生成 ORC 数据。在分析 .o 文件的所有代码路径后，它会确定文件中每个指令地址的堆栈状态信息，并将该信息输出到 .orc_unwind 和 .orc_unwind_ip 部分。

每个对象的 ORC 部分在链接时合并，并在引导时进行排序和后处理。展开器使用结果数据将指令地址与它们在运行时的堆栈状态相关联。

9.2. ORC 与帧指针
启用帧指针后，GCC 将检测代码添加到内核中的每个函数。内核的 .text 大小增加了大约 3.2%，导致内核范围的广泛减速。Mel Gorman 1的测量表明，某些工作负载的速度降低了 5-10%。

相反，ORC unwinder 对文本大小或运行时性能没有影响，因为 debuginfo 是带外的。因此，如果您禁用帧指针并启用 ORC 展开器，您将获得全面的性能提升，并且仍然具有可靠的堆栈跟踪。

Ingo Molnar 说：

“请注意，这不仅是性能改进，也是指令缓存局部性改进：3.2% 的文本节省几乎直接转化为类似大小的缓存占用减少。对于缓存位置处于临界状态的工作负载，这可以转化为更高的加速。”

与帧指针相比，ORC 的另一个好处是它可以在中断和异常之间可靠地展开。基于帧指针的展开有时可以跳过被中断函数的调用者，如果它是一个叶函数或者如果在帧指针被保存之前中断命中。

与帧指针相比，ORC 展开器的主要缺点是它需要更多内存来存储 ORC 展开表：大约 2-4MB，具体取决于内核配置。

9.3. 兽人对矮人
ORC debuginfo 相对于 DWARF 本身的优势在于它更简单。它摆脱了复杂的 DWARF CFI 状态机，也摆脱了对不必要寄存器的跟踪。这使得展开器更简单，意味着更少的错误，这对于关键任务 oops 代码尤其重要。

更简单的 debuginfo 格式还使 unwinder 比 DWARF 快得多，这对于 perf 和 lockdep 很重要。在 Jiri Slaby 2的基本性能测试中，ORC 展开器比树外 DWARF 展开器快约 20 倍。（注意：该测量是在添加一些性能调整之前进行的，这使性能翻了一番，因此 DWARF 的加速可能接近 40 倍。）

与 DWARF 相比，ORC 数据格式确实有一些缺点。ORC 展开表比基于 DWARF 的 eh_frame 表占用的 RAM 多约 50%（在 x86 defconfig 内核上为 +1.3MB）。

另一个潜在的缺点是，随着 GCC 的发展，可以想象 ORC 数据最终可能过于简单而无法描述某些优化的堆栈状态。但是 IMO 这不太可能，因为 GCC 会为任何不寻常的堆栈调整保存帧指针，所以我怀疑我们真的只需要跟踪调用帧之间的堆栈指针和帧指针。但是即使我们最终不得不跟踪 DWARF 跟踪的所有寄存器，至少我们仍然能够控制格式，例如没有复杂的状态机。

9.4。ORC 展开表生成
ORC 数据由 objtool 生成。使用现有的编译时堆栈元数据验证功能，objtool 已经遵循所有代码路径，因此它已经拥有能够从头开始生成 ORC 数据所需的所有信息。因此，从堆栈验证到 ORC 数据生成是一个简单的步骤。

应该可以使用将 DWARF 转换为 ORC 数据的简单工具来生成 ORC 数据。然而，由于内核广泛使用 asm、内联 asm 和异常表等特殊部分，这样的解决方案将是不完整的。

这可以通过使用 .S 文件中的 GNU 汇编器 .cfi 注释和 .c 文件中的内联 asm 的本地注释手动注释这些特殊代码路径来纠正。但是asm注解过去尝试过，发现无法维护。它们通常不正确/不完整，使代码更难阅读和保持更新。并且基于查看 glibc 代码，在 .c 文件中注释内联 asm 可能会更糟。

Objtool 仍然需要一些注释，但仅限于对堆栈执行异常操作的代码，例如入口代码。即便如此，所需的注释也比 DWARF 需要的要少得多，因此它们比 DWARF CFI 注释更易于维护。

所以使用 objtool 生成 ORC 数据的优点是它给出了更准确的 debuginfo，注解很少。它还将内核与工具链错误隔离开来，这些错误在内核中处理起来可能非常痛苦，因为多年来我们经常不得不解决旧版本工具链中的问题。

缺点是展开器现在变得依赖于 objtool 对 GCC 代码流进行逆向工程的能力。如果 GCC 优化变得过于复杂以至于 objtool 无法遵循，ORC 数据生成可能会停止工作或变得不完整。（值得注意的是，livepatch 已经对 objtool 遵循 GCC 代码流的能力产生了这种依赖性。）

如果较新版本的 GCC 提出了一些破坏 objtool 的优化，我们可能需要重新审视当前的实现。一些可能的解决方案是要求 GCC 使优化更容易接受，或者让 objtool 使用 DWARF 作为附加输入，或者创建一个 GCC 插件来帮助 objtool 进行分析。但就目前而言，objtool 很好地遵循了 GCC 代码。

9.5。开卷机实现细节
Objtool 通过与编译时堆栈元数据验证功能集成来生成 ORC 数据，在 tools/objtool/Documentation/stack-validation.txt 中有详细描述。在分析 .o 文件的所有代码路径后，它会创建一个 orc_entry 结构数组，以及与这些结构关联的指令地址的并行数组，并将它们分别写入 .orc_unwind 和 .orc_unwind_ip 部分。

出于性能原因，ORC 数据被分成两个数组，以使数据的可搜索部分 (.orc_unwind_ip) 更紧凑。数组在引导时并行排序。

通过使用在运行时创建的快速查找表进一步提高了性能。快速查找表将给定地址与 .orc_unwind 表的索引范围相关联，因此只需要搜索表的一小部分。

9.6。词源
兽人，中世纪民间传说中的可怕生物，是矮人的天敌。同样，ORC unwinder 的创建与 DWARF 的复杂性和缓慢性相反。

“虽然兽人很少考虑解决问题的多种方法，但他们确实擅长完成工作，因为他们是行动的生物，而不是思想的生物。” 3 同样，与深奥的 DWARF 展开器不同，真正的 ORC 展开器不会浪费时间或费力地解码可变长度零扩展无符号整数字节编码的基于状态机的调试信息条目。

与兽人经常解开他们的对手的善意计划类似，兽人展开器经常以残酷、不屈不挠的效率解开堆栈。

ORC 代表糟糕的倒带能力。

1
https://lore.kernel.org/r/20170602104048.jkkzssljsompjdwy@suse.de

2
https://lore.kernel.org/r/d2ca5435-6386-29b8-db87-7f227c2b713a@suse.cz

3
http://dustin.wikidot.com/half-orcs-and-orcs
